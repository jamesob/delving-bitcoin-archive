{
  "id": 325,
  "name": "Gregory Sanders",
  "username": "instagibbs",
  "avatar_template": "/user_avatar/delvingbitcoin.org/instagibbs/{size}/28_2.png",
  "created_at": "2023-11-01T18:13:50.577Z",
  "cooked": "<p>(copied from a gist)</p>\n<h1><a name=\"free-relay-1\" class=\"anchor\" href=\"#free-relay-1\"></a>\u201cFree Relay\u201d</h1>\n<p>In transaction relay we are trying to avoid \u201cfree relay\u201d which is roughly defined as:</p>\n<pre><code class=\"lang-auto\">(total_sats_in_mempool + total_sats_mined) / total_bytes_relayed &lt; minrelay\n</code></pre>\n<p>Did the sum total of bytes we\u2019ve been accepting to our mempool and propagating across\nthe network pay for the \u201cbandwidth\u201d to do so, dubbed <code>minrelay</code> which is a static value\nat 1 sat/vbyte?</p>\n<p>Therefore, if we for example remove bip125 rule#3 in a naive fashion, this can\nbe violated simply by filling the bottom of the mempool with 1 sat/vbyte junk,\nthen double-spending all of with minimum sized transactions at slightly higher\nrates, e.g., 2 sat/vbyte.</p>\n<p>This can be problematic in adversarial and time-sensitive scenarios such as Lightning\nNetwork tranasctions, both \u201ccommitment\u201d and \u201cHTLC\u201d transactions which each have timelines\nto be mined safely. The counter-party can intentionally slow down mining of these\ntransactions, and not pay for the privelage to do so, by putting these rule#3 pins\nat the bottom of the mempool that can become evicted.</p>\n<h1><a name=\"opt-in-policies-2\" class=\"anchor\" href=\"#opt-in-policies-2\"></a>Opt-in policies</h1>\n<p>Instead of working around rule#3 directly, we can instead allow wallets to add\n\u201cprior restraint\u201d to features of the transaction that may mitigate these issues.</p>\n<h1><a name=\"v3-3\" class=\"anchor\" href=\"#v3-3\"></a>\u201cV3\u201d</h1>\n<p>The \u201cV3\u201d transaction type is proposed specifically as this kind of policy. If nVersion==3,\nthis means the topology for this transaction in the mempool is highly restricted.\nThe tx may have up to one ancestor and one descendant total, which implies\na strict upper-bound parent-child relationship of size two. The child transaction\nis additionally restricted to 1 kvB. This is deemed large enough that a child\ncan bring reasonable amounts of funds to do package RBF, but two orders of magnitude\nsmaller than the upper-bound possible (101kvB) in packages. This reduces the pin\neffect by roughly 250-500 times, making pins hopefully impractical.</p>\n<p>Very importantly, the parent transaction size is unrestricted.</p>\n<p>This transaction type works well specifically for things such as commitment\ntransactions, in which utxos are locked into smart contracts between only\nthe authorized spending parties, and no ANYONECANPAY like behavior is allowed.\nThis precludes its usage in today\u2019s LN HTLC transactions, without a significant\nrewrite of how they work to include (Ephemeral?) anchors, and the resulting\nadditional vbytes in the commone non-pinning case.</p>\n<p>Ephemeral anchors additionally allow:</p>\n<ol>\n<li>0-value anchors</li>\n<li>\u201csibling eviction\u201d, which allows other outputs of transactions to not require \u201c1 CSV\u201d\nhacks that are common in things such as LN BOLTs to avoid package limit pinning.\nThis saves bytes, and allows these outputs to be directly spent immdaitely as fees.\nBut relies on \u201cV3\u201d for its topological restrictions to ensure (2).</li>\n</ol>\n<p>See more discussion on Ephemeral anchors and its relation to SIGHASH_GROUP fore more background:\n<a href=\"https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021334.html\" class=\"onebox\" target=\"_blank\" rel=\"noopener\">https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021334.html</a></p>\n<h1><a name=\"cluster-mempool-4\" class=\"anchor\" href=\"#cluster-mempool-4\"></a>Cluster Mempool</h1>\n<p>With the cluster mempool, we have the ability to efficiently order the entire\nmempool, both in eviction and the mining. This can be efficiently updated incrementally\nfor each transaction added and removed from the mempool. Since the mempool\nis completely ordered for mining at each step, we can efficiently simulate mining\nN blocks, and give the necessary \u201cmining scores\u201d required for each chunk to\nbe included in that range of the mempool.</p>\n<h1><a name=\"transaction-priority-opt-in-5\" class=\"anchor\" href=\"#transaction-priority-opt-in-5\"></a>Transaction Priority Opt-in</h1>\n<p>Once you have a mapping from chunk mining score to \u201ctop N blocks\u201d, the system is\nfairly straight forward.</p>\n<p>Users commit to the \u201cN\u201d in their transaction input(?). The proposed transaction\nis relayed, a node simulates adding the transaction to the cluster, runs linearization\nalgorithm, has the resulting mining score, checks that the \u201cN\u201d computed is higher\nthan any committed to in the transaction. If so, it\u2019s let into the mempool. If not,\nit\u2019s simply rejected.</p>\n<p>Subsequent descendants to that tranasaction must also conform to the most restrictive\nancestor\u2019s \u201ctop N block\u201d chunk restriction, or they will be rejected.\nTherefore both \u201cancestor junk\u201d and \u201cdescendant junk\u201d are prevented.</p>\n<p>The downside to this method is if the pinner somehow gets lucky when the mempool is empty,\nadds their top-of-mempool tx that is \u201ctoo large\u201d, the mempool fills, then the initial\ntransaction is now a pin. f the attacker can predict when a mempool will naturally\nfill, they could perhaps time this, but they risk getting mined, which defeats the purpose\nof the attack. I think in practice this is not a realistic concern, but\nrequires further consideration.</p>\n<p>Prior restraint via \u201cV3\u201d like means don\u2019t have the same issue, but the \u201cV3\u201d topological\nrestrictions are also more weakly motivated from a wallet usage perspective, so it\u2019s\nsomething that has to be weighed.</p>\n<p>Don\u2019t forget that lack of topological restrictions means batch CPFP is back on the\ntable.</p>\n<h1><a name=\"takeaway-6\" class=\"anchor\" href=\"#takeaway-6\"></a>Takeaway</h1>\n<p>\u201cV3\u201d by itself may be subsumed by priority transactions, but in conjunction with Ephemeral\nAnchors still can make a lot of sense for:</p>\n<ol>\n<li>sibling eviction usage when the base transaction cannot be directly conflicted</li>\n<li>and when signers are committing to multiple \u201cstate\u201d outputs\nand don\u2019t want to \u201csap\u201d value from the smart contract itself (mixing funds and fees).</li>\n</ol>\n<h1><a name=\"bonus-sighash_group-7\" class=\"anchor\" href=\"#bonus-sighash_group-7\"></a>Bonus? SIGHASH_GROUP</h1>\n<p>This method seems to naturally slot into SIGHASH_GROUP anti-pinning. A transaction input commits\nto the \u201ctop N blocks\u201d policy, and the rest of the constructed transaction is otherwise\nunrestricted.</p>\n<p>Alternatively, restricting based on \u201cmax size of cluster\u201d means you\u2019re putting\nprior restraint on yourself with respect to BYOF, batched bumps, etc. Similar\nto V3 constraints.</p>\n<p>Thought experiment: Are \u201cV3\u201d and Epehemeral anchors use-cases entirely subsumed by SIGHASH_GROUP + priority?</p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 3,
  "updated_at": "2024-02-22T03:32:11.783Z",
  "reply_count": 1,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 5,
  "reads": 21,
  "readers_count": 20,
  "score": 34.2,
  "yours": false,
  "topic_id": 159,
  "topic_slug": "opt-in-transaction-policies-for-anti-pinning",
  "topic_title": "Opt-in transaction policies for anti-pinning",
  "topic_html_title": "Opt-in transaction policies for anti-pinning",
  "category_id": 8,
  "display_username": "Gregory Sanders",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 3,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "(copied from a gist)\n\n\"Free Relay\"\n=\nIn transaction relay we are trying to avoid \"free relay\" which is roughly defined as:\n\n```\n(total_sats_in_mempool + total_sats_mined) / total_bytes_relayed < minrelay\n```\n\nDid the sum total of bytes we've been accepting to our mempool and propagating across\nthe network pay for the \"bandwidth\" to do so, dubbed `minrelay` which is a static value\nat 1 sat/vbyte?\n\nTherefore, if we for example remove bip125 rule#3 in a naive fashion, this can\nbe violated simply by filling the bottom of the mempool with 1 sat/vbyte junk,\nthen double-spending all of with minimum sized transactions at slightly higher\nrates, e.g., 2 sat/vbyte.\n\nThis can be problematic in adversarial and time-sensitive scenarios such as Lightning\nNetwork tranasctions, both \"commitment\" and \"HTLC\" transactions which each have timelines\nto be mined safely. The counter-party can intentionally slow down mining of these\ntransactions, and not pay for the privelage to do so, by putting these rule#3 pins\nat the bottom of the mempool that can become evicted.\n\nOpt-in policies\n===\n\nInstead of working around rule#3 directly, we can instead allow wallets to add\n\"prior restraint\" to features of the transaction that may mitigate these issues.\n\n\"V3\"\n===\n\nThe \"V3\" transaction type is proposed specifically as this kind of policy. If nVersion==3,\nthis means the topology for this transaction in the mempool is highly restricted.\nThe tx may have up to one ancestor and one descendant total, which implies\na strict upper-bound parent-child relationship of size two. The child transaction\nis additionally restricted to 1 kvB. This is deemed large enough that a child\ncan bring reasonable amounts of funds to do package RBF, but two orders of magnitude\nsmaller than the upper-bound possible (101kvB) in packages. This reduces the pin\neffect by roughly 250-500 times, making pins hopefully impractical.\n\nVery importantly, the parent transaction size is unrestricted.\n\nThis transaction type works well specifically for things such as commitment\ntransactions, in which utxos are locked into smart contracts between only\nthe authorized spending parties, and no ANYONECANPAY like behavior is allowed.\nThis precludes its usage in today's LN HTLC transactions, without a significant\nrewrite of how they work to include (Ephemeral?) anchors, and the resulting \nadditional vbytes in the commone non-pinning case.\n\nEphemeral anchors additionally allow:\n1) 0-value anchors\n2) \"sibling eviction\", which allows other outputs of transactions to not require \"1 CSV\"\n      hacks that are common in things such as LN BOLTs to avoid package limit pinning.\n      This saves bytes, and allows these outputs to be directly spent immdaitely as fees.\nBut relies on \"V3\" for its topological restrictions to ensure (2).\n\nSee more discussion on Ephemeral anchors and its relation to SIGHASH_GROUP fore more background:\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021334.html\n\nCluster Mempool\n===\n\nWith the cluster mempool, we have the ability to efficiently order the entire\nmempool, both in eviction and the mining. This can be efficiently updated incrementally\nfor each transaction added and removed from the mempool. Since the mempool\nis completely ordered for mining at each step, we can efficiently simulate mining\nN blocks, and give the necessary \"mining scores\" required for each chunk to\nbe included in that range of the mempool.\n\nTransaction Priority Opt-in\n===\n\nOnce you have a mapping from chunk mining score to \"top N blocks\", the system is\nfairly straight forward.\n\nUsers commit to the \"N\" in their transaction input(?). The proposed transaction\nis relayed, a node simulates adding the transaction to the cluster, runs linearization\nalgorithm, has the resulting mining score, checks that the \"N\" computed is higher\nthan any committed to in the transaction. If so, it's let into the mempool. If not,\nit's simply rejected.\n\nSubsequent descendants to that tranasaction must also conform to the most restrictive\nancestor's \"top N block\" chunk restriction, or they will be rejected.\nTherefore both \"ancestor junk\" and \"descendant junk\" are prevented.\n\nThe downside to this method is if the pinner somehow gets lucky when the mempool is empty,\nadds their top-of-mempool tx that is \"too large\", the mempool fills, then the initial\ntransaction is now a pin. f the attacker can predict when a mempool will naturally\nfill, they could perhaps time this, but they risk getting mined, which defeats the purpose\nof the attack. I think in practice this is not a realistic concern, but\nrequires further consideration.\n\nPrior restraint via \"V3\" like means don't have the same issue, but the \"V3\" topological\nrestrictions are also more weakly motivated from a wallet usage perspective, so it's\nsomething that has to be weighed.\n\nDon't forget that lack of topological restrictions means batch CPFP is back on the\ntable.\n\nTakeaway\n===\n\n\"V3\" by itself may be subsumed by priority transactions, but in conjunction with Ephemeral\nAnchors still can make a lot of sense for:\n1) sibling eviction usage when the base transaction cannot be directly conflicted\n2) and when signers are committing to multiple \"state\" outputs\nand don't want to \"sap\" value from the smart contract itself (mixing funds and fees).\n\nBonus? SIGHASH_GROUP\n===\nThis method seems to naturally slot into SIGHASH_GROUP anti-pinning. A transaction input commits\nto the \"top N blocks\" policy, and the rest of the constructed transaction is otherwise\nunrestricted.\n\nAlternatively, restricting based on \"max size of cluster\" means you're putting\nprior restraint on yourself with respect to BYOF, batched bumps, etc. Similar\nto V3 constraints.\n\nThought experiment: Are \"V3\" and Epehemeral anchors use-cases entirely subsumed by SIGHASH_GROUP + priority?",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 31,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "(copied from a gist) \n<a name=\"free-relay-1\" class=\"anchor\" href=\"#free-relay-1\"></a>\u201cFree Relay\u201d\nIn transaction relay we are trying to avoid \u201cfree relay\u201d which is roughly defined as: \n(total_sats_in_mempool + total_sats_mined) / total_bytes_relayed &lt; minrelay\n\nDid the sum total of bytes we\u2019ve been accepting to our mempool and propagating across\nthe network pay&hellip;",
  "truncated": true,
  "post_url": "/t/opt-in-transaction-policies-for-anti-pinning/159/1",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}