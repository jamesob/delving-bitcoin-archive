{
  "id": 352,
  "name": "Pieter Wuille",
  "username": "sipa",
  "avatar_template": "/user_avatar/delvingbitcoin.org/sipa/{size}/1100_2.png",
  "created_at": "2023-11-08T21:36:37.084Z",
  "cooked": "<p>Follow-up to <a href=\"https://delvingbitcoin.org/t/cluster-mempool-package-rbf-sketch/171\" class=\"inline-onebox\">[DEFUNCT] Cluster Mempool Package RBF sketch</a>.\nSuperseded by <a href=\"https://delvingbitcoin.org/t/post-clustermempool-package-rbf-per-chunk-processing/190\" class=\"inline-onebox\">Post-clustermempool package RBF: per-chunk processing</a>.</p>\n<h1><a name=\"design-for-post-clustermempool-package-rbf-rules-1\" class=\"anchor\" href=\"#design-for-post-clustermempool-package-rbf-rules-1\"></a>Design for post-clustermempool Package RBF rules.</h1>\n<p>A new package comes in (consisting of a set of transactions <code>PKG</code>). Ignore for now how the P2P side happens.</p>\n<ul>\n<li>\n<ol start=\"0\">\n<li><strong>Deduplication</strong>: remove from <code>PKG</code> any transaction that\u2019s already in the receiver\u2019s mempool.</li>\n</ol>\n</li>\n<li>\n<ol>\n<li><strong>Pre-linearization</strong>: linearize (what remains of) <code>PKG</code> (so <em>without</em> in-mempool dependencies).</li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li><strong>Pre-eviction</strong>: remove from <code>PKG</code> any chunk whose feerate is below <code>mempoolminfee</code> or below <code>incremental_relay_feerate</code>. [DoS protection]</li>\n</ol>\n</li>\n<li>\n<ol start=\"3\">\n<li>Gather <code>CON</code>, the set of in-mempool conflicts with (what remains of) <code>PKG</code>. If <code>CON</code> is non-empty:</li>\n</ol>\n<ul>\n<li>\n<ol start=\"4\">\n<li>Gather <code>OLD</code>: the union of all in-mempool clusters that contain <code>CON</code> or contain ancestors of <code>PKG</code>.</li>\n</ol>\n</li>\n<li>\n<ol start=\"5\">\n<li>Compute <code>NEW = OLD - CON + PKG</code>.</li>\n</ol>\n</li>\n<li>\n<ol start=\"6\">\n<li><strong>Relay check</strong>: <code>fee(NEW) &gt;= fee(OLD) + incremental_relay_feerate * size(PKG)</code>. [DoS protection]</li>\n</ol>\n</li>\n<li>\n<ol start=\"7\">\n<li><strong>Linearization</strong>: linearize all clusters in <code>NEW</code> (note that there can be multiple).</li>\n</ol>\n</li>\n<li>\n<ol start=\"8\">\n<li><strong>Diagram check</strong>: verify that the fee-size diagram of <code>NEW</code> is nowhere worse than that of <code>OLD</code>, and at least better in one place. [incentive compatibility]</li>\n</ol>\n</li>\n<li>\n<ol start=\"9\">\n<li><strong>Tail check</strong>: (only if <code>tail_feerate &gt;= incremental_relay_feerate</code>): verify that <code>fee(NEW) &gt;= tail_feerate * (size(NEW) - size(OLD)) + fee(OLD)</code>. [incentive compatibility]</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<ol start=\"10\">\n<li><strong>Verification</strong>: verify all transactions in <code>PKG</code> using policy/standardness rules, against UTXOs gathered from chain, mempool, and <code>PKG</code> itself.</li>\n</ol>\n</li>\n</ul>\n<p>(At this point the package is valid)</p>\n<ul>\n<li>\n<ol start=\"11\">\n<li><strong>Eviction</strong> Drop all of <code>CON</code> from mempool.</li>\n</ol>\n</li>\n<li>\n<ol start=\"12\">\n<li><strong>Addition</strong> One by one, add the transactions of <code>PKG</code> to mempool performing consensus validation.</li>\n</ol>\n</li>\n</ul>\n<p>In the above, wherever a linearization occurs, fail the package if it involves a cluster that exceeds cluster count limit. Also fail the package whenever a cluster would be created that exceeds the cluster size limit.</p>\n<h1><a name=\"open-questions-2\" class=\"anchor\" href=\"#open-questions-2\"></a>Open questions</h1>\n<ul>\n<li>\n<p>Q1. Do we need to run the sequence of operations inside (3) separately for each connected component inside <code>PKG</code> rather than all of (the remainder of) <code>PKG</code>  at once? Doing so would prevent some situations where there are two subpackages, one making a cluster a lot better, and one making another cluster somewhat worse, in such a way that the overall package is an improvement. On the other hand, this cannot possibly discover all cases where a combination of old and new transactions are better than both just old or just new.</p>\n</li>\n<li>\n<p>Q2. More generally, is this \u201cgood enough\u201d? One example is this: assume a new package is received consisting of transactions A(feerate 100), B(depends on A, feerate 4), C(depends on A, feerate 5). In the mempool we already have C\u2019(feerate 6). Assuming a sufficiently low <code>mempoolminfee</code>, the package (A,B,C) will replace C\u2019 according to the rules above. Yet, if C\u2019 gets relayed again, it would evict C, and you\u2019d end up with (A,B,C\u2019). This isn\u2019t free relay: both replacements are paid for, can only happens once (each), and both strictly improve the mempool. Some degree of subpackage validation could catch this (and/or result in the final version being reached immediately), as could chunk merging of <code>OLD</code> with <code>NEW</code>, but there almost certainly exist more complicated examples where the optimal mix of old and new cannot be found naively.</p>\n</li>\n</ul>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 11,
  "updated_at": "2024-02-22T03:32:11.993Z",
  "reply_count": 2,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 88,
  "reads": 19,
  "readers_count": 18,
  "score": 453.8,
  "yours": false,
  "topic_id": 173,
  "topic_slug": "defunct-post-clustermempool-package-rbf",
  "topic_title": "[DEFUNCT] Post-clustermempool Package RBF",
  "topic_html_title": "[DEFUNCT] Post-clustermempool Package RBF",
  "category_id": 8,
  "display_username": "Pieter Wuille",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 5,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Follow-up to https://delvingbitcoin.org/t/cluster-mempool-package-rbf-sketch/171.\nSuperseded by https://delvingbitcoin.org/t/post-clustermempool-package-rbf-per-chunk-processing/190.\n\n# Design for post-clustermempool Package RBF rules. \n\nA new package comes in (consisting of a set of transactions `PKG`). Ignore for now how the P2P side happens.\n\n* 0. **Deduplication**: remove from `PKG` any transaction that's already in the receiver's mempool.\n* 1. **Pre-linearization**: linearize (what remains of) `PKG` (so *without* in-mempool dependencies).\n* 2. **Pre-eviction**: remove from `PKG` any chunk whose feerate is below `mempoolminfee` or below `incremental_relay_feerate`. [DoS protection]\n* 3. Gather `CON`, the set of in-mempool conflicts with (what remains of) `PKG`. If `CON` is non-empty:\n  * 4. Gather `OLD`: the union of all in-mempool clusters that contain `CON` or contain ancestors of `PKG`.\n  * 5. Compute `NEW = OLD - CON + PKG`.\n  * 6. **Relay check**: `fee(NEW) >= fee(OLD) + incremental_relay_feerate * size(PKG)`. [DoS protection]\n  * 7. **Linearization**: linearize all clusters in `NEW` (note that there can be multiple).\n  * 8. **Diagram check**: verify that the fee-size diagram of `NEW` is nowhere worse than that of `OLD`, and at least better in one place. [incentive compatibility]\n  * 9. **Tail check**: (only if `tail_feerate >= incremental_relay_feerate`): verify that `fee(NEW) >= tail_feerate * (size(NEW) - size(OLD)) + fee(OLD)`. [incentive compatibility]\n\n* 10. **Verification**: verify all transactions in `PKG` using policy/standardness rules, against UTXOs gathered from chain, mempool, and `PKG` itself.\n\n(At this point the package is valid)\n\n* 11. **Eviction** Drop all of `CON` from mempool.\n* 12. **Addition** One by one, add the transactions of `PKG` to mempool performing consensus validation.\n\nIn the above, wherever a linearization occurs, fail the package if it involves a cluster that exceeds cluster count limit. Also fail the package whenever a cluster would be created that exceeds the cluster size limit.\n\n# Open questions\n\n* Q1. Do we need to run the sequence of operations inside (3) separately for each connected component inside `PKG` rather than all of (the remainder of) `PKG`  at once? Doing so would prevent some situations where there are two subpackages, one making a cluster a lot better, and one making another cluster somewhat worse, in such a way that the overall package is an improvement. On the other hand, this cannot possibly discover all cases where a combination of old and new transactions are better than both just old or just new.\n\n* Q2. More generally, is this \"good enough\"? One example is this: assume a new package is received consisting of transactions A(feerate 100), B(depends on A, feerate 4), C(depends on A, feerate 5). In the mempool we already have C'(feerate 6). Assuming a sufficiently low `mempoolminfee`, the package (A,B,C) will replace C' according to the rules above. Yet, if C' gets relayed again, it would evict C, and you'd end up with (A,B,C'). This isn't free relay: both replacements are paid for, can only happens once (each), and both strictly improve the mempool. Some degree of subpackage validation could catch this (and/or result in the final version being reached immediately), as could chunk merging of `OLD` with `NEW`, but there almost certainly exist more complicated examples where the optimal mix of old and new cannot be found naively.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 96,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "Follow-up to <a href=\"https://delvingbitcoin.org/t/cluster-mempool-package-rbf-sketch/171\" class=\"inline-onebox\">[DEFUNCT] Cluster Mempool Package RBF sketch</a>.\nSuperseded by <a href=\"https://delvingbitcoin.org/t/post-clustermempool-package-rbf-per-chunk-processing/190\" class=\"inline-onebox\">Post-clustermempool package RBF: per-chunk processing</a>. \n<a name=\"design-for-post-clustermempool-package-rbf-rules-1\" class=\"anchor\" href=\"#design-for-post-clustermempool-package-rbf-rules-1\"></a>Design for post-clustermempool Package RBF rules.\nA new package comes in (consisting of a set of transactions PKG). Ignore for now how the P2P side happens. \n\n\n\nDeduplicat&hellip;",
  "truncated": true,
  "post_url": "/t/defunct-post-clustermempool-package-rbf/173/1",
  "reactions": [
    {
      "id": "rocket",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}