{
  "id": 494,
  "name": "Anthony Towns",
  "username": "ajtowns",
  "avatar_template": "/user_avatar/delvingbitcoin.org/ajtowns/{size}/417_2.png",
  "created_at": "2023-11-27T07:15:18.258Z",
  "cooked": "<p>Oh, this gets easier if you split <span class=\"math\">C</span> into two steps: one to raise <code>List Tx</code> into <code>List (List Tx)</code> (by putting every element in a singleton list), call it <span class=\"math\">c=R(s)</span>, and the other that repeatedly merges adjacent chunks when they\u2019re out of order and gives you the best chunking, <span class=\"math\">b=C(c)</span></p>\n<p>Then you have <span class=\"math\">C(a) \\ge a</span> fairly straightforwardly (hopefully?), and also <span class=\"math\">C(a+b) = C(C(a) + b) = C(a+C(b)) = C(C(a)+C(b))</span> directly from merge order independence.</p>\n<p>Also, I think that means you\u2019re always comparing chunks (<code>List Tx</code>) by feerate, and chunkings (<code>List (List Tx)</code>) by diagram.</p>",
  "post_number": 22,
  "post_type": 1,
  "posts_count": 46,
  "updated_at": "2023-11-27T07:15:18.258Z",
  "reply_count": 1,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 34,
  "readers_count": 33,
  "score": 11.8,
  "yours": false,
  "topic_id": 209,
  "topic_slug": "merging-incomparable-linearizations",
  "topic_title": "Merging incomparable linearizations",
  "topic_html_title": "Merging incomparable linearizations",
  "category_id": 8,
  "display_username": "Anthony Towns",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Oh, this gets easier if you split $C$ into two steps: one to raise `List Tx` into `List (List Tx)` (by putting every element in a singleton list), call it $c=R(s)$, and the other that repeatedly merges adjacent chunks when they're out of order and gives you the best chunking, $b=C(c)$\n\nThen you have $C(a) \\ge a$ fairly straightforwardly (hopefully?), and also $C(a+b) = C(C(a) + b) = C(a+C(b)) = C(C(a)+C(b))$ directly from merge order independence.\n\nAlso, I think that means you're always comparing chunks (`List Tx`) by feerate, and chunkings (`List (List Tx)`) by diagram.",
  "actions_summary": [],
  "moderator": true,
  "admin": true,
  "staff": true,
  "user_id": 3,
  "hidden": false,
  "trust_level": 4,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "Oh, this gets easier if you split C into two steps: one to raise List Tx into List (List Tx) (by putting every element in a singleton list), call it c=R(s), and the other that repeatedly merges adjacent chunks when they\u2019re out of order and gives you the best chunking, b=C(c) \nThen you have C(a) \\ge &hellip;",
  "truncated": true,
  "post_url": "/t/merging-incomparable-linearizations/209/22",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}