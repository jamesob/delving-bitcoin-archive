{
  "id": 320,
  "name": "Suhas Daftuar",
  "username": "sdaftuar",
  "avatar_template": "/letter_avatar_proxy/v4/letter/s/0ea827/{size}.png",
  "created_at": "2023-11-01T02:06:07.737Z",
  "cooked": "<div data-theme-toc=\"true\"> </div>\n<h1><a name=\"background-1\" class=\"anchor\" href=\"#background-1\"></a>Background</h1>\n<p>What should the RBF rules be in a cluster-mempool implementation?  I originally proposed a heuristic involving a new transaction and its conflicts that I thought would be incentive compatible.  Another option is to define a measure on the mempool that we try to optimize.</p>\n<h1><a name=\"potential-ways-of-evaluating-an-rbf-2\" class=\"anchor\" href=\"#potential-ways-of-evaluating-an-rbf-2\"></a>Potential ways of evaluating an RBF</h1>\n<h2><a name=\"heuristic-proposal-3\" class=\"anchor\" href=\"#heuristic-proposal-3\"></a>Heuristic proposal</h2>\n<p>My first proposal of a heuristic for an RBF is to (a) require that the new transaction have a higher mining score than that\nof any transaction which would be evicted, and (b) require that the new transaction have a higher total fee than that of\nall transactions being evicted.</p>\n<p>To implement this, we have to calculate all conflicts (including descendants of direct conflicts), and then construct the\ncluster for a candidate replacement, linearize that cluster, and from there we get the new transaction\u2019s score. We can compare\nthat score to that of the conflicting transactions (which are cached in the mempool) to test whether the heuristic is met.</p>\n<h2><a name=\"mempool-metric-4\" class=\"anchor\" href=\"#mempool-metric-4\"></a>Mempool metric</h2>\n<p>An alternative approach would be to ensure that the the mempool that would result from a replacement is\n<em>strictly better</em> than the current mempool.</p>\n<p>To define <em>strictly better</em>, we consider the mempool fee vs. size diagram that we construct by looking at the accumulated size and accumulated fee of each in-mempool chunk, when we sort the mempool\u2019s chunks by chunk feerate.  We can compare two diagrams A and B by checking, for each diagram, whether each (size, fee) data point is contained within (or along) the convex hull of the points in the other diagram (that is, connect each pair of successive points in diagram A with a straight line, and test\nwhether the chunk (size, fee) points of diagram B are inside, outside, or along the lines of diagram A; then repeat in the opposite direction).  In this way, two diagrams can be equivalent (if all points of each are along the lines of the other), or\nthey can be incomparable (if each has points that lie outside the other), or one can be strictly better (if exactly one diagram contains points that are outside the other diagram).</p>\n<p>Example fee vs. size diagram from a live mempool (truncated to first 25 chunks):</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/1X/b184de6b742b233bf36d64049b6c39453a1e6d5c.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/b184de6b742b233bf36d64049b6c39453a1e6d5c\" title=\"sample feesize\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/1X/b184de6b742b233bf36d64049b6c39453a1e6d5c_2_690x399.png\" alt=\"sample feesize\" data-base62-sha1=\"pkpbjdtRMUsQbAOfi5zxOAKw1Nq\" width=\"690\" height=\"399\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/1X/b184de6b742b233bf36d64049b6c39453a1e6d5c_2_690x399.png, https://delvingbitcoin.org/uploads/default/optimized/1X/b184de6b742b233bf36d64049b6c39453a1e6d5c_2_1035x598.png 1.5x, https://delvingbitcoin.org/uploads/default/optimized/1X/b184de6b742b233bf36d64049b6c39453a1e6d5c_2_1380x798.png 2x\" data-dominant-color=\"FDFDFE\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">sample feesize</span><span class=\"informations\">1437\u00d7831 27.2 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>With this in mind, we can define an RBF validation strategy by requiring that the new mempool that would result must be strictly better than the current mempool.  To do this, we\u2019d first determine the clusters affected by the replacement (ie the\nclusters containing all the conflicts and the cluster(s) that the new transaction would join); we\u2019d calculate the fee vs size diagram for the chunks in those clusters; we\u2019d simulate removing the conflicts and adding the new transaction, and re-cluster/re-linearize those clusters; we\u2019d compute a new fee vs size diagram for the resulting clusters; and finally we\u2019d compare them to see if the new diagram is strictly better.</p>\n<h1><a name=\"discussion-5\" class=\"anchor\" href=\"#discussion-5\"></a>Discussion</h1>\n<p>Ultimately the intuition behind the heuristic is to implement something simple that would capture the improvement described\nin the mempool metric. However, it turns out that even with an optimal cluster sort, the heuristic doesn\u2019t guarantee that\nthe resulting mempool will be strictly better than what it replaced.</p>\n<h2><a name=\"example-of-heuristic-based-rbf-not-strictly-improving-the-mempool-6\" class=\"anchor\" href=\"#example-of-heuristic-based-rbf-not-strictly-improving-the-mempool-6\"></a>Example of heuristic-based rbf not strictly improving the mempool</h2>\n<p>All transactions are the same size (say, 100 bytes), and the numbers indicate feerate in sat/byte:</p>\n<pre data-code-height=\"147\" data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">graph TD;\n    A[Tx A: 1]--&gt;B[Tx B: 3.5];\n    A--&gt;C[Tx C: 5];\n    D[Tx D: 1];\n</code></pre>\n<p>In this graph, the optimal sort is [A, B, C],[D] (brackets indicate chunks).  The first chunk has total (size in bytes, fee in sats) = (300, 950), while the second chunk is (100, 100).  (See below for the fee vs size diagram.)</p>\n<p>Now consider an RBF that replaces tx C with tx E, as follows:</p>\n<pre data-code-height=\"147\" data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">graph TD;\n    A[Tx A: 1]--&gt;B[Tx B: 3.5];\n    D[Tx D: 1]--&gt;E[Tx E: 6];\n</code></pre>\n<p>The optimal sort of this new mempool would be: [D, E], [A, B]. The score of E is 700/200 = 3.5sat/byte, which\nis higher than the mining score of C before the replacement (3.17 sat/byte). Also, E pays more total fee than C (600 &gt; 500).</p>\n<p>So this replacement would pass the heuristic. However, the fee vs. size diagram for the new mempool (after replacement) has points (200, 700) and (400, 1150).  Let us now compare the old and new mempool diagrams:</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/1X/1c2a247ebb45bc3a930e83d0e900d19c741e8ca6.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/1c2a247ebb45bc3a930e83d0e900d19c741e8ca6\" title=\"Figure_1\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/1X/1c2a247ebb45bc3a930e83d0e900d19c741e8ca6_2_690x428.png\" alt=\"Figure_1\" data-base62-sha1=\"419ERV2azSMD2X1vcJOmTZenlRQ\" width=\"690\" height=\"428\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/1X/1c2a247ebb45bc3a930e83d0e900d19c741e8ca6_2_690x428.png, https://delvingbitcoin.org/uploads/default/original/1X/1c2a247ebb45bc3a930e83d0e900d19c741e8ca6.png 1.5x, https://delvingbitcoin.org/uploads/default/original/1X/1c2a247ebb45bc3a930e83d0e900d19c741e8ca6.png 2x\" data-dominant-color=\"FCFCFC\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">Figure_1</span><span class=\"informations\">1014\u00d7630 26.3 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>Note that the (300, 950) point from the first diagram lies outside the diagram for the new mempool, and so the replacement under these rules did not make the mempool strictly better.</p>\n<h2><a name=\"mempool-metric-7\" class=\"anchor\" href=\"#mempool-metric-7\"></a>Mempool metric</h2>\n<p>A few questions arise after seeing this example:</p>\n<ol>\n<li>Is there a simple way to understand why the mempool might not be strictly better off based on the heuristic, and can we add a simple rule that would eliminate the possibility?</li>\n<li>If not, should we instead just use the fee-size diagram test as our RBF validation metric?  Engineering this correctly will be annoying to do, particularly if we want to avoid linearizing the same clusters multiple times, but fundamentally this shouldn\u2019t be an operation that is too slow.</li>\n<li>Does the fee-size diagram actually capture the right idea?  For instance, would using this as our test allow for more pinning vectors than we have today?  How can we reason about what is happening?</li>\n</ol>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 25,
  "updated_at": "2024-02-22T03:32:12.956Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 135,
  "reads": 48,
  "readers_count": 47,
  "score": 684.6,
  "yours": false,
  "topic_id": 156,
  "topic_slug": "cluster-mempool-rbf-thoughts",
  "topic_title": "Cluster Mempool RBF Thoughts",
  "topic_html_title": "Cluster Mempool RBF Thoughts",
  "category_id": 8,
  "display_username": "Suhas Daftuar",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 6,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "<div data-theme-toc=\"true\"> </div>\n\n# Background\n\nWhat should the RBF rules be in a cluster-mempool implementation?  I originally proposed a heuristic involving a new transaction and its conflicts that I thought would be incentive compatible.  Another option is to define a measure on the mempool that we try to optimize.\n\n# Potential ways of evaluating an RBF\n\n## Heuristic proposal\n\nMy first proposal of a heuristic for an RBF is to (a) require that the new transaction have a higher mining score than that\nof any transaction which would be evicted, and (b) require that the new transaction have a higher total fee than that of\nall transactions being evicted.\n\nTo implement this, we have to calculate all conflicts (including descendants of direct conflicts), and then construct the\ncluster for a candidate replacement, linearize that cluster, and from there we get the new transaction's score. We can compare\nthat score to that of the conflicting transactions (which are cached in the mempool) to test whether the heuristic is met.\n\n## Mempool metric\n\nAn alternative approach would be to ensure that the the mempool that would result from a replacement is\n*strictly better* than the current mempool.  \n\nTo define *strictly better*, we consider the mempool fee vs. size diagram that we construct by looking at the accumulated size and accumulated fee of each in-mempool chunk, when we sort the mempool's chunks by chunk feerate.  We can compare two diagrams A and B by checking, for each diagram, whether each (size, fee) data point is contained within (or along) the convex hull of the points in the other diagram (that is, connect each pair of successive points in diagram A with a straight line, and test\nwhether the chunk (size, fee) points of diagram B are inside, outside, or along the lines of diagram A; then repeat in the opposite direction).  In this way, two diagrams can be equivalent (if all points of each are along the lines of the other), or\nthey can be incomparable (if each has points that lie outside the other), or one can be strictly better (if exactly one diagram contains points that are outside the other diagram).\n\nExample fee vs. size diagram from a live mempool (truncated to first 25 chunks):\n\n![sample feesize](upload://pkpbjdtRMUsQbAOfi5zxOAKw1Nq.png)\n\nWith this in mind, we can define an RBF validation strategy by requiring that the new mempool that would result must be strictly better than the current mempool.  To do this, we'd first determine the clusters affected by the replacement (ie the\nclusters containing all the conflicts and the cluster(s) that the new transaction would join); we'd calculate the fee vs size diagram for the chunks in those clusters; we'd simulate removing the conflicts and adding the new transaction, and re-cluster/re-linearize those clusters; we'd compute a new fee vs size diagram for the resulting clusters; and finally we'd compare them to see if the new diagram is strictly better.\n\n# Discussion\n\nUltimately the intuition behind the heuristic is to implement something simple that would capture the improvement described\nin the mempool metric. However, it turns out that even with an optimal cluster sort, the heuristic doesn't guarantee that\nthe resulting mempool will be strictly better than what it replaced.\n\n## Example of heuristic-based rbf not strictly improving the mempool\n\nAll transactions are the same size (say, 100 bytes), and the numbers indicate feerate in sat/byte:\n\n```mermaid height=147,auto\ngraph TD;\n    A[Tx A: 1]-->B[Tx B: 3.5];\n    A-->C[Tx C: 5];\n    D[Tx D: 1];\n```\n\nIn this graph, the optimal sort is [A, B, C],[D] (brackets indicate chunks).  The first chunk has total (size in bytes, fee in sats) = (300, 950), while the second chunk is (100, 100).  (See below for the fee vs size diagram.)\n\nNow consider an RBF that replaces tx C with tx E, as follows:\n\n```mermaid height=147,auto\ngraph TD;\n    A[Tx A: 1]-->B[Tx B: 3.5];\n    D[Tx D: 1]-->E[Tx E: 6];\n```\n\nThe optimal sort of this new mempool would be: [D, E], [A, B]. The score of E is 700/200 = 3.5sat/byte, which\nis higher than the mining score of C before the replacement (3.17 sat/byte). Also, E pays more total fee than C (600 > 500).\n\nSo this replacement would pass the heuristic. However, the fee vs. size diagram for the new mempool (after replacement) has points (200, 700) and (400, 1150).  Let us now compare the old and new mempool diagrams:\n\n![Figure_1](upload://419ERV2azSMD2X1vcJOmTZenlRQ.png)\n\nNote that the (300, 950) point from the first diagram lies outside the diagram for the new mempool, and so the replacement under these rules did not make the mempool strictly better.\n\n## Mempool metric \n\nA few questions arise after seeing this example:\n1. Is there a simple way to understand why the mempool might not be strictly better off based on the heuristic, and can we add a simple rule that would eliminate the possibility?\n2. If not, should we instead just use the fee-size diagram test as our RBF validation metric?  Engineering this correctly will be annoying to do, particularly if we want to avoid linearizing the same clusters multiple times, but fundamentally this shouldn't be an operation that is too slow.\n3. Does the fee-size diagram actually capture the right idea?  For instance, would using this as our test allow for more pinning vectors than we have today?  How can we reason about what is happening?",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 95,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "<a name=\"background-1\" class=\"anchor\" href=\"#background-1\"></a>Background\nWhat should the RBF rules be in a cluster-mempool implementation?  I originally proposed a heuristic involving a new transaction and its conflicts that I thought would be incentive compatible.  Another option is to define a measure on the mempool that we try to optimize. \n<a name=\"potential-ways-of-evaluating-an-rbf-2\" class=\"anchor\" href=\"#potential-ways-of-evaluating-an-rbf-2\"></a>Potential ways&hellip;",
  "truncated": true,
  "post_url": "/t/cluster-mempool-rbf-thoughts/156/1",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}