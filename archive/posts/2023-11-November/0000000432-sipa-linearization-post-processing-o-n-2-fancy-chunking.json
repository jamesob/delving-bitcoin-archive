{
  "id": 432,
  "name": "Pieter Wuille",
  "username": "sipa",
  "avatar_template": "/user_avatar/delvingbitcoin.org/sipa/{size}/1100_2.png",
  "created_at": "2023-11-16T22:45:48.228Z",
  "cooked": "<h3><a name=\"cluster-processing-overview-1\" class=\"anchor\" href=\"#cluster-processing-overview-1\"></a>Cluster processing overview</h3>\n<p>So far we\u2019ve thought of the process of processing clusters as:</p>\n<ul>\n<li>Run a linearization algorithm on the cluster (outputting a valid, and hopefully decent, topological ordering for its transactions).\n<ul>\n<li>The linearization algorithm internally repeatedly invokes a \u201cfind high-feerate topologically-valid subset\u201d algorithm (which could be ancestor set feerate based, or an exponential search algorithm), adding its results to the output.</li>\n</ul>\n</li>\n<li>Then run an <span class=\"math\">\\mathcal{O}(n)</span> chunking algorithm, which partitions the linearization into chunks that can be included in blocks at once. Intuitively: start with every transaction in its own chunk, and then repeatedly merge subsequent chunks where the second one has higher feerate than the first until no such pairs are left. In more detail, the algorithm is:\n<ul>\n<li>Start with an empty list of chunks.</li>\n<li>For each transaction <em>tx</em> in the linearization:\n<ul>\n<li>Create a new chunk at the end of the list with just <em>tx</em>.</li>\n<li>While there are at least two chunks, and the last one has higher feerate than the one before it:\n<ul>\n<li>merge the two chunks.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>Since at most <em>n-1</em> merge operations can take place, the inner while loop can run at most <em>2n-1</em> times, making this <span class=\"math\">\\mathcal{O}(n)</span>.</p>\n<h3><a name=\"chunking-can-go-bad-2\" class=\"anchor\" href=\"#chunking-can-go-bad-2\"></a>Chunking can go bad</h3>\n<p>In the context of <a href=\"https://delvingbitcoin.org/t/post-clustermempool-package-rbf-per-chunk-processing/190\">per-chunk package RBF</a>, it is becoming more important that the chunks that come out are \u201csane\u201d. We\u2019d expect that with a decent linearization algorithm choice, this would be the case, but it turns out it\u2019s not too hard to find bizarre examples.</p>\n<p>All transactions are the same size, number is feerate:</p>\n<pre data-code-height=\"234\" data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">graph BT \n   T2[\"A: 8\"];\n   T4[\"B: 1\"];\n   T1[\"C: 13\"];\n   T3[\"D: 13\"];\n   T0[\"E: 1\"];\n   T0 --&gt; T1 --&gt; T4;\n   T0 --&gt; T2;\n   T0 --&gt; T3 --&gt; T4;\n</code></pre>\n<p>Ancestor-set based linearization gives order [A,B,C,D,E]. The chunking algorithm turns this into [ABCD,E]. However, ABCD consists of two disconnected components (A and BCD). Of course the optimal order is [B,C,D,A,E] which would get chunked as [BCD,A,E], but ancestor-set linearization does not discover this.</p>\n<p>In the context of RBF policy it is probably undesirable that A and BCD would get processed simultaneously.</p>\n<h3><a name=\"a-better-chunking-algorithm-3\" class=\"anchor\" href=\"#a-better-chunking-algorithm-3\"></a>A better chunking algorithm</h3>\n<p>To address this, it is possible to amend the chunking algorithm so that it can guarantee that the resulting chunks are always connected. Instead of merging two chunks when the second one has higher feerate, only do that if there is a dependency between the two chunks. If not, swap the two chunks. In more detail:</p>\n<ul>\n<li>Start with an empty list of chunks.</li>\n<li>For each transaction <em>tx</em> in the linearization:\n<ul>\n<li>Create a new chunk with just <em>tx</em> in it at the end of the list.</li>\n<li>Make the variable <em>work</em> point to this newly created chunk.</li>\n<li>While <em>work</em> is not the first chunk in the list, and <em>work</em> has higher feerate than the chunk before it:\n<ul>\n<li>If <em>work</em> depends on its predecessor:\n<ul>\n<li>Merge <em>work</em> and its predecessor in one chunk</li>\n<li>Continue with <em>work</em> pointing to this merged chunk.</li>\n</ul>\n</li>\n<li>If <em>work</em> does not depend on its predecessor:\n<ul>\n<li>Swap the positions of the <em>work</em> chunk and its precessor.</li>\n<li>Continue with <em>work</em> pointing to the same (now moved) chunk.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>This can perform <span class=\"math\">\\frac{n(n-1)}{2}</span> swap operations, which makes the algorithm have complexity <span class=\"math\">\\mathcal{O}(n^2)</span>. If applied to an already-optimal linearization however, no swaps will take place, making the result <span class=\"math\">\\mathcal{O}(n)</span>. Based on fuzz-based searching, it appears possible that the number of swaps can remain quadratic for ancestor-based linearization.</p>\n<p>To see why this is correct, observe that this never merges disconnected components, so that alone guarantees that the result consists of connected chunks. For it to be a valid chunking, it also needs to have monotonically decreasing feerates. This is a loop invariant: if we assume this is true before a new tx is processed, it\u2019s only every untrue for the <em>work</em> variable, which gets resolved before continuing with the next transaction.</p>\n<p>This algorithm does more than just preventing connected chunks though; it swaps things, possibly making the resulting feerate diagram actually better. In fact, it <em>always</em> makes the feerate diagram strictly better everywhere, or doesn\u2019t affect it at all. It never worsens the diagram, or result in something incomparable. The cluster depicted above is also the simplest example (that I can find) for which this new algorithm improves the result.</p>\n<p>Despite that, the quality of the input linearization still matters. For example:</p>\n<pre data-code-height=\"147\" data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">graph BT \n   A[\"A: 1\"];\n   B[\"B: 2\"];\n   C[\"C: 9\"];\n   B --&gt; A;\n   C --&gt; A;\n</code></pre>\n<p>The optimal chunking (and one which ancestor-based linearization plus naive chunking would find) is [AC,B]. However, if the (terrible) linearization [A,B,C] were to be given to this fancier algorithm, it would just result in the single chunk [ABC]. This is because after merging [AB] with [C], it doesn\u2019t consider splitting off [B] again. As a result, we cannot use this algorithm as a replacement for linearization - doing so would sometimes result in worse chunkings than ancestor-based would.</p>\n<h3><a name=\"as-a-postprocessing-step-4\" class=\"anchor\" href=\"#as-a-postprocessing-step-4\"></a>As a postprocessing step</h3>\n<p>This algorithm can be considered as an improved version of the chunking algorithm, but it can also be conceived of as a post-processing algorithm for linearization. In this case it would operate on a list of lists of transactions rather than a list of chunks, but otherwise it remains the same. This has the advantage of outputting a linearization that the naive chunking algorithm (with lower complexity) can turn into the correct chunks again. In some cases it may be useful to be able to perform operations on the linearization that do not need a full relinearization, but only a rechunking.</p>\n<p>Given that even ancestor-set based linearization is quadratic, having a (fast) postprocessing step for it with the same complexity is probably not too bad. Furthermore, re-running this postprocessing step on the output does only require linear time, so it may be desirable to remember the post-processed linearization.</p>\n<p>When used in this manner, the algorithm also improves the linearization at a sub-chunk level, which may be useful when packing the very end of a block. There are other solutions too, though.</p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 8,
  "updated_at": "2024-02-22T03:32:12.116Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 29,
  "reads": 32,
  "readers_count": 31,
  "score": 211.4,
  "yours": false,
  "topic_id": 201,
  "topic_slug": "linearization-post-processing-o-n-2-fancy-chunking",
  "topic_title": "Linearization post-processing (O(n^2) fancy chunking)",
  "topic_html_title": "Linearization post-processing (O(n^2) fancy chunking)",
  "category_id": 8,
  "display_username": "Pieter Wuille",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 8,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "### Cluster processing overview\n\nSo far we've thought of the process of processing clusters as:\n* Run a linearization algorithm on the cluster (outputting a valid, and hopefully decent, topological ordering for its transactions).\n  * The linearization algorithm internally repeatedly invokes a \"find high-feerate topologically-valid subset\" algorithm (which could be ancestor set feerate based, or an exponential search algorithm), adding its results to the output.\n* Then run an $\\mathcal{O}(n)$ chunking algorithm, which partitions the linearization into chunks that can be included in blocks at once. Intuitively: start with every transaction in its own chunk, and then repeatedly merge subsequent chunks where the second one has higher feerate than the first until no such pairs are left. In more detail, the algorithm is:\n  * Start with an empty list of chunks.\n  * For each transaction *tx* in the linearization:\n    * Create a new chunk at the end of the list with just *tx*.\n    * While there are at least two chunks, and the last one has higher feerate than the one before it:\n      * merge the two chunks.\n\nSince at most *n-1* merge operations can take place, the inner while loop can run at most *2n-1* times, making this $\\mathcal{O}(n)$.\n\n### Chunking can go bad\n\nIn the context of [per-chunk package RBF](https://delvingbitcoin.org/t/post-clustermempool-package-rbf-per-chunk-processing/190), it is becoming more important that the chunks that come out are \"sane\". We'd expect that with a decent linearization algorithm choice, this would be the case, but it turns out it's not too hard to find bizarre examples.\n\nAll transactions are the same size, number is feerate:\n\n```mermaid height=234,auto\ngraph BT \n   T2[\"A: 8\"];\n   T4[\"B: 1\"];\n   T1[\"C: 13\"];\n   T3[\"D: 13\"];\n   T0[\"E: 1\"];\n   T0 --> T1 --> T4;\n   T0 --> T2;\n   T0 --> T3 --> T4;\n```\n\nAncestor-set based linearization gives order [A,B,C,D,E]. The chunking algorithm turns this into [ABCD,E]. However, ABCD consists of two disconnected components (A and BCD). Of course the optimal order is [B,C,D,A,E] which would get chunked as [BCD,A,E], but ancestor-set linearization does not discover this.\n\nIn the context of RBF policy it is probably undesirable that A and BCD would get processed simultaneously.\n\n### A better chunking algorithm\n\nTo address this, it is possible to amend the chunking algorithm so that it can guarantee that the resulting chunks are always connected. Instead of merging two chunks when the second one has higher feerate, only do that if there is a dependency between the two chunks. If not, swap the two chunks. In more detail:\n\n* Start with an empty list of chunks.\n* For each transaction *tx* in the linearization:\n  * Create a new chunk with just *tx* in it at the end of the list.\n  * Make the variable *work* point to this newly created chunk.\n  * While *work* is not the first chunk in the list, and *work* has higher feerate than the chunk before it:\n    * If *work* depends on its predecessor:\n      * Merge *work* and its predecessor in one chunk\n      * Continue with *work* pointing to this merged chunk.\n    * If *work* does not depend on its predecessor:\n      * Swap the positions of the *work* chunk and its precessor.\n      * Continue with *work* pointing to the same (now moved) chunk.\n\nThis can perform $\\frac{n(n-1)}{2}$ swap operations, which makes the algorithm have complexity $\\mathcal{O}(n^2)$. If applied to an already-optimal linearization however, no swaps will take place, making the result $\\mathcal{O}(n)$. Based on fuzz-based searching, it appears possible that the number of swaps can remain quadratic for ancestor-based linearization.\n\nTo see why this is correct, observe that this never merges disconnected components, so that alone guarantees that the result consists of connected chunks. For it to be a valid chunking, it also needs to have monotonically decreasing feerates. This is a loop invariant: if we assume this is true before a new tx is processed, it's only every untrue for the *work* variable, which gets resolved before continuing with the next transaction.\n\nThis algorithm does more than just preventing connected chunks though; it swaps things, possibly making the resulting feerate diagram actually better. In fact, it *always* makes the feerate diagram strictly better everywhere, or doesn't affect it at all. It never worsens the diagram, or result in something incomparable. The cluster depicted above is also the simplest example (that I can find) for which this new algorithm improves the result.\n\nDespite that, the quality of the input linearization still matters. For example:\n\n```mermaid height=147,auto\ngraph BT \n   A[\"A: 1\"];\n   B[\"B: 2\"];\n   C[\"C: 9\"];\n   B --> A;\n   C --> A;\n```\n\nThe optimal chunking (and one which ancestor-based linearization plus naive chunking would find) is [AC,B]. However, if the (terrible) linearization [A,B,C] were to be given to this fancier algorithm, it would just result in the single chunk [ABC]. This is because after merging [AB] with [C], it doesn't consider splitting off [B] again. As a result, we cannot use this algorithm as a replacement for linearization - doing so would sometimes result in worse chunkings than ancestor-based would.\n\n### As a postprocessing step\n\nThis algorithm can be considered as an improved version of the chunking algorithm, but it can also be conceived of as a post-processing algorithm for linearization. In this case it would operate on a list of lists of transactions rather than a list of chunks, but otherwise it remains the same. This has the advantage of outputting a linearization that the naive chunking algorithm (with lower complexity) can turn into the correct chunks again. In some cases it may be useful to be able to perform operations on the linearization that do not need a full relinearization, but only a rechunking.\n\nGiven that even ancestor-set based linearization is quadratic, having a (fast) postprocessing step for it with the same complexity is probably not too bad. Furthermore, re-running this postprocessing step on the output does only require linear time, so it may be desirable to remember the post-processed linearization.\n\nWhen used in this manner, the algorithm also improves the linearization at a sub-chunk level, which may be useful when packing the very end of a block. There are other solutions too, though.",
  "actions_summary": [
    {
      "id": 2,
      "count": 2
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 96,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "<a name=\"cluster-processing-overview-1\" class=\"anchor\" href=\"#cluster-processing-overview-1\"></a>Cluster processing overview\nSo far we\u2019ve thought of the process of processing clusters as: \n\nRun a linearization algorithm on the cluster (outputting a valid, and hopefully decent, topological ordering for its transactions).\n\nThe linearization algorithm internally repeatedly invokes a \u201cfind high-fee&hellip;",
  "truncated": true,
  "post_url": "/t/linearization-post-processing-o-n-2-fancy-chunking/201/1",
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 2
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 2,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}