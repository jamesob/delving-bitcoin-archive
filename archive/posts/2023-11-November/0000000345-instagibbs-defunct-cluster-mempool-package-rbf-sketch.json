{
  "id": 345,
  "name": "Gregory Sanders",
  "username": "instagibbs",
  "avatar_template": "/user_avatar/delvingbitcoin.org/instagibbs/{size}/28_2.png",
  "created_at": "2023-11-08T15:42:12.562Z",
  "cooked": "<p>\u201cI really should write this on delving but\u201d - Pieter, literally</p>\n<p>Copied for posterity:</p>\n<p>So I think this is roughly the idea we discussed today for post-clustermempool package-rbf processing (no subpackage validation!):</p>\n<ol>\n<li>Compute the set OLD of all affected clusters in the mempool (any parent/conflict of the package\u2019s transactions, plus all other transactions in the same cluster(s)). This may contain multiple existing clusters.</li>\n<li>Compute the set NEW that this OLD would be replaced with: equal to OLD, with the new package added to it, and all conflicts removed. Note that this may contain multiple clusters if existing stuff splits. NEW contains actually new transactions, but also stuff already in OLD that just may get rechunked.</li>\n<li>Linearize all clusters in NEW.</li>\n<li>\u201cPre-eviction\u201d: remove from NEW any actually new transaction (so in NEW but not in OLD) whose chunk feerate is below mempoolminfee.</li>\n<li>Incremental feerate check: fee(NEW) - fee(OLD) &gt;= incfeerate * size(NEW \\ OLD). If not, reject the whole thing.</li>\n<li>Fee-size diagram check: compare the fee-side diagram of NEW with that of OLD. If it\u2019s worse anywhere, reject the whole thing. Also do the tail feerate check here, if not subsumed by incfeerate check.</li>\n<li>Verify new transactions.</li>\n<li>Add to NEW all transactions from OLD that don\u2019t actually conflict anymore (due to things removed by the pre-eviction step).</li>\n<li>Apply to mempool.</li>\n</ol>\n<p>Writing this down now, it seems to me that doing (8) between (4) and (5) is strictly better; it\u2019s work you need to do anyway, and it can only help the (5) and (6) checks.\n5:02 PM</p>\n<p>2</p>\n<p>Pieter Wuille\nA re-linearization after (4) and/or (8) is possible too, but it\u2019s not clear how much that helps, and doing that consistently would probably imply redoing (4) again too - possibly leading to a long set of iterations.</p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 2,
  "updated_at": "2024-02-22T03:32:12.859Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 93,
  "reads": 21,
  "readers_count": 20,
  "score": 529.2,
  "yours": false,
  "topic_id": 171,
  "topic_slug": "defunct-cluster-mempool-package-rbf-sketch",
  "topic_title": "[DEFUNCT] Cluster Mempool Package RBF sketch",
  "topic_html_title": "[DEFUNCT] Cluster Mempool Package RBF sketch",
  "category_id": 8,
  "display_username": "Gregory Sanders",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 4,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "\"I really should write this on delving but\" - Pieter, literally\n\nCopied for posterity:\n\nSo I think this is roughly the idea we discussed today for post-clustermempool package-rbf processing (no subpackage validation!):\n\n1. Compute the set OLD of all affected clusters in the mempool (any parent/conflict of the package's transactions, plus all other transactions in the same cluster(s)). This may contain multiple existing clusters.\n2. Compute the set NEW that this OLD would be replaced with: equal to OLD, with the new package added to it, and all conflicts removed. Note that this may contain multiple clusters if existing stuff splits. NEW contains actually new transactions, but also stuff already in OLD that just may get rechunked.\n3. Linearize all clusters in NEW.\n4. \"Pre-eviction\": remove from NEW any actually new transaction (so in NEW but not in OLD) whose chunk feerate is below mempoolminfee.\n5. Incremental feerate check: fee(NEW) - fee(OLD) >= incfeerate * size(NEW \\ OLD). If not, reject the whole thing.\n6. Fee-size diagram check: compare the fee-side diagram of NEW with that of OLD. If it's worse anywhere, reject the whole thing. Also do the tail feerate check here, if not subsumed by incfeerate check.\n7. Verify new transactions.\n8. Add to NEW all transactions from OLD that don't actually conflict anymore (due to things removed by the pre-eviction step).\n9. Apply to mempool.\n\nWriting this down now, it seems to me that doing (8) between (4) and (5) is strictly better; it's work you need to do anyway, and it can only help the (5) and (6) checks.\n5:02 PM\n\n2\n\nPieter Wuille\nA re-linearization after (4) and/or (8) is possible too, but it's not clear how much that helps, and doing that consistently would probably imply redoing (4) again too - possibly leading to a long set of iterations.",
  "actions_summary": [
    {
      "id": 2,
      "count": 2
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 31,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "\u201cI really should write this on delving but\u201d - Pieter, literally \nCopied for posterity: \nSo I think this is roughly the idea we discussed today for post-clustermempool package-rbf processing (no subpackage validation!): \n\nCompute the set OLD of all affected clusters in the mempool (any parent/conflic&hellip;",
  "truncated": true,
  "post_url": "/t/defunct-cluster-mempool-package-rbf-sketch/171/1",
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 2
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 2,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}