{
  "id": 434,
  "name": "Pieter Wuille",
  "username": "sipa",
  "avatar_template": "/user_avatar/delvingbitcoin.org/sipa/{size}/1100_2.png",
  "created_at": "2023-11-17T02:40:41.092Z",
  "cooked": "<h1><a name=\"cluster-mempool-theory-1\" class=\"anchor\" href=\"#cluster-mempool-theory-1\"></a>Cluster mempool theory</h1>\n<div data-theme-toc=\"true\"> </div>\n<h2><a name=\"transaction-graphs-and-clusters-2\" class=\"anchor\" href=\"#transaction-graphs-and-clusters-2\"></a>Transaction graphs and clusters</h2>\n<p><em><strong>Definition</strong></em>. A <strong>transaction graph</strong>, or in cluster mempool context, just <strong>graph</strong>, is a <a href=\"https://en.wikipedia.org/wiki/Directed_acyclic_graph\">directed acyclic graph</a> (DAG), with <em>n</em> vertices (also called <strong>transactions</strong>), where each vertex is labelled with a <strong>fee</strong> (an integer) and a <strong>size</strong> (a strictly positive integer). If an edge from node <em>c</em> to node <em>p</em> exists, <em>p</em> is called a <strong>parent</strong> or <strong>dependency</strong> of <em>c</em>, and <em>c</em> a <strong>child</strong> of <em>p</em>. In other words, transaction graphs are dependency graph whose vertices point to their dependencies.</p>\n<p><em><strong>Definition</strong></em>. Given a graph <em>G</em> and a transaction <em>x</em> in it, the <strong>ancestor set</strong> <span class=\"math\">\\operatorname{anc}_G(x)</span> of <em>x</em> is the set of all transactions which can be <a href=\"https://en.wikipedia.org/wiki/Reachability\">reached</a> from <em>x</em> (this always includes <em>x</em> itself). For sets <span class=\"math\">S</span>, we define <span class=\"math\">\\operatorname{anc}_G(S) = \\cup_{x \\in S} \\operatorname{anc}_G(x)</span>, the union of the ancestor sets of all the transactions in the set.</p>\n<p><em><strong>Definition</strong></em>. Given a graph <em>G</em> and a transaction <em>x</em> in it, the <strong>descendant set</strong> <span class=\"math\">\\operatorname{desc}_G(x)</span> of <em>x</em> is the set of all transactions from which <em>x</em> can be reached. For sets <span class=\"math\">S</span>, we define <span class=\"math\">\\operatorname{desc}_G(S) = \\cup_{x \\in S} \\operatorname{desc}_G(x)</span>, the union of the descendant sets of all the transactions in the set.</p>\n<p><em><strong>Definition</strong></em>. A <strong>cluster</strong> is a <a href=\"https://en.wikipedia.org/wiki/Component_(graph_theory)\">connected component</a> of a graph <em>ignoring direction</em>. In other words, for any two transactions in a cluster it is possible to go from one to the other by making a sequence of steps, each traveling along an edge in either forward or backward direction. The clusters of a graph form a <a href=\"https://en.wikipedia.org/wiki/Partition_of_a_set\">partition</a> of its vertices, and the <strong>cluster of a transaction</strong> is the connected component which that transaction is part of. It can be found as the <a href=\"https://en.wikipedia.org/wiki/Transitive_closure\">transitive closure</a> of the \u201cis parent or child of\u201d relation on the singleton of the given transaction.</p>\n<p>Consider the transaction graph below (fees and sizes are omitted):</p>\n<pre data-code-height=\"234\" data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">graph BT\n   t5[\"t&lt;sub&gt;5&lt;/sub&gt;\"] --&gt; t2[\"t&lt;sub&gt;2&lt;/sub&gt;\"];\n   t6[\"t&lt;sub&gt;6&lt;/sub&gt;\"] --&gt; t2;\n   t6 --&gt; t3[\"t&lt;sub&gt;3&lt;/sub&gt;\"] --&gt; t1[\"t&lt;sub&gt;1&lt;/sub&gt;\"];\n   t7[\"t&lt;sub&gt;7&lt;/sub&gt;\"] --&gt; t4[\"t&lt;sub&gt;4&lt;/sub&gt;\"];\n</code></pre>\n<p>In this example there are two clusters: <span class=\"math\">\\{t_1, t_2, t_3, t_5, t_6\\}</span> and <span class=\"math\">\\{t_4, t_7\\}</span>.</p>\n<p><em><strong>Definition</strong></em>. Given a subset <span class=\"math\">S</span> of nodes of a graph, define the following functions:</p>\n<ul>\n<li><span class=\"math\">\\operatorname{fee}(S) = \\sum_{x \\in S} \\operatorname{fee}_x</span>: the sum of fees of transactions in <span class=\"math\">S</span>.</li>\n<li><span class=\"math\">\\operatorname{size}(S) = \\sum_{x \\in S} \\operatorname{size}_x</span>: the sum of sizes of transactions in <span class=\"math\">S</span>.</li>\n<li><span class=\"math\">\\operatorname{feerate}(S) = \\operatorname{fee}(S) / \\operatorname{size}(S)</span>: the sum of the fees divided by the sum of the sizes of transactions in <span class=\"math\">S</span>. Only defined for non-empty sets <span class=\"math\">S</span>.</li>\n</ul>\n<h2><a name=\"linearizations-and-chunks-3\" class=\"anchor\" href=\"#linearizations-and-chunks-3\"></a>Linearizations and chunks</h2>\n<p><em><strong>Definition</strong></em>. A <strong>topological subset</strong> <span class=\"math\">S</span> of a graph <span class=\"math\">G</span> is a subset of its transactions that includes all ancestors of all its elements. In other words, <span class=\"math\">S</span> is topological subset of <span class=\"math\">G</span> iff <span class=\"math\">\\operatorname{anc}_G(S) = S</span>.</p>\n<p><em><strong>Definition</strong></em>. A <strong>linearization</strong> <span class=\"math\">L</span> for a given graph <span class=\"math\">G</span> is a permutation of its transactions in which parents appear before children. In other words, <span class=\"math\">L = (t_1, t_2, \\ldots, t_n)</span> is a linearization of <span class=\"math\">G</span> if <span class=\"math\">\\{t_1, t_2, \\ldots, t_k\\}</span> is a topological subset of <span class=\"math\">G</span> for all <span class=\"math\">k = 1 \\ldots n</span>. A linearization is thus a <a href=\"https://en.wikipedia.org/wiki/Topological_sorting\">topological sort</a> of the graph vertices.</p>\n<p>In the example above:</p>\n<ul>\n<li><span class=\"math\">(t_1, t_2, t_3, t_4, t_5, t_6, t_7)</span> is a valid linearization.</li>\n<li><span class=\"math\">(t_2, t_5, t_1, t_3, t_6, t_4, t_7)</span> is a valid linearization.</li>\n<li><span class=\"math\">(t_1, t_3, t_6, t_2, t_5, t_4, t_7)</span> is not (<span class=\"math\">t_6</span> is included before its parent <span class=\"math\">t_2</span>).</li>\n</ul>\n<p><em><strong>Definition</strong></em>. Given a linearization <span class=\"math\">L</span> for a graph <span class=\"math\">G</span>, and a subset <span class=\"math\">S</span> of <span class=\"math\">G</span>, the <strong>sublinearization</strong> <span class=\"math\">L[S]</span> is the linearization of <span class=\"math\">S</span> which keeps the same internal ordering as those transactions have in <span class=\"math\">L</span>.</p>\n<p><em><strong>Definition</strong></em>. A <strong>chunking</strong> <span class=\"math\">C = (c_1, c_2, \\ldots, c_n)</span> for a given graph <em>G</em> is a sequence of sets of transactions (called <strong>chunks</strong>) of <em>G</em> such that:</p>\n<ul>\n<li>The chunks <span class=\"math\">c_i</span> form a partition of <em>G</em> (no overlap, and their union contains all elements).</li>\n<li>Every prefix of chunks is topological (<span class=\"math\">\\cup_{i=1}^{k} c_i</span> for <span class=\"math\">k=1 \\ldots n</span> are topological subsets of <span class=\"math\">G</span>). Thus, a transaction\u2019s parent can appear in the same chunk as the transaction itself or in an earlier chunk, but not in a later chunk.</li>\n<li>The feerates of the sets are monotonically decreasing.</li>\n</ul>\n<p>Note that in practice, we will only work with chunkings of individual clusters, rather than possibly-disconnected graphs. The reasoning for that will come later, so for now, we define chunkings for graphs in general.</p>\n<p><em><strong>Definition</strong></em>. The function <span class=\"math\">\\operatorname{chunks}(L)</span> for a linearization <span class=\"math\">L = (t_1, t_2, \\ldots, t_n)</span> of a graph <span class=\"math\">G</span> returns the <strong>corresponding chunking</strong> of that linearization, defined as:</p>\n<ul>\n<li>If <span class=\"math\">L</span> (and thus <span class=\"math\">G</span>) is empty, <span class=\"math\">\\operatorname{chunks}(L) = ()</span>.</li>\n<li>Otherwise:\n<ul>\n<li>Let <span class=\"math\">f_j = \\operatorname{feerate}(\\{t_1, t_2, \\ldots, t_j)</span> for <span class=\"math\">j = 1 \\ldots n</span>.</li>\n<li>Let <span class=\"math\">k</span> be the smallest integer <span class=\"math\">\\geq 1</span> such that no <span class=\"math\">f_j &gt; f_k</span> exists.</li>\n<li>Let <span class=\"math\">c = \\{t_1, t_2, \\ldots, t_k\\}</span>.</li>\n<li><span class=\"math\">\\operatorname{chunks}(L) = (c) + \\operatorname{chunks}(L[\\{t_{k+1}, \\ldots n\\}])</span>.</li>\n</ul>\n</li>\n</ul>\n<p>In other words, <span class=\"math\">\\operatorname{chunks}</span> constructs the chunking of a linearization consisting of successively best remaining prefixes of that linearization.</p>\n<p><em><strong>Theorem</strong></em>. The corresponding chunking <span class=\"math\">\\operatorname{chunks}(L)</span> is a valid chunking for <span class=\"math\">G</span>.</p>\n<p><em><strong>Proof</strong></em>. All criteria for a valid chunking are fulfilled:</p>\n<ul>\n<li>All transactions that occurred in <span class=\"math\">L</span> (which are all transactions in <span class=\"math\">G</span>) will appear in <span class=\"math\">\\operatorname{chunks}(L)</span> once.</li>\n<li>Every prefix of chunks is topological, because each corresponds to a prefix of <span class=\"math\">L</span> (which are topological for any valid linearization).</li>\n<li>The feerates are monotonically decreasing. If that wasn\u2019t the case, the chosen <span class=\"math\">k</span> would violate the \u201cno <span class=\"math\">f_j &gt; f_k</span>\u201d rule.</li>\n</ul>\n<p><em><strong>Theorem</strong></em>. The <strong>feerate of a prefix of a linearization never exceeds its first chunk feerate</strong>. If it did, the first chunk would clearly not be the highest-feerate prefix of the linearization.</p>\n<p><em><strong>Theorem</strong></em>. The <strong>feerate of a suffix of a linearization is never less than its last chunk feerate</strong>. This is true within the last chunk, because if there was a suffix of the last chunk with lower feerate than that chunk, that suffix could be split off, and the feerate of the part before it would go up. It is also true across multiple chunks, because if a suffix can\u2019t have a lower feerate than the last chunk, then extended the suffix to a chunk before it (whose maximum suffix feerate is even higher) cannot change that property.</p>\n<p><em><strong>Definition</strong></em>. We also define a <strong>corresponding linearization of a chunking</strong> as a linearization consisting of a concatenation of the chunks, in order, and within each chunk ordered topologically. This correspondence is not unique (because there can be multiple topological sorts of the chunk elements), but all corresponding linearizations of a chunking have the original chunking as corresponding chunking (or a strictly better one)\nDue to the simplicity of converting between chunking and linearization, we can often treat them as the same.</p>\n<p><em><strong>Definition</strong></em>. Given a chunking <span class=\"math\">C = (c_1, c_2, \\ldots, c_n)</span>, its <strong>feerate diagram</strong> <span class=\"math\">\\operatorname{diag}_C</span> is a real function with domain <span class=\"math\">[0, \\operatorname{size}(c_1 \\cup c_2 \\cup \\ldots c_n)]</span>, defined as follows:</p>\n<ul>\n<li>Let <span class=\"math\">\\gamma_i = \\cup_{j=0}^{i} c_j</span> for <span class=\"math\">i=0 \\ldots n</span>, the union of all transactions in the first <span class=\"math\">i</span> chunks.</li>\n<li>For all <span class=\"math\">i = 0 \\ldots n-1</span> and <span class=\"math\">\\alpha \\in [0,1]</span>:\n<ul>\n<li><span class=\"math\">\\operatorname{diag}_C(\\operatorname{size}(\\gamma_i) + \\alpha \\operatorname{size}(c_{i+1})) = \\operatorname{fee}(\\gamma_i) + \\alpha \\operatorname{fee}(c_{i+1})</span>.</li>\n</ul>\n</li>\n<li>In other words, <span class=\"math\">\\operatorname{diag}_C</span> is a function from cumulative fees to cumulative sizes. When evaluated in the size of a prefix of chunks in <span class=\"math\">C</span>, it gives the fee in that prefix. For other values it linearly interpolates between those points.</li>\n<li>The feerate diagram of a linearization is that of its corresponding chunking.</li>\n</ul>\n<p><em><strong>Theorem</strong></em>. The feerate diagram <span class=\"math\">\\operatorname{diag}_L</span> of a linearization <span class=\"math\">L = (t_1, t_2, \\ldots, t_n)</span> is the minimal concave function for which for every <span class=\"math\">k = 0 \\ldots n</span> it holds that <span class=\"math\">\\operatorname{diag}_L(\\operatorname{size}(\\{t_1, t_2, \\ldots, t_k\\}) \\geq \\operatorname{fee}(\\{t_1, t_2, \\ldots, t_k\\})</span>. As such, it gives an overestimate for the fees in all prefixes of a linearization. In other words, the grouping of transactions performed by <span class=\"math\">\\operatorname{chunks}</span> exactly corresponds to the straight line segments resulting from requiring the feerate diagram to be concave. [no proof]</p>\n<p><em><strong>Definition</strong></em>. We define a <strong><a href=\"https://en.wikipedia.org/wiki/Preorder\">preorder</a></strong> on linearizations/chunkings for the same graph <span class=\"math\">G</span> by comparing their feerate diagrams:</p>\n<ul>\n<li>Two linearizations are equivalent if their feerate diagrams coincide: <span class=\"math\">L_1 \\sim L_2 \\iff \\forall x \\in [0, \\operatorname{size}(G)]: \\operatorname{diag}_{L_1}(x) = \\operatorname{diag}_{L_2}(x)</span>.</li>\n<li>A linearization is <strong>at least as good</strong> as another if its feerate diagram is never lower than the other\u2019s: <span class=\"math\">L_1 \\gtrsim L_2 \\iff \\forall x \\in [0, \\operatorname{size}(G)]: \\operatorname{diag}_{L_1}(x) \\geq \\operatorname{diag}_{L_2}(x)</span>.</li>\n<li>A linearization is <strong>at least as bad</strong> as another if its feerate diagram is never higher than the other\u2019s:  <span class=\"math\">L_1 \\lesssim L_2 \\iff \\forall x \\in [0, \\operatorname{size}(G)]: \\operatorname{diag}_{L_1}(x) \\leq \\operatorname{diag}_{L_2}(x)</span>.</li>\n<li>A linearization is <strong>better</strong> than another if its feerate diagram is never lower than the other\u2019s, and at least somewhere higher: <span class=\"math\">L_1 &gt; L_2 \\iff L_1 \\gtrsim L_2</span> and not <span class=\"math\">L_1 \\sim L_2</span>.</li>\n<li>A linearization is <strong>worse</strong> than another if its feerate diagram is never higher than the other\u2019s, and at least somewhere lower: <span class=\"math\">L_1 &lt; L_2 \\iff L_1 \\lesssim L_2</span> and not <span class=\"math\">L_1 \\sim L_2</span>.</li>\n<li>Linearizations <span class=\"math\">L_1</span> and <span class=\"math\">L_2</span> are <strong>incomparable</strong> when neither <span class=\"math\">L_1 \\gtrsim L_2</span> nor <span class=\"math\">L_1 \\lesssim L_2</span> (and <strong>comparable</strong> when at least one of those relations holds).</li>\n<li>This is not a <a href=\"https://en.wikipedia.org/wiki/Partially_ordered_set\">partial order</a>, because <span class=\"math\">L_1 \\sim L_2</span> does not imply <span class=\"math\">L_1 = L_2</span> (distinct linearizations can be equivalent).</li>\n</ul>\n<h2><a name=\"transformations-on-linearizations-4\" class=\"anchor\" href=\"#transformations-on-linearizations-4\"></a>Transformations on linearizations</h2>\n<p><em><strong>Theorem</strong></em>. The <strong>chunk reordering theorem</strong>: reordering a linearization with changes restricted to a single chunk results leaves it at least as good, provided the result is still a valid linearization (i.e., its prefixes are topological).</p>\n<p><em><strong>Proof</strong></em>. Every prefix of chunks in the original linearization remains a prefix of transactions in the new linearization. Because the new feerate diagram is the minimal concave function not below these points, and these points form the old feerate diagram, the new feerate diagram cannot be below the old one.</p>\n<p><em><strong>Theorem</strong></em>. The <strong>prefix stripping theorem</strong>: Given two linearizations <span class=\"math\">L_1 = (t_1, t_2, \\ldots, t_n)</span> and <span class=\"math\">L_2 = (u_1, u_2, \\ldots, u_n)</span> for the same graph with a shared prefix: <span class=\"math\">t_i = u_i</span> for all <span class=\"math\">i = 1 \\ldots k</span>. In this case:</p>\n<ul>\n<li>If the suffix is at least as good, then the whole linearization is at least as good: <span class=\"math\">(t_{k+1}, t_{k+2}, \\ldots, t_n) \\gtrsim (u_{k+1}, u_{k+2}, \\ldots, u_n) \\implies L_1 \\gtrsim L_2</span>.</li>\n<li>If the suffix is at least as bad, then the whole linearization is at least as bad: <span class=\"math\">(t_{k+1}, t_{k+2}, \\ldots, t_n) \\lesssim (u_{k+1}, u_{k+2}, \\ldots, u_n) \\implies L_1 \\lesssim L_2</span>.</li>\n</ul>\n<p><em><strong>Theorem</strong></em>. The <strong>gathering theorem</strong>. Moving a sublinearization of transactions to the front of a linearization never worsens the linearization if the sublinearization\u2019s worst chunk feerate is at least that of the linearization\u2019s best chunk feerate (see discussion in <a href=\"https://delvingbitcoin.org/t/merging-incomparable-linearizations/209\">merging incomparable linearizations</a>):</p>\n<ul>\n<li>Let <span class=\"math\">L</span> be a linearization of a graph <span class=\"math\">G</span>.</li>\n<li>Let <span class=\"math\">C = (c_1, c_2, \\ldots, c_n) = \\operatorname{chunks}(L)</span>.</li>\n<li>Let <span class=\"math\">S</span> be a topologically valid subset of <span class=\"math\">G</span>.</li>\n<li>Let <span class=\"math\">D = (d_1, d_2, \\ldots, d_m) = \\operatorname{chunks}(L[S])</span>.</li>\n<li>Let <span class=\"math\">L' = L[S] + L[G \\setminus S])</span>, the linearization obtained by moving <span class=\"math\">L[S]</span> to the front.</li>\n</ul>\n<p>In this case, <span class=\"math\">\\operatorname{feerate}(d_m) \\geq \\operatorname{feerate}(c_1) \\implies L' \\gtrsim L</span>.</p>\n<p><em><strong>Proof</strong></em>.</p>\n<ul>\n<li>Let <span class=\"math\">f = \\operatorname{feerate}(c_1)</span>, the feerate of the highest-feerate prefix of <span class=\"math\">L</span>.</li>\n<li>Let <span class=\"math\">e_j = c_j \\cap S</span> for <span class=\"math\">j=1 \\ldots n</span>, the <span class=\"math\">S</span> transactions in chunk <span class=\"math\">j</span> of <span class=\"math\">L</span>. Note that this is distinct from <span class=\"math\">d_j</span> because <span class=\"math\">e_j</span> follows the chunk boundaries of <span class=\"math\">L</span>, while <span class=\"math\">d_j</span> follows the boundaries of <span class=\"math\">L[S]</span>.</li>\n<li>Let <span class=\"math\">\\gamma_j = \\cup_{i=1}^{j} c_i</span> for <span class=\"math\">j=1 \\ldots n</span>, the transactions in the first <span class=\"math\">j</span> chunks of <span class=\"math\">L</span>.</li>\n<li>Let <span class=\"math\">\\zeta_j = \\cup_{i=j+1}^{n} e_i</span> for <span class=\"math\">j = 1 \\ldots n</span>, all remaining transactions of <span class=\"math\">S</span> <em>after</em> the first <span class=\"math\">j</span> chunks of <span class=\"math\">L</span>.</li>\n<li>Let <span class=\"math\">P(x) = (\\operatorname{size}(x), \\operatorname{fee}(x))</span>, the point in 2D space corresponding to the size and fee of set <span class=\"math\">x</span>.</li>\n<li>We know <span class=\"math\">\\operatorname{feerate}(c_j) \\leq f</span> for <span class=\"math\">j=1 \\ldots n</span>, because chunk feerate decrease monotonically.</li>\n<li>We know <span class=\"math\">\\operatorname{feerate}(\\zeta_j) \\geq f</span> for <span class=\"math\">j=0 \\ldots n-1</span>, because feerates of the suffix of a linearization (<span class=\"math\">L[S]</span> in this case) are never below the last chunk\u2019s feerate.</li>\n<li>Thus, <span class=\"math\">\\operatorname{feerate}(\\zeta_j) \\geq \\operatorname{feerate}(c_k)</span> for any <span class=\"math\">j, k</span> where those values are defined.</li>\n<li>Define <span class=\"math\">\\operatorname{ndiag}(x)</span> as the real function that linearly interpolates through <span class=\"math\">(0,0)</span> and through all <span class=\"math\">(P(\\gamma_j \\cup \\zeta_j))_{j=0}^{n}</span> (the set of chunk prefixes of $L plus all transactions from <span class=\"math\">S</span>).</li>\n<li><span class=\"math\">\\operatorname{ndiag}</span> is not <span class=\"math\">\\operatorname{diag_{L'}}</span>, the feerate diagram of <span class=\"math\">L'</span>, because it doesn\u2019t follow the proper chunking of <span class=\"math\">L'</span>. It is however a valid underestimate of it: <span class=\"math\">\\forall x \\in [0, \\operatorname{size}(G)] : \\operatorname{ndiag}(x) \\leq \\operatorname{diag_{L'}}</span>. This is because:\n<ul>\n<li><span class=\"math\">\\operatorname{diag_{L'}}</span> is the minimal concave function through the <span class=\"math\">P</span> points for all prefixes of <span class=\"math\">L'</span>.</li>\n<li><span class=\"math\">\\operatorname{ndiag}</span> is the minimal concave function through the <span class=\"math\">P</span> points for some prefixes of <span class=\"math\">L'</span> (those corresponding to the chunk prefixes of <span class=\"math\">L</span>, plus all transactions of <span class=\"math\">S</span>).</li>\n</ul>\n</li>\n</ul>\n<p>In what follows, we will show that <span class=\"math\">\\forall x \\in [0,\\operatorname{size}(G)]: \\operatorname{ndiag}(x) \\geq \\operatorname{diag_L}(x)</span>, and thus by extension that <span class=\"math\">\\operatorname{diag_{L'}}(x) \\geq \\operatorname{diag}(x)</span>, or <span class=\"math\">L' \\gtrsim L</span>.</p>\n<p>In the drawing below, the red line represents <span class=\"math\">\\operatorname{diag}_L</span>, while the blue line (plus the green <span class=\"math\">\\zeta_0</span> segment) represents <span class=\"math\">\\operatorname{ndiag}</span>. Intuitively, the blue line lies above (or on) the red line everywhere because the slope of every the green <span class=\"math\">\\zeta_j</span> segments between red and blue is at least as high as that of any red <span class=\"math\">c_j</span> segment.</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/1X/b79f64bc357702b659cbc32e652091b19d42e874.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/b79f64bc357702b659cbc32e652091b19d42e874\" title=\"gather_theorem\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/1X/b79f64bc357702b659cbc32e652091b19d42e874_2_500x375.png\" alt=\"gather_theorem\" data-base62-sha1=\"qcoSjFob3vPnhqph1XMaXU6GaPy\" width=\"500\" height=\"375\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/1X/b79f64bc357702b659cbc32e652091b19d42e874_2_500x375.png, https://delvingbitcoin.org/uploads/default/optimized/1X/b79f64bc357702b659cbc32e652091b19d42e874_2_750x562.png 1.5x, https://delvingbitcoin.org/uploads/default/optimized/1X/b79f64bc357702b659cbc32e652091b19d42e874_2_1000x750.png 2x\" data-dominant-color=\"161616\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">gather_theorem</span><span class=\"informations\">1400\u00d71048 43.8 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p><span class=\"math\">\\operatorname{diag_L}</span> is a concave function, which means it lies on or below each of its tangents. This implies that a point lies on or above the function iff it lies on or above at least one of its tangents. For every point on <span class=\"math\">\\operatorname{ndiag}</span> we will identify a tangent of <span class=\"math\">\\operatorname{diag_L}</span> that it lies on or above. As that function is made up of straight segments, its tangents are exactly these segments, extended to infinity in both directions.</p>\n<ul>\n<li>The points <span class=\"math\">\\{\\forall \\alpha \\in [0, 1]: \\alpha P(\\zeta_0)\\}</span> lie on the first segment of <span class=\"math\">\\operatorname{ndiag}</span>. We show they lie on or above the (extension of the) <span class=\"math\">c_1</span> segment of <span class=\"math\">\\operatorname{diag}(L)</span>.\n<ul>\n<li>For <span class=\"math\">\\alpha=0</span>, the functions coincide at <span class=\"math\">(0, 0)</span>.</li>\n<li>For <span class=\"math\">\\alpha &gt; 0</span>, the slope from <span class=\"math\">(0,0)</span> to <span class=\"math\">P(\\gamma_1)</span> is <span class=\"math\">\\operatorname{feerate}(c_1) = f</span>.\nThe slope of the line from <span class=\"math\">(0,0)</span> to <span class=\"math\">\\alpha P(\\zeta_0)</span> is <span class=\"math\">\\operatorname{feerate}(\\zeta_0) \\geq f </span>, which is at least as high.</li>\n</ul>\n</li>\n<li>For <span class=\"math\">i=0 \\ldots n-1</span>, the points <span class=\"math\">\\{\\forall \\alpha \\in [0, 1]: (1-\\alpha)P(\\gamma_i \\cup \\zeta_i) + \\alpha P(\\gamma_{i+1} \\cup \\zeta_{i+1})\\}</span> lie on <span class=\"math\">\\operatorname{ndiag}</span>. We show they lie on or above the (extension of the) <span class=\"math\">c_{i+1}</span> segment of <span class=\"math\">\\operatorname{diag}(L)</span>.\n<ul>\n<li>The slope of the <span class=\"math\">c_{i+1}</span> segment, from <span class=\"math\">P(\\gamma_i)</span> to <span class=\"math\">P(\\gamma_{i+1})</span>, is <span class=\"math\">\\operatorname{feerate}(c_{i+1}) \\leq f</span>.</li>\n<li>For <span class=\"math\">\\alpha = 0</span>, the slope of the line from <span class=\"math\">P(\\gamma_i)</span> to <span class=\"math\">(1-\\alpha)P(\\gamma_i \\cup \\zeta_i) + \\alpha P(\\gamma_{i+1} \\cup \\zeta_{i+1})</span> is <span class=\"math\">\\operatorname{feerate}(\\zeta_i) \\geq f</span>.</li>\n<li>For <span class=\"math\">\\alpha = 1</span>, the slope of the line from <span class=\"math\">P(\\gamma_i)</span> to <span class=\"math\">(1-\\alpha)P(\\gamma_i \\cup \\zeta_i) + \\alpha P(\\gamma_{i+1} \\cup \\zeta_{i+1})</span> is <span class=\"math\">\\operatorname{feerate}(\\zeta_{i+1} \\cup c_{i+1})</span>. Since <span class=\"math\">\\operatorname{feerate}(\\zeta_{i+1}) \\geq \\operatorname{feerate}(c_{i+1})</span>, it follows that <span class=\"math\">\\operatorname{feerate}(\\zeta_{i+1} \\cup c_{i+1}) \\geq \\operatorname{feerate}(c_{i+1})</span>.\n<ul>\n<li>The one exception is <span class=\"math\">i = n-1</span>, as <span class=\"math\">\\zeta_n</span> is empty there, and thus has no <span class=\"math\">\\operatorname{feerate}</span>; this is not a problem as the functions coincide in this point.</li>\n</ul>\n</li>\n<li>The points with <span class=\"math\">0 &lt; \\alpha &lt; 1</span> linearly interpolate between <span class=\"math\">\\alpha=0</span> and <span class=\"math\">\\alpha=1</span>. Since both endpoints lie on or above the segment, the points in between also lie on or above the same segment.</li>\n</ul>\n</li>\n</ul>\n<p>Thus, <span class=\"math\">\\operatorname{ndiag}</span>, an underestimate for the feerate diagram of <span class=\"math\">L'</span>, is always at least as high as <span class=\"math\">\\operatorname{diag_L}</span>, the feerate diagram of <span class=\"math\">L</span>. We conclude that <span class=\"math\">L' \\gtrsim L</span>.</p>\n<h2><a name=\"merging-linearizations-5\" class=\"anchor\" href=\"#merging-linearizations-5\"></a>Merging linearizations</h2>\n<p><em><strong>Definition</strong></em>. Let <span class=\"math\">\\operatorname{merge}(G, L_1, L_2)</span> be the function on graphs <span class=\"math\">G</span> with valid linearizations <span class=\"math\">L_1</span> and <span class=\"math\">L_2</span>, defined as follows:</p>\n<ul>\n<li>If <span class=\"math\">G</span> (and thus <span class=\"math\">L_1</span> and <span class=\"math\">L_2</span>) are empty, <span class=\"math\">\\operatorname{merge}(\\{\\}, (), ()) = ()</span>.</li>\n<li>Otherwise:\n<ul>\n<li>Let <span class=\"math\">(c_1, \\ldots) = \\operatorname{chunks}(L_1)</span>.</li>\n<li>Let <span class=\"math\">(c_2, \\ldots) = \\operatorname{chunks}(L_2)</span>.</li>\n<li>If <span class=\"math\">\\operatorname{feerate}(c_1) &gt; \\operatorname{feerate}(c_2)</span>, swap <span class=\"math\">L_1</span> with <span class=\"math\">L_2</span> (and <span class=\"math\">c_1</span> with <span class=\"math\">c_2</span>).</li>\n<li>Let <span class=\"math\">L_3 = L_1[c_2]</span>, the first chunk of <span class=\"math\">L_2</span>, using the order these transactions have in <span class=\"math\">L_1</span>.</li>\n<li>Let <span class=\"math\">(c_3, \\ldots) = \\operatorname{chunks}(L_3)</span>.</li>\n<li>Let <span class=\"math\">L_4 = L_3[c_3] = L_1[c_3]</span>, the linearization of the first chunk of <span class=\"math\">L_3</span>.</li>\n<li><span class=\"math\">\\operatorname{merge}(G, L_1, L_2) = L_4 + \\operatorname{merge}(G \\setminus c_3, L_1[G \\setminus c_3], L_2[G \\setminus c_3])</span>.</li>\n</ul>\n</li>\n</ul>\n<p><em><strong>Theorem</strong></em>. <span class=\"math\">\\operatorname{merge}(G, L_1, L_2) \\gtrsim L_1</span> and <span class=\"math\">\\operatorname{merge}(G, L_1, L_2) \\gtrsim L_2</span>.</p>\n<p><em><strong>Proof</strong></em>.</p>\n<p>The theorem is trivially true for empty <span class=\"math\">G</span>. For others, we use induction:</p>\n<ul>\n<li>First note that <span class=\"math\">\\operatorname{feerate}(c_3) \\geq \\operatorname{feerate}(c_1)</span>:\n<ul>\n<li>After the optional swapping step it must be the case that <span class=\"math\">\\operatorname{feerate}(c_2) \\geq \\operatorname{feerate}(c_1)</span>.</li>\n<li>Further, <span class=\"math\">\\operatorname{feerate}(c_3) \\geq \\operatorname{feerate}(c_2)</span>, because <span class=\"math\">L_3</span> contains the same transactions as <span class=\"math\">c_2</span>. If the <span class=\"math\">\\operatorname{chunks}</span> operation on <span class=\"math\">L_3</span> finds nothing better, it will pick the entirety of <span class=\"math\">L_3</span> as <span class=\"math\">c_3</span>, which has the same feerate as <span class=\"math\">c_2</span>.</li>\n</ul>\n</li>\n<li>Now define the following:\n<ul>\n<li>Let <span class=\"math\">L_1' = L_4 + L_1[G \\setminus c_3]</span>. By the gathering theorem, <span class=\"math\">L_1' \\gtrsim L_1</span>, as it is bringing a topologically valid sublinearization (<span class=\"math\">L_4 = L_1[c_3]</span>) to the front, and it has just a single chunk (<span class=\"math\">c_3</span>), whose feerate is <span class=\"math\">\\geq \\operatorname{feerate}(c_1)</span>, the highest feerate in <span class=\"math\">L_1</span>.</li>\n<li>Let <span class=\"math\">L_2' = L_4 + L_2[G \\setminus c_3]</span>. By the chunk reordering them, <span class=\"math\">L_2' \\gtrsim L_2</span>, as <span class=\"math\">L_2'</span> equals <span class=\"math\">L_2</span> apart from its first chunk (<span class=\"math\">c_3 \\subset c_2</span>).</li>\n</ul>\n</li>\n<li>By the induction hypothesis, <span class=\"math\">\\operatorname{merge}(G \\setminus c_3, L_1[G \\setminus c_3], L_2[G \\setminus c_3]) \\gtrsim L_1[G \\setminus c_3]</span>, and thus by the stripping theorem, <span class=\"math\">L_4 + \\operatorname{merge}(G \\setminus c_3, L_1[G \\setminus c_3], L_2[G \\setminus c_3]) \\gtrsim L_4 + L_1[G \\setminus c_3] = L_1'</span>. The same reasoning applies to <span class=\"math\">L_2'</span>.</li>\n<li>Put together, <span class=\"math\">\\operatorname{merge}(G, L_1, L_2) \\gtrsim L_1' \\gtrsim L_1</span> and <span class=\"math\">\\operatorname{merge}(G, L_1, L_2) \\gtrsim L_2' \\gtrsim L_2</span>.</li>\n</ul>\n<p><em><strong>Variations</strong></em>. A number of variations on this algorithm are possible which do not break the proof above:</p>\n<ul>\n<li>Whenever a non-empty prefix <span class=\"math\">P</span> is shared by <span class=\"math\">L_1</span> and <span class=\"math\">L_2</span>, it can be skipped (this follows directly from the stripping theorem), so if <span class=\"math\">L_1 = P + A</span> and <span class=\"math\">L_2 = P + B</span>, then one can define <span class=\"math\">\\operatorname{merge}(G, L_1, L_2) = P + \\operatorname{merge}(G \\setminus P, A, B)</span>.</li>\n<li>Instead of only considering the first chunk of <span class=\"math\">L_2</span> in the order of <span class=\"math\">L_1</span>, it\u2019s possible to also consider the first chunk of <span class=\"math\">L_1</span> in the order of <span class=\"math\">L_2</span>, and then pick the first chunk of the one of those two which has the higher feerate.</li>\n</ul>\n<h2><a name=\"optimal-linearizations-6\" class=\"anchor\" href=\"#optimal-linearizations-6\"></a>Optimal linearizations</h2>\n<p><em><strong>Definition</strong></em>. An <strong>optimal linearization/chunking</strong> for a graph is one which sorts higher or equal than every other linearization/chunking for the same graph. Note that this implies that optimal linearizations/chunkings are comparable with every other linearization/chunking. An optimal linearization/chunking is a <a href=\"https://en.wikipedia.org/wiki/Greatest_element_and_least_element\">greatest element</a> of the set of all linearizations/chunkings of a graph.</p>\n<p><em><strong>Theorem</strong></em>. The set of linearizations/chunkings of a graph, with the preorder relation defined above, forms an  (upward) <strong><a href=\"https://en.wikipedia.org/wiki/Directed_set\">directed set</a></strong>.</p>\n<p><em><strong>Proof</strong></em>. From the properties of the <span class=\"math\">\\operatorname{merge}</span> algorithm it follows that for any two linearizations <span class=\"math\">L_1</span> and <span class=\"math\">L_2</span> there exists a <span class=\"math\">L_3 = \\operatorname{merge}(G, L_1, L_2)</span> such that <span class=\"math\">L_3 \\gtrsim L_1</span> and <span class=\"math\">L_3 \\gtrsim L_2</span>.</p>\n<p><em><strong>Theorem</strong></em>. <strong>Every graph has at least one optimal linearization/chunking</strong>.</p>\n<p><em><strong>Proof</strong></em>. In a directed set, every <a href=\"https://en.wikipedia.org/wiki/Maximal_and_minimal_elements\">maximal element</a> is a greatest element. Every finite preordered set has at least one maximal element. In a directed set, that element is a greatest element too.</p>\n<p><em><strong>Definition</strong></em>. For a given total ordering <span class=\"math\">R_1</span> on the set of sets of transactions, and a total ordering <span class=\"math\">R_2</span> on the set of sequences of transactions, define the function <span class=\"math\">\\operatorname{opt}_{R_1,R_2}(G)</span>, for a given graph <span class=\"math\">G</span> as follows:</p>\n<ul>\n<li>If <span class=\"math\">G</span> is empty, return the empty sequence: <span class=\"math\">\\operatorname{opt}_{R_1,R_2}(G) = ()</span>.</li>\n<li>Otherwise:\n<ul>\n<li>Let <span class=\"math\">S</span> be the highest-feerate subset of <span class=\"math\">G</span>. If there are multiple, pick the first one according to <span class=\"math\">R_1</span>.</li>\n<li>Let <span class=\"math\">L_S</span> be the first valid linearization of <span class=\"math\">S</span> according to <span class=\"math\">R_2</span>.</li>\n<li><span class=\"math\">\\operatorname{opt}_{R_1,R_2}(G) = L_S + \\operatorname{opt}_{R_1,R_2}(G \\setminus S)</span>.</li>\n</ul>\n</li>\n</ul>\n<p><em><strong>Theorem</strong></em>. <span class=\"math\">\\operatorname{opt}_{R_1,R_2}(G)</span> is an optimal linearization of <span class=\"math\">G</span>.</p>\n<p><em><strong>Proof</strong></em>. Assume <span class=\"math\">L = \\operatorname{opt}_{R_1,R_2}(G)</span> is not an optimal linearization of <span class=\"math\">G</span>. We already know an actual optimal linearization <span class=\"math\">L_{opt}</span> must exist though, so <span class=\"math\">L_{opt} &gt; L</span>.</p>\n<p>There must be a first chunk in the chunking of <span class=\"math\">L</span> where the fee-size diagram differs with <span class=\"math\">L_{opt}</span>. Let <span class=\"math\">p</span> be the set of all transactions in <span class=\"math\">L</span> in chunks before that point. Let <span class=\"math\">L_{opt}' = L[p] + L_{opt}[G \\setminus p]</span>, i.e. the linearization obtained by moving the diagram-equal <span class=\"math\">L</span> chunks to the front in <span class=\"math\">L_{opt}</span>. By repeatedly applying the gathering and stripping theorem, <span class=\"math\">L_{opt}' \\gtrsim L_{opt}</span>. Because <span class=\"math\">L_{opt}</span> is optimal this implies <span class=\"math\">L_{opt}' \\sim L_{opt} &gt; L</span>. <span class=\"math\">L_{opt}'</span> and <span class=\"math\">L</span> both start with the same chunks, so by removing them we get <span class=\"math\">L_{opt}[G \\setminus p] &gt; L[G \\setminus p]</span>. <span class=\"math\">L[G \\setminus p] = \\operatorname{opt}_{R_1,R_2}(G \\setminus p)</span> however, and it starts by picking the highest-feerate subset of <span class=\"math\">(G \\setminus p)</span>, and yet <span class=\"math\">L_{opt}[G \\setminus p]</span> starts with a better chunk. This is a contradiction.</p>\n<p>For how to compute <span class=\"math\">\\operatorname{opt}(G)</span> efficiently, see <a href=\"https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303\">How to linearize your cluster</a>.</p>\n<h2><a name=\"connected-chunks-7\" class=\"anchor\" href=\"#connected-chunks-7\"></a>Connected chunks</h2>\n<p><em><strong>Definition</strong></em>. A <strong>connected chunking</strong> is a chunking for which each chunk is connected ignoring direction (i.e., given any transaction in a chunk, every other transaction in the same chunk can be reached when ignoring direction of the edges).</p>\n<p><em><strong>Theorem</strong></em>. <strong>In an optimal linearization/chunking, the corresponding chunks have connected components whose feerate is all the same</strong>. This is trivially true if the chunks are all connected.</p>\n<p><em><strong>Proof</strong></em> If not, the chunks could be split in two, which would improve the diagram.</p>\n<p><em><strong>Theorem</strong></em>. <strong>Every graph has at least one optimal linearization/chunking whose chunks are connected.</strong></p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 21,
  "updated_at": "2024-02-22T03:32:13.270Z",
  "reply_count": 2,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 335,
  "reads": 108,
  "readers_count": 107,
  "score": 1796.6,
  "yours": false,
  "topic_id": 202,
  "topic_slug": "cluster-mempool-definitions-theory",
  "topic_title": "Cluster mempool definitions & theory",
  "topic_html_title": "Cluster mempool definitions &amp; theory",
  "category_id": 8,
  "display_username": "Pieter Wuille",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 37,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "# Cluster mempool theory\n\n<div data-theme-toc=\"true\"> </div>\n\n## Transaction graphs and clusters\n\n***Definition***. A **transaction graph**, or in cluster mempool context, just **graph**, is a [directed acyclic graph](https://en.wikipedia.org/wiki/Directed_acyclic_graph) (DAG), with *n* vertices (also called **transactions**), where each vertex is labelled with a **fee** (an integer) and a **size** (a strictly positive integer). If an edge from node *c* to node *p* exists, *p* is called a **parent** or **dependency** of *c*, and *c* a **child** of *p*. In other words, transaction graphs are dependency graph whose vertices point to their dependencies.\n\n***Definition***. Given a graph *G* and a transaction *x* in it, the **ancestor set** $\\operatorname{anc}_G(x)$ of *x* is the set of all transactions which can be [reached](https://en.wikipedia.org/wiki/Reachability) from *x* (this always includes *x* itself). For sets $S$, we define $\\operatorname{anc}_G(S) = \\cup_{x \\in S} \\operatorname{anc}_G(x)$, the union of the ancestor sets of all the transactions in the set.\n\n***Definition***. Given a graph *G* and a transaction *x* in it, the **descendant set** $\\operatorname{desc}_G(x)$ of *x* is the set of all transactions from which *x* can be reached. For sets $S$, we define $\\operatorname{desc}_G(S) = \\cup_{x \\in S} \\operatorname{desc}_G(x)$, the union of the descendant sets of all the transactions in the set.\n\n***Definition***. A **cluster** is a [connected component](https://en.wikipedia.org/wiki/Component_(graph_theory)) of a graph *ignoring direction*. In other words, for any two transactions in a cluster it is possible to go from one to the other by making a sequence of steps, each traveling along an edge in either forward or backward direction. The clusters of a graph form a [partition](https://en.wikipedia.org/wiki/Partition_of_a_set) of its vertices, and the **cluster of a transaction** is the connected component which that transaction is part of. It can be found as the [transitive closure](https://en.wikipedia.org/wiki/Transitive_closure) of the \"is parent or child of\" relation on the singleton of the given transaction.\n\nConsider the transaction graph below (fees and sizes are omitted):\n```mermaid height=234,auto\ngraph BT\n   t5[\"t<sub>5</sub>\"] --> t2[\"t<sub>2</sub>\"];\n   t6[\"t<sub>6</sub>\"] --> t2;\n   t6 --> t3[\"t<sub>3</sub>\"] --> t1[\"t<sub>1</sub>\"];\n   t7[\"t<sub>7</sub>\"] --> t4[\"t<sub>4</sub>\"];\n```\n\nIn this example there are two clusters: $\\{t_1, t_2, t_3, t_5, t_6\\}$ and $\\{t_4, t_7\\}$.\n\n***Definition***. Given a subset $S$ of nodes of a graph, define the following functions:\n* $\\operatorname{fee}(S) = \\sum_{x \\in S} \\operatorname{fee}_x$: the sum of fees of transactions in $S$.\n* $\\operatorname{size}(S) = \\sum_{x \\in S} \\operatorname{size}_x$: the sum of sizes of transactions in $S$.\n* $\\operatorname{feerate}(S) = \\operatorname{fee}(S) / \\operatorname{size}(S)$: the sum of the fees divided by the sum of the sizes of transactions in $S$. Only defined for non-empty sets $S$.\n\n## Linearizations and chunks\n\n***Definition***. A **topological subset** $S$ of a graph $G$ is a subset of its transactions that includes all ancestors of all its elements. In other words, $S$ is topological subset of $G$ iff $\\operatorname{anc}_G(S) = S$.\n\n***Definition***. A **linearization** $L$ for a given graph $G$ is a permutation of its transactions in which parents appear before children. In other words, $L = (t_1, t_2, \\ldots, t_n)$ is a linearization of $G$ if $\\{t_1, t_2, \\ldots, t_k\\}$ is a topological subset of $G$ for all $k = 1 \\ldots n$. A linearization is thus a [topological sort](https://en.wikipedia.org/wiki/Topological_sorting) of the graph vertices.\n\nIn the example above:\n* $(t_1, t_2, t_3, t_4, t_5, t_6, t_7)$ is a valid linearization.\n* $(t_2, t_5, t_1, t_3, t_6, t_4, t_7)$ is a valid linearization.\n* $(t_1, t_3, t_6, t_2, t_5, t_4, t_7)$ is not ($t_6$ is included before its parent $t_2$).\n\n***Definition***. Given a linearization $L$ for a graph $G$, and a subset $S$ of $G$, the **sublinearization** $L[S]$ is the linearization of $S$ which keeps the same internal ordering as those transactions have in $L$.\n\n***Definition***. A **chunking** $C = (c_1, c_2, \\ldots, c_n)$ for a given graph *G* is a sequence of sets of transactions (called **chunks**) of *G* such that:\n* The chunks $c_i$ form a partition of *G* (no overlap, and their union contains all elements).\n* Every prefix of chunks is topological ($\\cup_{i=1}^{k} c_i$ for $k=1 \\ldots n$ are topological subsets of $G$). Thus, a transaction's parent can appear in the same chunk as the transaction itself or in an earlier chunk, but not in a later chunk.\n* The feerates of the sets are monotonically decreasing.\n\nNote that in practice, we will only work with chunkings of individual clusters, rather than possibly-disconnected graphs. The reasoning for that will come later, so for now, we define chunkings for graphs in general.\n\n***Definition***. The function $\\operatorname{chunks}(L)$ for a linearization $L = (t_1, t_2, \\ldots, t_n)$ of a graph $G$ returns the **corresponding chunking** of that linearization, defined as:\n* If $L$ (and thus $G$) is empty, $\\operatorname{chunks}(L) = ()$.\n* Otherwise:\n  * Let $f_j = \\operatorname{feerate}(\\{t_1, t_2, \\ldots, t_j)$ for $j = 1 \\ldots n$.\n  * Let $k$ be the smallest integer $\\geq 1$ such that no $f_j > f_k$ exists.\n  * Let $c = \\{t_1, t_2, \\ldots, t_k\\}$.\n  * $\\operatorname{chunks}(L) = (c) + \\operatorname{chunks}(L[\\{t_{k+1}, \\ldots n\\}])$.\n\nIn other words, $\\operatorname{chunks}$ constructs the chunking of a linearization consisting of successively best remaining prefixes of that linearization.\n\n***Theorem***. The corresponding chunking $\\operatorname{chunks}(L)$ is a valid chunking for $G$.\n\n***Proof***. All criteria for a valid chunking are fulfilled:\n* All transactions that occurred in $L$ (which are all transactions in $G$) will appear in $\\operatorname{chunks}(L)$ once.\n* Every prefix of chunks is topological, because each corresponds to a prefix of $L$ (which are topological for any valid linearization).\n* The feerates are monotonically decreasing. If that wasn't the case, the chosen $k$ would violate the \"no $f_j > f_k$\" rule.\n\n***Theorem***. The **feerate of a prefix of a linearization never exceeds its first chunk feerate**. If it did, the first chunk would clearly not be the highest-feerate prefix of the linearization.\n\n***Theorem***. The **feerate of a suffix of a linearization is never less than its last chunk feerate**. This is true within the last chunk, because if there was a suffix of the last chunk with lower feerate than that chunk, that suffix could be split off, and the feerate of the part before it would go up. It is also true across multiple chunks, because if a suffix can't have a lower feerate than the last chunk, then extended the suffix to a chunk before it (whose maximum suffix feerate is even higher) cannot change that property.\n\n***Definition***. We also define a **corresponding linearization of a chunking** as a linearization consisting of a concatenation of the chunks, in order, and within each chunk ordered topologically. This correspondence is not unique (because there can be multiple topological sorts of the chunk elements), but all corresponding linearizations of a chunking have the original chunking as corresponding chunking (or a strictly better one)\n Due to the simplicity of converting between chunking and linearization, we can often treat them as the same.\n\n***Definition***. Given a chunking $C = (c_1, c_2, \\ldots, c_n)$, its **feerate diagram** $\\operatorname{diag}_C$ is a real function with domain $[0, \\operatorname{size}(c_1 \\cup c_2 \\cup \\ldots c_n)]$, defined as follows:\n* Let $\\gamma_i = \\cup_{j=0}^{i} c_j$ for $i=0 \\ldots n$, the union of all transactions in the first $i$ chunks.\n* For all $i = 0 \\ldots n-1$ and $\\alpha \\in [0,1]$:\n  * $\\operatorname{diag}_C(\\operatorname{size}(\\gamma_i) + \\alpha \\operatorname{size}(c_{i+1})) = \\operatorname{fee}(\\gamma_i) + \\alpha \\operatorname{fee}(c_{i+1})$.\n* In other words, $\\operatorname{diag}_C$ is a function from cumulative fees to cumulative sizes. When evaluated in the size of a prefix of chunks in $C$, it gives the fee in that prefix. For other values it linearly interpolates between those points.\n* The feerate diagram of a linearization is that of its corresponding chunking.\n\n***Theorem***. The feerate diagram $\\operatorname{diag}_L$ of a linearization $L = (t_1, t_2, \\ldots, t_n)$ is the minimal concave function for which for every $k = 0 \\ldots n$ it holds that $\\operatorname{diag}_L(\\operatorname{size}(\\{t_1, t_2, \\ldots, t_k\\}) \\geq \\operatorname{fee}(\\{t_1, t_2, \\ldots, t_k\\})$. As such, it gives an overestimate for the fees in all prefixes of a linearization. In other words, the grouping of transactions performed by $\\operatorname{chunks}$ exactly corresponds to the straight line segments resulting from requiring the feerate diagram to be concave. [no proof]\n\n***Definition***. We define a **[preorder](https://en.wikipedia.org/wiki/Preorder)** on linearizations/chunkings for the same graph $G$ by comparing their feerate diagrams:\n* Two linearizations are equivalent if their feerate diagrams coincide: $L_1 \\sim L_2 \\iff \\forall x \\in [0, \\operatorname{size}(G)]: \\operatorname{diag}_{L_1}(x) = \\operatorname{diag}_{L_2}(x)$.\n* A linearization is **at least as good** as another if its feerate diagram is never lower than the other's: $L_1 \\gtrsim L_2 \\iff \\forall x \\in [0, \\operatorname{size}(G)]: \\operatorname{diag}_{L_1}(x) \\geq \\operatorname{diag}_{L_2}(x)$.\n* A linearization is **at least as bad** as another if its feerate diagram is never higher than the other's:  $L_1 \\lesssim L_2 \\iff \\forall x \\in [0, \\operatorname{size}(G)]: \\operatorname{diag}_{L_1}(x) \\leq \\operatorname{diag}_{L_2}(x)$.\n* A linearization is **better** than another if its feerate diagram is never lower than the other's, and at least somewhere higher: $L_1 > L_2 \\iff L_1 \\gtrsim L_2$ and not $L_1 \\sim L_2$.\n* A linearization is **worse** than another if its feerate diagram is never higher than the other's, and at least somewhere lower: $L_1 < L_2 \\iff L_1 \\lesssim L_2$ and not $L_1 \\sim L_2$.\n* Linearizations $L_1$ and $L_2$ are **incomparable** when neither $L_1 \\gtrsim L_2$ nor $L_1 \\lesssim L_2$ (and **comparable** when at least one of those relations holds).\n* This is not a [partial order](https://en.wikipedia.org/wiki/Partially_ordered_set), because $L_1 \\sim L_2$ does not imply $L_1 = L_2$ (distinct linearizations can be equivalent).\n\n## Transformations on linearizations\n\n***Theorem***. The **chunk reordering theorem**: reordering a linearization with changes restricted to a single chunk results leaves it at least as good, provided the result is still a valid linearization (i.e., its prefixes are topological).\n\n***Proof***. Every prefix of chunks in the original linearization remains a prefix of transactions in the new linearization. Because the new feerate diagram is the minimal concave function not below these points, and these points form the old feerate diagram, the new feerate diagram cannot be below the old one.\n\n***Theorem***. The **prefix stripping theorem**: Given two linearizations $L_1 = (t_1, t_2, \\ldots, t_n)$ and $L_2 = (u_1, u_2, \\ldots, u_n)$ for the same graph with a shared prefix: $t_i = u_i$ for all $i = 1 \\ldots k$. In this case:\n* If the suffix is at least as good, then the whole linearization is at least as good: $(t_{k+1}, t_{k+2}, \\ldots, t_n) \\gtrsim (u_{k+1}, u_{k+2}, \\ldots, u_n) \\implies L_1 \\gtrsim L_2$.\n* If the suffix is at least as bad, then the whole linearization is at least as bad: $(t_{k+1}, t_{k+2}, \\ldots, t_n) \\lesssim (u_{k+1}, u_{k+2}, \\ldots, u_n) \\implies L_1 \\lesssim L_2$.\n\n***Theorem***. The **gathering theorem**. Moving a sublinearization of transactions to the front of a linearization never worsens the linearization if the sublinearization's worst chunk feerate is at least that of the linearization's best chunk feerate (see discussion in [merging incomparable linearizations](https://delvingbitcoin.org/t/merging-incomparable-linearizations/209)):\n\n* Let $L$ be a linearization of a graph $G$.\n* Let $C = (c_1, c_2, \\ldots, c_n) = \\operatorname{chunks}(L)$.\n* Let $S$ be a topologically valid subset of $G$.\n* Let $D = (d_1, d_2, \\ldots, d_m) = \\operatorname{chunks}(L[S])$.\n* Let $L' = L[S] + L[G \\setminus S])$, the linearization obtained by moving $L[S]$ to the front.\n\nIn this case, $\\operatorname{feerate}(d_m) \\geq \\operatorname{feerate}(c_1) \\implies L' \\gtrsim L$.\n\n***Proof***.\n\n* Let $f = \\operatorname{feerate}(c_1)$, the feerate of the highest-feerate prefix of $L$.\n* Let $e_j = c_j \\cap S$ for $j=1 \\ldots n$, the $S$ transactions in chunk $j$ of $L$. Note that this is distinct from $d_j$ because $e_j$ follows the chunk boundaries of $L$, while $d_j$ follows the boundaries of $L[S]$.\n* Let $\\gamma_j = \\cup_{i=1}^{j} c_i$ for $j=1 \\ldots n$, the transactions in the first $j$ chunks of $L$.\n* Let $\\zeta_j = \\cup_{i=j+1}^{n} e_i$ for $j = 1 \\ldots n$, all remaining transactions of $S$ *after* the first $j$ chunks of $L$.\n* Let $P(x) = (\\operatorname{size}(x), \\operatorname{fee}(x))$, the point in 2D space corresponding to the size and fee of set $x$.\n* We know $\\operatorname{feerate}(c_j) \\leq f$ for $j=1 \\ldots n$, because chunk feerate decrease monotonically.\n* We know $\\operatorname{feerate}(\\zeta_j) \\geq f$ for $j=0 \\ldots n-1$, because feerates of the suffix of a linearization ($L[S]$ in this case) are never below the last chunk's feerate.\n* Thus, $\\operatorname{feerate}(\\zeta_j) \\geq \\operatorname{feerate}(c_k)$ for any $j, k$ where those values are defined.\n* Define $\\operatorname{ndiag}(x)$ as the real function that linearly interpolates through $(0,0)$ and through all $(P(\\gamma_j \\cup \\zeta_j))_{j=0}^{n}$ (the set of chunk prefixes of $L plus all transactions from $S$).\n* $\\operatorname{ndiag}$ is not $\\operatorname{diag_{L'}}$, the feerate diagram of $L'$, because it doesn't follow the proper chunking of $L'$. It is however a valid underestimate of it: $\\forall x \\in [0, \\operatorname{size}(G)] : \\operatorname{ndiag}(x) \\leq \\operatorname{diag_{L'}}$. This is because:\n  * $\\operatorname{diag_{L'}}$ is the minimal concave function through the $P$ points for all prefixes of $L'$.\n  * $\\operatorname{ndiag}$ is the minimal concave function through the $P$ points for some prefixes of $L'$ (those corresponding to the chunk prefixes of $L$, plus all transactions of $S$).\n\nIn what follows, we will show that $\\forall x \\in [0,\\operatorname{size}(G)]: \\operatorname{ndiag}(x) \\geq \\operatorname{diag_L}(x)$, and thus by extension that $\\operatorname{diag_{L'}}(x) \\geq \\operatorname{diag}(x)$, or $L' \\gtrsim L$.\n\nIn the drawing below, the red line represents $\\operatorname{diag}_L$, while the blue line (plus the green $\\zeta_0$ segment) represents $\\operatorname{ndiag}$. Intuitively, the blue line lies above (or on) the red line everywhere because the slope of every the green $\\zeta_j$ segments between red and blue is at least as high as that of any red $c_j$ segment.\n\n![gather_theorem|667x500, 75%](upload://qcoSjFob3vPnhqph1XMaXU6GaPy.png)\n\n$\\operatorname{diag_L}$ is a concave function, which means it lies on or below each of its tangents. This implies that a point lies on or above the function iff it lies on or above at least one of its tangents. For every point on $\\operatorname{ndiag}$ we will identify a tangent of $\\operatorname{diag_L}$ that it lies on or above. As that function is made up of straight segments, its tangents are exactly these segments, extended to infinity in both directions.\n\n* The points $\\{\\forall \\alpha \\in [0, 1]: \\alpha P(\\zeta_0)\\}$ lie on the first segment of $\\operatorname{ndiag}$. We show they lie on or above the (extension of the) $c_1$ segment of $\\operatorname{diag}(L)$.\n  * For $\\alpha=0$, the functions coincide at $(0, 0)$.\n  * For $\\alpha > 0$, the slope from $(0,0)$ to $P(\\gamma_1)$ is $\\operatorname{feerate}(c_1) = f$. \nThe slope of the line from $(0,0)$ to $\\alpha P(\\zeta_0)$ is $\\operatorname{feerate}(\\zeta_0) \\geq f $, which is at least as high.\n* For $i=0 \\ldots n-1$, the points $\\{\\forall \\alpha \\in [0, 1]: (1-\\alpha)P(\\gamma_i \\cup \\zeta_i) + \\alpha P(\\gamma_{i+1} \\cup \\zeta_{i+1})\\}$ lie on $\\operatorname{ndiag}$. We show they lie on or above the (extension of the) $c_{i+1}$ segment of $\\operatorname{diag}(L)$.\n  * The slope of the $c_{i+1}$ segment, from $P(\\gamma_i)$ to $P(\\gamma_{i+1})$, is $\\operatorname{feerate}(c_{i+1}) \\leq f$.\n  * For $\\alpha = 0$, the slope of the line from $P(\\gamma_i)$ to $(1-\\alpha)P(\\gamma_i \\cup \\zeta_i) + \\alpha P(\\gamma_{i+1} \\cup \\zeta_{i+1})$ is $\\operatorname{feerate}(\\zeta_i) \\geq f$.\n  * For $\\alpha = 1$, the slope of the line from $P(\\gamma_i)$ to $(1-\\alpha)P(\\gamma_i \\cup \\zeta_i) + \\alpha P(\\gamma_{i+1} \\cup \\zeta_{i+1})$ is $\\operatorname{feerate}(\\zeta_{i+1} \\cup c_{i+1})$. Since $\\operatorname{feerate}(\\zeta_{i+1}) \\geq \\operatorname{feerate}(c_{i+1})$, it follows that $\\operatorname{feerate}(\\zeta_{i+1} \\cup c_{i+1}) \\geq \\operatorname{feerate}(c_{i+1})$.\n    * The one exception is $i = n-1$, as $\\zeta_n$ is empty there, and thus has no $\\operatorname{feerate}$; this is not a problem as the functions coincide in this point.\n  * The points with $0 < \\alpha < 1$ linearly interpolate between $\\alpha=0$ and $\\alpha=1$. Since both endpoints lie on or above the segment, the points in between also lie on or above the same segment.\n\nThus, $\\operatorname{ndiag}$, an underestimate for the feerate diagram of $L'$, is always at least as high as $\\operatorname{diag_L}$, the feerate diagram of $L$. We conclude that $L' \\gtrsim L$.\n\n## Merging linearizations\n\n***Definition***. Let $\\operatorname{merge}(G, L_1, L_2)$ be the function on graphs $G$ with valid linearizations $L_1$ and $L_2$, defined as follows:\n* If $G$ (and thus $L_1$ and $L_2$) are empty, $\\operatorname{merge}(\\{\\}, (), ()) = ()$.\n* Otherwise:\n  * Let $(c_1, \\ldots) = \\operatorname{chunks}(L_1)$.\n  * Let $(c_2, \\ldots) = \\operatorname{chunks}(L_2)$.\n  * If $\\operatorname{feerate}(c_1) > \\operatorname{feerate}(c_2)$, swap $L_1$ with $L_2$ (and $c_1$ with $c_2$).\n  * Let $L_3 = L_1[c_2]$, the first chunk of $L_2$, using the order these transactions have in $L_1$.\n  * Let $(c_3, \\ldots) = \\operatorname{chunks}(L_3)$.\n  * Let $L_4 = L_3[c_3] = L_1[c_3]$, the linearization of the first chunk of $L_3$.\n  * $\\operatorname{merge}(G, L_1, L_2) = L_4 + \\operatorname{merge}(G \\setminus c_3, L_1[G \\setminus c_3], L_2[G \\setminus c_3])$.\n\n***Theorem***. $\\operatorname{merge}(G, L_1, L_2) \\gtrsim L_1$ and $\\operatorname{merge}(G, L_1, L_2) \\gtrsim L_2$.\n\n***Proof***.\n\nThe theorem is trivially true for empty $G$. For others, we use induction:\n* First note that $\\operatorname{feerate}(c_3) \\geq \\operatorname{feerate}(c_1)$:\n  * After the optional swapping step it must be the case that $\\operatorname{feerate}(c_2) \\geq \\operatorname{feerate}(c_1)$.\n  * Further, $\\operatorname{feerate}(c_3) \\geq \\operatorname{feerate}(c_2)$, because $L_3$ contains the same transactions as $c_2$. If the $\\operatorname{chunks}$ operation on $L_3$ finds nothing better, it will pick the entirety of $L_3$ as $c_3$, which has the same feerate as $c_2$.\n* Now define the following:\n  * Let $L_1' = L_4 + L_1[G \\setminus c_3]$. By the gathering theorem, $L_1' \\gtrsim L_1$, as it is bringing a topologically valid sublinearization ($L_4 = L_1[c_3]$) to the front, and it has just a single chunk ($c_3$), whose feerate is $\\geq \\operatorname{feerate}(c_1)$, the highest feerate in $L_1$.\n  * Let $L_2' = L_4 + L_2[G \\setminus c_3]$. By the chunk reordering them, $L_2' \\gtrsim L_2$, as $L_2'$ equals $L_2$ apart from its first chunk ($c_3 \\subset c_2$).\n* By the induction hypothesis, $\\operatorname{merge}(G \\setminus c_3, L_1[G \\setminus c_3], L_2[G \\setminus c_3]) \\gtrsim L_1[G \\setminus c_3]$, and thus by the stripping theorem, $L_4 + \\operatorname{merge}(G \\setminus c_3, L_1[G \\setminus c_3], L_2[G \\setminus c_3]) \\gtrsim L_4 + L_1[G \\setminus c_3] = L_1'$. The same reasoning applies to $L_2'$.\n* Put together, $\\operatorname{merge}(G, L_1, L_2) \\gtrsim L_1' \\gtrsim L_1$ and $\\operatorname{merge}(G, L_1, L_2) \\gtrsim L_2' \\gtrsim L_2$.\n\n***Variations***. A number of variations on this algorithm are possible which do not break the proof above:\n* Whenever a non-empty prefix $P$ is shared by $L_1$ and $L_2$, it can be skipped (this follows directly from the stripping theorem), so if $L_1 = P + A$ and $L_2 = P + B$, then one can define $\\operatorname{merge}(G, L_1, L_2) = P + \\operatorname{merge}(G \\setminus P, A, B)$.\n* Instead of only considering the first chunk of $L_2$ in the order of $L_1$, it's possible to also consider the first chunk of $L_1$ in the order of $L_2$, and then pick the first chunk of the one of those two which has the higher feerate.\n\n\n## Optimal linearizations\n\n***Definition***. An **optimal linearization/chunking** for a graph is one which sorts higher or equal than every other linearization/chunking for the same graph. Note that this implies that optimal linearizations/chunkings are comparable with every other linearization/chunking. An optimal linearization/chunking is a [greatest element](https://en.wikipedia.org/wiki/Greatest_element_and_least_element) of the set of all linearizations/chunkings of a graph.\n\n***Theorem***. The set of linearizations/chunkings of a graph, with the preorder relation defined above, forms an  (upward) **[directed set](https://en.wikipedia.org/wiki/Directed_set)**.\n\n***Proof***. From the properties of the $\\operatorname{merge}$ algorithm it follows that for any two linearizations $L_1$ and $L_2$ there exists a $L_3 = \\operatorname{merge}(G, L_1, L_2)$ such that $L_3 \\gtrsim L_1$ and $L_3 \\gtrsim L_2$.\n\n***Theorem***. **Every graph has at least one optimal linearization/chunking**. \n\n***Proof***. In a directed set, every [maximal element](https://en.wikipedia.org/wiki/Maximal_and_minimal_elements) is a greatest element. Every finite preordered set has at least one maximal element. In a directed set, that element is a greatest element too.\n\n***Definition***. For a given total ordering $R_1$ on the set of sets of transactions, and a total ordering $R_2$ on the set of sequences of transactions, define the function $\\operatorname{opt}_{R_1,R_2}(G)$, for a given graph $G$ as follows:\n* If $G$ is empty, return the empty sequence: $\\operatorname{opt}_{R_1,R_2}(G) = ()$.\n* Otherwise:\n  * Let $S$ be the highest-feerate subset of $G$. If there are multiple, pick the first one according to $R_1$.\n  * Let $L_S$ be the first valid linearization of $S$ according to $R_2$.\n  * $\\operatorname{opt}_{R_1,R_2}(G) = L_S + \\operatorname{opt}_{R_1,R_2}(G \\setminus S)$.\n\n***Theorem***. $\\operatorname{opt}_{R_1,R_2}(G)$ is an optimal linearization of $G$.\n\n***Proof***. Assume $L = \\operatorname{opt}_{R_1,R_2}(G)$ is not an optimal linearization of $G$. We already know an actual optimal linearization $L_{opt}$ must exist though, so $L_{opt} > L$.\n\nThere must be a first chunk in the chunking of $L$ where the fee-size diagram differs with $L_{opt}$. Let $p$ be the set of all transactions in $L$ in chunks before that point. Let $L_{opt}' = L[p] + L_{opt}[G \\setminus p]$, i.e. the linearization obtained by moving the diagram-equal $L$ chunks to the front in $L_{opt}$. By repeatedly applying the gathering and stripping theorem, $L_{opt}' \\gtrsim L_{opt}$. Because $L_{opt}$ is optimal this implies $L_{opt}' \\sim L_{opt} > L$. $L_{opt}'$ and $L$ both start with the same chunks, so by removing them we get $L_{opt}[G \\setminus p] > L[G \\setminus p]$. $L[G \\setminus p] = \\operatorname{opt}_{R_1,R_2}(G \\setminus p)$ however, and it starts by picking the highest-feerate subset of $(G \\setminus p)$, and yet $L_{opt}[G \\setminus p]$ starts with a better chunk. This is a contradiction.\n\nFor how to compute $\\operatorname{opt}(G)$ efficiently, see [How to linearize your cluster](https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303).\n\n## Connected chunks\n\n***Definition***. A **connected chunking** is a chunking for which each chunk is connected ignoring direction (i.e., given any transaction in a chunk, every other transaction in the same chunk can be reached when ignoring direction of the edges).\n\n***Theorem***. **In an optimal linearization/chunking, the corresponding chunks have connected components whose feerate is all the same**. This is trivially true if the chunks are all connected.\n\n***Proof*** If not, the chunks could be split in two, which would improve the diagram.\n\n***Theorem***. **Every graph has at least one optimal linearization/chunking whose chunks are connected.**",
  "actions_summary": [
    {
      "id": 2,
      "count": 6
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 96,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "<a name=\"cluster-mempool-theory-1\" class=\"anchor\" href=\"#cluster-mempool-theory-1\"></a>Cluster mempool theory\n \n<a name=\"transaction-graphs-and-clusters-2\" class=\"anchor\" href=\"#transaction-graphs-and-clusters-2\"></a>Transaction graphs and clusters\nDefinition. A transaction graph, or in cluster mempool context, just graph, is a <a href=\"https://en.wikipedia.org/wiki/Directed_acyclic_graph\">directed acyclic graph</a> (DAG), with n vertices (also called transactions), where each vertex is labelled with a fee (an integer) and a size (a strictly positive in&hellip;",
  "truncated": true,
  "post_url": "/t/cluster-mempool-definitions-theory/202/1",
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 3
    },
    {
      "id": "heart",
      "type": "emoji",
      "count": 2
    },
    {
      "id": "rocket",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 6,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}