{
  "id": 342,
  "name": "ZmnSCPxj jxPCSnmZ",
  "username": "ZmnSCPxj",
  "avatar_template": "/letter_avatar_proxy/v4/letter/z/ee7513/{size}.png",
  "created_at": "2023-11-08T14:45:57.141Z",
  "cooked": "<p>Good morning delvingbitcoin,</p>\n<p>I believe at least part of the effort towards a splicing protocol\nalso includes a sub-protocol by which it is possible to add\narbitrary inputs and outputs to the splicing transaction.</p>\n<p>The intent of this sub-protocol is to allow batching of additional\nonchain operations to the splice.</p>\n<p>For instance, suppose I have a channel with peers B and C.\nSuppose I have no channel with a potential peer D.</p>\n<p>Now suppose I wish to splice out from the channel with B, and\nalso splice out from the channel with C, in order to fund a\nnew channel with D, which is intended to be a 0-conf channel\nfor a JIT channel operation.\nAnd suppose that the splicing protocol, as well as my awesome\ncode, is sophisticated enough to be able to actually batch\nthese operations in a single large transaction.</p>\n<p>Now, the transaction would have inputs:</p>\n<ul>\n<li>channel-with-B (pre-splice).</li>\n<li>channel-with-C (pre-splice).</li>\n</ul>\n<p>And would have outputs:</p>\n<ul>\n<li>channel-with-B (post-splice).</li>\n<li>channel-with-C (post-splice).</li>\n<li>channel-with-D.</li>\n</ul>\n<p>Suppose B actually is run by a competitor that wishes to\ndamage my interactions with my other peers in order to\nconvince my peers that I suck.\nWhat can B do?</p>\n<p>B can actually double-spend channel-with-B (pre-splice)\nusing a revoked commitment transaction.</p>\n<p>Now of course, if B does that, then B will be punished\nand will lose its funds in the channel-with-B.</p>\n<p>But consider: why would <em><strong>I</strong></em> splice out from\nchannel-with-B?\nObviously I would do that if I have too much funds in\nchannel-with-B, which implies that it is very likely\nthat B has little funds in channel-with-B.\nThus, if B wants to hurt me, the cost of the attack\nmay very well be worth it, even with 1% reserve\n(woe betide me if I allowed 0% reserve with B, or if the\nchannel was new and funded by me and thus B has no reserves\nyet).</p>\n<p>Now remember, I said:</p>\n<blockquote>\n<p>Now suppose I wish to splice out from the channel with B, and\nalso splice out from the channel with C, in order to fund a\nnew channel with D, which is intended to be a 0-conf channel\nfor a JIT channel operation.</p>\n</blockquote>\n<p>D, having seen me broadcast the batched transaction that includes\nthe open of the channel-with-D, has now, naively, sent the\npreimage to the HTLC for the JIT channel payment.</p>\n<p>But because B double-spent the entire batched transaction out\nfrom under me (with help from a miner), it also double-spent\nthe JIT channel funding of channel-with-D.\nThus, I have inadvertently attacked peer D, caused by B\nattacking me.\nThis is a bad security breach escalation; it is bad enough\nfor me to be attacked, but now I am induced to also attack\nothers.</p>\n<p>This implies that B (and C!) can cause disruption to my other\npeers, because I batched splicing of channels with other\nonchain operations, in this case, a 0-conf channel open.</p>\n<p>If B is a competitor, then the fact that B can induce me to\nperform an attack on my client D would let them redirect D\ntowards them.\nThus, there is a strong incentive to attack me, as it allows\nB to move my hands and commit the crime.</p>\n<p>Note as well that this is splice-out and not splice-in.\nWe already know that splice-in has even worse problems, with\nthe splicing-in peer also being able to double-spend this\nout from under you using unilaterally-controlled funds, with\nno risk of punishment.</p>\n<p>A similar attack is also possible with batching dual-funded\nopenv2.\nIf we dual-fund with one peer, that peer can also disrupt\nthe channel openings of other peers in the same batch.</p>\n<p>Of note is that even if I \u201cjust\u201d batch splicings, the attack\nremains a massive nuisance.\nOne good reason I might have to splice out is in order to\nsplice in to a different peer.\nIdeally, both operations should be batched in a single\nlarge transaction, but that leaves me vulnerable to attacks\nfrom both peers.</p>\n<p>For example, suppose I want to splice out from peer B and\nsplice in the same amount to peer C, and there is <strong>no</strong>\npeer D involved in a JIT channel.\nIf I batch both splices in a single transaction, and B\ndisrupts the batch, I need to be able to tell C \u201cforget\nabout the splice, let us go back to our original channel\nfunding output\u201d, without having to close the channel-with-C,\nin order to try again with a different batched splice that\nno longer involves the peer B, or to splice in to C with my\nonchain funds instead of from the channel-with-B.</p>\n<p>(Instead of telling C it would be better if C monitored\nthe chain for double-spending of the splice in transaction,\nand then automatically negotiate with me to disregard the\nsplice, but that increases complexity of splice code even\nmore;\nbecause of timeliness concerns it would be best if this was\nnot a timeout but rather an actual detailed check of the\ntxins of the splice in transaction.\nIn particular, this may make batched splicing non-viable\nfor usecases where users need to use SPV.)</p>\n<p>In current Lightning Network without splice, in order to\nmove my funds from a channel with a peer, to a different\npeer, I have to do a circular routing rebalance.\nIn that case, I will end up paying directly to the peer I\nam moving liquidity away from, via routing fees.\nThus, that peer has a disincentive against disrupting my\ncircular routing, as they would lose the routing fee if\nthey disrupted it.</p>\n<p>But with splicing, there is no routing fee to pay to the\npeer that I am moving liquidity away from.\nThus, there is no disincentive against disrupting a batched\nsplice.\n(other than loss of the reserve, of course, but there may\nbe situations where I splice out of a channel where the\npeer has no reserve yet, and that is likely if I have put\ntoo many funds into that channel and that peer has not\nbeen receiving;\nthis is one reason for me to do a splice out, but the\npeer now has the ability to hostage those funds by\ndisrupting a splice out that is batched with a splice\nin to a different peer.\nThus, batched splicing considered risky.)</p>\n<p>It has been proposed elsewhere that the splice transaction\ncan be re-created periodically, such as once a block at\nleast.\nHowever, we should note that a miner can select <em>any</em> of\nthe still-valid splice transactions, including the\nnon-latest splice transaction.\nThis may happen by sheer accident, such as the winning\nminer having a slow mempool update from your own mempool.\nEvery new splice transaction would thus require a new\nset of commitment transactions per update, because\n<em>any</em> of the splice transactions could confirm.\ni.e. if there is a splice transaction that does not\nconfirm, and me and my \u201cfriends\u201d make a new one, then\nevery update of every channel in the splice must by\nnecessity include signatures for commitment transactions\nspending the per-splice, the first splice, and the second\nsplice transaction output (3 sets of signatures!) and\nwould require exchanging another set of signatures for each\nadditional splice transaction.\nThis solution thus greatly increases complexity and may\nvery well have more losses due to bugs than the problems\nit tries to fix.</p>\n<p>The above <em>can</em> be ameliorated with <code>SIGHASH_ANYPREVOUT</code>.\nHowever, this may make 0-conf channel use-cases worse, as\n<code>SIGHASH_ANYPREVOUT</code> inherently allows RBF (by adding new\noutputs that pay fees) and thus the client code now has to\nrely on a particular address and output amount appearing\non some confirmed transaction, instead of a specific\ntransaction ID getting confirmed, i.e. JIT channel\nspecifications that want to reduce trust in the LSP need\nto be modified to consider the address and output amount\ninstead of the transaction ID, but only if\n<code>SIGHASH_ANYPREVOUT</code> actually gets added to consensus.\nPrior to <code>SIGHASH_ANYPREVOUT</code>, the address and output\namount is insufficient and the client needs to check for\nthe specific transaction ID, as the signatures it holds\nare for the specific transaction ID.</p>\n<p>Regards,\nZmnSCPxj</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2023-11-08T14:45:57.141Z",
  "reply_count": 1,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 23,
  "reads": 7,
  "readers_count": 6,
  "score": 121.4,
  "yours": false,
  "topic_id": 170,
  "topic_slug": "lightning-batched-splicing-considered-risky",
  "topic_title": "[Lightning] Batched Splicing Considered Risky",
  "topic_html_title": "[Lightning] Batched Splicing Considered Risky",
  "category_id": 7,
  "display_username": "ZmnSCPxj jxPCSnmZ",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Good morning delvingbitcoin,\n\nI believe at least part of the effort towards a splicing protocol\nalso includes a sub-protocol by which it is possible to add\narbitrary inputs and outputs to the splicing transaction.\n\nThe intent of this sub-protocol is to allow batching of additional\nonchain operations to the splice.\n\nFor instance, suppose I have a channel with peers B and C.\nSuppose I have no channel with a potential peer D.\n\nNow suppose I wish to splice out from the channel with B, and\nalso splice out from the channel with C, in order to fund a\nnew channel with D, which is intended to be a 0-conf channel\nfor a JIT channel operation.\nAnd suppose that the splicing protocol, as well as my awesome\ncode, is sophisticated enough to be able to actually batch\nthese operations in a single large transaction.\n\nNow, the transaction would have inputs:\n\n* channel-with-B (pre-splice).\n* channel-with-C (pre-splice).\n\nAnd would have outputs:\n\n* channel-with-B (post-splice).\n* channel-with-C (post-splice).\n* channel-with-D.\n\nSuppose B actually is run by a competitor that wishes to\ndamage my interactions with my other peers in order to\nconvince my peers that I suck.\nWhat can B do?\n\nB can actually double-spend channel-with-B (pre-splice)\nusing a revoked commitment transaction.\n\nNow of course, if B does that, then B will be punished\nand will lose its funds in the channel-with-B.\n\nBut consider: why would ***I*** splice out from\nchannel-with-B?\nObviously I would do that if I have too much funds in\nchannel-with-B, which implies that it is very likely\nthat B has little funds in channel-with-B.\nThus, if B wants to hurt me, the cost of the attack\nmay very well be worth it, even with 1% reserve\n(woe betide me if I allowed 0% reserve with B, or if the\nchannel was new and funded by me and thus B has no reserves\nyet).\n\nNow remember, I said:\n\n> Now suppose I wish to splice out from the channel with B, and\n> also splice out from the channel with C, in order to fund a\n> new channel with D, which is intended to be a 0-conf channel\n> for a JIT channel operation.\n\nD, having seen me broadcast the batched transaction that includes\nthe open of the channel-with-D, has now, naively, sent the\npreimage to the HTLC for the JIT channel payment.\n\nBut because B double-spent the entire batched transaction out\nfrom under me (with help from a miner), it also double-spent\nthe JIT channel funding of channel-with-D.\nThus, I have inadvertently attacked peer D, caused by B\nattacking me.\nThis is a bad security breach escalation; it is bad enough\nfor me to be attacked, but now I am induced to also attack\nothers.\n\nThis implies that B (and C!) can cause disruption to my other\npeers, because I batched splicing of channels with other\nonchain operations, in this case, a 0-conf channel open.\n\nIf B is a competitor, then the fact that B can induce me to\nperform an attack on my client D would let them redirect D\ntowards them.\nThus, there is a strong incentive to attack me, as it allows\nB to move my hands and commit the crime.\n\nNote as well that this is splice-out and not splice-in.\nWe already know that splice-in has even worse problems, with\nthe splicing-in peer also being able to double-spend this\nout from under you using unilaterally-controlled funds, with\nno risk of punishment.\n\nA similar attack is also possible with batching dual-funded\nopenv2.\nIf we dual-fund with one peer, that peer can also disrupt\nthe channel openings of other peers in the same batch.\n\nOf note is that even if I \"just\" batch splicings, the attack\nremains a massive nuisance.\nOne good reason I might have to splice out is in order to\nsplice in to a different peer.\nIdeally, both operations should be batched in a single\nlarge transaction, but that leaves me vulnerable to attacks\nfrom both peers.\n\nFor example, suppose I want to splice out from peer B and\nsplice in the same amount to peer C, and there is **no**\npeer D involved in a JIT channel.\nIf I batch both splices in a single transaction, and B\ndisrupts the batch, I need to be able to tell C \"forget\nabout the splice, let us go back to our original channel\nfunding output\", without having to close the channel-with-C,\nin order to try again with a different batched splice that\nno longer involves the peer B, or to splice in to C with my\nonchain funds instead of from the channel-with-B.\n\n(Instead of telling C it would be better if C monitored\nthe chain for double-spending of the splice in transaction,\nand then automatically negotiate with me to disregard the\nsplice, but that increases complexity of splice code even\nmore;\nbecause of timeliness concerns it would be best if this was\nnot a timeout but rather an actual detailed check of the\ntxins of the splice in transaction.\nIn particular, this may make batched splicing non-viable\nfor usecases where users need to use SPV.)\n\nIn current Lightning Network without splice, in order to\nmove my funds from a channel with a peer, to a different\npeer, I have to do a circular routing rebalance.\nIn that case, I will end up paying directly to the peer I\nam moving liquidity away from, via routing fees.\nThus, that peer has a disincentive against disrupting my\ncircular routing, as they would lose the routing fee if\nthey disrupted it.\n\nBut with splicing, there is no routing fee to pay to the\npeer that I am moving liquidity away from.\nThus, there is no disincentive against disrupting a batched\nsplice.\n(other than loss of the reserve, of course, but there may\nbe situations where I splice out of a channel where the\npeer has no reserve yet, and that is likely if I have put\ntoo many funds into that channel and that peer has not\nbeen receiving;\nthis is one reason for me to do a splice out, but the\npeer now has the ability to hostage those funds by\ndisrupting a splice out that is batched with a splice\nin to a different peer.\nThus, batched splicing considered risky.)\n\nIt has been proposed elsewhere that the splice transaction\ncan be re-created periodically, such as once a block at\nleast.\nHowever, we should note that a miner can select *any* of\nthe still-valid splice transactions, including the\nnon-latest splice transaction.\nThis may happen by sheer accident, such as the winning\nminer having a slow mempool update from your own mempool.\nEvery new splice transaction would thus require a new\nset of commitment transactions per update, because\n*any* of the splice transactions could confirm.\ni.e. if there is a splice transaction that does not\nconfirm, and me and my \"friends\" make a new one, then\nevery update of every channel in the splice must by\nnecessity include signatures for commitment transactions\nspending the per-splice, the first splice, and the second\nsplice transaction output (3 sets of signatures!) and\nwould require exchanging another set of signatures for each\nadditional splice transaction.\nThis solution thus greatly increases complexity and may\nvery well have more losses due to bugs than the problems\nit tries to fix.\n\nThe above *can* be ameliorated with `SIGHASH_ANYPREVOUT`.\nHowever, this may make 0-conf channel use-cases worse, as\n`SIGHASH_ANYPREVOUT` inherently allows RBF (by adding new\noutputs that pay fees) and thus the client code now has to\nrely on a particular address and output amount appearing\non some confirmed transaction, instead of a specific\ntransaction ID getting confirmed, i.e. JIT channel\nspecifications that want to reduce trust in the LSP need\nto be modified to consider the address and output amount\ninstead of the transaction ID, but only if\n`SIGHASH_ANYPREVOUT` actually gets added to consensus.\nPrior to `SIGHASH_ANYPREVOUT`, the address and output\namount is insufficient and the client needs to check for\nthe specific transaction ID, as the signatures it holds\nare for the specific transaction ID.\n\nRegards,\nZmnSCPxj",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 104,
  "hidden": false,
  "trust_level": 0,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}