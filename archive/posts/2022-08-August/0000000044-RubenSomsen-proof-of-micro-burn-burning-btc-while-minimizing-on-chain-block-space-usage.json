{
  "id": 44,
  "name": "Ruben Somsen",
  "username": "RubenSomsen",
  "avatar_template": "/letter_avatar_proxy/v4/letter/r/35a633/{size}.png",
  "created_at": "2022-08-24T13:45:44.221Z",
  "cooked": "<h1>\n<a name=\"proof-of-micro-burn-1\" class=\"anchor\" href=\"#proof-of-micro-burn-1\"></a>Proof-of-micro-burn</h1>\n<p>Proof-of-micro-burn is a possible way to revitalize the original hashcash use case, e.g. by only accepting emails which have an SPV proof of some burned sats attached, or any other place where spam is an issue.</p>\n<p>What you need is a basic merkle sum tree (not sparse), so if e.g. you want to burn 10, 20, 30 and 40 sats for separate use cases, in a single tx you can burn 100 sats and commit to a tree with four leaves, and the merkle proof contains the values. E.g. the rightmost leaf is 40 and has 30 as its neighbor, and moves up to a node of 70 which has 30 (=10+20) as its neighbor, totaling 100.</p>\n<p>The leaf hash needs to commit to the intent/recipient of the burn, so that way you can\u2019t \u201cdouble spend\u201d the burn by reusing it for more than one purpose.</p>\n<p>You could outsource the burn to an aggregating third party by paying them e.g. over LN but it won\u2019t be atomic, so they could walk away with your payment without actually following through with the burn (but presumably take a reputational hit).</p>\n<p>While an op_return is needed (or rather, preferred) to burn, you don\u2019t necessarily have to put the hash there and can thus save some bytes. One possible place to commit the root hash is in a double taproot commitment in the change output. So while taproot is <code>Q = P + hash(Q||mast)*G</code>, you\u2019d commit the root in <code>P</code> such that <code>P = N + hash(N||burn_tree_root)*G</code>. What\u2019s important is that the location is fully deterministic, in order to ensure there isn\u2019t more than one tree (which would be yet another way to \u201cdouble spend\u201d).</p>\n<p>Finally, you can perform the burn on a <a href=\"https://gist.github.com/RubenSomsen/c9f0a92493e06b0e29acced61ca9f49a#spacechains\">spacechain</a> (basically a \u201csidechain\u201d that has burned BTC as its native token) in order to pretty much avoid using mainchain block space altogether, so it should scale much better. It\u2019s worth noting that this fully supports SPV proofs, so the third party you\u2019re proving the burn to doesn\u2019t have to run a full node (though SPV may not be safe enough for big amounts).</p>\n<h2>\n<a name=\"more-details-about-the-sum-merkle-tree-2\" class=\"anchor\" href=\"#more-details-about-the-sum-merkle-tree-2\"></a>More details about the sum merkle tree</h2>\n<p>The goal is to burn multiple amounts (10, 20, 30, 40) in a single <code>OP_RETURN</code> (100) and specifically indicating how much of the total is intended for what use case. A merkle sum tree achieves this.</p>\n<pre><code class=\"lang-auto\">(1a)  100      (1b)  ABCD       (2a)  100     (2b)  ABCD\n    /    \\          /    \\          /    \\         /    \\\n  30      70      AB      CD      30      70     AB      CD\n /  \\    /  \\    /  \\    /  \\    /  \\           /  \\\n10  20  30  40   A  B    C  D   10  20          A  B\n</code></pre>\n<p>So while in a normal merkle tree (1a) you hash e.g. A and B to get AB, with a sum tree (1b) you also hash 10 and 20 to get 30.</p>\n<p>When you verify the full merkle sum proof (2a + 2b, combined in a single tree), you verify that 10 (A) + 20 (B) add up to 30 (AB), and 30 (AB) + 70 (CD) add up to 100 (ABCD), else the root hash won\u2019t match.</p>\n<p>This ensures that you can\u2019t create a valid tree with commitments that add up to more than the burned amount (essentially a \u201cdouble spend\u201d).</p>\n<svg width=\"517pt\" height=\"188pt\" viewbox=\"0.00 0.00 517.15 188.00\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" class=\"graphviz-svg-render\">\n<g id=\"graph0\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 184)\">\n<polygon fill=\"white\" stroke=\"transparent\" points=\"-4,4 -4,-184 513.15,-184 513.15,4 -4,4\"></polygon>\n<!-- ABCD -->\n<g id=\"node1\" class=\"node\">\n<title>ABCD</title>\n<ellipse fill=\"none\" stroke=\"black\" cx=\"251.87\" cy=\"-162\" rx=\"117.16\" ry=\"18\"></ellipse>\n<text text-anchor=\"middle\" x=\"251.87\" y=\"-157.8\" font-family=\"Times,serif\" font-size=\"14.00\">ABCD=H(AB, 30, CD, 70)</text>\n</g>\n<!-- AB -->\n<g id=\"node2\" class=\"node\">\n<title>AB</title>\n<ellipse fill=\"none\" stroke=\"black\" cx=\"152.87\" cy=\"-90\" rx=\"90.51\" ry=\"18\"></ellipse>\n<text text-anchor=\"middle\" x=\"152.87\" y=\"-85.8\" font-family=\"Times,serif\" font-size=\"14.00\">AB=H(A, 10, B, 20)</text>\n</g>\n<!-- ABCD&#45;&gt;AB -->\n<g id=\"edge1\" class=\"edge\">\n<title>ABCD-&gt;AB</title>\n<path fill=\"none\" stroke=\"black\" d=\"M228.16,-144.23C215.18,-135.06 198.91,-123.56 184.83,-113.6\"></path>\n<polygon fill=\"black\" stroke=\"black\" points=\"186.57,-110.55 176.39,-107.63 182.53,-116.26 186.57,-110.55\"></polygon>\n</g>\n<!-- CD -->\n<g id=\"node3\" class=\"node\">\n<title>CD</title>\n<ellipse fill=\"none\" stroke=\"black\" cx=\"351.87\" cy=\"-90\" rx=\"90.51\" ry=\"18\"></ellipse>\n<text text-anchor=\"middle\" x=\"351.87\" y=\"-85.8\" font-family=\"Times,serif\" font-size=\"14.00\">CD=H(C, 30, D, 40)</text>\n</g>\n<!-- ABCD&#45;&gt;CD -->\n<g id=\"edge2\" class=\"edge\">\n<title>ABCD-&gt;CD</title>\n<path fill=\"none\" stroke=\"black\" d=\"M275.82,-144.23C289.03,-134.99 305.6,-123.39 319.9,-113.38\"></path>\n<polygon fill=\"black\" stroke=\"black\" points=\"322.27,-115.99 328.46,-107.39 318.26,-110.26 322.27,-115.99\"></polygon>\n</g>\n<!-- A -->\n<g id=\"node4\" class=\"node\">\n<title>A</title>\n<ellipse fill=\"none\" stroke=\"black\" cx=\"51.87\" cy=\"-18\" rx=\"51.74\" ry=\"18\"></ellipse>\n<text text-anchor=\"middle\" x=\"51.87\" y=\"-13.8\" font-family=\"Times,serif\" font-size=\"14.00\">A = H(A')</text>\n</g>\n<!-- AB&#45;&gt;A -->\n<g id=\"edge3\" class=\"edge\">\n<title>AB-&gt;A</title>\n<path fill=\"none\" stroke=\"black\" d=\"M129.19,-72.59C115.25,-62.93 97.47,-50.6 82.47,-40.21\"></path>\n<polygon fill=\"black\" stroke=\"black\" points=\"84.23,-37.17 74.02,-34.35 80.24,-42.92 84.23,-37.17\"></polygon>\n</g>\n<!-- B -->\n<g id=\"node5\" class=\"node\">\n<title>B</title>\n<ellipse fill=\"none\" stroke=\"black\" cx=\"172.87\" cy=\"-18\" rx=\"50.61\" ry=\"18\"></ellipse>\n<text text-anchor=\"middle\" x=\"172.87\" y=\"-13.8\" font-family=\"Times,serif\" font-size=\"14.00\">B = H(B')</text>\n</g>\n<!-- AB&#45;&gt;B -->\n<g id=\"edge4\" class=\"edge\">\n<title>AB-&gt;B</title>\n<path fill=\"none\" stroke=\"black\" d=\"M157.81,-71.7C160.04,-63.9 162.72,-54.51 165.2,-45.83\"></path>\n<polygon fill=\"black\" stroke=\"black\" points=\"168.6,-46.68 167.98,-36.1 161.87,-44.76 168.6,-46.68\"></polygon>\n</g>\n<!-- C -->\n<g id=\"node6\" class=\"node\">\n<title>C</title>\n<ellipse fill=\"none\" stroke=\"black\" cx=\"331.87\" cy=\"-18\" rx=\"50.61\" ry=\"18\"></ellipse>\n<text text-anchor=\"middle\" x=\"331.87\" y=\"-13.8\" font-family=\"Times,serif\" font-size=\"14.00\">C = H(C')</text>\n</g>\n<!-- CD&#45;&gt;C -->\n<g id=\"edge5\" class=\"edge\">\n<title>CD-&gt;C</title>\n<path fill=\"none\" stroke=\"black\" d=\"M346.93,-71.7C344.7,-63.9 342.01,-54.51 339.53,-45.83\"></path>\n<polygon fill=\"black\" stroke=\"black\" points=\"342.87,-44.76 336.76,-36.1 336.14,-46.68 342.87,-44.76\"></polygon>\n</g>\n<!-- D -->\n<g id=\"node7\" class=\"node\">\n<title>D</title>\n<ellipse fill=\"none\" stroke=\"black\" cx=\"454.87\" cy=\"-18\" rx=\"54.07\" ry=\"18\"></ellipse>\n<text text-anchor=\"middle\" x=\"454.87\" y=\"-13.8\" font-family=\"Times,serif\" font-size=\"14.00\">D = \u00a0H(D')</text>\n</g>\n<!-- CD&#45;&gt;D -->\n<g id=\"edge6\" class=\"edge\">\n<title>CD-&gt;D</title>\n<path fill=\"none\" stroke=\"black\" d=\"M376.02,-72.59C390.13,-62.99 408.11,-50.78 423.34,-40.43\"></path>\n<polygon fill=\"black\" stroke=\"black\" points=\"425.63,-43.1 431.93,-34.59 421.69,-37.31 425.63,-43.1\"></polygon>\n</g>\n</g>\n</svg>\n<p>The original posts on bitcoin-dev can be found <a href=\"https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-July/020746.html\">here</a> and <a href=\"https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-July/020756.html\">here</a>.</p>\n<p>This topic was also discussed in the Bitcoin Optech Twitter space, which can be listened to <a href=\"https://twitter.com/bitcoinoptech/status/1552324101649334273\">here</a>.</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2022-08-24T14:30:25.769Z",
  "reply_count": 1,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 10,
  "reads": 12,
  "readers_count": 11,
  "score": 102.2,
  "yours": false,
  "topic_id": 21,
  "topic_slug": "proof-of-micro-burn-burning-btc-while-minimizing-on-chain-block-space-usage",
  "topic_title": "Proof-of-micro-burn \u2013 Burning BTC while minimizing on-chain block space usage",
  "topic_html_title": "Proof-of-micro-burn \u2013 Burning BTC while minimizing on-chain block space usage",
  "category_id": 7,
  "display_username": "Ruben Somsen",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 6,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "# Proof-of-micro-burn\n\nProof-of-micro-burn is a possible way to revitalize the original hashcash use case, e.g. by only accepting emails which have an SPV proof of some burned sats attached, or any other place where spam is an issue.\n\nWhat you need is a basic merkle sum tree (not sparse), so if e.g. you want to burn 10, 20, 30 and 40 sats for separate use cases, in a single tx you can burn 100 sats and commit to a tree with four leaves, and the merkle proof contains the values. E.g. the rightmost leaf is 40 and has 30 as its neighbor, and moves up to a node of 70 which has 30 (=10+20) as its neighbor, totaling 100.\n\nThe leaf hash needs to commit to the intent/recipient of the burn, so that way you can't \"double spend\" the burn by reusing it for more than one purpose.\n\nYou could outsource the burn to an aggregating third party by paying them e.g. over LN but it won't be atomic, so they could walk away with your payment without actually following through with the burn (but presumably take a reputational hit).\n\nWhile an op_return is needed (or rather, preferred) to burn, you don't necessarily have to put the hash there and can thus save some bytes. One possible place to commit the root hash is in a double taproot commitment in the change output. So while taproot is `Q = P + hash(Q||mast)*G`, you'd commit the root in `P` such that `P = N + hash(N||burn_tree_root)*G`. What's important is that the location is fully deterministic, in order to ensure there isn't more than one tree (which would be yet another way to \"double spend\").\n\nFinally, you can perform the burn on a [spacechain](https://gist.github.com/RubenSomsen/c9f0a92493e06b0e29acced61ca9f49a#spacechains) (basically a \"sidechain\" that has burned BTC as its native token) in order to pretty much avoid using mainchain block space altogether, so it should scale much better. It's worth noting that this fully supports SPV proofs, so the third party you're proving the burn to doesn't have to run a full node (though SPV may not be safe enough for big amounts).\n\n\n## More details about the sum merkle tree\n\nThe goal is to burn multiple amounts (10, 20, 30, 40) in a single `OP_RETURN` (100) and specifically indicating how much of the total is intended for what use case. A merkle sum tree achieves this.\n\n\n```\n(1a)  100      (1b)  ABCD       (2a)  100     (2b)  ABCD\n    /    \\          /    \\          /    \\         /    \\\n  30      70      AB      CD      30      70     AB      CD\n /  \\    /  \\    /  \\    /  \\    /  \\           /  \\\n10  20  30  40   A  B    C  D   10  20          A  B\n```\n\n\nSo while in a normal merkle tree (1a) you hash e.g. A and B to get AB, with a sum tree (1b) you also hash 10 and 20 to get 30.\n\nWhen you verify the full merkle sum proof (2a + 2b, combined in a single tree), you verify that 10 (A) + 20 (B) add up to 30 (AB), and 30 (AB) + 70 (CD) add up to 100 (ABCD), else the root hash won't match.\n\nThis ensures that you can't create a valid tree with commitments that add up to more than the burned amount (essentially a \"double spend\").\n\n[graphviz]\ndigraph {\nABCD -> AB\nABCD -> CD\nAB -> A\nAB -> B\nCD -> C\nCD -> D\nA [label=\"A = H(A')\"]\nB [label=\"B = H(B')\"]\nC [label=\"C = H(C')\"]\nD [label=\"D =  H(D')\"]\nAB [label=\"AB=H(A, 10, B, 20)\"]\nCD [label=\"CD=H(C, 30, D, 40)\"]\nABCD [label=\"ABCD=H(AB, 30, CD, 70)\"]\n}\n[/graphviz]\n\nThe original posts on bitcoin-dev can be found [here](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-July/020746.html) and [here](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-July/020756.html).\n\nThis topic was also discussed in the Bitcoin Optech Twitter space, which can be listened to [here](https://twitter.com/bitcoinoptech/status/1552324101649334273).",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": true,
  "admin": true,
  "staff": true,
  "user_id": 2,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}