{
  "id": 6487,
  "name": "",
  "username": "billymcbip",
  "avatar_template": "/user_avatar/delvingbitcoin.org/billymcbip/{size}/1696_2.png",
  "created_at": "2025-12-30T12:50:49.020Z",
  "cooked": "<p>Hello everyone,</p>\n<p>I want to share an idea for a new Tapscript opcode that makes consolidation transactions significantly more space-efficient: <strong>OP_CHECKCONSOLIDATION (OP_CC)</strong>.</p>\n<p>It\u2019s a simple introspection opcode: <strong>OP_CC pushes false for the first transaction input spending a particular scriptPubKey, and true for every subsequent input spending the same scriptPubKey.</strong> This enables a construction where all inputs spending the same SPK rely on the signature for the first input with that SPK.</p>\n<p>A simple example:</p>\n<ul>\n<li>We create a Taproot SPK (\u201caddress\u201d) with a known key-path and a single Tapscript leaf of just OP_CC.</li>\n<li>Now assume we have three UTXOs with that SPK and we want to spend all of them in the same transaction.</li>\n<li>The first UTXO is unlocked with a simple key-path spend. It\u2019s crucial that the signature commits to all inputs and outputs (SIGHASH_ALL).</li>\n<li>The second and third UTXOs are unlocked with the OP_CC script-path spends. No signatures are required.</li>\n</ul>\n<p>We save 58 witness bytes compared to spending all three UTXOs via key-path spends:</p>\n<ul>\n<li>Key-path witness size (per input): signature length (1), signature (64) \u2192 65 bytes</li>\n<li>Script-path witness size (per input): script length (1), script (1), control block length (1), control block (33) \u2192 36 bytes</li>\n</ul>\n<p>And that\u2019s just a simple example. The savings are much greater for <code>n&lt;m</code> multisigs, and greater still in a post-quantum world with much larger signatures.</p>\n<p>I made a <a href=\"https://github.com/billymcbip/bitcoin/pull/2\" rel=\"noopener nofollow ugc\">draft implementation</a> to explain the idea using code and unit tests.</p>\n<p>I\u2019ll post to the ML as well after collecting some initial feedback here on Delving.</p>\n<p>Looking forward to your feedback.</p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 14,
  "updated_at": "2025-12-30T12:53:14.176Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 18,
  "reads": 37,
  "readers_count": 36,
  "score": 112.4,
  "yours": false,
  "topic_id": 2177,
  "topic_slug": "op-cc-a-simple-introspection-opcode-to-enable-cheaper-consolidations",
  "topic_title": "OP_CC: A simple introspection opcode to enable cheaper consolidations",
  "topic_html_title": "OP_CC: A simple introspection opcode to enable cheaper consolidations",
  "category_id": 7,
  "display_username": "",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Hello everyone,\n\nI want to share an idea for a new Tapscript opcode that makes consolidation transactions significantly more space-efficient: **OP_CHECKCONSOLIDATION (OP_CC)**.\n\nIt's a simple introspection opcode: **OP_CC pushes false for the first transaction input spending a particular scriptPubKey, and true for every subsequent input spending the same scriptPubKey.** This enables a construction where all inputs spending the same SPK rely on the signature for the first input with that SPK.\n\nA simple example:\n* We create a Taproot SPK (\"address\") with a known key-path and a single Tapscript leaf of just OP_CC.\n* Now assume we have three UTXOs with that SPK and we want to spend all of them in the same transaction.\n* The first UTXO is unlocked with a simple key-path spend. It's crucial that the signature commits to all inputs and outputs (SIGHASH_ALL).\n* The second and third UTXOs are unlocked with the OP_CC script-path spends. No signatures are required.\n\nWe save 58 witness bytes compared to spending all three UTXOs via key-path spends:\n* Key-path witness size (per input): signature length (1), signature (64) \u2192 65 bytes\n* Script-path witness size (per input): script length (1), script (1), control block length (1), control block (33) \u2192 36 bytes\n\nAnd that's just a simple example. The savings are much greater for `n<m` multisigs, and greater still in a post-quantum world with much larger signatures.\n\nI made a [draft implementation](https://github.com/billymcbip/bitcoin/pull/2) to explain the idea using code and unit tests.\n\nI\u2019ll post to the ML as well after collecting some initial feedback here on Delving.\n\nLooking forward to your feedback.",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 1007,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "Hello everyone, \nI want to share an idea for a new Tapscript opcode that makes consolidation transactions significantly more space-efficient: OP_CHECKCONSOLIDATION (OP_CC). \nIt\u2019s a simple introspection opcode: OP_CC pushes false for the first transaction input spending a particular scriptPubKey, and&hellip;",
  "truncated": true,
  "post_url": "/t/op-cc-a-simple-introspection-opcode-to-enable-cheaper-consolidations/2177/1",
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}