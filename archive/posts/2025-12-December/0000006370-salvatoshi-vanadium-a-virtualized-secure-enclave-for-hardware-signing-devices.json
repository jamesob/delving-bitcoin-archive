{
  "id": 6370,
  "name": "salvatoshi",
  "username": "salvatoshi",
  "avatar_template": "/user_avatar/delvingbitcoin.org/salvatoshi/{size}/72_2.png",
  "created_at": "2025-12-03T14:19:10.864Z",
  "cooked": "<p>Developing firmware applications for hardware signing devices has always been constrained by the difficulties of embedded development: tiny RAM, tiny flash, vendor-specific SDKs, slow iteration cycles, and painful debugging.</p>\n<p>Over the past year, I\u2019ve been building <strong><a href=\"https://github.com/LedgerHQ/vanadium\" rel=\"noopener nofollow ugc\">Vanadium</a></strong>, a different approach. It isn\u2019t production-ready yet, but it is mature enough for external developers to try. Early feedback will directly shape the roadmap.</p>\n<h1><a name=\"p-6370-what-is-vanadium-1\" class=\"anchor\" href=\"#p-6370-what-is-vanadium-1\"></a>What is Vanadium?</h1>\n<p>Vanadium is a <strong>RISC-V Virtual Machine</strong> that can run in an embedded <strong>Secure Element</strong>, designed to run arbitrary applications (\u201cV-Apps\u201d) in a secure-enclave environment while <strong>outsourcing memory and storage to an untrusted host</strong>.</p>\n<p>This gives developers a <em>virtualized secure enclave</em> with dramatically fewer constraints than physical secure elements normally impose.</p>\n<h3><a name=\"p-6370-core-capabilities-2\" class=\"anchor\" href=\"#p-6370-core-capabilities-2\"></a>Core capabilities</h3>\n<ul>\n<li>\n<p><strong>Virtually unlimited memory</strong> \u2014 Only the pages actually used at runtime are loaded. Everything else lives on the host. Page swaps are transparent.</p>\n</li>\n<li>\n<p><strong>Native development workflow</strong> \u2014 Write and test V-Apps as normal Rust programs on your desktop. No vendor-specific SDK, no special toolchain, no emulator required.</p>\n</li>\n<li>\n<p><strong>Security of execution</strong> \u2014 The VM runs in the Secure Element. Outsourced pages are encrypted and authenticated; the host cannot modify code or data.</p>\n</li>\n</ul>\n<p>By virtualizing the secure enclave, Vanadium abstracts away many challenges of embedded programming. This will hopefully lead to much faster development cycles, and help innovation in self-custody and applied cryptography reach hardware signing devices at a fraction of today\u2019s cost and time commitments.</p>\n<h1><a name=\"p-6370-what-does-vanadium-solve-3\" class=\"anchor\" href=\"#p-6370-what-does-vanadium-solve-3\"></a>What does Vanadium solve?</h1>\n<p>Vanadium makes development substantially easier, allowing fast iterations. Moreover, most of the code written for Vanadium is portable: developers write standard Rust and are able to use existing Rust libraries.</p>\n<p>The goal is to make innovation in self-custody (and applied cryptography) happen at a much faster pace, be much more open and standardized.</p>\n<h1><a name=\"p-6370-technical-deep-dive-4\" class=\"anchor\" href=\"#p-6370-technical-deep-dive-4\"></a>Technical deep dive</h1>\n<p>This is an architecture diagram describing the various components of the Vanadium ecosystem.</p>\n<p><img src=\"https://delvingbitcoin.org/uploads/default/original/2X/b/b03aa2135064557fecb738a09a129e27f35020e5.svg\" alt=\"Vanadium Architecture diagram\" data-base62-sha1=\"p8ZEEkcleNXJFF61mJwY0CxY0D3\" width=\"666\" height=\"500\"></p>\n<p>While Vanadium is a complex project, this diagram illustrates how the project aims to minimize the developer\u2019s workload to the modules labeled as <em>USERLAND</em>. The system calls, the memory outsourcing protocol, and all direct communication between the VM and the host are encapsulated and transparent to developers.</p>\n<p>The public interface of the V-App SDK and the V-App Client SDK are the only contacts between the V-App and its client with the Vanadium ecosystem. Therefore, porting Vanadium to a new platform is reduced to providing workable implementations of these two crates. The current implementation benefits from this segregated architecture by enabling the <em><strong>native</strong></em> compilation target where apps (and their clients) use no Vanadium, no devices, and run directly on the developer\u2019s machine. This would also greatly simplify porting Vanadium to new hardware.</p>\n<h2><a name=\"p-6370-performance-5\" class=\"anchor\" href=\"#p-6370-performance-5\"></a>Performance</h2>\n<blockquote>\n<p>TL;DR <br><strong>The VM only executes business logic; cryptography and other heavy operations run natively via ECALLs.</strong></p>\n</blockquote>\n<p>As signing devices often have rather slow CPUs (but are in some cases equipped with a cryptographic accelerator), the performance would be unacceptable if one suffered the full slow-down caused by simulating a CPU for every operation.</p>\n<p>The solution is to provide system services that allow performance-critical operations to be executed at the native speed of the underlying device. In fact, few operations (for example, hashes, elliptic curve operations, signatures, etc.) tend to be the bottleneck in common applications of signing devices. Therefore, the severe slowdown of a VM is acceptable as long as it\u2019s limited to the <em>business logic</em> of the app.</p>\n<p>The standard way to introduce system services in RISC-V is via the ECALL opcode.</p>\n<p>Here is a list of the ECALLs currently implemented in Vanadium (as an example - not final):</p>\n<details>\n<summary>\nList of ECALLs</summary>\n<pre><code class=\"lang-auto\">ECALL_FATAL: u32 = 1; // abort the execution with error\nECALL_XSEND: u32 = 2; // send a buffer to the host\nECALL_XRECV: u32 = 3; // receive a buffer from the host\nECALL_EXIT: u32 = 4;  // exit the app normally\nECALL_PRINT: u32 = 5; // send a message to print to the host\n\n// Big numbers\nECALL_MODM   // modulus\nECALL_ADDM   // modular addition\nECALL_SUBM   // modular subtraction\nECALL_MULTM  // modular multiplication\nECALL_POWM   // modular power\n\n// Elliptic curves\nECALL_ECFP_ADD_POINT   \nECALL_ECFP_SCALAR_MULT\n\nECALL_DERIVE_HD_NODE: u32 = 130;         // BIP32 derivation\nECALL_GET_MASTER_FINGERPRINT: u32 = 131; // Master BIP32 fingerprint\nECALL_DERIVE_SLIP21_KEY: u32 = 132;      // symmetric key derivations\n\n// Hash functions (streaming)\nECALL_HASH_INIT\nECALL_HASH_UPDATE\nECALL_HASH_DIGEST\n\n// Random number generation\nECALL_GET_RANDOM_BYTES\n\n// Signatures\nECALL_ECDSA_SIGN\nECALL_ECDSA_VERIFY\nECALL_SCHNORR_SIGN\nECALL_SCHNORR_VERIFY\n\n\n// device handling, events, and UX\n// ...omitted for simplicity\n</code></pre>\n</details>\n<p>These provide the functionalities required for the majority of Bitcoin-related use cases, and can more generally be extended to cover most cryptographic applications.</p>\n<p>ECALLs are also used to provide communication, device-specific interactions and event handling, etc.</p>\n<h2><a name=\"p-6370-security-6\" class=\"anchor\" href=\"#p-6370-security-6\"></a>Security</h2>\n<blockquote>\n<p>TL;DR <br> <strong>Same threat model as existing hardware signing devices, with one caveat (memory access-pattern leakage) described below.</strong></p>\n</blockquote>\n<h3><a name=\"p-6370-assumptions-7\" class=\"anchor\" href=\"#p-6370-assumptions-7\"></a>Assumptions</h3>\n<p>The goal of Vanadium is to provide the same security model that hardware signing devices offer:</p>\n<ul>\n<li>The <strong>host is fully untrusted</strong>, can intercept, tamper with, or abort any message.</li>\n<li>The <strong>Secure Element is trusted</strong>.</li>\n<li>The <strong>display is trusted</strong> (the host cannot forge the UI).</li>\n</ul>\n<p>A successful attack is one where the host extracts secrets or tricks the device into misbehavior (e.g., signing the wrong message).</p>\n<h3><a name=\"p-6370-code-correctness-app-authenticity-8\" class=\"anchor\" href=\"#p-6370-code-correctness-app-authenticity-8\"></a>Code Correctness / App Authenticity</h3>\n<p>Vanadium uses a <strong>manifest</strong> that commits to the exact code and metadata of a V-App.\nDuring registration:</p>\n<ol>\n<li>User approves app \u2018installation\u2019.</li>\n<li>Device returns an HMAC as proof of registration.</li>\n<li>Only registered apps may execute.</li>\n</ol>\n<p>This mirrors the security of sideloaded binaries today. Planned improvements include signed manifests for simpler verification.</p>\n<h3><a name=\"p-6370-secure-outsourced-memory-9\" class=\"anchor\" href=\"#p-6370-secure-outsourced-memory-9\"></a>Secure Outsourced Memory</h3>\n<p>A naive outsourced memory system would be insecure. Vanadium uses standard constructions:</p>\n<p><strong>Integrity &amp; Freshness</strong>\nA Merkle tree commits to all memory pages.</p>\n<ul>\n<li>Host must provide a valid Merkle proof for every page read.</li>\n<li>Host must provide valid updates when committing new pages.\nAn invalid proof aborts execution.</li>\n</ul>\n<p><strong>Confidentiality</strong>\nPages are encrypted with <strong>AES-CTR</strong> before leaving the device.</p>\n<p>Other approaches are possible, with different choices of tradeoffs.</p>\n<p>This secures content\u2014but not <em>everything</em>.</p>\n<h3><a name=\"p-6370-caveat-memory-access-pattern-side-channel-10\" class=\"anchor\" href=\"#p-6370-caveat-memory-access-pattern-side-channel-10\"></a>Caveat: Memory Access Pattern Side Channel</h3>\n<p>Vanadium <strong>does not fully hide the access pattern</strong>: the host can observe which code and data pages are accessed and when.</p>\n<p>This matters if:</p>\n<ul>\n<li>secrets live in memory, and</li>\n<li>code paths or memory lookups depend on secret bits.</li>\n</ul>\n<p>Scalar-mult implementations that index lookup tables by secret bits are a canonical vulnerable case.</p>\n<p>Most apps won\u2019t implement cryptography directly and will rely on ECALLs instead, so most developers are not affected by this issue. But <strong>cryptographic developers must treat this as a real attack surface</strong>.</p>\n<p><strong><img src=\"https://delvingbitcoin.org/images/emoji/twitter/warning.png?v=14\" title=\":warning:\" class=\"emoji\" alt=\":warning:\" loading=\"lazy\" width=\"20\" height=\"20\"> Application developers should not implement cryptography</strong> in Vanadium apps without fully understanding the possible impact of this side channel. Existing cryptographic libraries should also be presumed vulnerable if used in Vanadium apps, unless they explicitly guarantee that their code paths and memory access patterns do not depend on secrets.</p>\n<p>An <a href=\"https://en.wikipedia.org/wiki/Oblivious_RAM\" rel=\"noopener nofollow ugc\">Oblivious RAM</a> would solve this, but bringing complexity and a significant performance impact. Simpler mitigations could also be considered, if there is demand for such cryptography-heavy applications.</p>\n<h2><a name=\"p-6370-current-limitations-11\" class=\"anchor\" href=\"#p-6370-current-limitations-11\"></a>Current limitations</h2>\n<ul>\n<li>It has not yet been audited.</li>\n<li>Performance not yet good enough for some applications (especially for large binaries).</li>\n<li>UX capabilities are currently rather limited.</li>\n</ul>\n<p>Work is steadily ongoing to address all the above points, and I look forward to demonstrating its practicality for an increasing number of use cases.</p>\n<h1><a name=\"p-6370-developer-preview-12\" class=\"anchor\" href=\"#p-6370-developer-preview-12\"></a>Developer Preview</h1>\n<blockquote>\n<p><strong>TL;DR</strong><br>Don\u2019t put money in it, but please do <a href=\"https://github.com/LedgerHQ/vanadium\" rel=\"noopener nofollow ugc\">try it out</a>!</p>\n</blockquote>\n<p>A working prototype of Vanadium for Ledger devices is available:<br>\n&nbsp;&nbsp;&nbsp;&nbsp;\u2192\n&nbsp;<a href=\"https://github.com/LedgerHQ/vanadium\" rel=\"noopener nofollow ugc\">https://github.com/LedgerHQ/vanadium</a></p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 1,
  "updated_at": "2025-12-03T19:54:28.081Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 85,
  "reads": 46,
  "readers_count": 45,
  "score": 584.2,
  "yours": false,
  "topic_id": 2142,
  "topic_slug": "vanadium-a-virtualized-secure-enclave-for-hardware-signing-devices",
  "topic_title": "Vanadium: A Virtualized Secure Enclave for Hardware Signing Devices",
  "topic_html_title": "Vanadium: A Virtualized Secure Enclave for Hardware Signing Devices",
  "category_id": 8,
  "display_username": "salvatoshi",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 3,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Developing firmware applications for hardware signing devices has always been constrained by the difficulties of embedded development: tiny RAM, tiny flash, vendor-specific SDKs, slow iteration cycles, and painful debugging.\n\nOver the past year, I\u2019ve been building **[Vanadium](https://github.com/LedgerHQ/vanadium)**, a different approach. It isn\u2019t production-ready yet, but it is mature enough for external developers to try. Early feedback will directly shape the roadmap.\n\n# What is Vanadium?\n\nVanadium is a **RISC-V Virtual Machine** that can run in an embedded **Secure Element**, designed to run arbitrary applications (\u201cV-Apps\u201d) in a secure-enclave environment while **outsourcing memory and storage to an untrusted host**.\n\nThis gives developers a *virtualized secure enclave* with dramatically fewer constraints than physical secure elements normally impose.\n\n### Core capabilities\n\n* **Virtually unlimited memory** \u2014 Only the pages actually used at runtime are loaded. Everything else lives on the host. Page swaps are transparent.\n\n* **Native development workflow** \u2014 Write and test V-Apps as normal Rust programs on your desktop. No vendor-specific SDK, no special toolchain, no emulator required.\n\n* **Security of execution** \u2014 The VM runs in the Secure Element. Outsourced pages are encrypted and authenticated; the host cannot modify code or data.\n\nBy virtualizing the secure enclave, Vanadium abstracts away many challenges of embedded programming. This will hopefully lead to much faster development cycles, and help innovation in self-custody and applied cryptography reach hardware signing devices at a fraction of today\u2019s cost and time commitments.\n\n# What does Vanadium solve?\n\nVanadium makes development substantially easier, allowing fast iterations. Moreover, most of the code written for Vanadium is portable: developers write standard Rust and are able to use existing Rust libraries.\n\nThe goal is to make innovation in self-custody (and applied cryptography) happen at a much faster pace, be much more open and standardized.\n\n# Technical deep dive\n\nThis is an architecture diagram describing the various components of the Vanadium ecosystem.\n\n![Vanadium Architecture diagram|666x500](upload://p8ZEEkcleNXJFF61mJwY0CxY0D3.svg)\n\nWhile Vanadium is a complex project, this diagram illustrates how the project aims to minimize the developer\u2019s workload to the modules labeled as *USERLAND*. The system calls, the memory outsourcing protocol, and all direct communication between the VM and the host are encapsulated and transparent to developers.\n\nThe public interface of the V-App SDK and the V-App Client SDK are the only contacts between the V-App and its client with the Vanadium ecosystem. Therefore, porting Vanadium to a new platform is reduced to providing workable implementations of these two crates. The current implementation benefits from this segregated architecture by enabling the ***native*** compilation target where apps (and their clients) use no Vanadium, no devices, and run directly on the developer\u2019s machine. This would also greatly simplify porting Vanadium to new hardware.\n\n## Performance\n\n> TL;DR <br>**The VM only executes business logic; cryptography and other heavy operations run natively via ECALLs.**\n\nAs signing devices often have rather slow CPUs (but are in some cases equipped with a cryptographic accelerator), the performance would be unacceptable if one suffered the full slow-down caused by simulating a CPU for every operation.\n\nThe solution is to provide system services that allow performance-critical operations to be executed at the native speed of the underlying device. In fact, few operations (for example, hashes, elliptic curve operations, signatures, etc.) tend to be the bottleneck in common applications of signing devices. Therefore, the severe slowdown of a VM is acceptable as long as it\u2019s limited to the *business logic* of the app.\n\nThe standard way to introduce system services in RISC-V is via the ECALL opcode.\n\nHere is a list of the ECALLs currently implemented in Vanadium (as an example - not final):\n\n\n[details=\"List of ECALLs\"]\n```\nECALL_FATAL: u32 = 1; // abort the execution with error\nECALL_XSEND: u32 = 2; // send a buffer to the host\nECALL_XRECV: u32 = 3; // receive a buffer from the host\nECALL_EXIT: u32 = 4;  // exit the app normally\nECALL_PRINT: u32 = 5; // send a message to print to the host\n\n// Big numbers\nECALL_MODM   // modulus\nECALL_ADDM   // modular addition\nECALL_SUBM   // modular subtraction\nECALL_MULTM  // modular multiplication\nECALL_POWM   // modular power\n\n// Elliptic curves\nECALL_ECFP_ADD_POINT   \nECALL_ECFP_SCALAR_MULT\n\nECALL_DERIVE_HD_NODE: u32 = 130;         // BIP32 derivation\nECALL_GET_MASTER_FINGERPRINT: u32 = 131; // Master BIP32 fingerprint\nECALL_DERIVE_SLIP21_KEY: u32 = 132;      // symmetric key derivations\n\n// Hash functions (streaming)\nECALL_HASH_INIT\nECALL_HASH_UPDATE\nECALL_HASH_DIGEST\n\n// Random number generation\nECALL_GET_RANDOM_BYTES\n\n// Signatures\nECALL_ECDSA_SIGN\nECALL_ECDSA_VERIFY\nECALL_SCHNORR_SIGN\nECALL_SCHNORR_VERIFY\n\n\n// device handling, events, and UX\n// ...omitted for simplicity\n```\n[/details]\n\n\nThese provide the functionalities required for the majority of Bitcoin-related use cases, and can more generally be extended to cover most cryptographic applications.\n\nECALLs are also used to provide communication, device-specific interactions and event handling, etc.\n\n## Security\n\n> TL;DR <br> **Same threat model as existing hardware signing devices, with one caveat (memory access-pattern leakage) described below.**\n\n### Assumptions\n\nThe goal of Vanadium is to provide the same security model that hardware signing devices offer: \n* The **host is fully untrusted**, can intercept, tamper with, or abort any message.\n* The **Secure Element is trusted**.\n* The **display is trusted** (the host cannot forge the UI).\n\nA successful attack is one where the host extracts secrets or tricks the device into misbehavior (e.g., signing the wrong message).\n\n### Code Correctness / App Authenticity\n\nVanadium uses a **manifest** that commits to the exact code and metadata of a V-App.\nDuring registration:\n\n1. User approves app 'installation'.\n2. Device returns an HMAC as proof of registration.\n3. Only registered apps may execute.\n\nThis mirrors the security of sideloaded binaries today. Planned improvements include signed manifests for simpler verification.\n\n### Secure Outsourced Memory\n\nA naive outsourced memory system would be insecure. Vanadium uses standard constructions:\n\n**Integrity & Freshness**\nA Merkle tree commits to all memory pages.\n\n* Host must provide a valid Merkle proof for every page read.\n* Host must provide valid updates when committing new pages.\nAn invalid proof aborts execution.\n\n**Confidentiality**\nPages are encrypted with **AES-CTR** before leaving the device.\n\nOther approaches are possible, with different choices of tradeoffs.\n\nThis secures content\u2014but not *everything*.\n\n### Caveat: Memory Access Pattern Side Channel\n\nVanadium **does not fully hide the access pattern**: the host can observe which code and data pages are accessed and when.\n\nThis matters if:\n\n* secrets live in memory, and\n* code paths or memory lookups depend on secret bits.\n\nScalar-mult implementations that index lookup tables by secret bits are a canonical vulnerable case.\n\nMost apps won\u2019t implement cryptography directly and will rely on ECALLs instead, so most developers are not affected by this issue. But **cryptographic developers must treat this as a real attack surface**.\n\n**\u26a0\ufe0f Application developers should not implement cryptography** in Vanadium apps without fully understanding the possible impact of this side channel. Existing cryptographic libraries should also be presumed vulnerable if used in Vanadium apps, unless they explicitly guarantee that their code paths and memory access patterns do not depend on secrets.\n\nAn [Oblivious RAM](https://en.wikipedia.org/wiki/Oblivious_RAM) would solve this, but bringing complexity and a significant performance impact. Simpler mitigations could also be considered, if there is demand for such cryptography-heavy applications.\n\n## Current limitations\n\n* It has not yet been audited.\n* Performance not yet good enough for some applications (especially for large binaries).\n* UX capabilities are currently rather limited.\n\nWork is steadily ongoing to address all the above points, and I look forward to demonstrating its practicality for an increasing number of use cases.\n\n# Developer Preview\n\n> **TL;DR**<br>Don\u2019t put money in it, but please do [try it out](https://github.com/LedgerHQ/vanadium)!\n\nA working prototype of Vanadium for Ledger devices is available:<br>\n&nbsp;&nbsp;&nbsp;&nbsp;\u2192\n&nbsp;[https://github.com/LedgerHQ/vanadium](https://github.com/LedgerHQ/vanadium)",
  "actions_summary": [
    {
      "id": 2,
      "count": 10
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 81,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "Developing firmware applications for hardware signing devices has always been constrained by the difficulties of embedded development: tiny RAM, tiny flash, vendor-specific SDKs, slow iteration cycles, and painful debugging. \nOver the past year, I\u2019ve been building <a href=\"https://github.com/LedgerHQ/vanadium\" rel=\"noopener nofollow ugc\">Vanadium</a>, a different approach. It &hellip;",
  "truncated": true,
  "post_url": "/t/vanadium-a-virtualized-secure-enclave-for-hardware-signing-devices/2142/1",
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 3
    },
    {
      "id": "heart",
      "type": "emoji",
      "count": 3
    },
    {
      "id": "eyes",
      "type": "emoji",
      "count": 2
    },
    {
      "id": "tada",
      "type": "emoji",
      "count": 2
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 10,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}