{
  "id": 6368,
  "name": "Johan T. Halseth",
  "username": "halseth",
  "avatar_template": "/user_avatar/delvingbitcoin.org/halseth/{size}/198_2.png",
  "created_at": "2025-12-03T12:33:16.837Z",
  "cooked": "<p>I want to announce a prototype for a design and implementation of a vault-like scheme that can be used on Bitcoin today, achieved by outsourcing the signing quorum to a set of blinded co-signers.</p>\n<p>Unlike traditional setups involving co-signers, this scheme uses a blinded version of Musig2 to ensure the signers learn as little as possible about the on-chain movements of the funds they are involved in co-signing.</p>\n<p>In order to have the co-signers add to the security of the funds (and not just blindly sign whatever is thrown at them), we attach a ZK proof to the signing requests, proving that the transaction is valid according to a pre-determined policy. In this case that is the timelock of the final tx.</p>\n<pre data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">classDiagram\n    vault_deposit &lt;|-- vault_recovery\n    vault_deposit &lt;|-- unvault\n    unvault &lt;|-- unvault_recovery\n    unvault &lt;|-- final\n\n    class vault_deposit{\n      aggregate_key\n    }\n    class vault_recovery{\n      recovery_address\n    }\n    class unvault{\n      aggregate_key'\n    }\n    class final{\n      destination_address\n      timelock(blocks)\n    }\n    class unvault_recovery{\n      recovery_address\n    }\n</code></pre>\n<p>Looking at the graph above, the four transactions <em>vault_deposit, vault_recovery, unvault and unvault_recovery</em> will be pre-signed before funds are deposited into the vault. At the time of unvaulting, the co-signers will be asked to sign the final tx, at which point they will also require a proof that the blinded transaction they are signing has the relative timelock set correctly.</p>\n<p>This gives the owner of the funds an assurance that he (or a watchtower) has time to sweep the funds back into the recovery address in case of an unauthorized unvault. The scheme is safe as long as at least one of the signer\u2019s key only signs according to the protocol.</p>\n<p>More details about the protocol and blinded signature scheme can be found here: <a href=\"https://github.com/halseth/blind-vault/blob/d98ad46d43c757dbf79409f5663daebd07164689/doc/vault.md\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">blind-vault/doc/vault.md at d98ad46d43c757dbf79409f5663daebd07164689 \u00b7 halseth/blind-vault \u00b7 GitHub</a></p>\n<h3><a name=\"p-6368-prototype-1\" class=\"anchor\" href=\"#p-6368-prototype-1\"></a>Prototype</h3>\n<p>There\u2019s a prototype implementation of the scheme available for regtest and signet at <a href=\"https://github.com/halseth/blind-vault\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">GitHub - halseth/blind-vault</a>. Keep in mind that this is very much a proof-of-concept and should not be used with real funds.</p>\n<p>Refer to <a href=\"https://github.com/halseth/blind-vault/blob/d98ad46d43c757dbf79409f5663daebd07164689/VAULT_TOOL.md\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">blind-vault/VAULT_TOOL.md at d98ad46d43c757dbf79409f5663daebd07164689 \u00b7 halseth/blind-vault \u00b7 GitHub</a> for details of how you can test the flow using a simplified bash script.</p>\n<pre data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">  graph TD;\n      Depositor&lt;--&gt;Client;\n      Client&lt;--&gt;Signer1;\n      Client&lt;--&gt;Signer2;\n</code></pre>\n<h3><a name=\"p-6368-proving-time-2\" class=\"anchor\" href=\"#p-6368-proving-time-2\"></a>Proving time</h3>\n<p>Since the signers should learn nothing about the the messages they sign, the other signers or any of the parameters used during the signing session, it is all blinded by the client. This creates a challenge for the signers to verify that key and nonce aggregation is performed correctly, since this in regular Musig2 is performed by every signer. To mitigate this the client will attaches a ZK proof that shows the signers that aggregation and blinding is done according to protocol.</p>\n<p>Proving proper Musig2 aggregation is by far the most time consuming part of the protocol, and takes around 4 minutes per tx per signer on an Apple M1 Max. I suspect this can be reduced significantly by using a more optimized ZK prover and/or a signing scheme that involves fewer EC operations.</p>\n<h3><a name=\"p-6368-future-work-3\" class=\"anchor\" href=\"#p-6368-future-work-3\"></a>Future work</h3>\n<p>The goal is to generalize this framework to be available for other policies than the vault transaction graph. I hope to also improve on the proving time to make it practically usable on less powerful devices.</p>\n<p>Feedback is greatly appreciated!</p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 3,
  "updated_at": "2025-12-03T12:38:19.537Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 55,
  "reads": 42,
  "readers_count": 41,
  "score": 293.0,
  "yours": false,
  "topic_id": 2141,
  "topic_slug": "building-a-vault-using-blinded-co-signers",
  "topic_title": "Building a vault using blinded co-signers",
  "topic_html_title": "Building a vault using blinded co-signers",
  "category_id": 7,
  "display_username": "Johan T. Halseth",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "I want to announce a prototype for a design and implementation of a vault-like scheme that can be used on Bitcoin today, achieved by outsourcing the signing quorum to a set of blinded co-signers.\n\nUnlike traditional setups involving co-signers, this scheme uses a blinded version of Musig2 to ensure the signers learn as little as possible about the on-chain movements of the funds they are involved in co-signing. \n\nIn order to have the co-signers add to the security of the funds (and not just blindly sign whatever is thrown at them), we attach a ZK proof to the signing requests, proving that the transaction is valid according to a pre-determined policy. In this case that is the timelock of the final tx.\n\n```mermaid\nclassDiagram\n    vault_deposit <|-- vault_recovery\n    vault_deposit <|-- unvault\n    unvault <|-- unvault_recovery\n    unvault <|-- final\n\n    class vault_deposit{\n      aggregate_key\n    }\n    class vault_recovery{\n      recovery_address\n    }\n    class unvault{\n      aggregate_key'\n    }\n    class final{\n      destination_address\n      timelock(blocks)\n    }\n    class unvault_recovery{\n      recovery_address\n    }\n```\n\nLooking at the graph above, the four transactions *vault_deposit, vault_recovery, unvault and unvault_recovery* will be pre-signed before funds are deposited into the vault. At the time of unvaulting, the co-signers will be asked to sign the final tx, at which point they will also require a proof that the blinded transaction they are signing has the relative timelock set correctly.  \n\nThis gives the owner of the funds an assurance that he (or a watchtower) has time to sweep the funds back into the recovery address in case of an unauthorized unvault. The scheme is safe as long as at least one of the signer's key only signs according to the protocol.\n\nMore details about the protocol and blinded signature scheme can be found here: https://github.com/halseth/blind-vault/blob/d98ad46d43c757dbf79409f5663daebd07164689/doc/vault.md\n\n### Prototype\nThere's a prototype implementation of the scheme available for regtest and signet at https://github.com/halseth/blind-vault. Keep in mind that this is very much a proof-of-concept and should not be used with real funds.\n\nRefer to https://github.com/halseth/blind-vault/blob/d98ad46d43c757dbf79409f5663daebd07164689/VAULT_TOOL.md for details of how you can test the flow using a simplified bash script.\n\n```mermaid\n  graph TD;\n      Depositor<-->Client;\n      Client<-->Signer1;\n      Client<-->Signer2;\n```\n\n### Proving time\nSince the signers should learn nothing about the the messages they sign, the other signers or any of the parameters used during the signing session, it is all blinded by the client. This creates a challenge for the signers to verify that key and nonce aggregation is performed correctly, since this in regular Musig2 is performed by every signer. To mitigate this the client will attaches a ZK proof that shows the signers that aggregation and blinding is done according to protocol.\n\n\nProving proper Musig2 aggregation is by far the most time consuming part of the protocol, and takes around 4 minutes per tx per signer on an Apple M1 Max. I suspect this can be reduced significantly by using a more optimized ZK prover and/or a signing scheme that involves fewer EC operations. \n\n### Future work\nThe goal is to generalize this framework to be available for other policies than the vault transaction graph. I hope to also improve on the proving time to make it practically usable on less powerful devices.\n\nFeedback is greatly appreciated!",
  "actions_summary": [
    {
      "id": 2,
      "count": 5
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 163,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": "Github link was replaced with a permanent link",
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "I want to announce a prototype for a design and implementation of a vault-like scheme that can be used on Bitcoin today, achieved by outsourcing the signing quorum to a set of blinded co-signers. \nUnlike traditional setups involving co-signers, this scheme uses a blinded version of Musig2 to ensure &hellip;",
  "truncated": true,
  "post_url": "/t/building-a-vault-using-blinded-co-signers/2141/1",
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 4
    },
    {
      "id": "heart",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 5,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}