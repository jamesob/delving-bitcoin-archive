{
  "id": 6445,
  "name": "Ilya Evdokimov",
  "username": "evd0kim",
  "avatar_template": "/user_avatar/delvingbitcoin.org/evd0kim/{size}/1111_2.png",
  "created_at": "2025-12-16T19:42:11.459Z",
  "cooked": "<p><em>Statechains are a concept that were introduced by Ruben Somsen more than 6 years ago. Since then Mercury Layer was launched by Commerce Block as arguably the most advanced Statechain - with blinded signing. In this article, we are going to introduce a spin-off protocol that we believe possesses advanced privacy properties. In this protocol, state transitions inside a dedicated ledger are replaced with zkSNARKs. The selected programmable ZK stack also allows for more flexibility when it comes to enabling smart contract support. We outline ideas for market-based solutions to address the non-fungibility of statecoins and bring-in private, albeit limited, zero-knowledge smart contracts for this execution layer on top of Bitcoin.</em></p>\n<h1><a name=\"p-6445-intro-1\" class=\"anchor\" href=\"#p-6445-intro-1\"></a>Intro</h1>\n<p>When working on a bitcoin-specific application for private payments, our team began thinking about ways to improve the trust assumptions related to pegging in and out of the protocol. Currently, the network hosts a \u201cbridge\u201d contract on a bitcoin rollup, making the protocol a Bitcoin \u201cL3\u201d per marketing language used on twitter.</p>\n<p>But the application itself is not a \u201clayer\u201d on top of any protocol. It is a sovereign network with its own consensus mechanism. The fact that it can host light clients on other protocols, for purposes of message passing, can connect it to bitcoin (or any other blockchain).</p>\n<p>When thinking through this lens, we\u2019ve asked ourselves, \u201chow can we improve the trust assumptions for bitcoiners who want improved privacy?\u201d We thought through many ideas; BitVM, Ark, and other types of Layer 2 protocols.</p>\n<p>We\u2019ve found that our protocol works well with statechain-like assumptions. Meaning, a user can deposit funds into a multisig collaboratively with an operator. They can transfer ownership of this UTXO, backing private notes on the private network, by transferring their spending key to a recipient. When doing this, the operator is trusted to not collude with the spender to double-spend the recipient.</p>\n<p>In this post, we cover how a statechain-like deposit mechanism can offer a different set of tradeoffs for users who want to have improved privacy related to their bitcoin holdings.</p>\n<h1><a name=\"p-6445-literature-review-2\" class=\"anchor\" href=\"#p-6445-literature-review-2\"></a>Literature Review</h1>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/2X/0/075b02a34b23623d44911931fdce62896604392b.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/075b02a34b23623d44911931fdce62896604392b\" title=\"image\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/2X/0/075b02a34b23623d44911931fdce62896604392b_2_395x296.png\" alt=\"image\" data-base62-sha1=\"134kwfxLwAIlmTVf3pZc2vZuJZN\" width=\"395\" height=\"296\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/2X/0/075b02a34b23623d44911931fdce62896604392b_2_395x296.png, https://delvingbitcoin.org/uploads/default/optimized/2X/0/075b02a34b23623d44911931fdce62896604392b_2_592x444.png 1.5x, https://delvingbitcoin.org/uploads/default/original/2X/0/075b02a34b23623d44911931fdce62896604392b.png 2x\" data-dominant-color=\"F8F8F8\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">image</span><span class=\"informations\">720\u00d7539 48.8 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>The basic idea behind statechains is that a user Bob (public key B) locks his funds in a 2-of-2 multisig. One multisig key is held by the statechain entity Alice (public key A) and the other by Bob (public key X). The statechain entity (Alice) and Bob together pre-sign a unilateral exit transaction for Bob in case of unresponsiveness from the statechain entity (Alice). When Bob wants to transfer the money (the entire UTXO) to Claire (public key C), he simply hands over the private key for X to Claire.</p>\n<p>Some resources on statechains are:</p>\n<ul>\n<li>\n<p>In the Mercury Layer design, the Statechain entity is signing blinded messages \u2014 it does not know whether these are Bitcoin transactions or something else entirely (<a href=\"https://medium.com/@RubenSomsen/statechains-non-custodial-off-chain-bitcoin-transfer-1ae4845a4a39\" rel=\"noopener nofollow ugc\">image source</a>).</p>\n</li>\n<li>\n<p>Ruben Somsen\u2019s <a href=\"https://medium.com/@RubenSomsen/statechains-non-custodial-off-chain-bitcoin-transfer-1ae4845a4a39\" rel=\"noopener nofollow ugc\">blog</a> is the most up-to-date source of accessible information about statechains principles and design.</p>\n</li>\n<li>\n<p>Later design ideas proposed a \u201cchannel\u201d based escrow that relies on Eltoo introduced by Christian Decker, Rusty Russell and Olaoluwa Osuntokun. This version of Statechains does not require a Statechain Entity. However, it can\u2019t work with Bitcoin now since it requires an activation of SIGHASH_NOINPUT opcode to enable Eltoo. This opcode was proposed in a <a href=\"https://github.com/bitcoin/bips/blob/1e663c21500979451c97da390ddd3052866af101/bip-0118.mediawiki\" rel=\"noopener nofollow ugc\">draft BIP-118</a> in 2017 and unlikely to be activated soon on the Bitcoin blockchain.</p>\n</li>\n</ul>\n<p>Statechain Entity-based designs achieved peak performance, in terms of privacy, via the Mercury Layer implementation. A detailed description of the protocol is available in the repository, in <a href=\"https://github.com/commerceblock/mercurylayer/tree/dev/docs\" rel=\"noopener nofollow ugc\">the documentation section</a>. Whereas receivers still have to verify the history of the statecoin, the Statechain Entity has no insight into the statecoin thanks to blind signing of the UTXO transfer.</p>\n<p>Another protocol flavor called Spark, which was launched in 2025, addressed non-fungibility of statecoins with its \u201c<a href=\"https://docs.spark.money/learn/technical-definitions#splitting-a-leaf\" rel=\"noopener nofollow ugc\">leaf splitting</a>\u201d technology. This way, users could spend not just whole UTXOs on the statechain, but use smaller amounts which greatly improved user experience (when compared to Commerce Block\u2019s Mercury Layer protocol). To our knowledge, Spark operators do <strong>not</strong> use blind signing, thus they have a record of every transaction that takes place in the Spark protocol. Leaf splitting also suggests there is a very large amount of pre-signed transactions that have to be constantly updated, adding significant overhead for the operators. Finally, the launch of Spark support in Wallet of Satoshi <a href=\"https://x.com/evankaloudis/status/1975997003680108908\" rel=\"noopener nofollow ugc\">highlighted</a> that all Lightning payments for WoS users may be publicly visible via Spark\u2019s block explorers.</p>\n<p>Spark and Mercury layer are production ready protocols based on the statechain paradigm. A research implementation from Super Testnet possibly provides the simplest implementation of statechains; <a href=\"https://github.com/supertestnet/statechainjs\" rel=\"noopener nofollow ugc\">statechainjs</a>. An interesting feature of this project is its reliance on relative timelocks. Relative timelocks do not require statecoin updates at fixed block heights, as opposed to absolute timelocks that force users to come onchain prior to the timelock expiry. They defer this inevitable \u201creset\u201d of the backup transaction to an undefined time horizon that depends on the usage of the corresponding coin. However, <em>any prior holder may broadcast their pre-signed exit transaction that \u201cstarts the clock,\u201d but they can\u2019t withdraw til after the latest holder gets a chance to do so, so prior holders have limited incentive to try and cheat the current user \u2013 unless they think the \u201creal holder\u201d is offline, in which case they may be able to steal from them. Due to this possibility, the latest holder has to watch the chain \u201cjust in case,\u201d and be ready to broadcast their withdrawal transaction \u201cfirst.\u201d</em></p>\n<p>Super Testnet\u2019s experimental implementation also lacks support for the important concept of <a href=\"https://conduition.io/scriptless/adaptorsigs\" rel=\"noopener nofollow ugc\">Adaptor signatures</a>. Therefore this design relies significantly on incentives to work cooperatively and not withholding key shares during statecoin transfers.</p>\n<h1><a name=\"p-6445-zk-execution-layer-for-private-transfers-3\" class=\"anchor\" href=\"#p-6445-zk-execution-layer-for-private-transfers-3\"></a>ZK Execution Layer for Private Transfers</h1>\n<p>Somsen\u2019s original idea implied a degree of freedom when it comes to statecoin \u201cledger\u201d that registers state coins transfers for coordination purposes. It practically addresses technical issues that stem from the ability of statechain users to look up original deposit transactions, track transitory keys, timelocks and verify backup transactions.</p>\n<p>We propose a combination of statechain exit mechanics with a zero-knowledge transaction layer (ZK Ledger) as the main ledger that is responsible for the validation of \u201ckey changes\u201d and simultaneous relative timelock decrements corresponding to onchain Bitcoin transactions. Our idea relies <a href=\"https://polybase.github.io/zk-rollup/whitepaper.pdf\" rel=\"noopener nofollow ugc\">on previous work</a> related to the ZK Rollup design for Payy Network. We found that the notion of private \u201cpayment links\u201d to be potentially synergetic with statechain-style protocols.</p>\n<p>When connected to statechains, the enhanced programmability of the ZK Ledger allows for simplified backup transaction updates. In this model, the receiving party verifies a zero-knowledge proof as a part of the UTXO transfers, in addition to normal ways to verify bitcoin transactions. It is our view that this programmability makes the protocol simpler and closer to Super Testnet\u2019s demo case.</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/2X/e/e8168c006612d5f65a3f3fc04b4ea35aa49d2961.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/e8168c006612d5f65a3f3fc04b4ea35aa49d2961\" title=\"image\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/2X/e/e8168c006612d5f65a3f3fc04b4ea35aa49d2961_2_513x295.png\" alt=\"image\" data-base62-sha1=\"x794W2gVnWvmvH1nfkm74Ecnrih\" width=\"513\" height=\"295\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/2X/e/e8168c006612d5f65a3f3fc04b4ea35aa49d2961_2_513x295.png, https://delvingbitcoin.org/uploads/default/optimized/2X/e/e8168c006612d5f65a3f3fc04b4ea35aa49d2961_2_769x442.png 1.5x, https://delvingbitcoin.org/uploads/default/optimized/2X/e/e8168c006612d5f65a3f3fc04b4ea35aa49d2961_2_1026x590.png 2x\" data-dominant-color=\"F5F5F0\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">image</span><span class=\"informations\">1106\u00d7635 19.9 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>Transmitting notes P2P</p>\n<h2><a name=\"p-6445-protocol-explainer-4\" class=\"anchor\" href=\"#p-6445-protocol-explainer-4\"></a>Protocol explainer</h2>\n<p>Let\u2019s dive into more details about proposed architecture. On the highest level, the Sender and Receiver facilitate a peer-to-peer transfer. For the Sender to generate a valid zkSNARK proof and transfer ownership of the UTXO to the recipient, they must have the corresponding the note\u2019s data (note being the private, offchain representation of an onchain UTXO). This zkSNARK proof is transferred to the user client-side, and only the hash commitment of the note is published to the operator within the ZK Ledger. Senders coordinate with the Statechain entity to pass ownership of the UTXO to a recipient. Upon validating the validity of the UTXO, recipients receive the coin and trust the operator to not collude with previous owners to double spend them. For the remainder of this post, we will refer to the Statechain entity as the \u201cOperator\u201d.</p>\n<h2><a name=\"p-6445-protocol-roles-5\" class=\"anchor\" href=\"#p-6445-protocol-roles-5\"></a>Protocol roles</h2>\n<p>The protocol has three actors; the operator, the sender and the receiver who operate the ZK Ledger. Each of these parties are responsible for specific items during a statecoin transfer.</p>\n<p><em>ZK Ledger:</em> The ZK Ledger is a sovereign network with its own consensus rules and implementation. It enables token transfers that are proven valid through zkSNARKs and minimal information leakage related to participants in a transaction.</p>\n<p><em>Operator</em>: The operator is responsible for maintaining a ledger of note commitments that nullify a sender\u2019s ability to double-spend a recipient (i.e. run a ZK Ledger full node). Upon verifying a sender\u2019s proof to spend a UTXO, and ensuring the newly generated output commitment does not exist within the list of previous commitments, the operator co-signs the new presigned transaction. The Operator is meant to be a Statechain Operator which is an independent role to validators in the ZK ledger.</p>\n<p><em>Sender</em>: The sender is a user in the protocol that wants to transfer funds to another party. To transfer these funds, they construct a new presigned transaction that designates the recipient as the recipient for the payout transaction. This presigned transaction has a lower timelock than that of their presigned transaction.</p>\n<p><em>Receiver</em>: The receiver is responsible for initiating transfers within the protocol and verifying their validity. When they want to receive funds, they generate a secret key that is passed to the sender, which the sender then uses to pre-sign a new pay out transaction (related to the bitcoin UTXO locked in the onchain multisig) specifying the recipient as the previous owner. After the sender and the operator pre-sign a new payout transaction, and this information is communicated with the recipient, the recipient verifies that the payout transaction is for a valid bitcoin UTXO and that their pay out transaction timelock is lower than that of the sender.</p>\n<h3><a name=\"p-6445-payment-flow-6\" class=\"anchor\" href=\"#p-6445-payment-flow-6\"></a>Payment flow</h3>\n<p>The payment flow can be described as the following: a user deposits funds into a 2-2 Musig address where they and the Operator each hold a keyshare. This deposit transaction is mirrored on the ZK Ledger and credits the user\u2019s balance with an amount of bitcoin-denominated tokens that is equivalent to that of tokens held in the multisig address. The Operator can be a single signer or their key can be sharded across multiple signers using some Threshold Signature Scheme. When depositing funds into the protocol, the user works with the Operator to generate a presigned transaction that enables them to unilaterally exit the protocol in case of an Operator liveness failure.</p>\n<p>To send funds to a recipient, the sender is responsible for communicating her UTXO in the form of \u201cinput note\u2019s\u201d data to a receiver via short \u201cpayment links\u201d. Such payment links may be shown as QR code or sent via communication channels. This way the receiver \u201cpulls\u201d payment and constructs her new UTXO. SuperTestnet suggested a way that is <a href=\"https://thebitcoinmanual.com/articles/send-ecash-tokens-nostr/\" rel=\"noopener nofollow ugc\">featured by some eCash projects</a> when bearer tokens are sent via Nostr relays. If implemented, it would mean achieving the goal of \u201cpush\u201d payments via a combination of creating a \u201cpull\u201d note by the Sender, encrypting it for the Receiver using the Receiver\u2019s Nostr public key, and broadcasting the message via a dedicated Nostr relay.</p>\n<p>To fully facilitate a payment, the sender (Bob) first proposes a transaction within the ZK Ledger. He creates a payment link for a note (UTXO) and broadcasts the payment to this link to the network\u2019s validators. If newly created UTXO satisfies rules for normal send, mint or burn type of transaction, the network validators confirm the payment as valid and add its corresponding commitments to the ZK Ledger chain. It is the purpose of the future research to evaluate potential options for note contents and corresponding rules. For example, a transitory key may be handed over along with a nullifier inside the note or alternatively note could commit to a key that was used for creating Bob\u2019s backup address, i.e. when handing over secret in the payment link automatically invalidates previous timeout spending branch. This \u201cInputNote\u201d created by Bob has to be handed over to the recipient (Carol).</p>\n<p>As mentioned, in the ZK Ledger, the sender (Bob) has created a note to transfer funds to the recipient (Carol). To mirror this transfer on Bitcoin, we need to transfer ownership of the spending key in the onchain bitcoin multisig from Bob to Carol if it wasn\u2019t transferred via note. To do this, the sender (Bob) works with the operator to create a new pre-signed exit transaction for the new recipient (Carol) as depicted in Figure n (\u201cblind statechains\u201d). This procedure establishes the recipient (Carol) as the new current owner. As with all statechain-like designs, the timelock on this new exit transaction expires before the timelock of the previous exit transaction belonging to Bob. After this procedure is complete, the sender (Bob) communicates the secret key for X the recipient (Carol).</p>\n<p>Upon downloading the link, the recipient can then claim the note and create new UTXO through a second ZK Ledger transaction. Carol does this and broadcasts said transaction to the networks\u2019 validators who confirm their claim. A second commitment is added to the chain, finalizing the transfer within the ZK Ledger. This transfer is also reflected on bitcoin via the statechain-like ownership transfer procedure. Carol now holds a note within the ZK Ledger and a copy of a presigned transaction for the 2-2 multisig on bitcoin for optional unilateral exit.</p>\n<p>In this protocol, the transfer of ownership is proven valid by a zkSNARK proof which the recipient validates client-side. The zkSNARK proves, per some zero-knowledge circuit logic, that the sender constructed a presigned payout transaction with a lower timelock than the one they previously received and that the note they\u2019ve received on the ZK Ledger is valid and has an available output commitment. To prove that the sender has not previously transferred ownership to another user within the ZK Ledger, the receiver checks the generated output commitment against all commitments through its ZK Ledger full node or a third-party node. If the output commitment is unique, and the proof is valid, the recipient validates the ZK proof and finalizes the transaction. After verifying the transfer\u2019s validity, the recipient locally stores the backup transaction, but does not broadcast it. The recipient is now the current owner of the statecoin. Note, that in our protocol, a history of backup transactions is not passed to the recipient. The zkSNARK that they validate locally is proof that the note they are receiving in the ZK Ledger is valid, and that this transfer of ownership is updating the bitcoin multisig\u2019s view of said transaction.</p>\n<p>A successful verification means that that locktime committing to the output hash was accepted along with his Shielded note secret key hash in private inputs of corresponding SNARK proof and it was lower than locktime in previous transactions.</p>\n<h4><a name=\"p-6445-note-structure-7\" class=\"anchor\" href=\"#p-6445-note-structure-7\"></a>Note structure</h4>\n<p>Within the example above, you may note that the sender is responsible for two operations: 1) create a payment in the ZK Ledger and engage in a key reassignment procedure with the operator to transfer ownership of the bitcoin multisig to a recipient. This is necessary, but user complexity can likely be mitigated through application UI abstraction.For the receiver, we can construct the ZK Ledger\u2019s note structure and corresponding ZK-Circuits to verify the validity of a transfer pertaining to funds in the bitcoin multisig, offchain. It is important for Receiver\u2019s security that upon receipt of the pre-signed backup transaction, the Receiver must obtain a finalized transaction that spends from an existing Bitcoin UTXO and contains a timelock that is lower than all previously generated backup transactions.</p>\n<p>In previous protocols, the timelock decrement could be enforced via verification of the entire history of statecoin transfers client side. In our protocol, we address that in a way that allows compressed representation via SNARK while providing privacy as a by-product.</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/2X/9/9f5bca7772f949a38c7e55cb2fbadf94081bac57.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/9f5bca7772f949a38c7e55cb2fbadf94081bac57\" title=\"image\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/2X/9/9f5bca7772f949a38c7e55cb2fbadf94081bac57_2_624x429.png\" alt=\"image\" data-base62-sha1=\"mJKzT9W982RkvarLKQV7KWoD6dh\" width=\"624\" height=\"429\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/2X/9/9f5bca7772f949a38c7e55cb2fbadf94081bac57_2_624x429.png, https://delvingbitcoin.org/uploads/default/optimized/2X/9/9f5bca7772f949a38c7e55cb2fbadf94081bac57_2_936x643.png 1.5x, https://delvingbitcoin.org/uploads/default/optimized/2X/9/9f5bca7772f949a38c7e55cb2fbadf94081bac57_2_1248x858.png 2x\" data-dominant-color=\"EDF4FA\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">image</span><span class=\"informations\">1600\u00d71101 43.2 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>Updated UTXO note structure</p>\n<p>When included into note structure, the timelock validation becomes a part of the dedicated UTXO circuit which validates privately if Receiver\u2019s timelock in the output satisfies a condition to be less than timelock in the input with given delta. The timelock and the authentication key become two entities that connect a shielded pool note with Bitcoin. The authentication key may be a valid libsecp256k1 private  key that corresponds to the backup transaction and is not known to the next receiver until signing of the new backup is complete.</p>\n<p>In the less private setup after obtaining the payment link with the previous transitory key along with private key to backup address, the receiver includes them as input into a new shielded transaction, validates it, generates proofs and sends the new transaction to the Operator. However, albeit less private (details are shared with counterparty), this way may be considered also as most secure since the next shielded coin owner also has a private key from the previous backup transaction. This disincentivizes the previous owner from broadcasting an old backup.</p>\n<p>In a more private setup the Receiver can only obtain Sender\u2019s public key in case of an attempt to spend funding UTXO and because Receiver already has a transitory key after completion of the statecoin transfer, she may convince Operator to punish dishonest sender and co-sign to the new \u201crecovery\u201d address of the owner of valid Shielded note.</p>\n<h1><a name=\"p-6445-crime-and-punishment-8\" class=\"anchor\" href=\"#p-6445-crime-and-punishment-8\"></a>Crime and Punishment</h1>\n<p>In the current design, we propose a more straightforward way to facilitate backup UTXO transfer. However, it still allows Spenders to <em>attempt</em> a double-spend. In a scenario where the Spender hands over payment links with the note private key encoded, broadcasting an old backup does not make sense since the Receiver may know the private key for the backup output from the link (i.e. it becomes a way to revoke backup). Alternatively, when the Sender publishes their previous back up transaction onchain, and the Receiver already has a backup transaction, the recipient reconstructs the commitment and expects confirmation in the ZK Ledger which only happens if the timelock in the Output was lower than the timelock in the Input. Here, double spend is impossible too, unless the Operator colludes and secretly co-signs a new transaction with lower timelock without submitting it into ZK ledger.</p>\n<p>However, this situation may be detected by external observers and fraud is provable the same way it is done in the original statechains. When defrauded, the Receiver may obtain a transaction that spends funding input of the state coin, extract public key, amount and timelock and obtain commitment that should have been submitted into statechain ledger in the honest scenario. If the existence of the output commitment is not confirmed, it means that the operator colluded with dishonest Sender.</p>\n<p>When the Operator entity is represented by FROST federation, each participant may track funding UTXO and verify if new spends correspond to shielded UTXO. Besides detecting potential collusion, this defines a unilateral exit scenario when UTXO must be burned.</p>\n<h1><a name=\"p-6445-fungibility-of-notes-in-shielded-pool-9\" class=\"anchor\" href=\"#p-6445-fungibility-of-notes-in-shielded-pool-9\"></a>Fungibility of Notes in Shielded Pool</h1>\n<p>Backup transactions may lead to privacy leaks which will make all efforts on improving it on the statecoin ledger side fruitless. Therefore an important feature of the Operator should be blind signing of backup transactions similarly to the Mercury layer. However it also means that schemes with splitting of shielded coins denominations with simultaneous backing similar to Spark\u2019s are likely impractical when joined with blind signing. In this situation we propose to preserve privacy benefits while addressing shielded coins\u2019 fungibility via market based mechanics when circulating shielded notes may be merged and exchanged privately inside a shielded pool with support of pre-programmed circuits implementing dedicated smart contract functionality.</p>\n<p>The transaction structure of the original ZK Rollup architecture assumes 2-input, 2-output transactions and allows merging and splitting notes with change by design. For notes of \u201cstatecoin\u201d kind rules may define 1 padding \u201czero\u201d note in the input and the output correspondingly and such simple rules could be enforced via dedicated UTXO circuit which could be programmable.</p>\n<p>For an illustration, let\u2019s consider an existing code snippet, a simple check for various types of notes: if note facilitates regular transfer, mint (gets into the pool) or burn (exits shielded pool).</p>\n<pre><code class=\"lang-auto\">\n    if (kind == 1) {\n\n        //SEND\n\n        assert(input_value == output_value, \"Input and output totals do not match\");\n\n    } else if (kind == 2) {\n\n        // MINT\n\n        // Assert mint utxo is balanced:\n\n        //   - \\`output_value\\` is checked above\n\n        //   - \\`input_value\\` is checked as it must have previously been an output value\n\n        //   - \\`msg_value\\` is checked above (but also using that to overflow would be detrimental to the\n\n        //      attacker)\n\n        assert(output_value == input_value + msg_value, \"Mint output must match value message\");\n\n        // Assert mint hash\n\n        assert(mint_hash == msg_hash, \"Mint hash must match message\");\n\n        // Assert note kind\n\n        assert(output_notes\\[0\\].kind == msg_note_kind, \"Mint note kind must match message\")\n\n    } else if (kind == 3) {\n\n        // BURN\n\n        // Prevent frontrunning the txn and changing the evm address\n\n        assert(pmessage4 == burn_addr, \"messages\\[4\\] must match private input\");\n\n        // Assert burn hash\n\n        assert(burn_hash == msg_hash, \"Burn hash must match message\");\n\n        // Assert burn utxo is balanced:\n\n        //   - \\`output_value\\` is checked above\n\n        //   - \\`input_value\\` is checked as it must have previously been an output value\n\n        //   - \\`msg_value\\` is checked above\n\n        assert(input_value == output_value + msg_value, \"Burn output must match value message\");\n\n        // Assert burn kind\n\n        assert(input_notes\\[0\\].note.kind == msg_note_kind, \"Burn note kind must match message\")\n\n    } else {\n\n        assert(false, \"Invalid kind\");\n\n    }\n</code></pre>\n<p>This way we could define more types and more checks. More importantly, we envision building a market place for peg-outs where whole pre-signed UTXO could be traded against shielded fungible tokens. Marked based approach assumes the existence of notes that may be detached from the corresponding backup transactions and therefore requiring less interactive process for regular private transfers.</p>\n<h1><a name=\"p-6445-nostr-based-relaying-10\" class=\"anchor\" href=\"#p-6445-nostr-based-relaying-10\"></a>Nostr-based Relaying</h1>\n<p><a href=\"https://polybase.github.io/zk-rollup/whitepaper.pdf\" rel=\"noopener nofollow ugc\">The original Moore\u2019s and Gandhi work</a> mentions \u201cEncrypted Registry\u201d which should help sending payments over the network when the Sender and Receiver are not online at the same time. During their absence, the transaction data could be stored in the Encrypted Registry, and this is an optional component of the network.</p>\n<p>As mentioned earlier, using Nostr allows achieving a \u201cpush\u201d payments user experience while not changing the existing method for sending coins. On a higher level, sending a payment to a selected Nostr public key specifies a resilient and sufficiently decentralized way to broadcast an encrypted transaction and possibly gain additional privacy because financial transactions will be relayed along with tons of different encrypted data, including regular text messages to this user.</p>\n<p>Besides that, relaying a message broadly via several Nostr relays may allow duplication of the original message. Because Nostr is becoming a modular sophisticated protocol, the goal of <em>a sharded decentralised encrypted registry, where the encrypted data is split into chunks and blindly stored across multiple nodes</em> may be achieved independently from ZK Ledger development goals.</p>\n<h1><a name=\"p-6445-conclusion-11\" class=\"anchor\" href=\"#p-6445-conclusion-11\"></a>Conclusion</h1>\n<p>Previous works around Bitcoin Statechains suggest a degree of freedom when it comes to implementing a ledger for tracking statecoin transfers and keeping the Operator accountable. We have attempted to replace implied UTXO-based ledger with the simplest possible flavor of the ZK Rollup that was previously developed for Ethereum. The eventual design becomes a rather zero-knowledge based smart contract execution layer for Bitcoin, with opportunities for unilateral exit and censorship resistance stemming from leveraging ZK technology stack.</p>\n<p>The proposed architecture occupies an intermediate position between Statechains and ShieldedCSV or ZKCoins. The latter omits on/off ramping into shielded pools while the former lacks privacy. However, options for using BitVM as for bridging coins back and forth are mentioned both in ShieldedCSV paper and <a href=\"https://gist.github.com/RobinLinus/d036511015caea5a28514259a1bab119\" rel=\"noopener nofollow ugc\">ZKCoins</a> as well. It makes the ZK execution layer an interesting opportunity to experiment with programmable market-based mechanics for on/off ramping into shielded pools. The closest example here might be the \u201cpragmatic rollup\u201d design implemented in <a href=\"https://signet.sh/\" rel=\"noopener nofollow ugc\">Signet</a> and completely unknown to the Bitcoin community. Its design suggest instant swaps and atomicity for cross-chain transactions which when applied to ZK Statechain would mean \u201cone in, one out\u201d rule facilitated with the help of \u201cprivacy arbitrators\u201d who are ready to post UTXO for exits or take ownership and possibly lift timelocks for entering participants.</p>\n<p><strong>Acknowledgments</strong></p>\n<p>I greatly appreciate the thorough review by <a href=\"https://x.com/januszg_\" rel=\"noopener nofollow ugc\">Janusz</a> and Gus Gotoski. I also thank SuperTestnet and fiatjaf for their valuable feedback.</p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 3,
  "updated_at": "2025-12-16T19:47:15.843Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 14,
  "reads": 29,
  "readers_count": 28,
  "score": 65.6,
  "yours": false,
  "topic_id": 2166,
  "topic_slug": "zk-statechains-without-states",
  "topic_title": "ZK-Statechains Without States",
  "topic_html_title": "ZK-Statechains Without States",
  "category_id": 7,
  "display_username": "Ilya Evdokimov",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "*Statechains are a concept that were introduced by Ruben Somsen more than 6 years ago. Since then Mercury Layer was launched by Commerce Block as arguably the most advanced Statechain - with blinded signing. In this article, we are going to introduce a spin-off protocol that we believe possesses advanced privacy properties. In this protocol, state transitions inside a dedicated ledger are replaced with zkSNARKs. The selected programmable ZK stack also allows for more flexibility when it comes to enabling smart contract support. We outline ideas for market-based solutions to address the non-fungibility of statecoins and bring-in private, albeit limited, zero-knowledge smart contracts for this execution layer on top of Bitcoin.*\n\n# Intro\n\nWhen working on a bitcoin-specific application for private payments, our team began thinking about ways to improve the trust assumptions related to pegging in and out of the protocol. Currently, the network hosts a \u201cbridge\u201d contract on a bitcoin rollup, making the protocol a Bitcoin \u201cL3\u201d per marketing language used on twitter.\n\nBut the application itself is not a \u201clayer\u201d on top of any protocol. It is a sovereign network with its own consensus mechanism. The fact that it can host light clients on other protocols, for purposes of message passing, can connect it to bitcoin (or any other blockchain).\n\nWhen thinking through this lens, we\u2019ve asked ourselves, \u201chow can we improve the trust assumptions for bitcoiners who want improved privacy?\u201d We thought through many ideas; BitVM, Ark, and other types of Layer 2 protocols.\n\nWe\u2019ve found that our protocol works well with statechain-like assumptions. Meaning, a user can deposit funds into a multisig collaboratively with an operator. They can transfer ownership of this UTXO, backing private notes on the private network, by transferring their spending key to a recipient. When doing this, the operator is trusted to not collude with the spender to double-spend the recipient.\n\nIn this post, we cover how a statechain-like deposit mechanism can offer a different set of tradeoffs for users who want to have improved privacy related to their bitcoin holdings.\n\n# Literature Review\n\n![image|395x296](upload://134kwfxLwAIlmTVf3pZc2vZuJZN.png)\n\nThe basic idea behind statechains is that a user Bob (public key B) locks his funds in a 2-of-2 multisig. One multisig key is held by the statechain entity Alice (public key A) and the other by Bob (public key X). The statechain entity (Alice) and Bob together pre-sign a unilateral exit transaction for Bob in case of unresponsiveness from the statechain entity (Alice). When Bob wants to transfer the money (the entire UTXO) to Claire (public key C), he simply hands over the private key for X to Claire.\n\nSome resources on statechains are:\n\n* In the Mercury Layer design, the Statechain entity is signing blinded messages \u2014 it does not know whether these are Bitcoin transactions or something else entirely ([image source](https://medium.com/@RubenSomsen/statechains-non-custodial-off-chain-bitcoin-transfer-1ae4845a4a39)).\n\n* Ruben Somsen\u2019s [blog](https://medium.com/@RubenSomsen/statechains-non-custodial-off-chain-bitcoin-transfer-1ae4845a4a39) is the most up-to-date source of accessible information about statechains principles and design.\n\n* Later design ideas proposed a \u201cchannel\u201d based escrow that relies on Eltoo introduced by Christian Decker, Rusty Russell and Olaoluwa Osuntokun. This version of Statechains does not require a Statechain Entity. However, it can\u2019t work with Bitcoin now since it requires an activation of SIGHASH_NOINPUT opcode to enable Eltoo. This opcode was proposed in a [draft BIP-118](https://github.com/bitcoin/bips/blob/1e663c21500979451c97da390ddd3052866af101/bip-0118.mediawiki) in 2017 and unlikely to be activated soon on the Bitcoin blockchain.\n\nStatechain Entity-based designs achieved peak performance, in terms of privacy, via the Mercury Layer implementation. A detailed description of the protocol is available in the repository, in [the documentation section](https://github.com/commerceblock/mercurylayer/tree/dev/docs). Whereas receivers still have to verify the history of the statecoin, the Statechain Entity has no insight into the statecoin thanks to blind signing of the UTXO transfer.\n\nAnother protocol flavor called Spark, which was launched in 2025, addressed non-fungibility of statecoins with its \u201c[leaf splitting](https://docs.spark.money/learn/technical-definitions#splitting-a-leaf)\u201d technology. This way, users could spend not just whole UTXOs on the statechain, but use smaller amounts which greatly improved user experience (when compared to Commerce Block\u2019s Mercury Layer protocol). To our knowledge, Spark operators do **not** use blind signing, thus they have a record of every transaction that takes place in the Spark protocol. Leaf splitting also suggests there is a very large amount of pre-signed transactions that have to be constantly updated, adding significant overhead for the operators. Finally, the launch of Spark support in Wallet of Satoshi [highlighted](https://x.com/evankaloudis/status/1975997003680108908) that all Lightning payments for WoS users may be publicly visible via Spark\u2019s block explorers.\n\nSpark and Mercury layer are production ready protocols based on the statechain paradigm. A research implementation from Super Testnet possibly provides the simplest implementation of statechains; [statechainjs](https://github.com/supertestnet/statechainjs). An interesting feature of this project is its reliance on relative timelocks. Relative timelocks do not require statecoin updates at fixed block heights, as opposed to absolute timelocks that force users to come onchain prior to the timelock expiry. They defer this inevitable \u201creset\u201d of the backup transaction to an undefined time horizon that depends on the usage of the corresponding coin. However, *any prior holder may broadcast their pre-signed exit transaction that \u201cstarts the clock,\u201d but they can\u2019t withdraw til after the latest holder gets a chance to do so, so prior holders have limited incentive to try and cheat the current user \u2013 unless they think the \u201creal holder\u201d is offline, in which case they may be able to steal from them. Due to this possibility, the latest holder has to watch the chain \u201cjust in case,\u201d and be ready to broadcast their withdrawal transaction \u201cfirst.\u201d*\n\nSuper Testnet\u2019s experimental implementation also lacks support for the important concept of [Adaptor signatures](https://conduition.io/scriptless/adaptorsigs). Therefore this design relies significantly on incentives to work cooperatively and not withholding key shares during statecoin transfers.\n\n# ZK Execution Layer for Private Transfers\n\nSomsen\u2019s original idea implied a degree of freedom when it comes to statecoin \u201cledger\u201d that registers state coins transfers for coordination purposes. It practically addresses technical issues that stem from the ability of statechain users to look up original deposit transactions, track transitory keys, timelocks and verify backup transactions.\n\nWe propose a combination of statechain exit mechanics with a zero-knowledge transaction layer (ZK Ledger) as the main ledger that is responsible for the validation of \u201ckey changes\u201d and simultaneous relative timelock decrements corresponding to onchain Bitcoin transactions. Our idea relies [on previous work](https://polybase.github.io/zk-rollup/whitepaper.pdf) related to the ZK Rollup design for Payy Network. We found that the notion of private \u201cpayment links\u201d to be potentially synergetic with statechain-style protocols.\n\nWhen connected to statechains, the enhanced programmability of the ZK Ledger allows for simplified backup transaction updates. In this model, the receiving party verifies a zero-knowledge proof as a part of the UTXO transfers, in addition to normal ways to verify bitcoin transactions. It is our view that this programmability makes the protocol simpler and closer to Super Testnet\u2019s demo case.\n\n![image|513x295](upload://x794W2gVnWvmvH1nfkm74Ecnrih.png)\n\nTransmitting notes P2P\n\n## Protocol explainer\n\nLet\u2019s dive into more details about proposed architecture. On the highest level, the Sender and Receiver facilitate a peer-to-peer transfer. For the Sender to generate a valid zkSNARK proof and transfer ownership of the UTXO to the recipient, they must have the corresponding the note\u2019s data (note being the private, offchain representation of an onchain UTXO). This zkSNARK proof is transferred to the user client-side, and only the hash commitment of the note is published to the operator within the ZK Ledger. Senders coordinate with the Statechain entity to pass ownership of the UTXO to a recipient. Upon validating the validity of the UTXO, recipients receive the coin and trust the operator to not collude with previous owners to double spend them. For the remainder of this post, we will refer to the Statechain entity as the \u201cOperator\u201d.\n\n## Protocol roles\n\nThe protocol has three actors; the operator, the sender and the receiver who operate the ZK Ledger. Each of these parties are responsible for specific items during a statecoin transfer.\n\n*ZK Ledger:* The ZK Ledger is a sovereign network with its own consensus rules and implementation. It enables token transfers that are proven valid through zkSNARKs and minimal information leakage related to participants in a transaction.\n\n*Operator*: The operator is responsible for maintaining a ledger of note commitments that nullify a sender\u2019s ability to double-spend a recipient (i.e. run a ZK Ledger full node). Upon verifying a sender\u2019s proof to spend a UTXO, and ensuring the newly generated output commitment does not exist within the list of previous commitments, the operator co-signs the new presigned transaction. The Operator is meant to be a Statechain Operator which is an independent role to validators in the ZK ledger.\n\n*Sender*: The sender is a user in the protocol that wants to transfer funds to another party. To transfer these funds, they construct a new presigned transaction that designates the recipient as the recipient for the payout transaction. This presigned transaction has a lower timelock than that of their presigned transaction.\n\n*Receiver*: The receiver is responsible for initiating transfers within the protocol and verifying their validity. When they want to receive funds, they generate a secret key that is passed to the sender, which the sender then uses to pre-sign a new pay out transaction (related to the bitcoin UTXO locked in the onchain multisig) specifying the recipient as the previous owner. After the sender and the operator pre-sign a new payout transaction, and this information is communicated with the recipient, the recipient verifies that the payout transaction is for a valid bitcoin UTXO and that their pay out transaction timelock is lower than that of the sender.\n\n### Payment flow\n\nThe payment flow can be described as the following: a user deposits funds into a 2-2 Musig address where they and the Operator each hold a keyshare. This deposit transaction is mirrored on the ZK Ledger and credits the user\u2019s balance with an amount of bitcoin-denominated tokens that is equivalent to that of tokens held in the multisig address. The Operator can be a single signer or their key can be sharded across multiple signers using some Threshold Signature Scheme. When depositing funds into the protocol, the user works with the Operator to generate a presigned transaction that enables them to unilaterally exit the protocol in case of an Operator liveness failure.\n\nTo send funds to a recipient, the sender is responsible for communicating her UTXO in the form of \u201cinput note\u2019s\u201d data to a receiver via short \u201cpayment links\u201d. Such payment links may be shown as QR code or sent via communication channels. This way the receiver \u201cpulls\u201d payment and constructs her new UTXO. SuperTestnet suggested a way that is [featured by some eCash projects](https://thebitcoinmanual.com/articles/send-ecash-tokens-nostr/) when bearer tokens are sent via Nostr relays. If implemented, it would mean achieving the goal of \u201cpush\u201d payments via a combination of creating a \u201cpull\u201d note by the Sender, encrypting it for the Receiver using the Receiver\u2019s Nostr public key, and broadcasting the message via a dedicated Nostr relay.\n\nTo fully facilitate a payment, the sender (Bob) first proposes a transaction within the ZK Ledger. He creates a payment link for a note (UTXO) and broadcasts the payment to this link to the network\u2019s validators. If newly created UTXO satisfies rules for normal send, mint or burn type of transaction, the network validators confirm the payment as valid and add its corresponding commitments to the ZK Ledger chain. It is the purpose of the future research to evaluate potential options for note contents and corresponding rules. For example, a transitory key may be handed over along with a nullifier inside the note or alternatively note could commit to a key that was used for creating Bob\u2019s backup address, i.e. when handing over secret in the payment link automatically invalidates previous timeout spending branch. This \u201cInputNote\u201d created by Bob has to be handed over to the recipient (Carol).\n\nAs mentioned, in the ZK Ledger, the sender (Bob) has created a note to transfer funds to the recipient (Carol). To mirror this transfer on Bitcoin, we need to transfer ownership of the spending key in the onchain bitcoin multisig from Bob to Carol if it wasn\u2019t transferred via note. To do this, the sender (Bob) works with the operator to create a new pre-signed exit transaction for the new recipient (Carol) as depicted in Figure n (\u201cblind statechains\u201d). This procedure establishes the recipient (Carol) as the new current owner. As with all statechain-like designs, the timelock on this new exit transaction expires before the timelock of the previous exit transaction belonging to Bob. After this procedure is complete, the sender (Bob) communicates the secret key for X the recipient (Carol).\n\nUpon downloading the link, the recipient can then claim the note and create new UTXO through a second ZK Ledger transaction. Carol does this and broadcasts said transaction to the networks\u2019 validators who confirm their claim. A second commitment is added to the chain, finalizing the transfer within the ZK Ledger. This transfer is also reflected on bitcoin via the statechain-like ownership transfer procedure. Carol now holds a note within the ZK Ledger and a copy of a presigned transaction for the 2-2 multisig on bitcoin for optional unilateral exit.\n\nIn this protocol, the transfer of ownership is proven valid by a zkSNARK proof which the recipient validates client-side. The zkSNARK proves, per some zero-knowledge circuit logic, that the sender constructed a presigned payout transaction with a lower timelock than the one they previously received and that the note they\u2019ve received on the ZK Ledger is valid and has an available output commitment. To prove that the sender has not previously transferred ownership to another user within the ZK Ledger, the receiver checks the generated output commitment against all commitments through its ZK Ledger full node or a third-party node. If the output commitment is unique, and the proof is valid, the recipient validates the ZK proof and finalizes the transaction. After verifying the transfer\u2019s validity, the recipient locally stores the backup transaction, but does not broadcast it. The recipient is now the current owner of the statecoin. Note, that in our protocol, a history of backup transactions is not passed to the recipient. The zkSNARK that they validate locally is proof that the note they are receiving in the ZK Ledger is valid, and that this transfer of ownership is updating the bitcoin multisig\u2019s view of said transaction.\n\nA successful verification means that that locktime committing to the output hash was accepted along with his Shielded note secret key hash in private inputs of corresponding SNARK proof and it was lower than locktime in previous transactions.\n\n#### Note structure\n\nWithin the example above, you may note that the sender is responsible for two operations: 1) create a payment in the ZK Ledger and engage in a key reassignment procedure with the operator to transfer ownership of the bitcoin multisig to a recipient. This is necessary, but user complexity can likely be mitigated through application UI abstraction.For the receiver, we can construct the ZK Ledger\u2019s note structure and corresponding ZK-Circuits to verify the validity of a transfer pertaining to funds in the bitcoin multisig, offchain. It is important for Receiver\u2019s security that upon receipt of the pre-signed backup transaction, the Receiver must obtain a finalized transaction that spends from an existing Bitcoin UTXO and contains a timelock that is lower than all previously generated backup transactions.\n\nIn previous protocols, the timelock decrement could be enforced via verification of the entire history of statecoin transfers client side. In our protocol, we address that in a way that allows compressed representation via SNARK while providing privacy as a by-product.\n\n![image|624x429](upload://mJKzT9W982RkvarLKQV7KWoD6dh.png)\n\nUpdated UTXO note structure\n\nWhen included into note structure, the timelock validation becomes a part of the dedicated UTXO circuit which validates privately if Receiver\u2019s timelock in the output satisfies a condition to be less than timelock in the input with given delta. The timelock and the authentication key become two entities that connect a shielded pool note with Bitcoin. The authentication key may be a valid libsecp256k1 private  key that corresponds to the backup transaction and is not known to the next receiver until signing of the new backup is complete.\n\nIn the less private setup after obtaining the payment link with the previous transitory key along with private key to backup address, the receiver includes them as input into a new shielded transaction, validates it, generates proofs and sends the new transaction to the Operator. However, albeit less private (details are shared with counterparty), this way may be considered also as most secure since the next shielded coin owner also has a private key from the previous backup transaction. This disincentivizes the previous owner from broadcasting an old backup.\n\nIn a more private setup the Receiver can only obtain Sender\u2019s public key in case of an attempt to spend funding UTXO and because Receiver already has a transitory key after completion of the statecoin transfer, she may convince Operator to punish dishonest sender and co-sign to the new \u201crecovery\u201d address of the owner of valid Shielded note.\n\n# Crime and Punishment\n\nIn the current design, we propose a more straightforward way to facilitate backup UTXO transfer. However, it still allows Spenders to *attempt* a double-spend. In a scenario where the Spender hands over payment links with the note private key encoded, broadcasting an old backup does not make sense since the Receiver may know the private key for the backup output from the link (i.e. it becomes a way to revoke backup). Alternatively, when the Sender publishes their previous back up transaction onchain, and the Receiver already has a backup transaction, the recipient reconstructs the commitment and expects confirmation in the ZK Ledger which only happens if the timelock in the Output was lower than the timelock in the Input. Here, double spend is impossible too, unless the Operator colludes and secretly co-signs a new transaction with lower timelock without submitting it into ZK ledger.\n\nHowever, this situation may be detected by external observers and fraud is provable the same way it is done in the original statechains. When defrauded, the Receiver may obtain a transaction that spends funding input of the state coin, extract public key, amount and timelock and obtain commitment that should have been submitted into statechain ledger in the honest scenario. If the existence of the output commitment is not confirmed, it means that the operator colluded with dishonest Sender.\n\nWhen the Operator entity is represented by FROST federation, each participant may track funding UTXO and verify if new spends correspond to shielded UTXO. Besides detecting potential collusion, this defines a unilateral exit scenario when UTXO must be burned.\n\n# Fungibility of Notes in Shielded Pool\n\nBackup transactions may lead to privacy leaks which will make all efforts on improving it on the statecoin ledger side fruitless. Therefore an important feature of the Operator should be blind signing of backup transactions similarly to the Mercury layer. However it also means that schemes with splitting of shielded coins denominations with simultaneous backing similar to Spark\u2019s are likely impractical when joined with blind signing. In this situation we propose to preserve privacy benefits while addressing shielded coins\u2019 fungibility via market based mechanics when circulating shielded notes may be merged and exchanged privately inside a shielded pool with support of pre-programmed circuits implementing dedicated smart contract functionality.\n\nThe transaction structure of the original ZK Rollup architecture assumes 2-input, 2-output transactions and allows merging and splitting notes with change by design. For notes of \u201cstatecoin\u201d kind rules may define 1 padding \u201czero\u201d note in the input and the output correspondingly and such simple rules could be enforced via dedicated UTXO circuit which could be programmable.\n\nFor an illustration, let\u2019s consider an existing code snippet, a simple check for various types of notes: if note facilitates regular transfer, mint (gets into the pool) or burn (exits shielded pool).\n\n```\n\n    if (kind == 1) {\n\n        //SEND\n\n        assert(input_value == output_value, \"Input and output totals do not match\");\n\n    } else if (kind == 2) {\n\n        // MINT\n\n        // Assert mint utxo is balanced:\n\n        //   - \\`output_value\\` is checked above\n\n        //   - \\`input_value\\` is checked as it must have previously been an output value\n\n        //   - \\`msg_value\\` is checked above (but also using that to overflow would be detrimental to the\n\n        //      attacker)\n\n        assert(output_value == input_value + msg_value, \"Mint output must match value message\");\n\n        // Assert mint hash\n\n        assert(mint_hash == msg_hash, \"Mint hash must match message\");\n\n        // Assert note kind\n\n        assert(output_notes\\[0\\].kind == msg_note_kind, \"Mint note kind must match message\")\n\n    } else if (kind == 3) {\n\n        // BURN\n\n        // Prevent frontrunning the txn and changing the evm address\n\n        assert(pmessage4 == burn_addr, \"messages\\[4\\] must match private input\");\n\n        // Assert burn hash\n\n        assert(burn_hash == msg_hash, \"Burn hash must match message\");\n\n        // Assert burn utxo is balanced:\n\n        //   - \\`output_value\\` is checked above\n\n        //   - \\`input_value\\` is checked as it must have previously been an output value\n\n        //   - \\`msg_value\\` is checked above\n\n        assert(input_value == output_value + msg_value, \"Burn output must match value message\");\n\n        // Assert burn kind\n\n        assert(input_notes\\[0\\].note.kind == msg_note_kind, \"Burn note kind must match message\")\n\n    } else {\n\n        assert(false, \"Invalid kind\");\n\n    }\n```\n\nThis way we could define more types and more checks. More importantly, we envision building a market place for peg-outs where whole pre-signed UTXO could be traded against shielded fungible tokens. Marked based approach assumes the existence of notes that may be detached from the corresponding backup transactions and therefore requiring less interactive process for regular private transfers.\n\n# Nostr-based Relaying\n\n[The original Moore\u2019s and Gandhi work](https://polybase.github.io/zk-rollup/whitepaper.pdf) mentions \u201cEncrypted Registry\u201d which should help sending payments over the network when the Sender and Receiver are not online at the same time. During their absence, the transaction data could be stored in the Encrypted Registry, and this is an optional component of the network.\n\nAs mentioned earlier, using Nostr allows achieving a \u201cpush\u201d payments user experience while not changing the existing method for sending coins. On a higher level, sending a payment to a selected Nostr public key specifies a resilient and sufficiently decentralized way to broadcast an encrypted transaction and possibly gain additional privacy because financial transactions will be relayed along with tons of different encrypted data, including regular text messages to this user.\n\nBesides that, relaying a message broadly via several Nostr relays may allow duplication of the original message. Because Nostr is becoming a modular sophisticated protocol, the goal of *a sharded decentralised encrypted registry, where the encrypted data is split into chunks and blindly stored across multiple nodes* may be achieved independently from ZK Ledger development goals.\n\n# Conclusion\n\nPrevious works around Bitcoin Statechains suggest a degree of freedom when it comes to implementing a ledger for tracking statecoin transfers and keeping the Operator accountable. We have attempted to replace implied UTXO-based ledger with the simplest possible flavor of the ZK Rollup that was previously developed for Ethereum. The eventual design becomes a rather zero-knowledge based smart contract execution layer for Bitcoin, with opportunities for unilateral exit and censorship resistance stemming from leveraging ZK technology stack.\n\nThe proposed architecture occupies an intermediate position between Statechains and ShieldedCSV or ZKCoins. The latter omits on/off ramping into shielded pools while the former lacks privacy. However, options for using BitVM as for bridging coins back and forth are mentioned both in ShieldedCSV paper and [ZKCoins](https://gist.github.com/RobinLinus/d036511015caea5a28514259a1bab119) as well. It makes the ZK execution layer an interesting opportunity to experiment with programmable market-based mechanics for on/off ramping into shielded pools. The closest example here might be the \u201cpragmatic rollup\u201d design implemented in [Signet](https://signet.sh/) and completely unknown to the Bitcoin community. Its design suggest instant swaps and atomicity for cross-chain transactions which when applied to ZK Statechain would mean \u201cone in, one out\u201d rule facilitated with the help of \u201cprivacy arbitrators\u201d who are ready to post UTXO for exits or take ownership and possibly lift timelocks for entering participants.\n\n**Acknowledgments**\n\nI greatly appreciate the thorough review by [Janusz](https://x.com/januszg_) and Gus Gotoski. I also thank SuperTestnet and fiatjaf for their valuable feedback.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 710,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": "Github link was replaced with a permanent link",
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "Statechains are a concept that were introduced by Ruben Somsen more than 6 years ago. Since then Mercury Layer was launched by Commerce Block as arguably the most advanced Statechain - with blinded signing. In this article, we are going to introduce a spin-off protocol that we believe possesses adva&hellip;",
  "truncated": true,
  "post_url": "/t/zk-statechains-without-states/2166/1",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}