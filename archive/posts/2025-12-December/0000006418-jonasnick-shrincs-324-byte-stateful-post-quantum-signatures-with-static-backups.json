{
  "id": 6418,
  "name": "",
  "username": "jonasnick",
  "avatar_template": "/user_avatar/delvingbitcoin.org/jonasnick/{size}/1518_2.png",
  "created_at": "2025-12-11T08:40:59.575Z",
  "cooked": "<p><strong>Abstract</strong>: Stateful hash-based signature schemes can be very efficient when the number of signatures generated by a public key is small. One major problem with stateful schemes is that the state needs to be backed up and updated correctly after every signing operation. By using a straightforward combination of a stateless hash-based scheme (such as a variant of SPHINCS+) and an unbalanced XMSS tree of one-time signatures (stateful), we obtain a scheme that we call SHRINCS. It is extremely efficient when only a few signatures are required and can be backed up with a static seed. More precisely, the SHRINCS public key is a hash of the stateful and stateless public keys. We assume key generation happens on a signing device that is able to keep state securely. Therefore, the signing device can use efficient stateful signatures to sign for the public key. When the state is known to be corrupted or lost, for example when a static seed backup has been restored, the signing device only uses stateless signatures. As a result, SHRINCS provides the efficiency of stateful signatures during normal operation while maintaining the robustness of stateless signatures as a fallback.</p>\n<h2><a name=\"p-6418-shrincs-1\" class=\"anchor\" href=\"#p-6418-shrincs-1\"></a>SHRINCS</h2>\n<p>SHRINCS is briefly covered deep in the appendix of our report \u201cHash-based Signatures for Bitcoin\u201d (<a href=\"https://eprint.iacr.org/2025/2203\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">Hash-based Signature Schemes for Bitcoin</a>) by Mikhail Kudinov and myself. This post gives a fuller explanation and invites feedback.</p>\n<p>The construction of SHRINCS requires a stateless signature scheme and a stateful signature scheme that generates small signatures. SHRINCS consists of the following algorithms:</p>\n<ul>\n<li><span class=\"math\">\\textsf{KeyGen}() \\rightarrow (\\mathit{seed}, \\mathit{pk}, \\mathit{state})</span>: The keygen algorithm draws a master seed, derives secret keys <span class=\"math\">\\mathit{sk}_1</span> and <span class=\"math\">\\mathit{sk}_2</span> for the stateful and stateless signature schemes, respectively. Using these, it generates public keys <span class=\"math\">\\mathit{pk}_1</span> and <span class=\"math\">\\mathit{pk}_2</span> for the stateful and stateless schemes. Finally, <span class=\"math\">\\textsf{KeyGen}</span> returns the tuple <span class=\"math\">(\\mathit{seed}, \\mathit{pk}, \\mathit{state})</span> where <span class=\"math\">\\mathit{pk} = H(\\mathit{pk}_1, \\mathit{pk}_2)</span> and <span class=\"math\">\\mathit{state}</span> is the initial state of the stateful scheme.</li>\n<li><span class=\"math\">\\textsf{Restore}(\\mathit{seed}) \\rightarrow (\\mathit{seed}, \\mathit{pk}, \\mathit{state})</span>: The restore algorithm rederives the SHRINCS public key <span class=\"math\">\\mathit{pk}</span>, sets <span class=\"math\">\\mathit{state}</span> to <span class=\"math\">\\textsf{LOST}</span> and returns the tuple <span class=\"math\">(\\mathit{seed}, \\mathit{pk}, \\mathit{state})</span>.</li>\n<li><span class=\"math\">\\textsf{Sign}(\\mathit{seed}, \\mathit{state}, m) \\rightarrow (\\mathit{state}', \\mathit{sig})</span>: If <span class=\"math\">\\mathit{state} \\neq \\textsf{LOST}</span>, the signing algorithm rederives <span class=\"math\">\\mathit{sk}_1</span> and <span class=\"math\">\\mathit{pk}_2</span> and runs the <span class=\"math\">\\textsf{Sign}</span> algorithm of the stateful scheme with <span class=\"math\">\\mathit{sk}_1</span>, <span class=\"math\">\\mathit{state}</span> and message <span class=\"math\">m</span>. Then, it returns the updated state <span class=\"math\">\\mathit{state}'</span> along with the signature concatenated with <span class=\"math\">\\mathit{pk}_2</span>. Otherwise, the signing algorithm rederives <span class=\"math\">\\mathit{sk}_2</span> and <span class=\"math\">\\mathit{pk}_1</span>, runs the <span class=\"math\">\\textsf{Sign}</span> algorithm of the stateless scheme with <span class=\"math\">\\mathit{sk}_2</span> and <span class=\"math\">m</span>, and returns <span class=\"math\">\\mathit{state}' = \\mathit{state}</span> and the signature concatenated with <span class=\"math\">\\mathit{pk}_1</span>.</li>\n<li><span class=\"math\">\\textsf{Verify}(\\mathit{pk}, m, \\mathit{sig}) \\rightarrow \\{\\textsf{true}, \\textsf{false}\\}</span>: The verification algorithm parses <span class=\"math\">\\mathit{sig}</span> as <span class=\"math\">\\mathit{sig}' \\| \\mathit{pk}'</span>, verifies <span class=\"math\">\\mathit{sig}'</span> according to the stateless or stateful scheme (which recovers the signing public key in hash-based schemes), and checks that the two public keys hash to <span class=\"math\">\\mathit{pk}</span>.</li>\n</ul>\n<p>So, when a signing device capable of maintaining state securely is initialized, it signs with the stateful scheme, but whenever a device is restored with the seed, it only signs with the stateless scheme. Because the stateful path is much more efficient in SHRINCS, signing from a restored device is much more expensive than from the device that originally ran <span class=\"math\">\\textsf{KeyGen}</span>.</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/2X/5/507128585e5d15a133dc3854bf024d371866c36d.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/507128585e5d15a133dc3854bf024d371866c36d\" title=\"2025-12-11-083452_417x373_scrot\"><img src=\"https://delvingbitcoin.org/uploads/default/original/2X/5/507128585e5d15a133dc3854bf024d371866c36d.png\" alt=\"2025-12-11-083452_417x373_scrot\" data-base62-sha1=\"btCDtmQVXsy9YJNI8O1nQ5bgNDD\" width=\"208\" height=\"186\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">2025-12-11-083452_417x373_scrot</span><span class=\"informations\">417\u00d7373 10.2 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>For the stateless signature scheme in SHRINCS, candidates include SLH-DSA or one of the variants of SPHINCS+ that we cover in detail in the report. Depending on the parameters, signature size is between 3KB and 8KB and the public key is 16 bytes (at NIST security level 1). For the stateful scheme SHRINCS uses what we call \u201cunbalanced XMSS\u201d. A regular XMSS public key is essentially a Merkle tree of one-time signature (OTS) public keys. A one-time signature scheme can generate no more than a single signature for a public key, otherwise it becomes insecure. So, the signing state is just the number of signatures that have already been produced, initialized at <span class=\"math\">q=0</span>. To sign a message in XMSS, the signer increments <span class=\"math\">q</span>, produces a signature with the <span class=\"math\">q</span>-th one-time public key in the Merkle tree, and computes the authentication path (aka \u201cMerkle proof\u201d) to the root. The final signature is essentially the one-time signature concatenated with the authentication path.</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/2X/a/a0da28d3851fb6484bc73275261c951c335a7897.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/a0da28d3851fb6484bc73275261c951c335a7897\" title=\"2025-12-11-083501_409x616_scrot\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/2X/a/a0da28d3851fb6484bc73275261c951c335a7897_2_248x375.png\" alt=\"2025-12-11-083501_409x616_scrot\" data-base62-sha1=\"mWXNApYGLiQIJfItEfZsfTKXOon\" width=\"248\" height=\"375\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/2X/a/a0da28d3851fb6484bc73275261c951c335a7897_2_248x375.png, https://delvingbitcoin.org/uploads/default/optimized/2X/a/a0da28d3851fb6484bc73275261c951c335a7897_2_372x562.png 1.5x, https://delvingbitcoin.org/uploads/default/original/2X/a/a0da28d3851fb6484bc73275261c951c335a7897.png 2x\" data-dominant-color=\"F6F6F6\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">2025-12-11-083501_409x616_scrot</span><span class=\"informations\">409\u00d7616 13.8 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>Instead of using a balanced Merkle tree of OTSs, we use an unbalanced tree for the stateful part of SHRINCS. Thus, the first OTS is at depth 1, the second OTS at depth 2 and so on. This minimizes authentication path length for early signatures, which is optimal when few signatures are expected. The <span class=\"math\">q</span>-th signature for this \u201cunbalanced XMSS\u201d scheme is the <span class=\"math\">q</span>-th OTS signature and its authentication path. At NIST security level 1, the size of the authentication path is <span class=\"math\">q \\cdot 16</span> bytes and the size of the OTS signature is 292 bytes. More precisely, for the OTS we use WOTS+C (for details, check the paper).</p>\n<p>Putting it all together, when signing with intact state, the signature size of SHRINCS is <span class=\"math\">\\min(292 + q \\cdot 16, s_l) + 16</span> where <span class=\"math\">q</span> is the number of signatures that have been generated for the public key through the stateful path and <span class=\"math\">s_l</span> is the size of signatures generated with the stateless scheme. For <span class=\"math\">q = 1</span> this signature is more than 11x smaller than the smallest NIST-standardized scheme (ML-DSA). I\u2019d expect that average <span class=\"math\">q</span> for regular Bitcoin wallets is between 1 and 2. The main downside of SHRINCS remains that security requires secure state management. However, unlike pure stateful schemes where state mismanagement can be catastrophic, if in doubt, SHRINCS signers can always fall back to the stateless path.</p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 6,
  "updated_at": "2025-12-11T08:40:59.575Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 537,
  "reads": 47,
  "readers_count": 46,
  "score": 2744.4,
  "yours": false,
  "topic_id": 2158,
  "topic_slug": "shrincs-324-byte-stateful-post-quantum-signatures-with-static-backups",
  "topic_title": "SHRINCS: 324-byte stateful post-quantum signatures with static backups",
  "topic_html_title": "SHRINCS: 324-byte stateful post-quantum signatures with static backups",
  "category_id": 7,
  "display_username": "",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "**Abstract**: Stateful hash-based signature schemes can be very efficient when the number of signatures generated by a public key is small. One major problem with stateful schemes is that the state needs to be backed up and updated correctly after every signing operation. By using a straightforward combination of a stateless hash-based scheme (such as a variant of SPHINCS+) and an unbalanced XMSS tree of one-time signatures (stateful), we obtain a scheme that we call SHRINCS. It is extremely efficient when only a few signatures are required and can be backed up with a static seed. More precisely, the SHRINCS public key is a hash of the stateful and stateless public keys. We assume key generation happens on a signing device that is able to keep state securely. Therefore, the signing device can use efficient stateful signatures to sign for the public key. When the state is known to be corrupted or lost, for example when a static seed backup has been restored, the signing device only uses stateless signatures. As a result, SHRINCS provides the efficiency of stateful signatures during normal operation while maintaining the robustness of stateless signatures as a fallback.\n\n## SHRINCS\n\nSHRINCS is briefly covered deep in the appendix of our report \"Hash-based Signatures for Bitcoin\" (https://eprint.iacr.org/2025/2203) by Mikhail Kudinov and myself. This post gives a fuller explanation and invites feedback.\n\nThe construction of SHRINCS requires a stateless signature scheme and a stateful signature scheme that generates small signatures. SHRINCS consists of the following algorithms:\n\n- $\\textsf{KeyGen}() \\rightarrow (\\mathit{seed}, \\mathit{pk}, \\mathit{state})$: The keygen algorithm draws a master seed, derives secret keys $\\mathit{sk}_1$ and $\\mathit{sk}_2$ for the stateful and stateless signature schemes, respectively. Using these, it generates public keys $\\mathit{pk}_1$ and $\\mathit{pk}_2$ for the stateful and stateless schemes. Finally, $\\textsf{KeyGen}$ returns the tuple $(\\mathit{seed}, \\mathit{pk}, \\mathit{state})$ where $\\mathit{pk} = H(\\mathit{pk}_1, \\mathit{pk}_2)$ and $\\mathit{state}$ is the initial state of the stateful scheme.\n- $\\textsf{Restore}(\\mathit{seed}) \\rightarrow (\\mathit{seed}, \\mathit{pk}, \\mathit{state})$: The restore algorithm rederives the SHRINCS public key $\\mathit{pk}$, sets $\\mathit{state}$ to $\\textsf{LOST}$ and returns the tuple $(\\mathit{seed}, \\mathit{pk}, \\mathit{state})$.\n- $\\textsf{Sign}(\\mathit{seed}, \\mathit{state}, m) \\rightarrow (\\mathit{state}', \\mathit{sig})$: If $\\mathit{state} \\neq \\textsf{LOST}$, the signing algorithm rederives $\\mathit{sk}_1$ and $\\mathit{pk}_2$ and runs the $\\textsf{Sign}$ algorithm of the stateful scheme with $\\mathit{sk}_1$, $\\mathit{state}$ and message $m$. Then, it returns the updated state $\\mathit{state}'$ along with the signature concatenated with $\\mathit{pk}_2$. Otherwise, the signing algorithm rederives $\\mathit{sk}_2$ and $\\mathit{pk}_1$, runs the $\\textsf{Sign}$ algorithm of the stateless scheme with $\\mathit{sk}_2$ and $m$, and returns $\\mathit{state}' = \\mathit{state}$ and the signature concatenated with $\\mathit{pk}_1$.\n- $\\textsf{Verify}(\\mathit{pk}, m, \\mathit{sig}) \\rightarrow \\{\\textsf{true}, \\textsf{false}\\}$: The verification algorithm parses $\\mathit{sig}$ as $\\mathit{sig}' \\| \\mathit{pk}'$, verifies $\\mathit{sig}'$ according to the stateless or stateful scheme (which recovers the signing public key in hash-based schemes), and checks that the two public keys hash to $\\mathit{pk}$.\n\nSo, when a signing device capable of maintaining state securely is initialized, it signs with the stateful scheme, but whenever a device is restored with the seed, it only signs with the stateless scheme. Because the stateful path is much more efficient in SHRINCS, signing from a restored device is much more expensive than from the device that originally ran $\\textsf{KeyGen}$.\n\n![2025-12-11-083452_417x373_scrot|417x373, 50%](upload://btCDtmQVXsy9YJNI8O1nQ5bgNDD.png)\n\n\nFor the stateless signature scheme in SHRINCS, candidates include SLH-DSA or one of the variants of SPHINCS+ that we cover in detail in the report. Depending on the parameters, signature size is between 3KB and 8KB and the public key is 16 bytes (at NIST security level 1). For the stateful scheme SHRINCS uses what we call \"unbalanced XMSS\". A regular XMSS public key is essentially a Merkle tree of one-time signature (OTS) public keys. A one-time signature scheme can generate no more than a single signature for a public key, otherwise it becomes insecure. So, the signing state is just the number of signatures that have already been produced, initialized at $q=0$. To sign a message in XMSS, the signer increments $q$, produces a signature with the $q$-th one-time public key in the Merkle tree, and computes the authentication path (aka \"Merkle proof\") to the root. The final signature is essentially the one-time signature concatenated with the authentication path.\n\n![2025-12-11-083501_409x616_scrot|331x500, 75%](upload://mWXNApYGLiQIJfItEfZsfTKXOon.png)\n\nInstead of using a balanced Merkle tree of OTSs, we use an unbalanced tree for the stateful part of SHRINCS. Thus, the first OTS is at depth 1, the second OTS at depth 2 and so on. This minimizes authentication path length for early signatures, which is optimal when few signatures are expected. The $q$-th signature for this \"unbalanced XMSS\" scheme is the $q$-th OTS signature and its authentication path. At NIST security level 1, the size of the authentication path is $q \\cdot 16$ bytes and the size of the OTS signature is 292 bytes. More precisely, for the OTS we use WOTS+C (for details, check the paper).\n\nPutting it all together, when signing with intact state, the signature size of SHRINCS is $\\min(292 + q \\cdot 16, s_l) + 16$ where $q$ is the number of signatures that have been generated for the public key through the stateful path and $s_l$ is the size of signatures generated with the stateless scheme. For $q = 1$ this signature is more than 11x smaller than the smallest NIST-standardized scheme (ML-DSA). I'd expect that average $q$ for regular Bitcoin wallets is between 1 and 2. The main downside of SHRINCS remains that security requires secure state management. However, unlike pure stateful schemes where state mismanagement can be catastrophic, if in doubt, SHRINCS signers can always fall back to the stateless path.",
  "actions_summary": [
    {
      "id": 2,
      "count": 4
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 632,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "Abstract: Stateful hash-based signature schemes can be very efficient when the number of signatures generated by a public key is small. One major problem with stateful schemes is that the state needs to be backed up and updated correctly after every signing operation. By using a straightforward comb&hellip;",
  "truncated": true,
  "post_url": "/t/shrincs-324-byte-stateful-post-quantum-signatures-with-static-backups/2158/1",
  "reactions": [
    {
      "id": "heart",
      "type": "emoji",
      "count": 3
    },
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 4,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}