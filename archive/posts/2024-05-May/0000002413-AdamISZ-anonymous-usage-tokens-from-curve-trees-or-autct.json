{
  "id": 2413,
  "name": "Adam Gibson",
  "username": "AdamISZ",
  "avatar_template": "/user_avatar/delvingbitcoin.org/adamisz/{size}/418_2.png",
  "created_at": "2024-05-14T13:13:42.707Z",
  "cooked": "<p>Yes it\u2019s one of the <em>potential</em> use cases, i.e. a drop-in replacement for fidelity bonds in a coinjoin protocol without a single central coordinator. However, I do remember back when I proposed <a href=\"https://reyify.com/blog/riddle\" rel=\"noopener nofollow ugc\">RIDDLE</a> that it <em>might</em> not be as great for that particular use case. So, \u201cdelving\u201d into that <img src=\"https://delvingbitcoin.org/images/emoji/twitter/wink.png?v=12\" title=\":wink:\" class=\"emoji\" alt=\":wink:\" loading=\"lazy\" width=\"20\" height=\"20\"> :</p>\n<p>First, let\u2019s be clear on the threat being addressed: Sybil attacks that allow deanonymisation of the coinjoin by being ~ all the other participants in the round. A technique that imposes a cost on taking part can never make this impossible, so our chosen threat is an attacker bounded in their costs, and our defence is contingent/limited (you could try to quantify it for a particular case, but it\u2019s going to be very handwavy). The costs imposed by a timelocked utxo can be calculated explicitly in terms of <a href=\"https://gist.github.com/chris-belcher/87ebbcbb639686057a389acb9ab3e25b\" rel=\"noopener nofollow ugc\">time value of money</a>, but the costs imposed by simple utxo ownership at the time of a <em>recent</em> snapshot are clearly much less; principally just a utxo creation cost (arguably ameliorated, even). This leads one to think along the lines I did in the above blog, that:</p>\n<blockquote>\n<p>By using age and BTC value requirements, a cost - in the form of BTC network fees - is imposed that is almost zero for slow, occasional use but becomes (nonlinearly) much larger for anyone attempting to use the service very frequently (and due to block arrival rate, <em>no</em> amount of money may be enough to achieve very high Sybilling rates).</p>\n</blockquote>\n<p>Notice I say <em>age</em> and value requirements; \u201cbefore the snapshot\u201d can enforce that, or, I think a better idea, one can set the filter as <span class=\"math\">Q = a^x v^y</span> where <span class=\"math\">a</span> is age and <span class=\"math\">v</span> is sats value. This can really bump up the cost to <em>burst attack</em> a system.</p>\n<p>But with a decentralized coinjoin protocol rather than e.g. a website or a nostr relay or maybe a Lightning node, our main concern isn\u2019t <em>burst attack</em> as much as very slow Sybilling. I\u2019m going to guess that, if we want to replace fidelity bonds direct money locking with this style of utxo proof, we need to set <span class=\"math\">x</span> in the above formula much higher, so that a proof of the necessary value will require quite an old utxo (thus enforcing a similar timelocking but in the past, not pushed into the future). This doesn\u2019t sound very practical (locking way before using the service?), and will also reduce the anon set (though I think that won\u2019t be as big of a deal, most likely).</p>\n<p>Finally, as well as these concerns (which can be summed up as \u201cyou can use this for coinjoins but it might end up being a weak defence unless you make it too impractical\u201d), there\u2019s one last one that bothers me:</p>\n<p>Structurally this aut-ct could be simplified to:</p>\n<pre><code>Prover -&gt; Verifier: [ZKP] [keyimage]\n</code></pre>\n<p>And that keyimage can\u2019t change unless you change the utxo (pubkey) (taproot). This means that every user of the decentralized protocol sees the same one, and if it\u2019s a token that lets them use the system for some considerable time (as it must be, as fidelity bonds are today), it by its nature allows linkage of different coinjoins.</p>\n<p>The problem here is very deep: we want purely private participation in a protocol, <em>and</em> we want defence against Sybilling behaviour.</p>\n<p>Probably the answer lies in token multi-issuance, which can be done <a href=\"https://github.com/AdamISZ/aut-ct/issues/8\" rel=\"noopener nofollow ugc\">as described in this Issue</a> :</p>\n<p>Basically, when you do the DLEQ proof, you need an independent NUMS basepoint <span class=\"math\">J</span> (and the \u201ckey image\u201d is your private key * <span class=\"math\">J</span>), and you create that <span class=\"math\">J</span> using a hash-to-curve operation acting on a string. Currently that string is \u201cJ,application-domain-label\u201d (e.g. \u201cJ,hodlboardmainnet\u201d) but we could instead imagine it being \u201cJ,application-domain-label,1\u201d and then 2,3 etc. This way you get multiple independent tokens per utxo. This is basically exactly what we do in PoDLE (which is <em>not</em> the same as fidelity bonds). I think this is probably the right way to go for a fully symmetric decentralized coinjoin protocol.</p>",
  "post_number": 3,
  "post_type": 1,
  "updated_at": "2024-05-14T13:13:42.707Z",
  "reply_count": 1,
  "reply_to_post_number": 2,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 12,
  "readers_count": 11,
  "score": 7.4,
  "yours": false,
  "topic_id": 862,
  "topic_slug": "anonymous-usage-tokens-from-curve-trees-or-autct",
  "topic_title": "Anonymous usage tokens from curve trees or autct",
  "topic_html_title": "Anonymous usage tokens from curve trees or autct",
  "category_id": 7,
  "display_username": "Adam Gibson",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "reply_to_user": {
    "username": "1440000bytes",
    "name": "/dev/fd0",
    "avatar_template": "/user_avatar/delvingbitcoin.org/1440000bytes/{size}/301_2.png"
  },
  "bookmarked": false,
  "raw": "Yes it's one of the *potential* use cases, i.e. a drop-in replacement for fidelity bonds in a coinjoin protocol without a single central coordinator. However, I do remember back when I proposed [RIDDLE](https://reyify.com/blog/riddle) that it *might* not be as great for that particular use case. So, \"delving\" into that ;) :\n\nFirst, let's be clear on the threat being addressed: Sybil attacks that allow deanonymisation of the coinjoin by being ~ all the other participants in the round. A technique that imposes a cost on taking part can never make this impossible, so our chosen threat is an attacker bounded in their costs, and our defence is contingent/limited (you could try to quantify it for a particular case, but it's going to be very handwavy). The costs imposed by a timelocked utxo can be calculated explicitly in terms of [time value of money](https://gist.github.com/chris-belcher/87ebbcbb639686057a389acb9ab3e25b), but the costs imposed by simple utxo ownership at the time of a *recent* snapshot are clearly much less; principally just a utxo creation cost (arguably ameliorated, even). This leads one to think along the lines I did in the above blog, that: \n\n> By using age and BTC value requirements, a cost - in the form of BTC network fees - is imposed that is almost zero for slow, occasional use but becomes (nonlinearly) much larger for anyone attempting to use the service very frequently (and due to block arrival rate, *no* amount of money may be enough to achieve very high Sybilling rates).\n\nNotice I say *age* and value requirements; \"before the snapshot\" can enforce that, or, I think a better idea, one can set the filter as $Q = a^x v^y$ where $a$ is age and $v$ is sats value. This can really bump up the cost to *burst attack* a system.\n\nBut with a decentralized coinjoin protocol rather than e.g. a website or a nostr relay or maybe a Lightning node, our main concern isn't *burst attack* as much as very slow Sybilling. I'm going to guess that, if we want to replace fidelity bonds direct money locking with this style of utxo proof, we need to set $x$ in the above formula much higher, so that a proof of the necessary value will require quite an old utxo (thus enforcing a similar timelocking but in the past, not pushed into the future). This doesn't sound very practical (locking way before using the service?), and will also reduce the anon set (though I think that won't be as big of a deal, most likely).\n\nFinally, as well as these concerns (which can be summed up as \"you can use this for coinjoins but it might end up being a weak defence unless you make it too impractical\"), there's one last one that bothers me:\n\nStructurally this aut-ct could be simplified to:\n\n    Prover -> Verifier: [ZKP] [keyimage]\n\nAnd that keyimage can't change unless you change the utxo (pubkey) (taproot). This means that every user of the decentralized protocol sees the same one, and if it's a token that lets them use the system for some considerable time (as it must be, as fidelity bonds are today), it by its nature allows linkage of different coinjoins.\n\nThe problem here is very deep: we want purely private participation in a protocol, *and* we want defence against Sybilling behaviour.\n\nProbably the answer lies in token multi-issuance, which can be done [as described in this Issue](https://github.com/AdamISZ/aut-ct/issues/8) : \n\nBasically, when you do the DLEQ proof, you need an independent NUMS basepoint $J$ (and the \"key image\" is your private key * $J$), and you create that $J$ using a hash-to-curve operation acting on a string. Currently that string is \"J,application-domain-label\" (e.g. \"J,hodlboardmainnet\") but we could instead imagine it being \"J,application-domain-label,1\" and then 2,3 etc. This way you get multiple independent tokens per utxo. This is basically exactly what we do in PoDLE (which is *not* the same as fidelity bonds). I think this is probably the right way to go for a fully symmetric decentralized coinjoin protocol.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 343,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}