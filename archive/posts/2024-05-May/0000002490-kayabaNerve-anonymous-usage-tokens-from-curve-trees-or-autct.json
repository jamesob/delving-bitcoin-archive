{
  "id": 2490,
  "name": "Luke Parker",
  "username": "kayabaNerve",
  "avatar_template": "/user_avatar/delvingbitcoin.org/kayabanerve/{size}/577_2.png",
  "created_at": "2024-05-22T03:26:28.797Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"AdamISZ\" data-post=\"1\" data-topic=\"862\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/adamisz/48/418_2.png\" class=\"avatar\"> AdamISZ:</div>\n<blockquote>\n<p>all the ring signature based stuff fails on sublinear verification</p>\n</blockquote>\n</aside>\n<p>Correct. You need a succinct proof (which would then have linear proving) or to move the problem statement to one with sublinear complexity (a merkle tree).</p>\n<aside class=\"quote no-group\" data-username=\"AdamISZ\" data-post=\"1\" data-topic=\"862\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/adamisz/48/418_2.png\" class=\"avatar\"> AdamISZ:</div>\n<blockquote>\n<p>But the <a href=\"https://eprint.iacr.org/2022/756.pdf\" rel=\"noopener nofollow ugc\">Curve Trees </a> approach solves this</p>\n</blockquote>\n</aside>\n<p>Curve Trees is one approach, and great for a trustless setup discussion.</p>\n<aside class=\"quote no-group\" data-username=\"AdamISZ\" data-post=\"1\" data-topic=\"862\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/adamisz/48/418_2.png\" class=\"avatar\"> AdamISZ:</div>\n<blockquote>\n<p>keyset sizes from 50K up to 2.5M and seen verification time mostly sitting between 40 and 70ms</p>\n</blockquote>\n</aside>\n<p>You can do quite a bit better. My work has been applying Curve Trees to Monero and we\u2019re at 35ms for verifying one proof (using two curves without tailored field implementations yet crypto-bigint\u2019s Residue type) of 219b. With batch verification (n=10), it quickly gets down to 11ms.</p>\n<aside class=\"quote no-group quote-modified\" data-username=\"AdamISZ\" data-post=\"1\" data-topic=\"862\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/adamisz/48/418_2.png\" class=\"avatar\"> AdamISZ:</div>\n<blockquote>\n<p>The reason for this processing is to allow the xxx-coordinate to curve point transformation to be unambiguous (the well known \u201cyyy-coordinate tiebreaker\u201d issue), but using an algorithm that is actually efficient inside the arithmetic circuit . Since this only has to be done once for each new key, this time cost can be ameliorated in every case but a pure trustless bootstrap to do a proof from scratch. Discussed <a href=\"https://github.com/AdamISZ/aut-ct/issues/10\" rel=\"noopener nofollow ugc\">here</a></p>\n</blockquote>\n</aside>\n<p>This isn\u2019t necessary if you define the linking tags as x coordinates. Then proving for a negative leaf may produce a negative linking tag, except the sign data is lost when you drop the tag\u2019s y coordinate.</p>\n<p>You could still trivially produce a collision on the layers by hashing negative words. That\u2019s solved by using an initialization generator as a term with a constant coefficient of 1. Since that term can\u2019t be negated, you\u2019d need to solve the DLP for the initialization generator and other generators.</p>\n<aside class=\"quote no-group\" data-username=\"AdamISZ\" data-post=\"1\" data-topic=\"862\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/adamisz/48/418_2.png\" class=\"avatar\"> AdamISZ:</div>\n<blockquote>\n<p>Curve Trees being based on bulletproof ZKPs</p>\n</blockquote>\n</aside>\n<p>Technically Generalized Bulletproofs (not Bulletproofs as published several years ago).</p>\n<aside class=\"quote no-group\" data-username=\"AdamISZ\" data-post=\"1\" data-topic=\"862\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/adamisz/48/418_2.png\" class=\"avatar\"> AdamISZ:</div>\n<blockquote>\n<p>There is another idea, see Microsoft\u2019s SPARTAN as applied <a href=\"https://github.com/personaelabs/spartan-ecdsa\" rel=\"noopener nofollow ugc\">here</a> which also does not require pairings nor any assumption beyond ECDL.</p>\n</blockquote>\n</aside>\n<p>The benefit of using Generalized Bulletproofs is the \u2018native\u2019 operations re: Pedersen Vector Commitments. Using Spartan would require manually building them on the towering curve (historically hundreds of multiplication constraints per word).</p>\n<aside class=\"quote no-group\" data-username=\"1440000bytes\" data-post=\"4\" data-topic=\"862\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/1440000bytes/48/301_2.png\" class=\"avatar\"> 1440000bytes:</div>\n<blockquote>\n<p>Is it possible that users can prove ownership</p>\n</blockquote>\n</aside>\n<p>They\u2019d just need to open the re-randomized output key. The existing DLEq proof does so (while additionally providing linkability).</p>",
  "post_number": 6,
  "post_type": 1,
  "updated_at": "2024-05-22T09:44:21.287Z",
  "reply_count": 2,
  "reply_to_post_number": null,
  "quote_count": 2,
  "incoming_link_count": 0,
  "reads": 13,
  "readers_count": 12,
  "score": 27.6,
  "yours": false,
  "topic_id": 862,
  "topic_slug": "anonymous-usage-tokens-from-curve-trees-or-autct",
  "topic_title": "Anonymous usage tokens from curve trees or autct",
  "topic_html_title": "Anonymous usage tokens from curve trees or autct",
  "category_id": 7,
  "display_username": "Luke Parker",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 3,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"AdamISZ, post:1, topic:862\"]\nall the ring signature based stuff fails on sublinear verification\n[/quote]\n\nCorrect. You need a succinct proof (which would then have linear proving) or to move the problem statement to one with sublinear complexity (a merkle tree).\n\n[quote=\"AdamISZ, post:1, topic:862\"]\nBut the [Curve Trees ](https://eprint.iacr.org/2022/756.pdf) approach solves this\n[/quote]\n\nCurve Trees is one approach, and great for a trustless setup discussion.\n\n[quote=\"AdamISZ, post:1, topic:862\"]\nkeyset sizes from 50K up to 2.5M and seen verification time mostly sitting between 40 and 70ms\n[/quote]\n\nYou can do quite a bit better. My work has been applying Curve Trees to Monero and we're at 35ms for verifying one proof (using two curves without tailored field implementations yet crypto-bigint's Residue type) of 219b. With batch verification (n=10), it quickly gets down to 11ms.\n\n[quote=\"AdamISZ, post:1, topic:862\"]\nThe reason for this processing is to allow the xxx-coordinate to curve point transformation to be unambiguous (the well known \u201cyyy-coordinate tiebreaker\u201d issue), but using an algorithm that is actually efficient inside the arithmetic circuit . Since this only has to be done once for each new key, this time cost can be ameliorated in every case but a pure trustless bootstrap to do a proof from scratch. Discussed [here](https://github.com/AdamISZ/aut-ct/issues/10)\n[/quote]\n\nThis isn't necessary if you define the linking tags as x coordinates. Then proving for a negative leaf may produce a negative linking tag, except the sign data is lost when you drop the tag's y coordinate.\n\nYou could still trivially produce a collision on the layers by hashing negative words. That's solved by using an initialization generator as a term with a constant coefficient of 1. Since that term can't be negated, you'd need to solve the DLP for the initialization generator and other generators.\n\n[quote=\"AdamISZ, post:1, topic:862\"]\nCurve Trees being based on bulletproof ZKPs\n[/quote]\n\nTechnically Generalized Bulletproofs (not Bulletproofs as published several years ago).\n\n[quote=\"AdamISZ, post:1, topic:862\"]\nThere is another idea, see Microsoft\u2019s SPARTAN as applied [here](https://github.com/personaelabs/spartan-ecdsa) which also does not require pairings nor any assumption beyond ECDL.\n[/quote]\n\nThe benefit of using Generalized Bulletproofs is the 'native' operations re: Pedersen Vector Commitments. Using Spartan would require manually building them on the towering curve (historically hundreds of multiplication constraints per word).\n\n[quote=\"1440000bytes, post:4, topic:862\"]\nIs it possible that users can prove ownership\n[/quote]\n\nThey'd just need to open the re-randomized output key. The existing DLEq proof does so (while additionally providing linkability).",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 440,
  "hidden": false,
  "trust_level": 0,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}