{
  "id": 2486,
  "name": "Anthony Towns",
  "username": "ajtowns",
  "avatar_template": "/user_avatar/delvingbitcoin.org/ajtowns/{size}/417_2.png",
  "created_at": "2024-05-21T17:29:13.782Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"PierreRochard\" data-post=\"1\" data-topic=\"890\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/pierrerochard/48/564_2.png\" class=\"avatar\"> PierreRochard:</div>\n<blockquote>\n<p>Limited number of op_code \u201cslots\u201d available to take.</p>\n</blockquote>\n</aside>\n<p>That one mostly probably doesn\u2019t matter: for tapscript we\u2019ve got 87 free opcodes via OP_SUCCESS, and any of those could be used to create multibyte opcodes if desired. The upgradable OP_NOPs form a much more limited set, restricting how we could upgrade p2sh or segwit v0 scripts, but that\u2019s probably not that interesting. Providing new bare outputs by using a new opcode directly in a scriptPubKey is similarly restricted, but probably even less interesting, since that would require creating a new address format and a bunch of upgrade hassles.</p>\n<aside class=\"quote no-group\" data-username=\"PierreRochard\" data-post=\"1\" data-topic=\"890\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/pierrerochard/48/564_2.png\" class=\"avatar\"> PierreRochard:</div>\n<blockquote>\n<p>Ecosystem complexity, multiple similar options to accomplish the same outcome.</p>\n</blockquote>\n</aside>\n<p>Script already has a variety of ways of doing the same thing: <code>EQUALVERIFY</code> is equivalent to <code>EQUAL VERIFY</code> (and similarly for all the other <code>FOOVERIFY</code> ops), <code>HASH256</code> is equivalent to <code>SHA256 SHA256</code>, and <code>HASH160</code> is the same as <code>SHA256 RIPEMD160</code>, <code>GREATERTHAN</code> is the same as <code>SWAP LESSTHAN</code>, <code>LESSTHANOREQUAL</code> is the same as <code>GREATERTHAN NOT</code>, before they were disabled <code>SUBSTR</code>, <code>LEFT</code> and <code>RIGHT</code> had moderately overlapping featuresets too. tapscript continues this trend, with <code>CHECKSIGADD</code> being the equivalent of <code>ROT SWAP CHECKSIG ADD</code>.</p>\n<p>The thing we probably don\u2019t want is subtly different ways of doing the same thing, where choosing the wrong one is likely to result in bugs that lose people money. eg, satoshi removed <code>OP_NOTEQUAL</code>, <a href=\"https://github.com/bitcoin/bitcoin/commit/e071a3f6c06f41068ad17134189a4ac3073ef76b#diff-27496895958ca30c47bbb873299a2ad7a7ea1003a9faa96b317250e3b7aa1fefR494-R498\">writing</a>:</p>\n<pre data-code-wrap=\"c++\"><code class=\"lang-c++\">    //case OP_NOTEQUAL: // use OP_NUMNOTEQUAL\n    ...\n    // OP_NOTEQUAL is disabled because it would be too easy to say\n    // something like n != 1 and have some wiseguy pass in 1 with extra\n    // zero bytes after it (numerically, 0x01 == 0x0001 == 0x000001)\n    //if (opcode == OP_NOTEQUAL)\n    //    fEqual = !fEqual;\n</code></pre>\n<p>Personally, I think a bigger issue is figuring out what we can do with the various features in practice, rather than just on a whiteboard. There are lots of essentially equivalent ways of doing things (eg compare CTV with similar approaches based on TXHASH, APO, or CAT/CHECKSIG, or with <a href=\"https://github.com/bitcoin/bips/pull/1587\">CTV-v2</a>) where the difference is pretty trivial when you\u2019re just talking about what you could do with it, but when you\u2019re actually trying to put things into production, you might end up with a strong preference to one or the other.</p>\n<p>If we deployed all those different features in mainnet, and then discovered everyone ends up just using (eg) TXHASH, that\u2019s a lot of wasted code in consensus, review effort, and makes for a confusing setup when people want to just develop on bitcoin (\u201coh, you should just ignore these parts\u201d). Likewise if we were to implement everything then decide we actually want some other way to do essentially the same thing that\u2019s just slightly different.</p>\n<p>I think the best way of overcoming those problems is actually going all the way to having fairly realistic wallet/lightning/etc software demoing the new features we want, before trying to add them to mainnet, so that we can see how they work in practice, and perhaps even have an easy way to compare how well/badly real software would work if we had one primitive versus a different one. Would be a way of getting concrete/objective answers to questions like: do the scripts end up being expensive on-chain, do they create new pinning vectors, is it hard to use them without introducing bugs/exploits, is it hard to debug contracts that use these features, etc.</p>\n<p>Another big question is \u201cis this feature enough on its own\u201d \u2013 eg CTV can do limited \u201cvault\u201d constructs on its own, but if you add some other features, you can make much more useful constructs; likewise eltoo was originally written up assuming that just a <code>NOINPUT</code> signature type would be enough, but when trying to actually make that work in ln-symmetry, it becomes pretty apparent that some way of attaching fees is also needed (<code>ANYONECANPAY</code> introduces pinning attacks, so ephemeral anchors was invented, but that then requires more work on package relay, which then really needs cluster mempool to work well), and some way of attaching data at signing time is also desirable (in this case it removes a round trip when forwarding HTLCs, and can be achieved via using the taproot annex or perhaps <code>CHECKSIGFROMSTACK</code>; or could perhaps be avoided by clever use of adaptor signatures).</p>\n<p>(Doing all the things via inquisition and signet, building demos on top of it, then choosing the features that turn out best and pulling them into mainnet is my best answer for how to turn the above into a practical todo list. YMMV obviously!)</p>",
  "post_number": 3,
  "post_type": 1,
  "updated_at": "2024-05-21T17:29:13.782Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 1,
  "incoming_link_count": 0,
  "reads": 9,
  "readers_count": 8,
  "score": 46.8,
  "yours": false,
  "topic_id": 890,
  "topic_slug": "mutual-exclusiveness-of-op-codes",
  "topic_title": "Mutual exclusiveness of op_codes",
  "topic_html_title": "Mutual exclusiveness of op_codes",
  "category_id": 5,
  "display_username": "Anthony Towns",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"PierreRochard, post:1, topic:890\"]\nLimited number of op_code \u201cslots\u201d available to take.\n[/quote]\n\nThat one mostly probably doesn't matter: for tapscript we've got 87 free opcodes via OP_SUCCESS, and any of those could be used to create multibyte opcodes if desired. The upgradable OP_NOPs form a much more limited set, restricting how we could upgrade p2sh or segwit v0 scripts, but that's probably not that interesting. Providing new bare outputs by using a new opcode directly in a scriptPubKey is similarly restricted, but probably even less interesting, since that would require creating a new address format and a bunch of upgrade hassles.\n\n[quote=\"PierreRochard, post:1, topic:890\"]\nEcosystem complexity, multiple similar options to accomplish the same outcome.\n[/quote]\n\nScript already has a variety of ways of doing the same thing: `EQUALVERIFY` is equivalent to `EQUAL VERIFY` (and similarly for all the other `FOOVERIFY` ops), `HASH256` is equivalent to `SHA256 SHA256`, and `HASH160` is the same as `SHA256 RIPEMD160`, `GREATERTHAN` is the same as `SWAP LESSTHAN`, `LESSTHANOREQUAL` is the same as `GREATERTHAN NOT`, before they were disabled `SUBSTR`, `LEFT` and `RIGHT` had moderately overlapping featuresets too. tapscript continues this trend, with `CHECKSIGADD` being the equivalent of `ROT SWAP CHECKSIG ADD`.\n\nThe thing we probably don't want is subtly different ways of doing the same thing, where choosing the wrong one is likely to result in bugs that lose people money. eg, satoshi removed `OP_NOTEQUAL`, [writing](https://github.com/bitcoin/bitcoin/commit/e071a3f6c06f41068ad17134189a4ac3073ef76b#diff-27496895958ca30c47bbb873299a2ad7a7ea1003a9faa96b317250e3b7aa1fefR494-R498):\n\n```c++\n    //case OP_NOTEQUAL: // use OP_NUMNOTEQUAL\n    ...\n    // OP_NOTEQUAL is disabled because it would be too easy to say\n    // something like n != 1 and have some wiseguy pass in 1 with extra\n    // zero bytes after it (numerically, 0x01 == 0x0001 == 0x000001)\n    //if (opcode == OP_NOTEQUAL)\n    //    fEqual = !fEqual;\n```\n\nPersonally, I think a bigger issue is figuring out what we can do with the various features in practice, rather than just on a whiteboard. There are lots of essentially equivalent ways of doing things (eg compare CTV with similar approaches based on TXHASH, APO, or CAT/CHECKSIG, or with [CTV-v2](https://github.com/bitcoin/bips/pull/1587)) where the difference is pretty trivial when you're just talking about what you could do with it, but when you're actually trying to put things into production, you might end up with a strong preference to one or the other.\n\nIf we deployed all those different features in mainnet, and then discovered everyone ends up just using (eg) TXHASH, that's a lot of wasted code in consensus, review effort, and makes for a confusing setup when people want to just develop on bitcoin (\"oh, you should just ignore these parts\"). Likewise if we were to implement everything then decide we actually want some other way to do essentially the same thing that's just slightly different.\n\nI think the best way of overcoming those problems is actually going all the way to having fairly realistic wallet/lightning/etc software demoing the new features we want, before trying to add them to mainnet, so that we can see how they work in practice, and perhaps even have an easy way to compare how well/badly real software would work if we had one primitive versus a different one. Would be a way of getting concrete/objective answers to questions like: do the scripts end up being expensive on-chain, do they create new pinning vectors, is it hard to use them without introducing bugs/exploits, is it hard to debug contracts that use these features, etc.\n\nAnother big question is \"is this feature enough on its own\" -- eg CTV can do limited \"vault\" constructs on its own, but if you add some other features, you can make much more useful constructs; likewise eltoo was originally written up assuming that just a `NOINPUT` signature type would be enough, but when trying to actually make that work in ln-symmetry, it becomes pretty apparent that some way of attaching fees is also needed (`ANYONECANPAY` introduces pinning attacks, so ephemeral anchors was invented, but that then requires more work on package relay, which then really needs cluster mempool to work well), and some way of attaching data at signing time is also desirable (in this case it removes a round trip when forwarding HTLCs, and can be achieved via using the taproot annex or perhaps `CHECKSIGFROMSTACK`; or could perhaps be avoided by clever use of adaptor signatures).\n\n(Doing all the things via inquisition and signet, building demos on top of it, then choosing the features that turn out best and pulling them into mainnet is my best answer for how to turn the above into a practical todo list. YMMV obviously!)",
  "actions_summary": [
    {
      "id": 2,
      "count": 3
    }
  ],
  "moderator": true,
  "admin": true,
  "staff": true,
  "user_id": 3,
  "hidden": false,
  "trust_level": 4,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 3
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 3,
  "current_user_used_main_reaction": false
}