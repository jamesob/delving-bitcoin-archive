{
  "id": 2485,
  "name": "Garlo Nicon",
  "username": "garlonicon",
  "avatar_template": "/letter_avatar_proxy/v4/letter/g/278dde/{size}.png",
  "created_at": "2024-05-21T12:06:58.874Z",
  "cooked": "<p>I think some opcodes could be simplified, if you do the same thing, which was already done in assembly: split each opcode into smaller parts, and calculate the real cost on a different layer. For example: <code>OP_CHECKSIG</code> is quite complex. It has at least some sub-opcodes inside, like calculating z-value (message hash), calculating R-value from r-value (lifting x-value public key into the real (x,y) point on secp256k1), and of course doing addition and multiplication, between given public keys and raw values, to get a matching equation.</p>\n<p>Which means, that if you want to implement for example <code>OP_CHECKSIGFROMSTACK</code>, then by having <code>OP_CHECKSIG</code> alone, a lot of that is already done, and the only replacement is the message to be hashed. The same is true for many other contracts, where you want to validate a given signature, by using a different message. For example: each change into sighashes (like <code>SIGHASH_ANYPREVOUT</code>) fall into a similar category.</p>\n<p>So, is it more code? Kinda, but not quite, because a lot of code can be reused (or even simplified, because if you have <code>OP_CHECKSIGFROMSTACK</code>, then you can implicitly convert each <code>OP_CHECKSIG</code> into <code>OP_CHECKSIGFROMSTACK</code>, and have a single place to handle all of that). So, instead of <code>&lt;signature&gt; &lt;pubkey&gt; OP_CHECKSIG</code>, you can convert it statically into <code>&lt;message&gt; &lt;signature&gt; &lt;pubkey&gt; OP_CHECKSIGFROMSTACK</code>, and then, in practice, <code>OP_CHECKSIG</code> could become just an alias into <code>OP_TUCK_MESSAGE OP_CHECKSIGFROMSTACK</code>, where <code>OP_TUCK_MESSAGE</code> don\u2019t have to be any real opcode, but just some internal function call in the source code (note that when it comes to existing code, there are lot of internal things, which already exist, and have no representation in the Script, so the whole diff is not that much bigger, as it seems to be; for example we already have functions for checking any signature, but they are just used in places like \u201cBitcoin Message\u201d handling).</p>\n<p>When it comes to available slots for new opcodes, then we still have a lot of them (but maybe we need some kind of page to trace them, like BIP numbers). Even Taproot can show us, that the whole Script can be completely changed into TapScript, without affecting the original one. Which means, that if there would be any need, to have some \u201cassembly for Script\u201d in the future, then a single opcode is all you need to introduce it. I can even think of cases, where you can use your own Script, for example with Homomorphic Encryption, and get it activated in Lightning Network, without touching any mainnet rules. Then, you would encrypt things, execute them in LN-only, and then decrypt and post on-chain. But in-between, you can have some execution steps, which are not allowed in the current Script, and could be handled only by some second layer.</p>\n<p>Also, that last case partially answers your question about activation politics: it could be done locally first, to test things properly, and deploy later, if there would be enough users, willing to move those changes on-chain (but if that kind of activation would be successful, then some improvements could just stay in L2, because in case of Homomorphic Encryption, they could be trustlessly decrypted, and shared in on-chain compatible form, if needed).</p>",
  "post_number": 2,
  "post_type": 1,
  "updated_at": "2024-05-21T12:06:58.874Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 8,
  "readers_count": 7,
  "score": 16.6,
  "yours": false,
  "topic_id": 890,
  "topic_slug": "mutual-exclusiveness-of-op-codes",
  "topic_title": "Mutual exclusiveness of op_codes",
  "topic_html_title": "Mutual exclusiveness of op_codes",
  "category_id": 5,
  "display_username": "Garlo Nicon",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "I think some opcodes could be simplified, if you do the same thing, which was already done in assembly: split each opcode into smaller parts, and calculate the real cost on a different layer. For example: `OP_CHECKSIG` is quite complex. It has at least some sub-opcodes inside, like calculating z-value (message hash), calculating R-value from r-value (lifting x-value public key into the real (x,y) point on secp256k1), and of course doing addition and multiplication, between given public keys and raw values, to get a matching equation.\n\nWhich means, that if you want to implement for example `OP_CHECKSIGFROMSTACK`, then by having `OP_CHECKSIG` alone, a lot of that is already done, and the only replacement is the message to be hashed. The same is true for many other contracts, where you want to validate a given signature, by using a different message. For example: each change into sighashes (like `SIGHASH_ANYPREVOUT`) fall into a similar category.\n\nSo, is it more code? Kinda, but not quite, because a lot of code can be reused (or even simplified, because if you have `OP_CHECKSIGFROMSTACK`, then you can implicitly convert each `OP_CHECKSIG` into `OP_CHECKSIGFROMSTACK`, and have a single place to handle all of that). So, instead of `<signature> <pubkey> OP_CHECKSIG`, you can convert it statically into `<message> <signature> <pubkey> OP_CHECKSIGFROMSTACK`, and then, in practice, `OP_CHECKSIG` could become just an alias into `OP_TUCK_MESSAGE OP_CHECKSIGFROMSTACK`, where `OP_TUCK_MESSAGE` don't have to be any real opcode, but just some internal function call in the source code (note that when it comes to existing code, there are lot of internal things, which already exist, and have no representation in the Script, so the whole diff is not that much bigger, as it seems to be; for example we already have functions for checking any signature, but they are just used in places like \"Bitcoin Message\" handling).\n\nWhen it comes to available slots for new opcodes, then we still have a lot of them (but maybe we need some kind of page to trace them, like BIP numbers). Even Taproot can show us, that the whole Script can be completely changed into TapScript, without affecting the original one. Which means, that if there would be any need, to have some \"assembly for Script\" in the future, then a single opcode is all you need to introduce it. I can even think of cases, where you can use your own Script, for example with Homomorphic Encryption, and get it activated in Lightning Network, without touching any mainnet rules. Then, you would encrypt things, execute them in LN-only, and then decrypt and post on-chain. But in-between, you can have some execution steps, which are not allowed in the current Script, and could be handled only by some second layer.\n\nAlso, that last case partially answers your question about activation politics: it could be done locally first, to test things properly, and deploy later, if there would be enough users, willing to move those changes on-chain (but if that kind of activation would be successful, then some improvements could just stay in L2, because in case of Homomorphic Encryption, they could be trustlessly decrypted, and shared in on-chain compatible form, if needed).",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 372,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}