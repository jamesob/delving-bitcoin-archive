{
  "id": 2401,
  "name": "Adam Gibson",
  "username": "AdamISZ",
  "avatar_template": "/user_avatar/delvingbitcoin.org/adamisz/{size}/418_2.png",
  "created_at": "2024-05-10T14:45:09.034Z",
  "cooked": "<p>Ever since whenever (I think when we introduced fidelity bonds in Joinmarket), I\u2019ve been researching the best way to have private proof of pubkey ownership.</p>\n<p>I did also think the same issue arises a lot in Lightning, potentially in solving jamming but also (as others pointed out to me), even more obviously in gossip of channels.</p>\n<p>I think this may be a decent partial solution, to the problem \u201chow can we gossip channels without revealing the utxos and without allowing people to sybil with fakes (too much)?\u201d.</p>\n<p>What stopped earlier ideas I had from being really practical (see my earlier post on RIDDLE **) was that all the ring signature based stuff fails on sublinear verification. Crudely, it always requires the verifier to \u201cread through\u201d an object whose size is the size of the ring. So while an anon set of 1000 was fine and very compact in proof size, an anon set of 1M was wildly impractical.</p>\n<p>But the <a href=\"https://eprint.iacr.org/2022/756.pdf\" rel=\"noopener nofollow ugc\">Curve Trees</a> approach solves this: think of it as a merkle tree except algebraic (using points not hashes), which allows you to create ZKPs (in this case, arithmetic circuits using bulletproofs) about the object (key) that you\u2019re proving is in the tree. So here you get the statement \u201cthis pubkey is one of the 100K pubkeys in this set of taproot outputs, but you don\u2019t know which one, and this \u201ckey image\u201d (think token) I\u2019m providing, is tied to that un-revealed pubkey so I can\u2019t just use it again\u201d. I\u2019ll mention how that \u201ctie\u201d-ing works in a moment.</p>\n<p>So the obvious application in Bitcoin is - make a proof of ownership of one taproot utxo pubkey out of N where N can be any large number up to the size of the utxo set. Given how many taproot utxos are dusty and let\u2019s say \u201cuneconomic\u201d you can just set a minimum value filter to get a sensible size. A couple months ago I got these values:</p>\n<pre><code class=\"lang-auto\">Amount in sats    Number of utxos(taproot only)\n&gt; 5 million         51674\n&gt; 2.5 million       81512\n&gt; 1 million         154130\n&gt; 500k              238060\n&gt; 250k              352235\n&gt; 100k              800843\n&gt; 50k               1043038\n&gt; 25k               1333547\n&gt; 10k               2853756\n&gt; 1000 sat          6084116\n&gt; 100 (i.e. ~all)   39034007\n</code></pre>\n<p>So as an example, a 500k sat threshold ends up with 240000 keys which is already practical for curve trees.</p>\n<p>Re: \u201ctie\u201d-ing: Now the curve trees proof is a proof of <em>set membership</em> and doesn\u2019t enforce scarcity, since by its nature it can be repeated without revealing re-use. For this reason I added a DLEQ part, similar to Joinmarket\u2019s PODLE (think of this as like \u201clinkable\u201d in a ring signature), that creates an extra curve point that\u2019s provably the \u201ckey image\u201d of the key whose membership you proved, without revealing that key. See <a href=\"https://github.com/AdamISZ/aut-ct/blob/7e673b572a300fd43f0ba4b1839fe682be676d93/aut-ct.pdf\" rel=\"noopener nofollow ugc\">here</a> for the writeup of that algorithm; it\u2019s using completely standard sigma protocol techniques.</p>\n<p>In practice I have done a lot of tests with keyset sizes from 50K up to 2.5M and seen verification time mostly sitting between 40 and 70ms although these aren\u2019t properly controlled scientific results; the point is that it remains fast! See Table 1 in the Curve Trees paper for their benchmarking results for the secp/secq cycle which are significantly better, even. The main point is that the logarithmic scaling coming from the tree, combined with how bulletproofs can be batch verified (a separate proof for each curve), gives extremely good scaling (it\u2019s a little difficult to write down a formula because of the arithmetic circuit; basically 1M keys are easily practical for verifying).</p>\n<p>Working code at <a href=\"https://github.com/AdamISZ/aut-ct\" rel=\"noopener nofollow ugc\">my aut-ct github repo</a>. This is using as a basis the <a href=\"https://github.com/simonkamp/curve-trees/\" rel=\"noopener nofollow ugc\">benchmarking code</a> of the authors of the curve trees paper.</p>\n<p>It should be easy to run tests, I hope, following the README. There are a couple of toy small and medium size keysets you can use to play with if you want. Forgive my Rust <img src=\"https://delvingbitcoin.org/images/emoji/twitter/slight_smile.png?v=12\" title=\":slight_smile:\" class=\"emoji\" alt=\":slight_smile:\" loading=\"lazy\" width=\"20\" height=\"20\"></p>\n<p>I even went as far as to make a proof of concept website where you sign up for a forum using a proof of taproot key ownership, see <a href=\"https://hodlboard.org\" rel=\"noopener nofollow ugc\">hodlboard</a>. Note that the process of creating a proof here turned out to be way more convoluted as you have to be able to access a private key for a taproot utxo you own, which to say the least, is not supported by any wallet (except Core, with multiple steps on the command line!). However this practical annoyance will be irrelevant for any usage of this protocol in e.g. Lightning. It would only be relevant if we want interoperable creation of such proofs at user level.</p>\n<p>As I understand it, the way in which this is \u201cnot a full solution\u201d is pretty clearly that a Lightning node wants to (or perhaps, \u201chas to\u201d is better!?) advertise capacity, and this doesn\u2019t do this, except in the most primitive way: you could advertise \u201camount within a range\u201d by choosing utxos from a range of values.</p>\n<p>Filling in some more technical details:</p>\n<ul>\n<li>The proof size: it varies but not by much, in the 3-4kB range for keyset sizes oom <span class=\"math\">10^4</span> to <span class=\"math\">10^6</span>. Varying the tree topology (branching factors 256 to 1024, depth from 2 to 6), doesn\u2019t seem to change it much; important to remember that we always end up with 2 bulletproofs because multiple proofs for one curve (secp or secq) can be aggregated.</li>\n<li>Points must be pre-processed before being added as leaves to the tree. This process can actually be quite computationally intensive. The reason for this processing is to allow the <span class=\"math\">x</span>-coordinate to curve point transformation to be unambiguous (the well known \u201c<span class=\"math\">y</span>-coordinate tiebreaker\u201d issue), but using an algorithm that is actually efficient inside the arithmetic circuit . Since this only has to be done once for each new key, this time cost can be ameliorated in every case but a pure trustless bootstrap to do a proof from scratch. Discussed <a href=\"https://github.com/AdamISZ/aut-ct/issues/10\" rel=\"noopener nofollow ugc\">here</a></li>\n<li>Verifications can be batched for bigger speedup (I believe also proofs, but I\u2019m not sure exactly how that works); these are bulletproofs arithmetic circuit ZKPs, so the properties follow from that.</li>\n<li>Curve Trees being based on bulletproof ZKPs means we do not require pairings nor any assumption beyond ECDL (not that one would dismiss a proposal which required other assumptions out of hand, but rather the issue is that with secp256k1 as our base curve we <em>really</em> don\u2019t want to deal with pairings *** )</li>\n</ul>\n<p>One thing that you might (should) wonder is, are there other techniques that can also provide near-constant fast verify for this Bitcoin use case? The most powerful techniques, e.g. Groth16 and its descendants, all require pairings; see note above. There is another idea, see Microsoft\u2019s SPARTAN as applied <a href=\"https://github.com/personaelabs/spartan-ecdsa\" rel=\"noopener nofollow ugc\">here</a> which also does not require pairings nor any assumption beyond ECDL. I briefly investigated SPARTAN but I don\u2019t <em>think</em> it\u2019s quite as powerful in getting super-fast verification. I haven\u2019t investigated STARKs in this context, though, perhaps there is a direction there.</p>\n<p>Extensions of this idea? From what I understand, we may be able to combine this Curve Trees construction with the idea of credentials, like KVAC as used in e.g. Wabisabi. If we could do this in a way that allowed a person to <em>independently</em> construct a single combined credential \u201cthis is 1.7 btc worth\u201d such that (a) reuse of value is not possible, and (b) this could be done without a central coordinating server, then \u2026 would we be getting very close to what might be needed for \u201cgood\u201d Lightning gossip? I\u2019m not very sure about anything I wrote in this paragraph <img src=\"https://delvingbitcoin.org/images/emoji/twitter/slight_smile.png?v=12\" title=\":slight_smile:\" class=\"emoji\" alt=\":slight_smile:\" loading=\"lazy\" width=\"20\" height=\"20\"></p>\n<p>** While I am sort-of dismissing that earlier RIDDLE idea, it\u2019s only the mathematical construction I\u2019m dismissing as too slow - the ideas there about tokens from (u)txo ownership I think are still interesting. <a href=\"https://reyify.com/blog/riddle\" rel=\"noopener nofollow ugc\">riddle blog</a></p>\n<p>*** It\u2019s worth expanding on that \u2026 in a <em>closed</em> system of peers you can obviously just have everyone sign a key of any exotic type you like, certainly including one for use in a pairings based system. But this drastically reduces the \u201cspontaneity\u201d of formation of anonymity sets, e.g. you can\u2019t include taproot utxos that aren\u2019t connected to running Lightning nodes etc. Tradeoff might be that you get <em>very</em> compact proofs etc. I tended to think that 3kB is already compact enough, since by design, there won\u2019t be millions of these proofs!</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2024-05-10T14:50:11.542Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 14,
  "reads": 12,
  "readers_count": 11,
  "score": 87.4,
  "yours": false,
  "topic_id": 862,
  "topic_slug": "anonymous-usage-tokens-from-curve-trees-or-autct",
  "topic_title": "Anonymous usage tokens from curve trees or autct",
  "topic_html_title": "Anonymous usage tokens from curve trees or autct",
  "category_id": 7,
  "display_username": "Adam Gibson",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Ever since whenever (I think when we introduced fidelity bonds in Joinmarket), I've been researching the best way to have private proof of pubkey ownership.\n\nI did also think the same issue arises a lot in Lightning, potentially in solving jamming but also (as others pointed out to me), even more obviously in gossip of channels.\n\nI think this may be a decent partial solution, to the problem \"how can we gossip channels without revealing the utxos and without allowing people to sybil with fakes (too much)?\".\n\nWhat stopped earlier ideas I had from being really practical (see my earlier post on RIDDLE **) was that all the ring signature based stuff fails on sublinear verification. Crudely, it always requires the verifier to \"read through\" an object whose size is the size of the ring. So while an anon set of 1000 was fine and very compact in proof size, an anon set of 1M was wildly impractical.\n\nBut the [Curve Trees](https://eprint.iacr.org/2022/756.pdf) approach solves this: think of it as a merkle tree except algebraic (using points not hashes), which allows you to create ZKPs (in this case, arithmetic circuits using bulletproofs) about the object (key) that you're proving is in the tree. So here you get the statement \"this pubkey is one of the 100K pubkeys in this set of taproot outputs, but you don't know which one, and this \"key image\" (think token) I'm providing, is tied to that un-revealed pubkey so I can't just use it again\". I'll mention how that \"tie\"-ing works in a moment.\n\nSo the obvious application in Bitcoin is - make a proof of ownership of one taproot utxo pubkey out of N where N can be any large number up to the size of the utxo set. Given how many taproot utxos are dusty and let's say \"uneconomic\" you can just set a minimum value filter to get a sensible size. A couple months ago I got these values:\n\n```\nAmount in sats    Number of utxos(taproot only)\n> 5 million         51674\n> 2.5 million       81512\n> 1 million         154130\n> 500k              238060\n> 250k              352235\n> 100k              800843\n> 50k               1043038\n> 25k               1333547\n> 10k               2853756\n> 1000 sat          6084116\n> 100 (i.e. ~all)   39034007\n```\n\nSo as an example, a 500k sat threshold ends up with 240000 keys which is already practical for curve trees.\n\nRe: \"tie\"-ing: Now the curve trees proof is a proof of *set membership* and doesn't enforce scarcity, since by its nature it can be repeated without revealing re-use. For this reason I added a DLEQ part, similar to Joinmarket's PODLE (think of this as like \"linkable\" in a ring signature), that creates an extra curve point that's provably the \"key image\" of the key whose membership you proved, without revealing that key. See [here](https://github.com/AdamISZ/aut-ct/blob/7e673b572a300fd43f0ba4b1839fe682be676d93/aut-ct.pdf) for the writeup of that algorithm; it's using completely standard sigma protocol techniques.\n\nIn practice I have done a lot of tests with keyset sizes from 50K up to 2.5M and seen verification time mostly sitting between 40 and 70ms although these aren't properly controlled scientific results; the point is that it remains fast! See Table 1 in the Curve Trees paper for their benchmarking results for the secp/secq cycle which are significantly better, even. The main point is that the logarithmic scaling coming from the tree, combined with how bulletproofs can be batch verified (a separate proof for each curve), gives extremely good scaling (it's a little difficult to write down a formula because of the arithmetic circuit; basically 1M keys are easily practical for verifying).\n\nWorking code at [my aut-ct github repo](https://github.com/AdamISZ/aut-ct). This is using as a basis the [benchmarking code](https://github.com/simonkamp/curve-trees/) of the authors of the curve trees paper.\n\nIt should be easy to run tests, I hope, following the README. There are a couple of toy small and medium size keysets you can use to play with if you want. Forgive my Rust :)\n\nI even went as far as to make a proof of concept website where you sign up for a forum using a proof of taproot key ownership, see [hodlboard](https://hodlboard.org). Note that the process of creating a proof here turned out to be way more convoluted as you have to be able to access a private key for a taproot utxo you own, which to say the least, is not supported by any wallet (except Core, with multiple steps on the command line!). However this practical annoyance will be irrelevant for any usage of this protocol in e.g. Lightning. It would only be relevant if we want interoperable creation of such proofs at user level.\n\nAs I understand it, the way in which this is \"not a full solution\" is pretty clearly that a Lightning node wants to (or perhaps, \"has to\" is better!?) advertise capacity, and this doesn't do this, except in the most primitive way: you could advertise \"amount within a range\" by choosing utxos from a range of values.\n\nFilling in some more technical details:\n* The proof size: it varies but not by much, in the 3-4kB range for keyset sizes oom $10^4$ to $10^6$. Varying the tree topology (branching factors 256 to 1024, depth from 2 to 6), doesn't seem to change it much; important to remember that we always end up with 2 bulletproofs because multiple proofs for one curve (secp or secq) can be aggregated.\n* Points must be pre-processed before being added as leaves to the tree. This process can actually be quite computationally intensive. The reason for this processing is to allow the $x$-coordinate to curve point transformation to be unambiguous (the well known \"$y$-coordinate tiebreaker\" issue), but using an algorithm that is actually efficient inside the arithmetic circuit . Since this only has to be done once for each new key, this time cost can be ameliorated in every case but a pure trustless bootstrap to do a proof from scratch. Discussed [here](https://github.com/AdamISZ/aut-ct/issues/10)\n* Verifications can be batched for bigger speedup (I believe also proofs, but I'm not sure exactly how that works); these are bulletproofs arithmetic circuit ZKPs, so the properties follow from that.\n* Curve Trees being based on bulletproof ZKPs means we do not require pairings nor any assumption beyond ECDL (not that one would dismiss a proposal which required other assumptions out of hand, but rather the issue is that with secp256k1 as our base curve we *really* don't want to deal with pairings *** )\n\nOne thing that you might (should) wonder is, are there other techniques that can also provide near-constant fast verify for this Bitcoin use case? The most powerful techniques, e.g. Groth16 and its descendants, all require pairings; see note above. There is another idea, see Microsoft's SPARTAN as applied [here](https://github.com/personaelabs/spartan-ecdsa) which also does not require pairings nor any assumption beyond ECDL. I briefly investigated SPARTAN but I don't *think* it's quite as powerful in getting super-fast verification. I haven't investigated STARKs in this context, though, perhaps there is a direction there.\n\nExtensions of this idea? From what I understand, we may be able to combine this Curve Trees construction with the idea of credentials, like KVAC as used in e.g. Wabisabi. If we could do this in a way that allowed a person to *independently* construct a single combined credential \"this is 1.7 btc worth\" such that (a) reuse of value is not possible, and (b) this could be done without a central coordinating server, then .. would we be getting very close to what might be needed for \"good\" Lightning gossip? I'm not very sure about anything I wrote in this paragraph :)\n\n\n** While I am sort-of dismissing that earlier RIDDLE idea, it's only the mathematical construction I'm dismissing as too slow - the ideas there about tokens from (u)txo ownership I think are still interesting. [riddle blog](https://reyify.com/blog/riddle)\n\n*** It's worth expanding on that ... in a *closed* system of peers you can obviously just have everyone sign a key of any exotic type you like, certainly including one for use in a pairings based system. But this drastically reduces the \"spontaneity\" of formation of anonymity sets, e.g. you can't include taproot utxos that aren't connected to running Lightning nodes etc. Tradeoff might be that you get *very* compact proofs etc. I tended to think that 3kB is already compact enough, since by design, there won't be millions of these proofs!",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 343,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": "Github link was replaced with a permanent link",
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "eyes",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}