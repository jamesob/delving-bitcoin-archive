{
  "id": 2361,
  "name": "Pieter Wuille",
  "username": "sipa",
  "avatar_template": "/user_avatar/delvingbitcoin.org/sipa/{size}/102_2.png",
  "created_at": "2024-05-04T04:24:26.070Z",
  "cooked": "<p>The message signing feature and encoding wasn\u2019t designed by Satoshi, but by me, so you can direct all blame for quirks and lack of documentation here. You\u2019re right that it predates the BIP process, so the code is really the specification I\u2019m afraid, though with many reimplementations there are probably several languages to choose from.</p>\n<p>It is roughly:</p>\n<ul>\n<li>Serialize the string \u201cBitcoin Signed Message:\\n\u201d plus the message being signed in the P2P protocol serialization format (which means: prepending each with a <a href=\"https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer\">CompactSize</a>-encoding of the number of bytes that follow)</li>\n<li>Double-SHA256 hash that serialization.</li>\n<li>Construct an ECDSA signature with that double-SHA256 as hashed message <span class=\"math\">z</span>, and the address\u2019 key as private key <span class=\"math\">d</span> (with corresponding public key <span class=\"math\">Q</span>), resulting in two integers <span class=\"math\">(r, s)</span>.</li>\n<li>That signature is encoded as a \u201crecoverable signature\u201d, which consists of a header byte plus 32-byte big-endian encodings of <span class=\"math\">r</span> and <span class=\"math\">s</span>. This header bytes is there to assist the verifier in recovering the public key from the signature. It can be computed by running the verification algorithm:\n<ul>\n<li>Let <span class=\"math\">u_1 = s^{-1}z\\, (\\operatorname{mod}\\, n)</span></li>\n<li>Let <span class=\"math\">u_2 = r^{-1}z\\, (\\operatorname{mod}\\, n)</span></li>\n<li>Let <span class=\"math\">R = u_1G + u_2Q</span></li>\n<li>From the result the \u201crecid\u201d can be derived:\n<ul>\n<li>The X coordinate of <span class=\"math\">R</span> must now either be <span class=\"math\">r</span> (recid=0 or 1) or <span class=\"math\">r + n</span> (recid=2 or 3).</li>\n<li>The Y coordinate of <span class=\"math\">R</span> must be even (recid=0 or 2) or odd (recid=1 or 3)</li>\n</ul>\n</li>\n<li>The header byte equals the recid + 27 for uncompressed <span class=\"math\">Q</span> and recid + 31 for compressed <span class=\"math\">Q</span>.</li>\n</ul>\n</li>\n</ul>",
  "post_number": 2,
  "post_type": 1,
  "updated_at": "2024-05-04T04:50:53.015Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 8,
  "readers_count": 7,
  "score": 61.6,
  "yours": false,
  "topic_id": 850,
  "topic_slug": "satoshi-style-message-signing",
  "topic_title": "Satoshi Style Message Signing",
  "topic_html_title": "Satoshi Style Message Signing",
  "category_id": 8,
  "display_username": "Pieter Wuille",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "The message signing feature and encoding wasn't designed by Satoshi, but by me, so you can direct all blame for quirks and lack of documentation here. You're right that it predates the BIP process, so the code is really the specification I'm afraid, though with many reimplementations there are probably several languages to choose from.\n\nIt is roughly:\n* Serialize the string \"Bitcoin Signed Message:\\n\" plus the message being signed in the P2P protocol serialization format (which means: prepending each with a [CompactSize](https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer)-encoding of the number of bytes that follow)\n* Double-SHA256 hash that serialization.\n* Construct an ECDSA signature with that double-SHA256 as hashed message $z$, and the address' key as private key $d$ (with corresponding public key $Q$), resulting in two integers $(r, s)$.\n* That signature is encoded as a \"recoverable signature\", which consists of a header byte plus 32-byte big-endian encodings of $r$ and $s$. This header bytes is there to assist the verifier in recovering the public key from the signature. It can be computed by running the verification algorithm:\n  * Let $u_1 = s^{-1}z\\, (\\operatorname{mod}\\, n)$\n  * Let $u_2 = r^{-1}z\\, (\\operatorname{mod}\\, n)$\n  * Let $R = u_1G + u_2Q$\n  * From the result the \"recid\" can be derived:\n    * The X coordinate of $R$ must now either be $r$ (recid=0 or 1) or $r + n$ (recid=2 or 3).\n    * The Y coordinate of $R$ must be even (recid=0 or 2) or odd (recid=1 or 3)\n  * The header byte equals the recid + 27 for uncompressed $Q$ and recid + 31 for compressed $Q$.",
  "actions_summary": [
    {
      "id": 2,
      "count": 2
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 96,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 2
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 2,
  "current_user_used_main_reaction": false
}