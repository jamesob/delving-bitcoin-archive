{
  "id": 2525,
  "name": "Suhas Daftuar",
  "username": "sdaftuar",
  "avatar_template": "/letter_avatar_proxy/v4/letter/s/0ea827/{size}.png",
  "created_at": "2024-05-23T14:35:30.440Z",
  "cooked": "<p>There\u2019s a potential pinning issue introduced by using feerate diagram comparisons alone as our RBF tool, which I wanted to describe so we don\u2019t forget this when we get to doing general package RBF.</p>\n<p>Imagine a transaction <span class=\"math\">V</span> with high feerate that\u2019s already in the mempool.  An adversary is looking to replace <span class=\"math\">V</span> with some low-feerate, high fee transaction that will be expensive to replace (due to the total fee test).</p>\n<p>Using the package RBF scheme described here, one possible way for the attacker to do this would be to prepare some big cluster that has  more transactions in it than we can optimally linearize.  Within it, imagine that we have some part of the transaction graph that (say) looks like this:</p>\n<pre data-code-height=\"233\" data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">   graph TD\n   A[some big cluster of transactions]--&gt; P[\"P (low fee)\"]\n   P--&gt;B[\"B (high fee)\"]\n   P--&gt;C[\"C (high fee)\"]\n</code></pre>\n<p>This might go undiscovered as a good single chunk in our linearization, because our heuristics might have a hard time picking this up (eg it\u2019s overlooked in ancestor feerate sorting).  However, a single transaction that spends <span class=\"math\">B</span> and <span class=\"math\">C</span>, even at a very low feerate, will cause the set to be considered and possibly improve the overall linearization quite a lot.  So imagine an attacker constructs two transactions, <span class=\"math\">D</span> and <span class=\"math\">E</span>, where <span class=\"math\">D</span> spends <span class=\"math\">B</span> and <span class=\"math\">C</span>, while <span class=\"math\">E</span> conflicts with <span class=\"math\">V</span>:</p>\n<pre data-code-height=\"408\" data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">   graph TD\n   V[\"V (high feerate)\"]\n   A[some big cluster of transactions]--&gt; P[\"P (low fee)\"]\n   P--&gt;B[\"B (high fee)\"]\n   P--&gt;C[\"C (high fee)\"]\n   B--&gt;D[\"D (low fee)\"]\n   C--&gt;D\n   D--&gt;E[\"E (slightly higher feerate than D, but very big and conflicts with V)\"]\n</code></pre>\n<p>We could imagine that merely <em>looking at</em> <span class=\"math\">D</span> being added to the cluster causes the cluster\u2019s feerate diagram to improve (because we discover the chunk <span class=\"math\">[P, B, C]</span>), so that the RBF that considers adding <span class=\"math\">D</span>+<span class=\"math\">E</span> vs <span class=\"math\">V</span> succeeds \u2013 even though the good transactions which lead to the improvement <em>were already in the mempool that contains <span class=\"math\">V</span> as well</em>.</p>\n<p>And then once <span class=\"math\">E</span> is in the mempool, it\u2019s expensive for <span class=\"math\">V</span> to replace it\u2026 Pinning complete. <img src=\"https://delvingbitcoin.org/images/emoji/twitter/frowning.png?v=12\" title=\":frowning:\" class=\"emoji\" alt=\":frowning:\" loading=\"lazy\" width=\"20\" height=\"20\"></p>\n<p>Really, the attacker is able to exploit two things in this scenario:</p>\n<ol>\n<li>Being able to run the linearization algorithm one extra time compared with the existing mempool.  If we do a bounded search, say, getting more search time can randomly cause a better linearization to be found, which benefits the new transaction when compared with the old.</li>\n<li>Being able to exploit limitations of our linearization algorithm. An attacker can intentionally construct a cluster that will linearize poorly using our various heuristics, but when a new leaf transaction is added suddenly sorts better.</li>\n</ol>\n<p>Also, this problem exists with how I envisioned single-transaction RBF to work as well (imagine <span class=\"math\">D</span> and <span class=\"math\">E</span> were a single transaction, rather than two, which conflicts with <span class=\"math\">V</span>).  We\u2019re exploring whether it might be possible to fix the single-RBF case by requiring the chunk feerate of the new transaction to be better than its conflicts, but I am not sure any such heuristic would work in the package RBF case without being too draconian.</p>",
  "post_number": 14,
  "post_type": 1,
  "updated_at": "2024-05-23T14:35:30.440Z",
  "reply_count": 1,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 5,
  "reads": 4,
  "readers_count": 3,
  "score": 25.6,
  "yours": false,
  "topic_id": 190,
  "topic_slug": "post-clustermempool-package-rbf-per-chunk-processing",
  "topic_title": "Post-clustermempool package RBF: per-chunk processing",
  "topic_html_title": "Post-clustermempool package RBF: per-chunk processing",
  "category_id": 8,
  "display_username": "Suhas Daftuar",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "There's a potential pinning issue introduced by using feerate diagram comparisons alone as our RBF tool, which I wanted to describe so we don't forget this when we get to doing general package RBF.\n\nImagine a transaction $V$ with high feerate that's already in the mempool.  An adversary is looking to replace $V$ with some low-feerate, high fee transaction that will be expensive to replace (due to the total fee test).\n\nUsing the package RBF scheme described here, one possible way for the attacker to do this would be to prepare some big cluster that has  more transactions in it than we can optimally linearize.  Within it, imagine that we have some part of the transaction graph that (say) looks like this:\n\n```mermaid height=233,auto\n   graph TD\n   A[some big cluster of transactions]--> P[\"P (low fee)\"]\n   P-->B[\"B (high fee)\"]\n   P-->C[\"C (high fee)\"]\n```\n\nThis might go undiscovered as a good single chunk in our linearization, because our heuristics might have a hard time picking this up (eg it's overlooked in ancestor feerate sorting).  However, a single transaction that spends $B$ and $C$, even at a very low feerate, will cause the set to be considered and possibly improve the overall linearization quite a lot.  So imagine an attacker constructs two transactions, $D$ and $E$, where $D$ spends $B$ and $C$, while $E$ conflicts with $V$:\n\n```mermaid height=408,auto\n   graph TD\n   V[\"V (high feerate)\"]\n   A[some big cluster of transactions]--> P[\"P (low fee)\"]\n   P-->B[\"B (high fee)\"]\n   P-->C[\"C (high fee)\"]\n   B-->D[\"D (low fee)\"]\n   C-->D\n   D-->E[\"E (slightly higher feerate than D, but very big and conflicts with V)\"]\n```\n\nWe could imagine that merely *looking at* $D$ being added to the cluster causes the cluster's feerate diagram to improve (because we discover the chunk $[P, B, C]$), so that the RBF that considers adding $D$+$E$ vs $V$ succeeds -- even though the good transactions which lead to the improvement *were already in the mempool that contains $V$ as well*.\n\nAnd then once $E$ is in the mempool, it's expensive for $V$ to replace it... Pinning complete. :frowning: \n\nReally, the attacker is able to exploit two things in this scenario:\n1) Being able to run the linearization algorithm one extra time compared with the existing mempool.  If we do a bounded search, say, getting more search time can randomly cause a better linearization to be found, which benefits the new transaction when compared with the old.\n2) Being able to exploit limitations of our linearization algorithm. An attacker can intentionally construct a cluster that will linearize poorly using our various heuristics, but when a new leaf transaction is added suddenly sorts better.\n\nAlso, this problem exists with how I envisioned single-transaction RBF to work as well (imagine $D$ and $E$ were a single transaction, rather than two, which conflicts with $V$).  We're exploring whether it might be possible to fix the single-RBF case by requiring the chunk feerate of the new transaction to be better than its conflicts, but I am not sure any such heuristic would work in the package RBF case without being too draconian.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 95,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "sob",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}