{
  "id": 2357,
  "name": "/dev/fd0",
  "username": "1440000bytes",
  "avatar_template": "/user_avatar/delvingbitcoin.org/1440000bytes/{size}/301_2.png",
  "created_at": "2024-05-03T21:19:30.599Z",
  "cooked": "<h1>Problem</h1>\n<p>Coinjoin process requires lot of interaction between peers</p>\n<h1>Research</h1>\n<ul>\n<li><a href=\"https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-May/021696.html\" rel=\"noopener nofollow ugc\"><code>SIGHASH_ALL | SIGHASH_ANYONECANPAY</code></a> reduces some steps</li>\n<li>Nostr encrypted channels can be used so that users don\u2019t need to be always online</li>\n<li>Payment Pools allow <a href=\"https://rubin.io/bitcoin/2021/12/10/advent-13/#fnref:greg\" rel=\"noopener nofollow ugc\">rolling coinjoin</a> but not possible without covenants <img src=\"https://delvingbitcoin.org/images/emoji/twitter/warning.png?v=12\" title=\":warning:\" class=\"emoji\" alt=\":warning:\" loading=\"lazy\" width=\"20\" height=\"20\"></li>\n</ul>\n<h1>Solution</h1>\n<p>Using <code>SIGHASH_ALL | SIGHASH_ANYONECANPAY</code> and nostr encrypted channels we can create pools in which users can enter any time and exit together. Unilateral exits are also possible which requires lot of pre-signed transactions, multisig and some interaction.</p>\n<p>I have used this approach in <a href=\"https://gitlab.com/1440000bytes/joinstr/-/tree/main/plugin\" rel=\"noopener nofollow ugc\">electrum plugin for joinstr</a> which is still a work in progress. There are different ways to create nostr channels and I have used basic method using NIP 4. See other NIPs in <a href=\"https://github.com/nostr-protocol/nips\" rel=\"noopener nofollow ugc\">nostr repository</a> that can be used to implement better encrypted channels.</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/1X/4e0e547dac27628e8fb1a9321f51ffb37b55c5d1.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/4e0e547dac27628e8fb1a9321f51ffb37b55c5d1\" title=\"GG7Tn0cbIAAJzdB\"><img src=\"https://delvingbitcoin.org/uploads/default/original/1X/4e0e547dac27628e8fb1a9321f51ffb37b55c5d1.png\" alt=\"GG7Tn0cbIAAJzdB\" data-base62-sha1=\"b8vWzjfdnYoGRp5NsV5xbDX72c9\" width=\"690\" height=\"441\" data-dominant-color=\"181918\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">GG7Tn0cbIAAJzdB</span><span class=\"informations\">856\u00d7548 30.8 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>Paid relay is used to avoid denial of service attacks and below are 2 functions used for creating and joining pools:</p>\n<pre><code class=\"lang-auto\">    def create_channel(self, denomination, peers, timeout, address, wallet, tab_widget):\n\n        letters = string.ascii_lowercase\n        pool_id = ''.join(random.choice(letters) for i in range(10)) + str(int(time.time()))\n\n        private_key = PrivateKey()\n        pub_key=private_key.public_key.hex()\n        channel = {\"type\": \"new_pool\",\"id\": pool_id, \"public_key\": pub_key,\"denomination\": float(denomination), \"peers\": int(peers), \"timeout\": int(time.time())+timeout, \"relay\": self.config.get('nostr_relay', 0)}\n        channel_creds = channel\n        channel_creds[\"private_key\"] = private_key.hex()     \n\n        pool_path = os.path.expanduser(os.path.join('~', '.electrum', \"pools.json\"))\n    \n        if os.path.exists(pool_path) and os.stat(pool_path).st_size &gt; 0:\n            with open(pool_path, 'r') as file:\n                pools = json.load(file)\n        else:\n            pools = []\n\n        pools.append(channel_creds)\n\n        with open(pool_path, 'w') as file:\n            json.dump(pools, file, indent=2)\n\n        self.publish_event(channel, 999999)\n\n        self.register_output(wallet,address, tab_widget)\n\n        thread = threading.Thread(target=self.run_checkevents, args=('pool_msg','join_request', None, None, None, None, pub_key, peers))\n        thread.daemon = True\n        thread.start()\n</code></pre>\n<pre><code class=\"lang-auto\">    def join_channel(self, request, pubkey, relay):\n        event = self.publish_event(request, 4, pubkey, relay=relay, qr=True)\n        \n        if not hasattr(self, 'dialog'):\n            self.dialog = QDialog()\n            self.dialog.setWindowTitle(\"Pool Request\")\n            self.dialog_layout = QVBoxLayout()\n            self.dialog.setLayout(self.dialog_layout)\n\n            self.message_label = QLabel(\"Waiting for pool credentials...\")\n            self.message_label.setAlignment(Qt.AlignCenter)\n            self.dialog_layout.addWidget(self.message_label)\n\n            self.progress_bar = QProgressBar()\n            self.progress_bar.setTextVisible(False)\n            self.dialog_layout.addWidget(self.progress_bar)\n\n            self.dialog.setFixedWidth(400)\n\n            self.dialog.show()\n\n        self.timer = QTimer()\n        self.timer.timeout.connect(self.update_progress)\n        self.timer.start(100)\n\n        thread = threading.Thread(target=self.run_checkevents, args=('own_msg', None, None, None, None, event.public_key))\n        thread.daemon = True\n        thread.start()\n</code></pre>\n<hr>\n<p>There was some <a href=\"https://github.com/stevenroose/covenants.info/pull/16#issuecomment-1891021885\" rel=\"noopener nofollow ugc\">discussion</a> about the terms so I have just called them \u201cpools\u201d. Such pools are not limited to coinjoin and could be used for other things. Example: Discreet Log Contracts</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2024-05-04T03:09:40.403Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 33,
  "reads": 7,
  "readers_count": 6,
  "score": 161.4,
  "yours": false,
  "topic_id": 847,
  "topic_slug": "pools-without-covenants",
  "topic_title": "Pools without covenants",
  "topic_html_title": "Pools without covenants",
  "category_id": 8,
  "display_username": "/dev/fd0",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "<h1>Problem</h1>\n\nCoinjoin process requires lot of interaction between peers\n\n<h1>Research</h1>\n\n- [`SIGHASH_ALL | SIGHASH_ANYONECANPAY`](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-May/021696.html) reduces some steps \n- Nostr encrypted channels can be used so that users don't need to be always online\n- Payment Pools allow [rolling coinjoin](https://rubin.io/bitcoin/2021/12/10/advent-13/#fnref:greg) but not possible without covenants :warning:\n\n<h1>Solution</h1>\n\nUsing `SIGHASH_ALL | SIGHASH_ANYONECANPAY` and nostr encrypted channels we can create pools in which users can enter any time and exit together. Unilateral exits are also possible which requires lot of pre-signed transactions, multisig and some interaction.\n\nI have used this approach in [electrum plugin for joinstr](https://gitlab.com/1440000bytes/joinstr/-/tree/main/plugin) which is still a work in progress. There are different ways to create nostr channels and I have used basic method using NIP 4. See other NIPs in [nostr repository](https://github.com/nostr-protocol/nips) that can be used to implement better encrypted channels.\n\n![GG7Tn0cbIAAJzdB|690x441](upload://b8vWzjfdnYoGRp5NsV5xbDX72c9.png)\n\nPaid relay is used to avoid denial of service attacks and below are 2 functions used for creating and joining pools:\n\n```\n    def create_channel(self, denomination, peers, timeout, address, wallet, tab_widget):\n\n        letters = string.ascii_lowercase\n        pool_id = ''.join(random.choice(letters) for i in range(10)) + str(int(time.time()))\n\n        private_key = PrivateKey()\n        pub_key=private_key.public_key.hex()\n        channel = {\"type\": \"new_pool\",\"id\": pool_id, \"public_key\": pub_key,\"denomination\": float(denomination), \"peers\": int(peers), \"timeout\": int(time.time())+timeout, \"relay\": self.config.get('nostr_relay', 0)}\n        channel_creds = channel\n        channel_creds[\"private_key\"] = private_key.hex()     \n\n        pool_path = os.path.expanduser(os.path.join('~', '.electrum', \"pools.json\"))\n    \n        if os.path.exists(pool_path) and os.stat(pool_path).st_size > 0:\n            with open(pool_path, 'r') as file:\n                pools = json.load(file)\n        else:\n            pools = []\n\n        pools.append(channel_creds)\n\n        with open(pool_path, 'w') as file:\n            json.dump(pools, file, indent=2)\n\n        self.publish_event(channel, 999999)\n\n        self.register_output(wallet,address, tab_widget)\n\n        thread = threading.Thread(target=self.run_checkevents, args=('pool_msg','join_request', None, None, None, None, pub_key, peers))\n        thread.daemon = True\n        thread.start()\n```\n\n```\n    def join_channel(self, request, pubkey, relay):\n        event = self.publish_event(request, 4, pubkey, relay=relay, qr=True)\n        \n        if not hasattr(self, 'dialog'):\n            self.dialog = QDialog()\n            self.dialog.setWindowTitle(\"Pool Request\")\n            self.dialog_layout = QVBoxLayout()\n            self.dialog.setLayout(self.dialog_layout)\n\n            self.message_label = QLabel(\"Waiting for pool credentials...\")\n            self.message_label.setAlignment(Qt.AlignCenter)\n            self.dialog_layout.addWidget(self.message_label)\n\n            self.progress_bar = QProgressBar()\n            self.progress_bar.setTextVisible(False)\n            self.dialog_layout.addWidget(self.progress_bar)\n\n            self.dialog.setFixedWidth(400)\n\n            self.dialog.show()\n\n        self.timer = QTimer()\n        self.timer.timeout.connect(self.update_progress)\n        self.timer.start(100)\n\n        thread = threading.Thread(target=self.run_checkevents, args=('own_msg', None, None, None, None, event.public_key))\n        thread.daemon = True\n        thread.start()\n```\n\n---\n\nThere was some [discussion](https://github.com/stevenroose/covenants.info/pull/16#issuecomment-1891021885) about the terms so I have just called them \"pools\". Such pools are not limited to coinjoin and could be used for other things. Example: Discreet Log Contracts",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 247,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}