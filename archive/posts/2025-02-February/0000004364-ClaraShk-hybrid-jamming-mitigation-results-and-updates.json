{
  "id": 4364,
  "name": "",
  "username": "ClaraShk",
  "avatar_template": "/user_avatar/delvingbitcoin.org/clarashk/{size}/370_2.png",
  "created_at": "2025-02-22T03:03:35.554Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"morehouse\" data-post=\"8\" data-topic=\"1147\" data-full=\"true\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/letter_avatar_proxy/v4/letter/m/df705f/48.png\" class=\"avatar\"> morehouse:</div>\n<blockquote>\n<p>So I presume the delta variance is entirely from fluctuations in the target node\u2019s incoming revenue?</p>\n</blockquote>\n</aside>\n<p>Yes, we\u2019re looking at forwards over a series of incoming channels, so so reputation will fluctuate with the incoming channel and the HTLC amount.</p>\n<aside class=\"quote no-group\" data-username=\"morehouse\" data-post=\"8\" data-topic=\"1147\" data-full=\"true\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/letter_avatar_proxy/v4/letter/m/df705f/48.png\" class=\"avatar\"> morehouse:</div>\n<blockquote>\n<p>I\u2019m also curious how you chose to exclude outliers and how the graph looks with them included.</p>\n</blockquote>\n</aside>\n<details>  \n <summary>Script we used for outliers and a graph with no outlier removal here. </summary>  \n<pre data-code-wrap=\"python\"><code class=\"lang-python\">import sys\nimport os\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom datetime import datetime, timedelta\n\nif len(sys.argv) != 3:\n    print(\"Usage: python reputation_graph.py &lt;file&gt; &lt;channel_id&gt;\")\n    sys.exit(1)\n\nfile_path = sys.argv[1]\nchannel_id = int(sys.argv[2])\n\n# Load CSV data\ndf = pd.read_csv(file_path)\n\n# Ensure ts_offset_ns column exists and convert to datetime\ndf['ts_offset_ns'] = pd.to_numeric(df['ts_offset_ns'])\n\n# Normalize ts_offset_ns to start from zero\ndf['normalized_ts_ns'] = df['ts_offset_ns'] - df['ts_offset_ns'].min()\n\n# Filter for the specified outgoing channel ID\ndf_filtered = df[df['outgoing_channel_id'] == channel_id].copy()\n\n# Check if the filtered DataFrame is empty\nif df_filtered.empty:\n    print(f\"No data found for outgoing_channel_id {channel_id}.\")\n    sys.exit(1)\n\n# Sort by normalized timestamp\ndf_filtered = df_filtered.sort_values(by='normalized_ts_ns')\n\n# Calculate reputation delta\ndf_filtered['reputation_delta'] = (\n    df_filtered['outgoing_reputation'] - df_filtered['in_flight_risk'] \n    - df_filtered['htlc_risk'] - df_filtered['incoming_revenue']\n)\n\n# Remove outliers\noutlier_threshold = 1\nif len(df_filtered['reputation_delta']) &gt; 0:\n    lower_percentile = np.percentile(df_filtered['reputation_delta'], outlier_threshold)\n    upper_percentile = np.percentile(df_filtered['reputation_delta'], 100 - outlier_threshold)\n    df_smooth = df_filtered[(df_filtered['reputation_delta'] &gt;= lower_percentile) &amp; (df_filtered['reputation_delta'] &lt;= upper_percentile)]\nelse:\n    df_smooth = df_filtered\n\n# Calculate Exponential Moving Average (EMA)\nalpha = 0.01  # Adjust for decay rate\nif not df_smooth.empty:\n    df_smooth['ema'] = df_smooth['reputation_delta'].ewm(alpha=alpha).mean()\n\n    # Plot\n    plt.figure(figsize=(10, 6))\n    plt.plot(df_smooth['normalized_ts_ns'], df_smooth['reputation_delta'], 'o', label='Reputation Delta No Outliers', alpha=0.7)\n    plt.plot(df_smooth['normalized_ts_ns'], df_smooth['ema'], label='Exponential Moving Average', linewidth=2)\n    plt.axhline(0, color='red', linewidth=2, linestyle='--', label='Zero Line')\n\n    plt.title('Reputation Delta with Moving Decaying Average')\n    plt.xlabel('Timestamp Offset (ns) from Start')\n    plt.ylabel('Reputation Delta')\n    plt.xticks(rotation=45)\n    plt.legend()\n    plt.tight_layout()\n\n    # Save graph\n    output_dir = os.path.dirname(file_path)\n    file_name = os.path.basename(file_path).rsplit('.', 1)[0]\n    output_path = os.path.join(output_dir, f\"{file_name}_reputation.png\")\n    plt.savefig(output_path)\n\n    print(f\"Graph saved to {output_path}\")\nelse:\n    print(f\"No data available to plot after outlier removal for channel_id {channel_id}.\")\n</code></pre>\n</details>\n<p>Turns out there isn\u2019t much of a difference for this experiment - in some of the others there was one large negative point which made it difficult to see the gradient of the exponential moving average.\n<strong><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/2X/5/56d11f810126ec6ffd9ce85a3bae47360d9482a2.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/56d11f810126ec6ffd9ce85a3bae47360d9482a2\" title=\"\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/2X/5/56d11f810126ec6ffd9ce85a3bae47360d9482a2_2_624x375.png\" alt=\"\" data-base62-sha1=\"co16BAznf3meGljzkJDa0bMo32W\" width=\"624\" height=\"375\" role=\"presentation\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/2X/5/56d11f810126ec6ffd9ce85a3bae47360d9482a2_2_624x375.png, https://delvingbitcoin.org/uploads/default/optimized/2X/5/56d11f810126ec6ffd9ce85a3bae47360d9482a2_2_936x562.png 1.5x, https://delvingbitcoin.org/uploads/default/original/2X/5/56d11f810126ec6ffd9ce85a3bae47360d9482a2.png 2x\" data-dominant-color=\"FAFAFA\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\"></span><span class=\"informations\">1000\u00d7600 33.2 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></strong></p>\n<aside class=\"quote no-group\" data-username=\"morehouse\" data-post=\"8\" data-topic=\"1147\" data-full=\"true\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/letter_avatar_proxy/v4/letter/m/df705f/48.png\" class=\"avatar\"> morehouse:</div>\n<blockquote>\n<p>So with outgoing reputation the final nodes in the jamming path get compensated. And with incoming reputation the initial nodes in the jamming path get compensated.</p>\n</blockquote>\n</aside>\n<p>Correct.</p>\n<aside class=\"quote no-group\" data-username=\"morehouse\" data-post=\"8\" data-topic=\"1147\" data-full=\"true\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/letter_avatar_proxy/v4/letter/m/df705f/48.png\" class=\"avatar\"> morehouse:</div>\n<blockquote>\n<p>Consider a simple example:</p>\n<pre data-code-height=\"59\" data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">graph LR \nM0 --- A --- T --- B --- M1\n</code></pre>\n<p><code>M0</code> builds reputation with <code>A</code>, <code>M1</code> builds reputation with <code>B</code>, and then the malicious nodes jam the <code>A-T</code> and <code>T-B</code> channels.  <code>T</code> gets nothing in this case.</p>\n</blockquote>\n</aside>\n<p>For honest node A to be able to send endorsed payments to <code>T</code>, they need to have paid <code>T</code> enough in the last 6 months over <code>A-T</code> to compensate them for their revenue from <code>T-B</code>. So while <code>T</code> hasn\u2019t been paid by the attacker, they\u2019ve still been compensated for the damage that abusing that reputation can do.</p>\n<p>Where bi-directional reputation helps is that it forces the attacker to pay to attach to this chain of existing reputation; without it, <code>M0</code> can take advantage of <code>A</code>\u2019s reputation with <code>T</code> without compensating <code>A</code> at all.</p>\n<aside class=\"quote no-group\" data-username=\"morehouse\" data-post=\"8\" data-topic=\"1147\" data-full=\"true\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/letter_avatar_proxy/v4/letter/m/df705f/48.png\" class=\"avatar\"> morehouse:</div>\n<blockquote>\n<p>In general, the problem gets worse the more intermediate nodes there are.</p>\n</blockquote>\n</aside>\n<p>The issue here doesn\u2019t seem to be compensation under attack, but rather how this chain of nodes will recover after an attack. If we think about this in multiple \u201crounds\u201d of two weeks (the period our reputation algorithm looks at):</p>\n<ul>\n<li>Round 1: attacker builds reputation and jams, nodes are compensated</li>\n<li>Round 2: attacker has lost reputation from attack, but chain has lost reputation</li>\n</ul>\n<p>Since we\u2019re aiming to protect revenue, not reputation itself, the chain of honest nodes runs into issues if they\u2019re general jammed in round 2 because some nodes\u2019 reputation will have been knocked out and they\u2019re not able to re-build it using general resources.</p>\n<p>This is because:</p>\n<ol>\n<li>Reputation is only focused on a 2 week horizon, so it is only compensating for that period exactly.</li>\n<li>General jamming is trivial for an extended period of time.</li>\n</ol>\n<p>We\u2019re going to look into some options for both of these!</p>\n<aside class=\"quote no-group\" data-username=\"morehouse\" data-post=\"8\" data-topic=\"1147\" data-full=\"true\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/letter_avatar_proxy/v4/letter/m/df705f/48.png\" class=\"avatar\"> morehouse:</div>\n<blockquote>\n<p>Thus once the attacker has enough reputation to route a single endorsed HTLC, they can actually do ~24x as much jamming and reputation damage (8 HTLC cycles * 3 target channels).</p>\n</blockquote>\n</aside>\n<p>I don\u2019t think that this can easily be translated to a loop. If <code>T0</code> has enough reputation with <code>T1</code> to get 8 HTLCs in flight, the <code>T0-T1</code> channel will be quite valuable to <code>T0</code>. Transitively, <code>M0</code> will need to meet quite a high threshold to get to that one endorsed HTLC, and will have to compensate <code>T0</code> accordingly. My intuition is that it wouldn\u2019t work out so advantageously for the attacker here, but we can take a look at some numbers.</p>\n<p>Cheers,</p>\n<p>Clara (posting on Carla\u2019s behalf while she\u2019s OOO)</p>",
  "post_number": 11,
  "post_type": 1,
  "updated_at": "2025-02-22T03:08:42.132Z",
  "reply_count": 0,
  "reply_to_post_number": 8,
  "quote_count": 1,
  "incoming_link_count": 0,
  "reads": 2,
  "readers_count": 1,
  "score": 0.4,
  "yours": false,
  "topic_id": 1147,
  "topic_slug": "hybrid-jamming-mitigation-results-and-updates",
  "topic_title": "Hybrid Jamming Mitigation: Results and Updates",
  "topic_html_title": "Hybrid Jamming Mitigation: Results and Updates",
  "category_id": 7,
  "display_username": "",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"morehouse, post:8, topic:1147, full:true\"]\nSo I presume the delta variance is entirely from fluctuations in the target node's incoming revenue?\n[/quote]\n\nYes, we\u2019re looking at forwards over a series of incoming channels, so so reputation will fluctuate with the incoming channel and the HTLC amount.\n\n[quote=\"morehouse, post:8, topic:1147, full:true\"]\nI\u2019m also curious how you chose to exclude outliers and how the graph looks with them included.\n[/quote]\n\n<details>  \n <summary>Script we used for outliers and a graph with no outlier removal here. </summary>  \n\n```python\nimport sys\nimport os\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom datetime import datetime, timedelta\n\nif len(sys.argv) != 3:\n    print(\"Usage: python reputation_graph.py <file> <channel_id>\")\n    sys.exit(1)\n\nfile_path = sys.argv[1]\nchannel_id = int(sys.argv[2])\n\n# Load CSV data\ndf = pd.read_csv(file_path)\n\n# Ensure ts_offset_ns column exists and convert to datetime\ndf['ts_offset_ns'] = pd.to_numeric(df['ts_offset_ns'])\n\n# Normalize ts_offset_ns to start from zero\ndf['normalized_ts_ns'] = df['ts_offset_ns'] - df['ts_offset_ns'].min()\n\n# Filter for the specified outgoing channel ID\ndf_filtered = df[df['outgoing_channel_id'] == channel_id].copy()\n\n# Check if the filtered DataFrame is empty\nif df_filtered.empty:\n    print(f\"No data found for outgoing_channel_id {channel_id}.\")\n    sys.exit(1)\n\n# Sort by normalized timestamp\ndf_filtered = df_filtered.sort_values(by='normalized_ts_ns')\n\n# Calculate reputation delta\ndf_filtered['reputation_delta'] = (\n    df_filtered['outgoing_reputation'] - df_filtered['in_flight_risk'] \n    - df_filtered['htlc_risk'] - df_filtered['incoming_revenue']\n)\n\n# Remove outliers\noutlier_threshold = 1\nif len(df_filtered['reputation_delta']) > 0:\n    lower_percentile = np.percentile(df_filtered['reputation_delta'], outlier_threshold)\n    upper_percentile = np.percentile(df_filtered['reputation_delta'], 100 - outlier_threshold)\n    df_smooth = df_filtered[(df_filtered['reputation_delta'] >= lower_percentile) & (df_filtered['reputation_delta'] <= upper_percentile)]\nelse:\n    df_smooth = df_filtered\n\n# Calculate Exponential Moving Average (EMA)\nalpha = 0.01  # Adjust for decay rate\nif not df_smooth.empty:\n    df_smooth['ema'] = df_smooth['reputation_delta'].ewm(alpha=alpha).mean()\n\n    # Plot\n    plt.figure(figsize=(10, 6))\n    plt.plot(df_smooth['normalized_ts_ns'], df_smooth['reputation_delta'], 'o', label='Reputation Delta No Outliers', alpha=0.7)\n    plt.plot(df_smooth['normalized_ts_ns'], df_smooth['ema'], label='Exponential Moving Average', linewidth=2)\n    plt.axhline(0, color='red', linewidth=2, linestyle='--', label='Zero Line')\n\n    plt.title('Reputation Delta with Moving Decaying Average')\n    plt.xlabel('Timestamp Offset (ns) from Start')\n    plt.ylabel('Reputation Delta')\n    plt.xticks(rotation=45)\n    plt.legend()\n    plt.tight_layout()\n\n    # Save graph\n    output_dir = os.path.dirname(file_path)\n    file_name = os.path.basename(file_path).rsplit('.', 1)[0]\n    output_path = os.path.join(output_dir, f\"{file_name}_reputation.png\")\n    plt.savefig(output_path)\n\n    print(f\"Graph saved to {output_path}\")\nelse:\n    print(f\"No data available to plot after outlier removal for channel_id {channel_id}.\")\n```\n\n</details>\n\nTurns out there isn\u2019t much of a difference for this experiment - in some of the others there was one large negative point which made it difficult to see the gradient of the exponential moving average.\n**![|624x375](upload://co16BAznf3meGljzkJDa0bMo32W.png)**\n\n[quote=\"morehouse, post:8, topic:1147, full:true\"]\nSo with outgoing reputation the final nodes in the jamming path get compensated. And with incoming reputation the initial nodes in the jamming path get compensated.\n[/quote]\n\nCorrect.\n\n\n[quote=\"morehouse, post:8, topic:1147, full:true\"]\nConsider a simple example:\n\n```mermaid height=59,auto\ngraph LR \nM0 --- A --- T --- B --- M1\n```\n\n`M0` builds reputation with `A`, `M1` builds reputation with `B`, and then the malicious nodes jam the `A-T` and `T-B` channels.  `T` gets nothing in this case.\n[/quote]\n\nFor honest node A to be able to send endorsed payments to `T`, they need to have paid `T` enough in the last 6 months over `A-T` to compensate them for their revenue from `T-B`. So while `T` hasn\u2019t been paid by the attacker, they\u2019ve still been compensated for the damage that abusing that reputation can do. \n\nWhere bi-directional reputation helps is that it forces the attacker to pay to attach to this chain of existing reputation; without it, `M0` can take advantage of `A`\u2019s reputation with `T` without compensating `A` at all.\n\n\n[quote=\"morehouse, post:8, topic:1147, full:true\"]\n In general, the problem gets worse the more intermediate nodes there are.\n[/quote]\n\nThe issue here doesn\u2019t seem to be compensation under attack, but rather how this chain of nodes will recover after an attack. If we think about this in multiple \u201crounds\u201d of two weeks (the period our reputation algorithm looks at):\n\n* Round 1: attacker builds reputation and jams, nodes are compensated\n* Round 2: attacker has lost reputation from attack, but chain has lost reputation\n\nSince we\u2019re aiming to protect revenue, not reputation itself, the chain of honest nodes runs into issues if they\u2019re general jammed in round 2 because some nodes' reputation will have been knocked out and they\u2019re not able to re-build it using general resources.\n\nThis is because:\n\n1. Reputation is only focused on a 2 week horizon, so it is only compensating for that period exactly.\n2. General jamming is trivial for an extended period of time.\n\nWe\u2019re going to look into some options for both of these!\n\n[quote=\"morehouse, post:8, topic:1147, full:true\"]\nThus once the attacker has enough reputation to route a single endorsed HTLC, they can actually do ~24x as much jamming and reputation damage (8 HTLC cycles * 3 target channels).\n[/quote]\n\nI don\u2019t think that this can easily be translated to a loop. If `T0` has enough reputation with `T1` to get 8 HTLCs in flight, the `T0-T1` channel will be quite valuable to `T0`. Transitively, `M0` will need to meet quite a high threshold to get to that one endorsed HTLC, and will have to compensate `T0` accordingly. My intuition is that it wouldn\u2019t work out so advantageously for the attacker here, but we can take a look at some numbers.\n\n\nCheers,\n\nClara (posting on Carla\u2019s behalf while she\u2019s OOO)",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 310,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": "downloaded local copies of images",
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}