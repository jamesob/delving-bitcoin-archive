{
  "id": 4204,
  "name": "Pieter Wuille",
  "username": "sipa",
  "avatar_template": "/user_avatar/delvingbitcoin.org/sipa/{size}/102_2.png",
  "created_at": "2025-02-06T18:16:54.745Z",
  "cooked": "<aside class=\"quote no-group quote-modified\" data-username=\"sipa\" data-post=\"24\" data-topic=\"303\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/sipa/48/102_2.png\" class=\"avatar\"> sipa:</div>\n<blockquote>\n<p>My belief was that since there can exist O(2^n)O(2n)O(2^n) different-feerate chunks, an algorithm like this needs extra work to remove previous chunks to avoid the blowup</p>\n</blockquote>\n</aside>\n<p>Just in case I confused you here: I was trying to explain why this ascending property you mention later wasn\u2019t obvious to me earlier. It doesn\u2019t matter, it makes sense to me now.</p>\n<aside class=\"quote no-group\" data-username=\"stefanwouldgo\" data-post=\"25\" data-topic=\"303\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/stefanwouldgo/48/664_2.png\" class=\"avatar\"> stefanwouldgo:</div>\n<blockquote>\n<p>I\u2019m not quite sure I understand your question.</p>\n</blockquote>\n</aside>\n<p>My question was whether I had understood things correctly; given your responses, I believe that was indeed the case.</p>\n<aside class=\"quote no-group\" data-username=\"stefanwouldgo\" data-post=\"25\" data-topic=\"303\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/stefanwouldgo/48/664_2.png\" class=\"avatar\"> stefanwouldgo:</div>\n<blockquote>\n<p>I know. But the structure that I have just tried to explain appears to guarantee that we can check if we can find a better diagram for the cluster including the new RBF tx by calculating a min-cut at the breakpoints of the combined conflicting diagram. In this way we might not find the optimal chunking, but we can decide if it is better than what we already have.</p>\n</blockquote>\n</aside>\n<p>I see now. That may work, but it\u2019s probably premature optimization. Just evaluating the new diagram at all the old diagram breakpoints may be just as hard as just computing the new diagram?</p>\n<aside class=\"quote no-group\" data-username=\"stefanwouldgo\" data-post=\"25\" data-topic=\"303\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/stefanwouldgo/48/664_2.png\" class=\"avatar\"> stefanwouldgo:</div>\n<blockquote>\n<p>I think the minimum unit of time in which this kind of algorithm can be useful is the time it takes to calculate a min-cut.</p>\n</blockquote>\n</aside>\n<p>That may be somewhat unfortunate. I was hoping it would be possible to spend some time finding <em>some</em> cut (not necessarily the minimal one), and then later revisit and find a better cut. Because even just finding a single min-cut is <span class=\"math\">O(n^3)</span> as I understand it (if <span class=\"math\">m = O(n^2)</span>), which is probably too much.</p>\n<aside class=\"quote no-group\" data-username=\"stefanwouldgo\" data-post=\"25\" data-topic=\"303\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/stefanwouldgo/48/664_2.png\" class=\"avatar\"> stefanwouldgo:</div>\n<blockquote>\n<p>But it is always easy to get a linearization of any cluster by simply sorting it topologically. From there, with every min-cut we calculate, we can find an optimal chunk to put at the beginning of a linearization.</p>\n</blockquote>\n</aside>\n<p>Right, but doing this in a \u201ctime-restricted\u201d setting means you might end up with a linearization where the beginning is optimal, but the end is terrible, which might be undesirable.</p>\n<aside class=\"quote no-group\" data-username=\"stefanwouldgo\" data-post=\"25\" data-topic=\"303\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/stefanwouldgo/48/664_2.png\" class=\"avatar\"> stefanwouldgo:</div>\n<blockquote>\n<p>Your LIMO algorithm might help here, but I haven\u2019t fully understood that yet.</p>\n</blockquote>\n</aside>\n<p>You can think of LIMO as repeatedly doing:</p>\n<ul>\n<li>Given a cluster with an existing linearization L for it\n<ul>\n<li>Loop:\n<ul>\n<li>Find a topological subset S with good feerate to move to the front.</li>\n<li>Compute L\u2019, which is L with with S moved to the front (leaving the order of transactions within S, and outside of S, unchanged from L).</li>\n<li>Compute L\u2019\u2019 as a merge of L and L\u2019, which has a diagram that\u2019s at least as good as the best of both everywhere.</li>\n<li>Output the first chunk of L\u2019\u2018, and continue with L as what remains of L\u2019'.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>I suspect this can be done in combination with the GGT approach, but the more interesting combination is if it can feed back too, i.e. the S set finding algorithm can be bootstrapped by using the first chunk of L at that point. This may be harder.</p>\n<p>I\u2019m currently polishing up an implementation of the spanning-forest algorithm, so that I don\u2019t forget the ideas I got while creating the writeup, and also to have a benchmark to target for future things (I think that comparing with the current exponential algorithm will be hard, as the style of graphs which are hard may differ wildly between exponential and GGT, but the difference between spanning-forest and GGT is probably smaller). After that, I plan to dig deeper into minimal-cut and GGT.</p>",
  "post_number": 26,
  "post_type": 1,
  "updated_at": "2025-02-06T18:16:54.745Z",
  "reply_count": 1,
  "reply_to_post_number": 25,
  "quote_count": 2,
  "incoming_link_count": 0,
  "reads": 9,
  "readers_count": 8,
  "score": 6.8,
  "yours": false,
  "topic_id": 303,
  "topic_slug": "how-to-linearize-your-cluster",
  "topic_title": "How to linearize your cluster",
  "topic_html_title": "How to linearize your cluster",
  "category_id": 8,
  "display_username": "Pieter Wuille",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"sipa, post:24, topic:303\"]\nMy belief was that since there can exist O(2^n)O(2n)O(2^n) different-feerate chunks, an algorithm like this needs extra work to remove previous chunks to avoid the blowup\n[/quote]\n\nJust in case I confused you here: I was trying to explain why this ascending property you mention later wasn't obvious to me earlier. It doesn't matter, it makes sense to me now.\n\n[quote=\"stefanwouldgo, post:25, topic:303\"]\nI\u2019m not quite sure I understand your question.\n[/quote]\n\nMy question was whether I had understood things correctly; given your responses, I believe that was indeed the case.\n\n[quote=\"stefanwouldgo, post:25, topic:303\"]\nI know. But the structure that I have just tried to explain appears to guarantee that we can check if we can find a better diagram for the cluster including the new RBF tx by calculating a min-cut at the breakpoints of the combined conflicting diagram. In this way we might not find the optimal chunking, but we can decide if it is better than what we already have.\n[/quote]\n\nI see now. That may work, but it's probably premature optimization. Just evaluating the new diagram at all the old diagram breakpoints may be just as hard as just computing the new diagram?\n\n[quote=\"stefanwouldgo, post:25, topic:303\"]\nI think the minimum unit of time in which this kind of algorithm can be useful is the time it takes to calculate a min-cut.\n[/quote]\n\nThat may be somewhat unfortunate. I was hoping it would be possible to spend some time finding *some* cut (not necessarily the minimal one), and then later revisit and find a better cut. Because even just finding a single min-cut is $O(n^3)$ as I understand it (if $m = O(n^2)$), which is probably too much.\n\n[quote=\"stefanwouldgo, post:25, topic:303\"]\nBut it is always easy to get a linearization of any cluster by simply sorting it topologically. From there, with every min-cut we calculate, we can find an optimal chunk to put at the beginning of a linearization.\n[/quote]\n\nRight, but doing this in a \"time-restricted\" setting means you might end up with a linearization where the beginning is optimal, but the end is terrible, which might be undesirable.\n\n[quote=\"stefanwouldgo, post:25, topic:303\"]\nYour LIMO algorithm might help here, but I haven\u2019t fully understood that yet.\n[/quote]\n\nYou can think of LIMO as repeatedly doing:\n* Given a cluster with an existing linearization L for it\n  * Loop:\n    * Find a topological subset S with good feerate to move to the front.\n    * Compute L', which is L with with S moved to the front (leaving the order of transactions within S, and outside of S, unchanged from L).\n    * Compute L'' as a merge of L and L', which has a diagram that's at least as good as the best of both everywhere.\n    * Output the first chunk of L'', and continue with L as what remains of L''.\n\nI suspect this can be done in combination with the GGT approach, but the more interesting combination is if it can feed back too, i.e. the S set finding algorithm can be bootstrapped by using the first chunk of L at that point. This may be harder.\n\nI'm currently polishing up an implementation of the spanning-forest algorithm, so that I don't forget the ideas I got while creating the writeup, and also to have a benchmark to target for future things (I think that comparing with the current exponential algorithm will be hard, as the style of graphs which are hard may differ wildly between exponential and GGT, but the difference between spanning-forest and GGT is probably smaller). After that, I plan to dig deeper into minimal-cut and GGT.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 96,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}