{
  "id": 4333,
  "name": "Matt Morehouse",
  "username": "morehouse",
  "avatar_template": "/letter_avatar_proxy/v4/letter/m/df705f/{size}.png",
  "created_at": "2025-02-19T18:28:29.521Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"t-bast\" data-post=\"1\" data-topic=\"1453\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/t-bast/48/98_2.png\" class=\"avatar\"> t-bast:</div>\n<blockquote>\n<p>A very simple proposal to fix that is to have the peer always sign two versions of HTLC transactions:</p>\n<ul>\n<li>the default one that doesn\u2019t pay any fee and needs additional on-chain inputs</li>\n<li>and another one in a custom TLV of <code>commitment_signed</code> at a high feerate that matches the currently observed feerate</li>\n<li>if the peer doesn\u2019t provide those signatures, the mobile wallet can force-close before revoking the commitment that doesn\u2019t contain the new HTLCs</li>\n</ul>\n</blockquote>\n</aside>\n<p>How will feerates be negotiated between the user and the LSP?  I think this might add some complexity\u2026</p>\n<h3><a name=\"p-4333-user-decides-lsp-acceptsrejects-1\" class=\"anchor\" href=\"#p-4333-user-decides-lsp-acceptsrejects-1\"></a>User decides, LSP accepts/rejects</h3>\n<p>If we just use what exists today, the user needs to periodically send <code>update_fee</code> to the LSP, so that the LSP uses the correct feerate when forwarding HTLCs to the user.  But if the user is offline for a while (as mobile users often are), the LSP may end up forwarding an HTLC with too low of a feerate.  In that case, the user would need to NACK the HTLC somehow.  Currently there\u2019s three ways to (kind of) do this:</p>\n<ol>\n<li>Accept the HTLC, sign updated commitments, and then fail it.</li>\n<li>Force close.</li>\n<li>Disconnect and reconnect with the peer.</li>\n</ol>\n<p>Option 1 might work if we\u2019re careful.  A state is created where the HTLC is accepted and the user\u2019s commitment+HTLC package won\u2019t confirm in a timely manner.  But the current HTLC is safe from theft because the user will fail it without revealing the preimage.  The only concern is theft of any <em>previous</em> HTLCs on the commitment for which the user has already revealed the preimage.  It seems like a rare corner case, but we\u2019d need to think carefully about how to avoid or get out of that situation.  Option 1 also has bad UX since the entire payment gets failed back to the sender even though the payment path was fine.</p>\n<p>Option 2 protects from theft, but also sucks from a UX perspective.  Especially if the the previous commitment has no HTLCs on it \u2013 then the user <em>can\u2019t</em> force close and would need to wait for the HTLC to expire and for the LSP to force close.</p>\n<p>In theory, Option 3 could work.  But in practice today\u2019s implementations simply resend the same commitment updates on reconnection, so I don\u2019t think the user would be able to do <code>update_fee</code> before the LSP resends the same commitment and HTLC signatures.</p>\n<h3><a name=\"p-4333-lsp-decides-user-acceptsrejects-2\" class=\"anchor\" href=\"#p-4333-lsp-decides-user-acceptsrejects-2\"></a>LSP decides, user accepts/rejects</h3>\n<p>The LSP could just choose the feerate on its own and use it when forwarding HTLCs to the user.  If the user thinks the feerate is too high/low, they (once again) need some way to NACK the HTLC.  In that case we have the same options and problems described above.</p>\n<p>To be fair, this feerate disagreement should only be expected during times of feerate spikes, which current lightning channels already have issues with.  But zero-fee commitments were supposed to fix this issue, so it\u2019s unfortunate that this approach brings it back.</p>\n<h3><a name=\"p-4333-add-a-new-nack-mechanism-3\" class=\"anchor\" href=\"#p-4333-add-a-new-nack-mechanism-3\"></a>Add a new NACK mechanism</h3>\n<p>I think there was discussion about adding a NACK mechanism to <code>option_simplified_update</code> at some point, but the <a href=\"https://github.com/lightning/bolts/pull/867\" rel=\"noopener nofollow ugc\">current spec proposal</a> doesn\u2019t have it.  We could either wait for that, or implement something special purpose for this case.  Either one is probably more work than we want.</p>",
  "post_number": 10,
  "post_type": 1,
  "updated_at": "2025-02-19T18:28:29.521Z",
  "reply_count": 1,
  "reply_to_post_number": null,
  "quote_count": 1,
  "incoming_link_count": 0,
  "reads": 10,
  "readers_count": 9,
  "score": 22.0,
  "yours": false,
  "topic_id": 1453,
  "topic_slug": "zero-fee-commitments-for-mobile-wallets",
  "topic_title": "Zero-fee commitments for mobile wallets",
  "topic_html_title": "Zero-fee commitments for mobile wallets",
  "category_id": 7,
  "display_username": "Matt Morehouse",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"t-bast, post:1, topic:1453\"]\nA very simple proposal to fix that is to have the peer always sign two versions of HTLC transactions:\n\n* the default one that doesn\u2019t pay any fee and needs additional on-chain inputs\n* and another one in a custom TLV of `commitment_signed` at a high feerate that matches the currently observed feerate\n* if the peer doesn\u2019t provide those signatures, the mobile wallet can force-close before revoking the commitment that doesn\u2019t contain the new HTLCs\n[/quote]\n\nHow will feerates be negotiated between the user and the LSP?  I think this might add some complexity...\n\n### User decides, LSP accepts/rejects\n\nIf we just use what exists today, the user needs to periodically send `update_fee` to the LSP, so that the LSP uses the correct feerate when forwarding HTLCs to the user.  But if the user is offline for a while (as mobile users often are), the LSP may end up forwarding an HTLC with too low of a feerate.  In that case, the user would need to NACK the HTLC somehow.  Currently there's three ways to (kind of) do this:\n\n1. Accept the HTLC, sign updated commitments, and then fail it.\n2. Force close.\n3. Disconnect and reconnect with the peer.\n\nOption 1 might work if we're careful.  A state is created where the HTLC is accepted and the user's commitment+HTLC package won't confirm in a timely manner.  But the current HTLC is safe from theft because the user will fail it without revealing the preimage.  The only concern is theft of any *previous* HTLCs on the commitment for which the user has already revealed the preimage.  It seems like a rare corner case, but we'd need to think carefully about how to avoid or get out of that situation.  Option 1 also has bad UX since the entire payment gets failed back to the sender even though the payment path was fine.\n\nOption 2 protects from theft, but also sucks from a UX perspective.  Especially if the the previous commitment has no HTLCs on it -- then the user *can't* force close and would need to wait for the HTLC to expire and for the LSP to force close.\n\nIn theory, Option 3 could work.  But in practice today's implementations simply resend the same commitment updates on reconnection, so I don't think the user would be able to do `update_fee` before the LSP resends the same commitment and HTLC signatures.\n\n### LSP decides, user accepts/rejects\n\nThe LSP could just choose the feerate on its own and use it when forwarding HTLCs to the user.  If the user thinks the feerate is too high/low, they (once again) need some way to NACK the HTLC.  In that case we have the same options and problems described above.\n\nTo be fair, this feerate disagreement should only be expected during times of feerate spikes, which current lightning channels already have issues with.  But zero-fee commitments were supposed to fix this issue, so it's unfortunate that this approach brings it back.\n\n### Add a new NACK mechanism\n\nI think there was discussion about adding a NACK mechanism to `option_simplified_update` at some point, but the [current spec proposal](https://github.com/lightning/bolts/pull/867) doesn't have it.  We could either wait for that, or implement something special purpose for this case.  Either one is probably more work than we want.",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 47,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}