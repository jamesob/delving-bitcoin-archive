{
  "id": 4137,
  "name": "Adam Gibson",
  "username": "AdamISZ",
  "avatar_template": "/user_avatar/delvingbitcoin.org/adamisz/{size}/418_2.png",
  "created_at": "2025-02-01T16:11:28.930Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"MattCorallo\" data-post=\"5\" data-topic=\"1407\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/letter_avatar_proxy/v4/letter/m/e47c2d/48.png\" class=\"avatar\"> MattCorallo:</div>\n<blockquote>\n<p>Why utreexo and groth16 vs much simpler UTXO snapshots and log-scale ring sigs? The ring sig approach has some overhead, but avoiding all the more complicated crypto seems well worth it</p>\n</blockquote>\n</aside>\n<p>IMHO the juice isn\u2019t worth the squeeze with the log scaled ring signature option, because the verification time (and compute too) is unavoidably linear in the set size. I just don\u2019t see much point in getting ring sizes of say a few thousand, which is still fragile anon-set-wise, and then also pay a lot in verifying time. To quote myself from an old blog post that <a href=\"https://gist.github.com/AdamISZ/03a5112172807ae614ccc34c55ed686e\" rel=\"noopener nofollow ugc\">implemented</a> triptych:</p>\n<blockquote>\n<p>You might naturally think, \u201ccool, let\u2019s do 100K keys or even more; it should still be pretty small\u201d. That\u2019s true. But the computation and verification costs, as discussed above w.r.t. Bootle15, are approximately linear in (N) and that means this will become impractical somewhere, depending on your coding efficiency. My guess from playing with the code in the gist above, is that with properly optimised code/algos, we can stay sub 1-3 seconds for these operations as long as we\u2019re in the 10K region or perhaps a little larger. But that\u2019s already a <em>huge</em> practical achievement, in my opinion (and \u2026 I\u2019m guessing).</p>\n</blockquote>\n<p>(from <a href=\"https://reyify.com/blog/little-riddle/\" rel=\"noopener nofollow ugc\">here</a>)</p>\n<p>Having said all of that, I still do get your point. It is at least conceivable. And on reflection maybe I\u2019m wrong that verifying time is so important; for <em>this</em> use case, I guess it\u2019s fine if it\u2019s somewhat slower(?).</p>\n<p><a class=\"mention\" href=\"/u/halseth\">@halseth</a> a couple of Qs, as I\u2019m also very interested to delve into understanding this better; it does look promising. Your <a href=\"https://github.com/halseth/output-zero/blob/15cfb6adcef11379c5601831a864e15fe09910dc/docs/musig2.md\" rel=\"noopener nofollow ugc\">gist</a> has an 80 second prove time for the un-wrapped, correct? Does the wrapped version take more time, if so how much more? Do we have a path to getting these numbers down, do you think?</p>\n<p>Clearly verif. is going to be cheap, and proof size naturally is at the ideal small O(1) for groth16. I need to study utreexo again and better understand how it fits into your circuit construction here before making other comments.</p>\n<p>I\u2019m glad to see in this thread there\u2019s discussion that realistically, we can just take regular snapshots of utxo set (or better, subset), and though we can\u2019t \u201cread\u201d channel closes in plaintext, it doesn\u2019t have to be a killer of this idea. For this reason I don\u2019t think either <a class=\"mention\" href=\"/u/halseth\">@halseth</a> 's work here, or aut-ct should be dismissed as a possibility based on \u201cit only proves ownership at one time\u201d. Other possibilities (like timelocks?) would I guess be really awkward.</p>\n<p>Re:</p>\n<blockquote>\n<p>Right, if we\u2019re gonna go ZK gossip we should remove this leak. No one cares about having the <em>exact</em> channel capacity, we should limit the precision of the announcements if we\u2019re still gonna tie proofs to channels.\nReally we should let people under-commit, though - commit to N BTC on chain, announce M*N BTC in channels (still probably with reduced precision).</p>\n</blockquote>\n<p>Wanted to mention, I added this kind of functionality - amount ranges, support for multiple utxos, in my aut-ct repo (see the <code>auditor-docs</code> subdirectory for details). People can generate concise proofs of aggregated-over-several-utxos total amount in a range (i.e. there is a range proof included in the bulletproofs circuit). If anyone\u2019s confused about how amounts fit in, just understand that the curve tree is not only a tree of pubkeys, it can be a tree of composite values (pubkey, amount) using a Pedersen commitment to both: C = P + vH + rJ for example. This idea is developed way further in <a class=\"mention\" href=\"/u/kayabanerve\">@kayabaNerve</a> 's <a href=\"https://github.com/kayabaNerve/fcmp-plus-plus/tree/develop\" rel=\"noopener nofollow ugc\">FCMP++</a> work.</p>\n<p>\u201cConcise\u201d in the above para. : maybe 2-4kB is not concise! There is some analysis <a href=\"https://github.com/AdamISZ/aut-ct/issues/19\" rel=\"noopener nofollow ugc\">here</a>. I always assumed that was fine, but for LN \u2026 perhaps it just isn\u2019t (?), even if there are other advantages like &lt; 100ms verification and 1-2 seconds for proof.</p>\n<p>Question for everybody:</p>\n<p>Something I often wondered is, could we use pairings based (e.g. KZG commitments) type stuff <em>if</em> we just make the tradeoff like this: every participant in LN, starting out with a new utxo or several, say, and has the utxo\u2019s pubkey sign a key on a pairing friendly curve. Then we can start using substantially more efficient crypto/ZK techniques with O(1) scaling for proofs and very cheap verifiers, but with the obvious tradeoff: the anon set is <em>only</em> the participants of \u201cthis system\u201d (what is \u201cthis\u201d? People would opt-in to adding their utxo to a list anonymously, and perhaps some altruistic volunteers also provide their non LN utxos to this list; kind of a fun thought!). An example of such a much-better-scaling system might be <a href=\"https://eprint.iacr.org/2022/621.pdf\" rel=\"noopener nofollow ugc\">Caulk</a> (just one example I happen to know is const. proof size and verif time, and log(N) proving compute \u2026 may not be the best).</p>",
  "post_number": 9,
  "post_type": 1,
  "updated_at": "2025-02-01T17:06:17.550Z",
  "reply_count": 1,
  "reply_to_post_number": 5,
  "quote_count": 1,
  "incoming_link_count": 0,
  "reads": 4,
  "readers_count": 3,
  "score": 5.6,
  "yours": false,
  "topic_id": 1407,
  "topic_slug": "zk-gossip-for-lightning-channel-announcements",
  "topic_title": "ZK-gossip for lightning channel announcements",
  "topic_html_title": "ZK-gossip for lightning channel announcements",
  "category_id": 7,
  "display_username": "Adam Gibson",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 3,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"MattCorallo, post:5, topic:1407\"]\nWhy utreexo and groth16 vs much simpler UTXO snapshots and log-scale ring sigs? The ring sig approach has some overhead, but avoiding all the more complicated crypto seems well worth it\n[/quote]\n\nIMHO the juice isn't worth the squeeze with the log scaled ring signature option, because the verification time (and compute too) is unavoidably linear in the set size. I just don't see much point in getting ring sizes of say a few thousand, which is still fragile anon-set-wise, and then also pay a lot in verifying time. To quote myself from an old blog post that [implemented](https://gist.github.com/AdamISZ/03a5112172807ae614ccc34c55ed686e) triptych:\n\n> You might naturally think, \"cool, let's do 100K keys or even more; it should still be pretty small\". That's true. But the computation and verification costs, as discussed above w.r.t. Bootle15, are approximately linear in (N) and that means this will become impractical somewhere, depending on your coding efficiency. My guess from playing with the code in the gist above, is that with properly optimised code/algos, we can stay sub 1-3 seconds for these operations as long as we're in the 10K region or perhaps a little larger. But that's already a *huge* practical achievement, in my opinion (and .. I'm guessing).\n\n(from [here](https://reyify.com/blog/little-riddle/))\n\nHaving said all of that, I still do get your point. It is at least conceivable. And on reflection maybe I'm wrong that verifying time is so important; for *this* use case, I guess it's fine if it's somewhat slower(?).\n\n@halseth a couple of Qs, as I'm also very interested to delve into understanding this better; it does look promising. Your [gist](https://github.com/halseth/output-zero/blob/15cfb6adcef11379c5601831a864e15fe09910dc/docs/musig2.md) has an 80 second prove time for the un-wrapped, correct? Does the wrapped version take more time, if so how much more? Do we have a path to getting these numbers down, do you think?\n\nClearly verif. is going to be cheap, and proof size naturally is at the ideal small O(1) for groth16. I need to study utreexo again and better understand how it fits into your circuit construction here before making other comments.\n\nI'm glad to see in this thread there's discussion that realistically, we can just take regular snapshots of utxo set (or better, subset), and though we can't \"read\" channel closes in plaintext, it doesn't have to be a killer of this idea. For this reason I don't think either @halseth 's work here, or aut-ct should be dismissed as a possibility based on \"it only proves ownership at one time\". Other possibilities (like timelocks?) would I guess be really awkward.\n\nRe: \n\n> Right, if we\u2019re gonna go ZK gossip we should remove this leak. No one cares about having the *exact* channel capacity, we should limit the precision of the announcements if we\u2019re still gonna tie proofs to channels.\nReally we should let people under-commit, though - commit to N BTC on chain, announce M*N BTC in channels (still probably with reduced precision).\n\nWanted to mention, I added this kind of functionality - amount ranges, support for multiple utxos, in my aut-ct repo (see the `auditor-docs` subdirectory for details). People can generate concise proofs of aggregated-over-several-utxos total amount in a range (i.e. there is a range proof included in the bulletproofs circuit). If anyone's confused about how amounts fit in, just understand that the curve tree is not only a tree of pubkeys, it can be a tree of composite values (pubkey, amount) using a Pedersen commitment to both: C = P + vH + rJ for example. This idea is developed way further in @kayabaNerve 's [FCMP++](https://github.com/kayabaNerve/fcmp-plus-plus/tree/develop) work.\n\n\"Concise\" in the above para. : maybe 2-4kB is not concise! There is some analysis [here](https://github.com/AdamISZ/aut-ct/issues/19). I always assumed that was fine, but for LN .. perhaps it just isn't (?), even if there are other advantages like < 100ms verification and 1-2 seconds for proof.\n\nQuestion for everybody:\n\nSomething I often wondered is, could we use pairings based (e.g. KZG commitments) type stuff *if* we just make the tradeoff like this: every participant in LN, starting out with a new utxo or several, say, and has the utxo's pubkey sign a key on a pairing friendly curve. Then we can start using substantially more efficient crypto/ZK techniques with O(1) scaling for proofs and very cheap verifiers, but with the obvious tradeoff: the anon set is *only* the participants of \"this system\" (what is \"this\"? People would opt-in to adding their utxo to a list anonymously, and perhaps some altruistic volunteers also provide their non LN utxos to this list; kind of a fun thought!). An example of such a much-better-scaling system might be [Caulk](https://eprint.iacr.org/2022/621.pdf) (just one example I happen to know is const. proof size and verif time, and log(N) proving compute .. may not be the best).",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 343,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}