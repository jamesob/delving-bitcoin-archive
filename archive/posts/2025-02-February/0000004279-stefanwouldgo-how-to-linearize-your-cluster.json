{
  "id": 4279,
  "name": "Stefanwouldgo",
  "username": "stefanwouldgo",
  "avatar_template": "/user_avatar/delvingbitcoin.org/stefanwouldgo/{size}/664_2.png",
  "created_at": "2025-02-11T10:44:34.778Z",
  "cooked": "<aside class=\"quote no-group quote-modified\" data-username=\"ajtowns\" data-post=\"41\" data-topic=\"303\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/ajtowns/48/417_2.png\" class=\"avatar\"> ajtowns:</div>\n<blockquote>\n<p>I haven\u2019t read the papers, but I\u2019m not following how you construct a network flow where solving a max flow / min cut gives you a subset of txs that maximises f_C - \\lambda s_CfC\u2212\u03bbsCf_C - \\lambda s_C for a given \\lambda\u03bb\\lambda.</p>\n</blockquote>\n</aside>\n<p>But that\u2019s just what the DeepSeek approach does. It finds a subset <span class=\"math\">C</span> with maximum weight under the side condition that <span class=\"math\">C</span> is a closure. And we choose the weight to be <span class=\"math\">f-\\lambda s</span> for all nodes. It\u2019s a closure because it\u2019s a min-cut, and the original edges get infinite capacity, so they are never cut. It maximizes weight because the size of the min-cut is exactly the sum of excluded nodes with positive weight plus the sum of included nodes with negative weight.</p>\n<p>The trick is that turning our feerate into a weight by introducing <span class=\"math\">\\lambda</span> lets us simply sum up the weights into total weight instead of directly optimizing a ratio.</p>\n<aside class=\"quote no-group quote-modified\" data-username=\"ajtowns\" data-post=\"41\" data-topic=\"303\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/ajtowns/48/417_2.png\" class=\"avatar\"> ajtowns:</div>\n<blockquote>\n<p>The <a href=\"https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303/15\">DeepSeek</a> approach seems like it could solve for a CCC that gives the largest feerate, by bisecting on different values for \\lambda\u03bb\\lambda, but that seems more like finding the breakpoints in order?</p>\n</blockquote>\n</aside>\n<p>No, bisection does not find them in order. It always finds the optimal improvement for the diagram in the interval you are looking at. And then you choose the next interval to look for.</p>",
  "post_number": 42,
  "post_type": 1,
  "updated_at": "2025-02-11T10:44:34.778Z",
  "reply_count": 0,
  "reply_to_post_number": 41,
  "quote_count": 1,
  "incoming_link_count": 0,
  "reads": 5,
  "readers_count": 4,
  "score": 1.0,
  "yours": false,
  "topic_id": 303,
  "topic_slug": "how-to-linearize-your-cluster",
  "topic_title": "How to linearize your cluster",
  "topic_html_title": "How to linearize your cluster",
  "category_id": 8,
  "display_username": "Stefanwouldgo",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"ajtowns, post:41, topic:303\"]\nI haven\u2019t read the papers, but I\u2019m not following how you construct a network flow where solving a max flow / min cut gives you a subset of txs that maximises f_C - \\lambda s_CfC\u2212\u03bbsCf_C - \\lambda s_C for a given \\lambda\u03bb\\lambda.\n[/quote]\n\nBut that's just what the DeepSeek approach does. It finds a subset $C$ with maximum weight under the side condition that $C$ is a closure. And we choose the weight to be $f-\\lambda s$ for all nodes. It's a closure because it's a min-cut, and the original edges get infinite capacity, so they are never cut. It maximizes weight because the size of the min-cut is exactly the sum of excluded nodes with positive weight plus the sum of included nodes with negative weight. \n\nThe trick is that turning our feerate into a weight by introducing $\\lambda$ lets us simply sum up the weights into total weight instead of directly optimizing a ratio. \n\n[quote=\"ajtowns, post:41, topic:303\"]\nThe [DeepSeek](https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303/15) approach seems like it could solve for a CCC that gives the largest feerate, by bisecting on different values for \\lambda\u03bb\\lambda, but that seems more like finding the breakpoints in order?\n[/quote]\n\nNo, bisection does not find them in order. It always finds the optimal improvement for the diagram in the interval you are looking at. And then you choose the next interval to look for.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 479,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}