{
  "id": 4143,
  "name": "Matt Corallo",
  "username": "MattCorallo",
  "avatar_template": "/letter_avatar_proxy/v4/letter/m/e47c2d/{size}.png",
  "created_at": "2025-02-01T19:18:18.695Z",
  "cooked": "<blockquote>\n<p>Depends on what you mean by \u201cefficient\u201d. My first implementation did build a merkle tree from the full utxo set dump, and that took about 10 minutes every time if I remember correctly (not optimized in any way).</p>\n</blockquote>\n<p>This seems pretty slow. Hashing the full UTXO set on my node (with a networkfed filesystem! though it seems to have mostly been hitting memory) only took 1:30. If we do that once every 6 hours that seems totally fine, honestly, especially since we\u2019d restrict to a subset of the UTXO set (eg taproot-only, outputs above value X, etc).</p>\n<aside class=\"quote no-group\" data-username=\"AdamISZ\" data-post=\"9\" data-topic=\"1407\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/adamisz/48/418_2.png\" class=\"avatar\"> AdamISZ:</div>\n<blockquote>\n<p>IMHO the juice isn\u2019t worth the squeeze with the log scaled ring signature option, because the verification time (and compute too) is unavoidably linear in the set size. I just don\u2019t see much point in getting ring sizes of say a few thousand, which is still fragile anon-set-wise, and then also pay a lot in verifying time.</p>\n</blockquote>\n</aside>\n<p>Shucks. Then it seems we\u2019re right back where we were three years ago - this is in theory a great idea, we know we want to do it, we even have some ideas for optimizations for it, but ultimately there simply is no suitable proof scheme with a mature implementation space.</p>\n<blockquote>\n<p>And on reflection maybe I\u2019m wrong that verifying time is so important; for <em>this</em> use case, I guess it\u2019s fine if it\u2019s somewhat slower(?).</p>\n</blockquote>\n<p>This was, sadly, not my point. Verification in the 1-3 second range is already probably too slow here (though if we can batch, verification in the 60+ second range may be totally fine!).</p>\n<blockquote>\n<p>Something I often wondered is, could we use pairings based (e.g. KZG commitments) type stuff <em>if</em> we just make the tradeoff like this: every participant in LN, starting out with a new utxo or several, say, and has the utxo\u2019s pubkey sign a key on a pairing friendly curve\u2026the anon set is <em>only</em> the participants of \u201cthis system\u201d</p>\n</blockquote>\n<p>I mean its better than what we have today, so\u2026sure? The real issue that we\u2019ve run into is that we can only use stuff where there\u2019s robust implementations that all lightning nodes are happy to take as a dependency (and/or is simple enough for there to be multiple implementations!). In our previous searches, that was far from the case\u2026there\u2019s plenty of ZK implementations of various algorithms, but most of them are kinda meh on quality, and the ones that are better are often more generic than we need (we could optimize a lot by not trying to verify secp256k1 curve ops in RISC-V) or impractical to build our own proof system using. The state of things may be better here than it was three years ago when we last looked, so happy to be proven wrong!</p>",
  "post_number": 10,
  "post_type": 1,
  "updated_at": "2025-02-01T19:18:18.695Z",
  "reply_count": 1,
  "reply_to_post_number": 9,
  "quote_count": 1,
  "incoming_link_count": 0,
  "reads": 8,
  "readers_count": 7,
  "score": 6.6,
  "yours": false,
  "topic_id": 1407,
  "topic_slug": "zk-gossip-for-lightning-channel-announcements",
  "topic_title": "ZK-gossip for lightning channel announcements",
  "topic_html_title": "ZK-gossip for lightning channel announcements",
  "category_id": 7,
  "display_username": "Matt Corallo",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": ">  Depends on what you mean by \u201cefficient\u201d. My first implementation did build a merkle tree from the full utxo set dump, and that took about 10 minutes every time if I remember correctly (not optimized in any way).\n\nThis seems pretty slow. Hashing the full UTXO set on my node (with a networkfed filesystem! though it seems to have mostly been hitting memory) only took 1:30. If we do that once every 6 hours that seems totally fine, honestly, especially since we'd restrict to a subset of the UTXO set (eg taproot-only, outputs above value X, etc).\n\n[quote=\"AdamISZ, post:9, topic:1407\"]\nIMHO the juice isn\u2019t worth the squeeze with the log scaled ring signature option, because the verification time (and compute too) is unavoidably linear in the set size. I just don\u2019t see much point in getting ring sizes of say a few thousand, which is still fragile anon-set-wise, and then also pay a lot in verifying time.\n[/quote]\n\nShucks. Then it seems we're right back where we were three years ago - this is in theory a great idea, we know we want to do it, we even have some ideas for optimizations for it, but ultimately there simply is no suitable proof scheme with a mature implementation space.\n\n> And on reflection maybe I\u2019m wrong that verifying time is so important; for *this* use case, I guess it\u2019s fine if it\u2019s somewhat slower(?).\n\nThis was, sadly, not my point. Verification in the 1-3 second range is already probably too slow here (though if we can batch, verification in the 60+ second range may be totally fine!).\n\n> Something I often wondered is, could we use pairings based (e.g. KZG commitments) type stuff *if* we just make the tradeoff like this: every participant in LN, starting out with a new utxo or several, say, and has the utxo\u2019s pubkey sign a key on a pairing friendly curve...the anon set is *only* the participants of \u201cthis system\u201d\n\nI mean its better than what we have today, so...sure? The real issue that we've run into is that we can only use stuff where there's robust implementations that all lightning nodes are happy to take as a dependency (and/or is simple enough for there to be multiple implementations!). In our previous searches, that was far from the case...there's plenty of ZK implementations of various algorithms, but most of them are kinda meh on quality, and the ones that are better are often more generic than we need (we could optimize a lot by not trying to verify secp256k1 curve ops in RISC-V) or impractical to build our own proof system using. The state of things may be better here than it was three years ago when we last looked, so happy to be proven wrong!",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 50,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}