{
  "id": 4235,
  "name": "Adam Gibson",
  "username": "AdamISZ",
  "avatar_template": "/user_avatar/delvingbitcoin.org/adamisz/{size}/418_2.png",
  "created_at": "2025-02-09T16:20:45.895Z",
  "cooked": "<p>Yes, I believe that works. So the process would be:</p>\n<p>(The following is modifications to Algorithm 2 per the doc): Alice provides:</p>\n<ul>\n<li>the unsigned transaction template for TX1, with the output address now being (taproot) key <span class=\"math\">X</span></li>\n<li><span class=\"math\">T</span></li>\n<li><span class=\"math\">\\pi_a</span> which now is modified to prove that <span class=\"math\">X = (a_1 + x_a)T</span> OR <span class=\"math\">=(a_2 + x_a)T</span> and additionally proves knowledge of the DL of <span class=\"math\">T</span> (or just sign on it, same thing). Using formal notation it becomes <span class=\"math\">R_a =   \\{a_1, a_2, t, x_a: H_1, H_2, T, P_a, X, G: \\\\ a_1 G = A_1 \\land a_2G = A_2 \\land  T = tG \\land \\textrm{hash}_p(A_1) = h_1 \\land \\textrm{hash}_p(A_2) = h_2 \\\\\n\\land H_1 = h_1 G \\land H_2 = h_2G \\\\\n\\land (X = t(P_a + A_1) \\lor X = t(P_a + A_2)) \\}</span></li>\n</ul>\n<p>To explain the next steps, though, we need a slight sidetrack: <span class=\"math\">X</span> is now not the output address <span class=\"math\">\\textrm{addr}_a</span>! The reason I say that is, we need to use an adaptor secret atomic revelation in signing (which plays the role analogous to the fact that in a hashlock output signing, you reveal the hash preimage, i.e. the pubkey), and to make that enforced, you need fixed <span class=\"math\">R</span>, which can only be accomplished by a collaborative signing.</p>\n<p>So we define <span class=\"math\">\\textrm{addr}_a</span> as MuSig(<span class=\"math\">X</span>, <span class=\"math\">P_b</span>). Using the simpler MuSig1 model the process would be:</p>\n<ul>\n<li><span class=\"math\">X</span> and <span class=\"math\">P_b</span> are the input pubkeys. Hashes of the two participant nonces <span class=\"math\">H(R_a)</span>, <span class=\"math\">H(R_b)</span> are shared as usual then <span class=\"math\">R_a, R_b</span> are shared. <span class=\"math\">P_{agg}</span> is calculated as normal from each key.</li>\n<li>Bob gives his partial sig on the TX1 message <span class=\"math\">m</span>, so <span class=\"math\">\\sigma_b = k_b + H(R_{agg} + T, P_{agg}, m)x_b</span></li>\n<li>Alice gives adaptor on her partial: <span class=\"math\">\\sigma_a' = k_a + H(R_{agg} + T, P_{agg}, m)x</span> where <span class=\"math\">x = t(x_a + a_1)</span> (if <span class=\"math\">a_1</span> was chosen).</li>\n<li>Bob verifies the adaptor to ensure that <span class=\"math\">t</span> will be revealed, by doing <span class=\"math\">\\sigma_a' G \\stackrel{?}{=} R_a + H(R_{agg} + T, P_{agg}, m)X</span></li>\n</ul>\n<p>(To be clear, I am not asserting that this is secure, because it does have at least one feature that is very non-standard: the private key for the signature adaptor depends on the adaptor secret <span class=\"math\">x = t(x_a + a_1)</span>. I actually really doubt that that is a security problem, since all of the RHS there is secret, but I\u2019m certainly not claiming to <em>know</em> it\u2019s secure.)</p>\n<p>At this point Bob is convinced that Alice\u2019s behaviour is correct, and proceeds to do the other side: choosing say <span class=\"math\">H_1</span> he\u2019ll construct <span class=\"math\">\\textrm{addr}_b</span> as <span class=\"math\">t_b(P_b + H_1)</span>. The situation is not entirely symmetrical: he <em>does</em> need to convince Alice that the address has the given structure, so the ZKP is needed (basically proving that it is <span class=\"math\">H_1 \\lor H_2</span>). And it still needs to be hidden from Alice, so we still need some blinding factor, hence <span class=\"math\">t_b</span>. But we do <em>not</em> need any adaptor secret business here; Alice doesn\u2019t need to extract the key, only wait for a timeout.\nSo just for completeness, Bob\u2019s ZKP will now be (not much changed):\n<span class=\"math\">R_b =   \\{P_b, \\sigma, t_b: H_1, H_2, X_b, G:\n\\textrm{sigVer}(\\sigma, P_b, X_b) = \\textrm{true} \\\\\n\\land (X_b = t_b(P_b + H_1) \\lor X_b = t_b(P_b + H_2)) \\}</span></p>\n<p>with of course <span class=\"math\">X_b = \\textrm{addr}_b</span> and <span class=\"math\">\\sigma</span> being as described in Algo. 2.</p>\n<p>With this structure, when Alice broadcasts, with her signature <span class=\"math\">\\sigma_a</span> she will reveal <span class=\"math\">t = \\sigma_a - \\sigma_a'</span>. Bob can then extract the <span class=\"math\">A_{1,2}</span> value by calculating <span class=\"math\">t^{-1}X = P_a + A_{1,2}</span> and subtracting <span class=\"math\">P_a</span>, from there getting the necessary tweak value <span class=\"math\">h_{1,2}</span> to spend the coin if he won the bet.</p>\n<p>Obviously this (a) makes it more complicated, at least somewhat, but it was already interactive so at least that part is not a stretch and (b) this is a rough draft and it might need modifying. The reason it interests me is I think you could make \u201cnative\u201d ZKPs work with good performance here (i.e. not slow proving) using bulletproofs, the circuits would be very small, heck, you could even just use generalised schnorr proofs.</p>",
  "post_number": 7,
  "post_type": 1,
  "updated_at": "2025-02-09T16:20:45.895Z",
  "reply_count": 0,
  "reply_to_post_number": 6,
  "quote_count": 0,
  "incoming_link_count": 46,
  "reads": 7,
  "readers_count": 6,
  "score": 231.4,
  "yours": false,
  "topic_id": 1409,
  "topic_slug": "emulating-op-rand",
  "topic_title": "Emulating OP_RAND",
  "topic_html_title": "Emulating OP_RAND",
  "category_id": 7,
  "display_username": "Adam Gibson",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "reply_to_user": {
    "username": "ajtowns",
    "name": "Anthony Towns",
    "avatar_template": "/user_avatar/delvingbitcoin.org/ajtowns/{size}/417_2.png"
  },
  "bookmarked": false,
  "raw": "Yes, I believe that works. So the process would be:\n\n(The following is modifications to Algorithm 2 per the doc): Alice provides:\n\n* the unsigned transaction template for TX1, with the output address now being (taproot) key $X$\n* $T$\n* $\\pi_a$ which now is modified to prove that $X = (a_1 + x_a)T$ OR $=(a_2 + x_a)T$ and additionally proves knowledge of the DL of $T$ (or just sign on it, same thing). Using formal notation it becomes $R_a =   \\{a_1, a_2, t, x_a: H_1, H_2, T, P_a, X, G: \\\\ a_1 G = A_1 \\land a_2G = A_2 \\land  T = tG \\land \\textrm{hash}_p(A_1) = h_1 \\land \\textrm{hash}_p(A_2) = h_2 \\\\\n\\land H_1 = h_1 G \\land H_2 = h_2G \\\\\n\\land (X = t(P_a + A_1) \\lor X = t(P_a + A_2)) \\}$\n\nTo explain the next steps, though, we need a slight sidetrack: $X$ is now not the output address $\\textrm{addr}_a$! The reason I say that is, we need to use an adaptor secret atomic revelation in signing (which plays the role analogous to the fact that in a hashlock output signing, you reveal the hash preimage, i.e. the pubkey), and to make that enforced, you need fixed $R$, which can only be accomplished by a collaborative signing.\n\nSo we define $\\textrm{addr}_a$ as MuSig($X$, $P_b$). Using the simpler MuSig1 model the process would be:\n\n* $X$ and $P_b$ are the input pubkeys. Hashes of the two participant nonces $H(R_a)$, $H(R_b)$ are shared as usual then $R_a, R_b$ are shared. $P_{agg}$ is calculated as normal from each key.\n* Bob gives his partial sig on the TX1 message $m$, so $\\sigma_b = k_b + H(R_{agg} + T, P_{agg}, m)x_b$\n* Alice gives adaptor on her partial: $\\sigma_a' = k_a + H(R_{agg} + T, P_{agg}, m)x$ where $x = t(x_a + a_1)$ (if $a_1$ was chosen).\n* Bob verifies the adaptor to ensure that $t$ will be revealed, by doing $\\sigma_a' G \\stackrel{?}{=} R_a + H(R_{agg} + T, P_{agg}, m)X$ \n\n(To be clear, I am not asserting that this is secure, because it does have at least one feature that is very non-standard: the private key for the signature adaptor depends on the adaptor secret $x = t(x_a + a_1)$. I actually really doubt that that is a security problem, since all of the RHS there is secret, but I'm certainly not claiming to *know* it's secure.)\n\nAt this point Bob is convinced that Alice's behaviour is correct, and proceeds to do the other side: choosing say $H_1$ he'll construct $\\textrm{addr}_b$ as $t_b(P_b + H_1)$. The situation is not entirely symmetrical: he *does* need to convince Alice that the address has the given structure, so the ZKP is needed (basically proving that it is $H_1 \\lor H_2$). And it still needs to be hidden from Alice, so we still need some blinding factor, hence $t_b$. But we do *not* need any adaptor secret business here; Alice doesn't need to extract the key, only wait for a timeout.\nSo just for completeness, Bob's ZKP will now be (not much changed):\n$R_b =   \\{P_b, \\sigma, t_b: H_1, H_2, X_b, G:\n\\textrm{sigVer}(\\sigma, P_b, X_b) = \\textrm{true} \\\\\n\\land (X_b = t_b(P_b + H_1) \\lor X_b = t_b(P_b + H_2)) \\}$\n\nwith of course $X_b = \\textrm{addr}_b$ and $\\sigma$ being as described in Algo. 2.\n\nWith this structure, when Alice broadcasts, with her signature $\\sigma_a$ she will reveal $t = \\sigma_a - \\sigma_a'$. Bob can then extract the $A_{1,2}$ value by calculating $t^{-1}X = P_a + A_{1,2}$ and subtracting $P_a$, from there getting the necessary tweak value $h_{1,2}$ to spend the coin if he won the bet.\n\nObviously this (a) makes it more complicated, at least somewhat, but it was already interactive so at least that part is not a stretch and (b) this is a rough draft and it might need modifying. The reason it interests me is I think you could make \"native\" ZKPs work with good performance here (i.e. not slow proving) using bulletproofs, the circuits would be very small, heck, you could even just use generalised schnorr proofs.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 343,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}