{
  "id": 5700,
  "name": "Zawy",
  "username": "zawy",
  "avatar_template": "/user_avatar/delvingbitcoin.org/zawy/{size}/750_2.png",
  "created_at": "2025-08-13T16:31:09.455Z",
  "cooked": "<p>Experimentally, given b blocks seen, a difficulty, and a uniformly random number of hashes, the Poisson equation seems to need a (b+1)/b correction which is in the opposite direction I had guessed. It\u2019s accurate down to b=1. This makes me wonder if my OP about hashrate needing a correction is correct. In the hashrate case, we\u2019re specifying a number of blocks to look at and the correction (N-1)/N is, in my intuition, based on converting it to be in a fixed amount of time, as in this case. But this is showing that if hashes per that fixed time are uniformly random, an (N+1)/N correction is also needed, giving a net N-1/N correction, or no net correction if our (N-1)/N is really supposed to be N/(N+1). This makes more sense to my intuitive interpretation.</p>\n<p>This correction is if work and therefore \u03bb are uniformly random, which may not be an assumption we should use when adjusting difficulty or checking hashrate.</p>\n<p>Output:</p>\n<pre><code class=\"lang-auto\">target/max_target = 0.0100\nb = 5, runs = 100000\nruns that had b blocks = 6156\nMean work when b blocks were seen = 600\nPoisson_work = b * max_target/target = 500\nPoisson_work * (b+1)/b = 600\nStdev work / mean_work when b blocks were seen = 0.409 \nStdDev 1/SQRT(b+1)= 0.408\n</code></pre>\n<p>Code:</p>\n<pre><code class=\"lang-auto\">import random\nimport statistics\n\n# Mean work for a given difficulty and given number of blocks found if work is uniformly random in a fixed amount of time. \n\nruns = 100000 # number of times to do the experiment  \nwork_if_b_blocks_found = []\nb = 5 # a given number of found blocks\nmax_target = pow(2,256)\ntarget = 0.01*max_target # difficulty target\nmax_work = int((1+5/pow(b,0.5))*b*max_target/target) # get 5 StdDev's more than estimated mean hashes needed\nPoisson_work = b * max_target / target\nfor i in range(1, runs):     \n    work = int(random.random()*max_work)  # perform random # of hashes\n    if work &lt; b: continue\n    hash_list = [random.random()*max_target for _ in range(work)] \n    wins_list = [x for x in hash_list if x &lt; target] # get winning hashes\n    if len(wins_list) == b:\n        work_if_b_blocks_found.append(work)\nprint(f\"\\ntarget/max_target = {target/max_target:,.4f}\")\nprint(\"b = \" + str(b) + \", runs = \" + str(runs) )\nprint(\"runs that had b blocks = \" + str(len(work_if_b_blocks_found)) )\nprint(\"Mean work when b blocks were seen = \" + str(int(statistics.mean(work_if_b_blocks_found))))\nprint(\"Poisson_work = b * max_target/target = \" + str(int(Poisson_work)))\nprint(\"Poisson_work * (b+1)/b = \" + str(int(Poisson_work*(b+1)/b)))\nprint(f\"Stdev work / mean_work when b blocks were seen = {statistics.stdev(work_if_b_blocks_found)/statistics.mean(work_if_b_blocks_found):.3f} \")\nprint(f\"StdDev 1/SQRT(b+1)= {1/pow(b+1,0.5):,.3f}\")\n</code></pre>",
  "post_number": 27,
  "post_type": 1,
  "posts_count": 30,
  "updated_at": "2025-08-14T00:25:06.933Z",
  "reply_count": 1,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 17,
  "readers_count": 16,
  "score": 8.4,
  "yours": false,
  "topic_id": 1745,
  "topic_slug": "correcting-the-error-in-getnetworkhashrateps",
  "topic_title": "Correcting the error in getnetworkhashrateps",
  "topic_html_title": "Correcting the error in getnetworkhashrateps",
  "category_id": 7,
  "display_username": "Zawy",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Experimentally, given b blocks seen, a difficulty, and a uniformly random number of hashes, the Poisson equation seems to need a (b+1)/b correction which is in the opposite direction I had guessed. It's accurate down to b=1. This makes me wonder if my OP about hashrate needing a correction is correct. In the hashrate case, we're specifying a number of blocks to look at and the correction (N-1)/N is, in my intuition, based on converting it to be in a fixed amount of time, as in this case. But this is showing that if hashes per that fixed time are uniformly random, an (N+1)/N correction is also needed, giving a net N-1/N correction, or no net correction if our (N-1)/N is really supposed to be N/(N+1). This makes more sense to my intuitive interpretation.\n\nThis correction is if work and therefore &lambda; are uniformly random, which may not be an assumption we should use when adjusting difficulty or checking hashrate.\n\nOutput:\n```\ntarget/max_target = 0.0100\nb = 5, runs = 100000\nruns that had b blocks = 6156\nMean work when b blocks were seen = 600\nPoisson_work = b * max_target/target = 500\nPoisson_work * (b+1)/b = 600\nStdev work / mean_work when b blocks were seen = 0.409 \nStdDev 1/SQRT(b+1)= 0.408\n```\nCode:\n```\nimport random\nimport statistics\n\n# Mean work for a given difficulty and given number of blocks found if work is uniformly random in a fixed amount of time. \n\nruns = 100000 # number of times to do the experiment  \nwork_if_b_blocks_found = []\nb = 5 # a given number of found blocks\nmax_target = pow(2,256)\ntarget = 0.01*max_target # difficulty target\nmax_work = int((1+5/pow(b,0.5))*b*max_target/target) # get 5 StdDev's more than estimated mean hashes needed\nPoisson_work = b * max_target / target\nfor i in range(1, runs):     \n    work = int(random.random()*max_work)  # perform random # of hashes\n    if work < b: continue\n    hash_list = [random.random()*max_target for _ in range(work)] \n    wins_list = [x for x in hash_list if x < target] # get winning hashes\n    if len(wins_list) == b:\n        work_if_b_blocks_found.append(work)\nprint(f\"\\ntarget/max_target = {target/max_target:,.4f}\")\nprint(\"b = \" + str(b) + \", runs = \" + str(runs) )\nprint(\"runs that had b blocks = \" + str(len(work_if_b_blocks_found)) )\nprint(\"Mean work when b blocks were seen = \" + str(int(statistics.mean(work_if_b_blocks_found))))\nprint(\"Poisson_work = b * max_target/target = \" + str(int(Poisson_work)))\nprint(\"Poisson_work * (b+1)/b = \" + str(int(Poisson_work*(b+1)/b)))\nprint(f\"Stdev work / mean_work when b blocks were seen = {statistics.stdev(work_if_b_blocks_found)/statistics.mean(work_if_b_blocks_found):.3f} \")\nprint(f\"StdDev 1/SQRT(b+1)= {1/pow(b+1,0.5):,.3f}\")\n```",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 502,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "Experimentally, given b blocks seen, a difficulty, and a uniformly random number of hashes, the Poisson equation seems to need a (b+1)/b correction which is in the opposite direction I had guessed. It\u2019s accurate down to b=1. This makes me wonder if my OP about hashrate needing a correction is correc&hellip;",
  "truncated": true,
  "post_url": "/t/correcting-the-error-in-getnetworkhashrateps/1745/27",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}