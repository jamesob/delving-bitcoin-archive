{
  "id": 5695,
  "name": "",
  "username": "josh",
  "avatar_template": "/user_avatar/delvingbitcoin.org/josh/{size}/95_2.png",
  "created_at": "2025-08-12T19:03:15.920Z",
  "cooked": "<h2><a name=\"p-5695-tldr-1\" class=\"anchor\" href=\"#p-5695-tldr-1\"></a>TLDR</h2>\n<p><a href=\"https://github.com/joshdoman/confidential-script-lib\" rel=\"noopener nofollow ugc\">confidential-script-lib</a> is a Rust library for emulating Bitcoin script by converting script path spends to key path spends. Intended for use inside a Trusted Execution Environment (TEE), the library validates unlocking conditions and then authorizes the transaction using a deterministically derived private key.</p>\n<p>This approach enables confidential execution of complex script, including opcodes not yet supported by the Bitcoin protocol. The actual on-chain footprint is a minimal key-path spend, and it is compatible with <code>rust-bitcoinkernel</code>, or a fork thereof.</p>\n<h2><a name=\"p-5695-motivation-2\" class=\"anchor\" href=\"#p-5695-motivation-2\"></a>Motivation</h2>\n<p>This library is a follow-up to the BTC++ hackathon in Austin, where I presented this architecture without any code, which <a href=\"https://devpost.com/software/confidential-script?_gl=1*1csbbzb*_gcl_au*MTY5NTI5ODMwMy4xNzUwOTY3OTI2*_ga*MTQ3NTc5NjQ5OS4xNzUwOTY3OTI2*_ga_0YHJK3Y10M*czE3NTUwMjM0MTMkbzMkZzAkdDE3NTUwMjM0MTMkajYwJGwwJGgw\" rel=\"noopener nofollow ugc\">won</a> the prize for \u201cMost Ambitious.\u201d</p>\n<p>The goal is to allow developers to experiment on mainnet with features not yet supported by the Bitcoin protocol (ex: <code>OP_CAT</code>, <code>OP_CTV</code>, <code>OP_CCV</code>, Simplicity, etc.), in a permissionless manner with minimal trust assumptions. This could provide a useful compromise in the soft fork debate and allow the community to see which upgrades have real world demand.</p>\n<h2><a name=\"p-5695-what-is-a-tee-3\" class=\"anchor\" href=\"#p-5695-what-is-a-tee-3\"></a>What is a TEE?</h2>\n<p>A Trusted Execution Environment is an isolated system that segregates memory and the CPU from the outside world, keeping secrets stored in memory secure against side-channel and physical attacks and providing secure attestations about the code being run inside and the result of any computation.</p>\n<p>A popular TEE is AWS\u2019s <a href=\"https://aws.amazon.com/ec2/nitro/nitro-enclaves/\" rel=\"noopener nofollow ugc\">Nitro Enclave</a>, which is used by <a href=\"https://aws.amazon.com/ec2/nitro/nitro-enclaves/#ACINQ\" rel=\"noopener nofollow ugc\">ACINQ</a> to secure funds held in its LSP. AWS Nitro notably integrates with the AWS key management system (KMS), which can facilitate the provisioning of sensitive material. Users must trust AWS as the manufacturer and operator of the machine, but the security guarantees of the system have proven sufficient for many use cases where developers must secure significant funds.</p>\n<h2><a name=\"p-5695-overview-4\" class=\"anchor\" href=\"#p-5695-overview-4\"></a>Overview</h2>\n<p>The <code>confidential-script-lib</code> library operates internally with a two-step process: emulation and signing.</p>\n<ol>\n<li>\n<p><strong>Emulation</strong>: A transaction is constructed using an input spending a <em>real</em> <code>previous_outpoint</code> with a witness that is a script-path spend from an <em>emulated</em> P2TR <code>script_pubkey</code>. The library validates this emulated witness using a <code>Verifier</code>, which matches the API of <code>rust-bitcoinkernel</code>. If compiled with the <code>bitcoinkernel</code> feature, users can use the actual kernel as the default verifier, or they can provide an alternative verifier that enforces a different set of rules (ex: a fork of <code>rust-bitcoinkernel</code> that supports Simplicity).</p>\n</li>\n<li>\n<p><strong>Signing</strong>: If the transaction is valid, the library uses the provided parent private key and the merkle root of the <em>emulated</em> script path spend to derive a child private key, which controls the key-path of the <em>actual</em> UTXO being spent. The library then updates the transaction with a key-path spend signed with this child key.</p>\n</li>\n</ol>\n<p>To facilitate offline generation of the real <code>script_pubkey</code>, the child key is derived from the parent key using a non-hardened HMAC-SHA512 derivation scheme. This lets users generate addresses using the parent <em>public</em> key, while the parent private key is secured elsewhere.</p>\n<p>This library is intended to be run within a TEE, which is securely provisioned with the parent private key. This decouples script execution from on-chain settlement, keeping execution private and enabling new functionality with minimal trust assumptions.</p>\n<h2><a name=\"p-5695-failsafe-mechanism-backup-script-path-5\" class=\"anchor\" href=\"#p-5695-failsafe-mechanism-backup-script-path-5\"></a>Failsafe Mechanism: Backup Script Path</h2>\n<p>To prevent funds from being irrecoverably locked if the TEE becomes unavailable, the library allows for the inclusion of an optional <code>backup_merkle_root</code> when creating the actual on-chain address. This backup merkle root defines the alternative spending paths that are available independently of the TEE.</p>\n<p>A common use case for this feature is to include a timelocked recovery script (e.g., using <code>OP_CHECKSEQUENCEVERIFY</code>). If the primary TEE-based execution path becomes unavailable for any reason, the owner can wait for the timelock to expire and then recover the funds using a pre-defined backup script. This provides a crucial failsafe, ensuring that users retain ultimate control over their assets.</p>\n<h2><a name=\"p-5695-extensibility-for-proposed-soft-forks-6\" class=\"anchor\" href=\"#p-5695-extensibility-for-proposed-soft-forks-6\"></a>Extensibility for Proposed Soft Forks</h2>\n<p>This library can be used to emulate proposed upgrades, such as new opcodes like <code>OP_CAT</code> or <code>OP_CTV</code> or new scripting languages like Simplicity. It accepts any verifier that adheres to the <code>rust-bitcoinkernel</code> API, allowing developers to experiment with new functionality by forking the kernel, without waiting for a soft fork to gain adoption on mainnet.</p>\n<h2><a name=\"p-5695-recommended-setup-7\" class=\"anchor\" href=\"#p-5695-recommended-setup-7\"></a>Recommended Setup</h2>\n<p>This library is intended to be used within a Nitro Enclave, integrated with KMS such that any AWS account can provision an identical enclave with the same master private key. For maximum security, <strong>the KMS key should be created with an irrevocable policy that makes it un-deletable and accessible only to enclaves running a specific, verified image</strong>. Crucially, it should allow requests from any AWS account that meets this strict criteria, so that usage is permissionless.</p>\n<p>To generate the master secret, an enclave should generate a random secret and use <code>GenerateDataKey</code> to encrypt it using KMS. To provision a different enclave with the secret, the user should provide the enclave the encrypted encryption key and the encrypted secret. The enclave can then decrypt the encryption key with KMS using <code>Decrypt</code> and subequently decrypt the secret.</p>\n<p>Finally, the enclave should expose the master public key, so that users can independently derive the on-chain address they should send funds to.</p>\n<h2><a name=\"p-5695-usage-8\" class=\"anchor\" href=\"#p-5695-usage-8\"></a>Usage</h2>\n<h3><a name=\"p-5695-convert-emulated-transaction-9\" class=\"anchor\" href=\"#p-5695-convert-emulated-transaction-9\"></a>Convert emulated transaction</h3>\n<pre data-code-wrap=\"rust\"><code class=\"lang-rust\">/// Verifies an emulated Bitcoin script and signs the corresponding transaction.\n///\n/// This function performs script verification using bitcoinkernel, verifying an\n/// emulated P2TR input. If successful, it derives an XOnlyPublicKey from the\n/// parent key and the emulated merkle root, which is then tweaked with an optional\n/// backup merkle root to derive the actual spent UTXO, which is then key path signed\n/// with `SIGHASH_DEFAULT`.\n///\n/// # Arguments\n/// * `verifier` - The verifier to use for script validation\n/// * `emulated_script_pubkey` - The P2TR script to verify against\n/// * `amount` - The amount for the input\n/// * `emulated_tx_to` - Serialized transaction to verify and sign\n/// * `input_index` - Index of the input to verify and sign (0-based)\n/// * `emulated_spent_outputs` - Outputs being spent in the emulated transaction\n/// * `actual_spent_outputs` - Actual outputs for signature generation\n/// * `aux_rand` - Auxiliary random data for signing\n/// * `parent_key` - Parent secret key used to derive child key for signing\n/// * `backup_merkle_root` - Optional merkle root for backup script path spending\n///\n/// # Errors\n/// Returns error if verification fails, key derivation fails, or signing fails\npub fn verify_and_sign&lt;V: Verifier&gt;(\n    verifier: &amp;V,\n    emulated_script_pubkey: &amp;[u8],\n    amount: i64,\n    emulated_tx_to: &amp;[u8],\n    input_index: u32,\n    emulated_spent_outputs: &amp;[TxOut],\n    actual_spent_outputs: &amp;[TxOut],\n    aux_rand: &amp;[u8; 32],\n    parent_key: SecretKey,\n    backup_merkle_root: Option&lt;TapNodeHash&gt;,\n) -&gt; Result&lt;Transaction, Error&gt;;\n</code></pre>\n<h3><a name=\"p-5695-generate-an-address-10\" class=\"anchor\" href=\"#p-5695-generate-an-address-10\"></a>Generate an address</h3>\n<pre data-code-wrap=\"rust\"><code class=\"lang-rust\">/// Generates P2TR address from a parent public key and the emulated merkle root,\n/// with an optional backup merkle root.\n///\n/// # Arguments\n/// * `parent_key` - The parent public key\n/// * `emulated_merkle_root` - The merkle root of the emulated input\n/// * `backup_merkle_root` - Optional merkle root for backup script path spending\n/// * `network` - The network to generate the address for\n///\n/// # Errors\n/// Returns an error if key derivation fails\nfn generate_address(\n    parent_key: PublicKey,\n    emulated_merkle_root: TapNodeHash,\n    backup_merkle_root: Option&lt;TapNodeHash&gt;,\n    network: Network,\n) -&gt; Result&lt;Address, secp256k1::Error&gt;;\n</code></pre>\n<h2><a name=\"p-5695-next-steps-11\" class=\"anchor\" href=\"#p-5695-next-steps-11\"></a>Next Steps</h2>\n<p>If there is interest in using this library, the next step would be to deploy it inside a TEE with a reproducible build. While users must trust the security guarantees of the TEE and the KMS provider, a proper setup can otherwise ensure that it is impossible to steal funds without a valid spend from an emulated or backup script. By setting up KMS such that any identical enclave can access the key, we can make the process of converting emulated script path spends to valid key path spends nearly permissionless.</p>\n<p><em>Special thanks to <a class=\"mention\" href=\"/u/alex\">@Alex</a> and Stephen DeLorme for encouraging me to put this idea into code.</em></p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 1,
  "updated_at": "2025-08-12T21:11:24.910Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 15,
  "reads": 7,
  "readers_count": 6,
  "score": 121.4,
  "yours": false,
  "topic_id": 1918,
  "topic_slug": "confidential-script-emulate-soft-forks-using-stateless-tees",
  "topic_title": "Confidential Script: Emulate soft forks using stateless TEEs",
  "topic_html_title": "Confidential Script: Emulate soft forks using stateless TEEs",
  "category_id": 8,
  "display_username": "",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 3,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "## TLDR\n\n[confidential-script-lib](https://github.com/joshdoman/confidential-script-lib) is a Rust library for emulating Bitcoin script by converting script path spends to key path spends. Intended for use inside a Trusted Execution Environment (TEE), the library validates unlocking conditions and then authorizes the transaction using a deterministically derived private key.\n\nThis approach enables confidential execution of complex script, including opcodes not yet supported by the Bitcoin protocol. The actual on-chain footprint is a minimal key-path spend, and it is compatible with `rust-bitcoinkernel`, or a fork thereof.\n\n## Motivation\n\nThis library is a follow-up to the BTC++ hackathon in Austin, where I presented this architecture without any code, which [won](https://devpost.com/software/confidential-script?_gl=1*1csbbzb*_gcl_au*MTY5NTI5ODMwMy4xNzUwOTY3OTI2*_ga*MTQ3NTc5NjQ5OS4xNzUwOTY3OTI2*_ga_0YHJK3Y10M*czE3NTUwMjM0MTMkbzMkZzAkdDE3NTUwMjM0MTMkajYwJGwwJGgw) the prize for \"Most Ambitious.\"\n\nThe goal is to allow developers to experiment on mainnet with features not yet supported by the Bitcoin protocol (ex: `OP_CAT`, `OP_CTV`, `OP_CCV`, Simplicity, etc.), in a permissionless manner with minimal trust assumptions. This could provide a useful compromise in the soft fork debate and allow the community to see which upgrades have real world demand.\n\n## What is a TEE?\n\nA Trusted Execution Environment is an isolated system that segregates memory and the CPU from the outside world, keeping secrets stored in memory secure against side-channel and physical attacks and providing secure attestations about the code being run inside and the result of any computation.\n\nA popular TEE is AWS's [Nitro Enclave](https://aws.amazon.com/ec2/nitro/nitro-enclaves/), which is used by [ACINQ](https://aws.amazon.com/ec2/nitro/nitro-enclaves/#ACINQ) to secure funds held in its LSP. AWS Nitro notably integrates with the AWS key management system (KMS), which can facilitate the provisioning of sensitive material. Users must trust AWS as the manufacturer and operator of the machine, but the security guarantees of the system have proven sufficient for many use cases where developers must secure significant funds.\n\n## Overview\n\nThe `confidential-script-lib` library operates internally with a two-step process: emulation and signing.\n\n1.  **Emulation**: A transaction is constructed using an input spending a *real* `previous_outpoint` with a witness that is a script-path spend from an *emulated* P2TR `script_pubkey`. The library validates this emulated witness using a `Verifier`, which matches the API of `rust-bitcoinkernel`. If compiled with the `bitcoinkernel` feature, users can use the actual kernel as the default verifier, or they can provide an alternative verifier that enforces a different set of rules (ex: a fork of `rust-bitcoinkernel` that supports Simplicity).\n\n2.  **Signing**: If the transaction is valid, the library uses the provided parent private key and the merkle root of the *emulated* script path spend to derive a child private key, which controls the key-path of the *actual* UTXO being spent. The library then updates the transaction with a key-path spend signed with this child key.\n\nTo facilitate offline generation of the real `script_pubkey`, the child key is derived from the parent key using a non-hardened HMAC-SHA512 derivation scheme. This lets users generate addresses using the parent _public_ key, while the parent private key is secured elsewhere.\n\nThis library is intended to be run within a TEE, which is securely provisioned with the parent private key. This decouples script execution from on-chain settlement, keeping execution private and enabling new functionality with minimal trust assumptions.\n\n## Failsafe Mechanism: Backup Script Path\n\nTo prevent funds from being irrecoverably locked if the TEE becomes unavailable, the library allows for the inclusion of an optional `backup_merkle_root` when creating the actual on-chain address. This backup merkle root defines the alternative spending paths that are available independently of the TEE.\n\nA common use case for this feature is to include a timelocked recovery script (e.g., using `OP_CHECKSEQUENCEVERIFY`). If the primary TEE-based execution path becomes unavailable for any reason, the owner can wait for the timelock to expire and then recover the funds using a pre-defined backup script. This provides a crucial failsafe, ensuring that users retain ultimate control over their assets.\n\n## Extensibility for Proposed Soft Forks\n\nThis library can be used to emulate proposed upgrades, such as new opcodes like `OP_CAT` or `OP_CTV` or new scripting languages like Simplicity. It accepts any verifier that adheres to the `rust-bitcoinkernel` API, allowing developers to experiment with new functionality by forking the kernel, without waiting for a soft fork to gain adoption on mainnet.\n\n## Recommended Setup\n\nThis library is intended to be used within a Nitro Enclave, integrated with KMS such that any AWS account can provision an identical enclave with the same master private key. For maximum security, **the KMS key should be created with an irrevocable policy that makes it un-deletable and accessible only to enclaves running a specific, verified image**. Crucially, it should allow requests from any AWS account that meets this strict criteria, so that usage is permissionless.\n\nTo generate the master secret, an enclave should generate a random secret and use `GenerateDataKey` to encrypt it using KMS. To provision a different enclave with the secret, the user should provide the enclave the encrypted encryption key and the encrypted secret. The enclave can then decrypt the encryption key with KMS using `Decrypt` and subequently decrypt the secret.\n\nFinally, the enclave should expose the master public key, so that users can independently derive the on-chain address they should send funds to.\n\n## Usage\n\n### Convert emulated transaction\n\n```rust\n/// Verifies an emulated Bitcoin script and signs the corresponding transaction.\n///\n/// This function performs script verification using bitcoinkernel, verifying an\n/// emulated P2TR input. If successful, it derives an XOnlyPublicKey from the\n/// parent key and the emulated merkle root, which is then tweaked with an optional\n/// backup merkle root to derive the actual spent UTXO, which is then key path signed\n/// with `SIGHASH_DEFAULT`.\n///\n/// # Arguments\n/// * `verifier` - The verifier to use for script validation\n/// * `emulated_script_pubkey` - The P2TR script to verify against\n/// * `amount` - The amount for the input\n/// * `emulated_tx_to` - Serialized transaction to verify and sign\n/// * `input_index` - Index of the input to verify and sign (0-based)\n/// * `emulated_spent_outputs` - Outputs being spent in the emulated transaction\n/// * `actual_spent_outputs` - Actual outputs for signature generation\n/// * `aux_rand` - Auxiliary random data for signing\n/// * `parent_key` - Parent secret key used to derive child key for signing\n/// * `backup_merkle_root` - Optional merkle root for backup script path spending\n///\n/// # Errors\n/// Returns error if verification fails, key derivation fails, or signing fails\npub fn verify_and_sign<V: Verifier>(\n    verifier: &V,\n    emulated_script_pubkey: &[u8],\n    amount: i64,\n    emulated_tx_to: &[u8],\n    input_index: u32,\n    emulated_spent_outputs: &[TxOut],\n    actual_spent_outputs: &[TxOut],\n    aux_rand: &[u8; 32],\n    parent_key: SecretKey,\n    backup_merkle_root: Option<TapNodeHash>,\n) -> Result<Transaction, Error>;\n```\n\n### Generate an address\n\n```rust\n/// Generates P2TR address from a parent public key and the emulated merkle root,\n/// with an optional backup merkle root.\n///\n/// # Arguments\n/// * `parent_key` - The parent public key\n/// * `emulated_merkle_root` - The merkle root of the emulated input\n/// * `backup_merkle_root` - Optional merkle root for backup script path spending\n/// * `network` - The network to generate the address for\n///\n/// # Errors\n/// Returns an error if key derivation fails\nfn generate_address(\n    parent_key: PublicKey,\n    emulated_merkle_root: TapNodeHash,\n    backup_merkle_root: Option<TapNodeHash>,\n    network: Network,\n) -> Result<Address, secp256k1::Error>;\n```\n\n## Next Steps\n\nIf there is interest in using this library, the next step would be to deploy it inside a TEE with a reproducible build. While users must trust the security guarantees of the TEE and the KMS provider, a proper setup can otherwise ensure that it is impossible to steal funds without a valid spend from an emulated or backup script. By setting up KMS such that any identical enclave can access the key, we can make the process of converting emulated script path spends to valid key path spends nearly permissionless.\n\n*Special thanks to @Alex and Stephen DeLorme for encouraging me to put this idea into code.*",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 98,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "<a name=\"p-5695-tldr-1\" class=\"anchor\" href=\"#p-5695-tldr-1\"></a>TLDR\n<a href=\"https://github.com/joshdoman/confidential-script-lib\" rel=\"noopener nofollow ugc\">confidential-script-lib</a> is a Rust library for emulating Bitcoin script by converting script path spends to key path spends. Intended for use inside a Trusted Execution Environment (TEE), the library validates unlocking conditions and then authorizes the transaction using a deterministically der&hellip;",
  "truncated": true,
  "post_url": "/t/confidential-script-emulate-soft-forks-using-stateless-tees/1918/1",
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}