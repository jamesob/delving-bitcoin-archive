{
  "id": 5737,
  "name": "",
  "username": "roconnor-blockstream",
  "avatar_template": "/user_avatar/delvingbitcoin.org/roconnor-blockstream/{size}/427_2.png",
  "created_at": "2025-08-18T14:26:20.062Z",
  "cooked": "<p>In <a href=\"https://delvingbitcoin.org/t/delving-simplicity-part-three-fundamental-ways-of-combining-computations/1902\">Part \u2160</a> of this series, we described the three methods of composition in programming: sequential, parallel, and conditional. In this part, we will see how these methods of composition are directly realized within Simplicity.</p>\n<h1><a name=\"p-5737-simplicity-types-1\" class=\"anchor\" href=\"#p-5737-simplicity-types-1\"></a>Simplicity Types</h1>\n<p>Parallel compositions produce an output that is a product of two types. We write this product type as <code>A \u00d7 B</code> or <code>A * B</code>. Conditional compositions consume an input that is a sum (also known as a tagged union) of two types <code>A + B</code>. In order to directly realize these forms of composition, Simplicity\u2019s type system includes these two type formers. Simplicity has only one other type: the unit type.</p>\n<h2><a name=\"p-5737-unit-type-2\" class=\"anchor\" href=\"#p-5737-unit-type-2\"></a>Unit Type</h2>\n<p>Simplicity\u2019s unit type, written <code>\ud835\udfd9</code> or <code>ONE</code>, is a type with only one value. This single value is typically denoted by the empty tuple, written <code>\u27e8\u27e9</code> or <code>()</code>. Since this type consists of only a single value, values of this type contain no information; it is essentially a zero-bit data type.</p>\n<p>We use the <code>:</code> to denote a value\u2019s type, so <code>\u27e8\u27e9 : \ud835\udfd9</code> means the empty tuple has unit type.</p>\n<h2><a name=\"p-5737-sum-type-3\" class=\"anchor\" href=\"#p-5737-sum-type-3\"></a>Sum Type</h2>\n<p>The sum of two types, <code>A + B</code>, is the tagged union of two types. The tag is either \u201cleft\u201d or \u201cright,\u201d indicating whether a given value corresponds to the left-hand type of the sum or the right-hand type. If <code>a : A</code>, then we write <code>\u03c3\u1d38(a)</code> or <code>inl(a)</code> for the left-tagged value of type <code>A + B</code> (i.e., <code>\u03c3\u1d38(a) : A + B</code>). Similarly, if <code>b : B</code>, then we write <code>\u03c3\u1d3f(b)</code> or <code>inr(b)</code> for the right-tagged value (i.e., <code>\u03c3\u1d3f(b) : A + B</code>).</p>\n<p>Values of a sum type always contains a tag, even when taking the sum of two identical types. In particular, if <code>a : A</code>, then <code>\u03c3\u1d38(a)</code> and <code>\u03c3\u1d3f(a)</code> are two distinct values of type <code>A + A</code> because they have different tags.</p>\n<h3><a name=\"p-5737-boolean-type-4\" class=\"anchor\" href=\"#p-5737-boolean-type-4\"></a>Boolean Type</h3>\n<p>We will discuss building data structures in more detail in the next part of this series, but as a preview, let\u2019s look at our first non-trivial type: <code>\ud835\udfd9 + \ud835\udfd9</code>. We typically denote this type using the shorthand <code>\ud835\udfda</code> or <code>TWO</code>. Keep in mind that this is purely notational convenience. This type is the tagged union of two unit types and therefore has two values: <code>\u03c3\u1d38\u27e8\u27e9 : \ud835\udfda</code> and <code>\u03c3\u1d3f\u27e8\u27e9 : \ud835\udfda</code>. This is a one-bit data type. By convention, we consider <code>\u03c3\u1d38\u27e8\u27e9</code> to be a zero or false value, which we may write as <code>0</code> or <code>false</code>. Similarly, we consider <code>\u03c3\u1d3f\u27e8\u27e9</code> to be a one or true value, which we may write as <code>1</code> or <code>true</code>. Again, this is just notational convenience.</p>\n<h2><a name=\"p-5737-product-type-5\" class=\"anchor\" href=\"#p-5737-product-type-5\"></a>Product Type</h2>\n<p>The product of two types, <code>A \u00d7 B</code>, contains pairs of values. If <code>a : A</code> and <code>b : B</code> are values of types <code>A</code> and <code>B</code>, then the pair, written as <code>\u27e8a, b\u27e9</code> or <code>(a, b)</code>, has type <code>A \u00d7 B</code> (i.e., <code>\u27e8a, b\u27e9 : A \u00d7 B</code>).</p>\n<p>\ud83d\udec8\nSimplicity only has finite types. You can read off the number of values a type has by interpreting the type using arithmetic. For example, the type <code>\ud835\udfda \u00d7 \ud835\udfda</code> has four values. The type <code>\ud835\udfda + \ud835\udfda</code> also has four values; however, they are different values from those of type <code>\ud835\udfda \u00d7 \ud835\udfda</code>.</p>\n<h1><a name=\"p-5737-core-simplicity-expressions-6\" class=\"anchor\" href=\"#p-5737-core-simplicity-expressions-6\"></a>Core Simplicity Expressions</h1>\n<p>In Part \u2160, we presumed we had some set of basic operations, and each operation had an input type and an output type. We will write <code>f : A \u22a2 B</code> or <code>f : A |- B</code> to mean that <code>f</code> has input type <code>A</code> and output type <code>B</code>.</p>\n<p><img src=\"https://delvingbitcoin.org/images/emoji/twitter/warning.png?v=14\" title=\":warning:\" class=\"emoji only-emoji\" alt=\":warning:\" loading=\"lazy\" width=\"20\" height=\"20\">\nWhile Simplicity expressions have input and output types, Simplicity\u2019s types do not include function types. Simplicity is a \u201cfirst-order\u201d programming language.</p>\n<h2><a name=\"p-5737-two-basic-operations-7\" class=\"anchor\" href=\"#p-5737-two-basic-operations-7\"></a>Two Basic Operations</h2>\n<p>Simplicity provides several basic operations, most of which we will see later in this series when we talk about Simplicity jets. The core language provides expressions for only two basic operations: <code>iden : A \u22a2 A</code> and <code>unit : A \u22a2 \ud835\udfd9</code>. Technically, these are two families of operations, with one of each operation per Simplicity type <code>A</code>.</p>\n<p>The <code>iden</code> operation passes its input along to its output. The <code>unit</code> operation discards its input and returns the empty tuple, <code>\u27e8\u27e9</code>.</p>\n<p>To be more precise, we need to distinguish between programming language syntax and semantics. <code>iden</code> and <code>unit</code> are Simplicity <em>expressions</em>, which constitute the language\u2019s syntax. Simplicity expressions <em>denote</em> operations, which are functions from an input type to an output type. We use fancy square brackets to indicate what a Simplicity expression denotes:</p>\n<ul>\n<li>\n<p><code>\u27e6iden\u27e7(a) = a</code> (alternatively written<code>|[iden]|(a) = a</code>)</p>\n</li>\n<li>\n<p><code>\u27e6unit\u27e7(a) = \u27e8\u27e9</code></p>\n</li>\n</ul>\n<h2><a name=\"p-5737-three-composition-combinators-8\" class=\"anchor\" href=\"#p-5737-three-composition-combinators-8\"></a>Three Composition Combinators</h2>\n<p>The sequential and parallel composition methods are directly implemented by Simplicity <em>combinators</em>. Recall that Simplicity expressions denote functions. A combinator is a function that takes functions and returns a function. We follow the usual programming language practice of defining these Simplicity expressions using typing rules:</p>\n<ul>\n<li>\n<pre data-code-wrap=\"none\"><code class=\"lang-none\">f : A \u22a2 B    g : B \u22a2 C\n----------------------\n   comp f g : A \u22a2 C\n</code></pre>\n</li>\n<li>\n<pre data-code-wrap=\"none\"><code class=\"lang-none\">f : A \u22a2 B    g : A \u22a2 C\n----------------------\n pair f g : A \u22a2 B \u00d7 C\n</code></pre>\n</li>\n</ul>\n<p>The first rule states that if <code>f</code> is a Simplicity expression with input type <code>A</code> and output type <code>B</code>, and <code>g</code> is an expression with input type <code>B</code> and output type <code>C</code>, then <code>comp f g</code> is a Simplicity expression with input type <code>A</code> and output type <code>C</code>. The second rule defines the <code>pair f g</code> expression similarly.</p>\n<p>We may also write <code>comp f g</code> as <code>f \u2a3e g</code> or <code>f &gt;&gt;&gt; g</code> and we may write <code>pair f g</code> as <code>f \u25b5 g</code> or <code>f &amp;&amp;&amp; g</code>.</p>\n<p>These combinators form expressions of exactly the right type to implement sequential and parallel composition. Accordingly, these expressions have semantics for these forms of composition.</p>\n<ul>\n<li><code>\u27e6f \u2a3e g\u27e7(a) = \u27e6g\u27e7(\u27e6f\u27e7(a))</code></li>\n<li><code>\u27e6f \u25b5 g\u27e7(a) = \u27e8\u27e6f\u27e7(a), \u27e6g\u27e7(a)\u27e9</code></li>\n</ul>\n<p><img src=\"https://delvingbitcoin.org/images/emoji/twitter/warning.png?v=14\" title=\":warning:\" class=\"emoji only-emoji\" alt=\":warning:\" loading=\"lazy\" width=\"20\" height=\"20\">\nThe version of sequential composition used in mathematics is backwards with respect to our syntax.</p>\n<p>The other method of composition is conditional composition. The natural approach would be, given <code>f : A \u22a2 C</code> and <code>g : B \u22a2 C</code>, to define <code>copair f g : A + B \u22a2 C</code>. However, <code>copair</code> doesn\u2019t allow branches to access shared data. In particular, the distribution function,</p>\n<p><code>dist : (A + B) \u00d7 C \u22a2 A \u00d7 C + B \u00d7 C</code>,</p>\n<p>cannot be defined in terms of <code>copair</code> alone.</p>\n<p>Instead of <code>copair</code>, we use the following <code>case</code> combinator instead.</p>\n<ul>\n<li>\n<pre data-code-wrap=\"none\"><code class=\"lang-none\">f : A \u00d7 C \u22a2 D    g : B \u00d7 C \u22a2 D\n------------------------------\n  case f g : (A + B) \u00d7 C \u22a2 D\n</code></pre>\n</li>\n</ul>\n<p>This <code>case</code> combinator does conditional composition and distribution all in one. It\u2019s helpful to think of the type <code>C</code> as the type of a shared environment that both branches of the <code>case</code> expression get access to. Accordingly, the <code>case</code> combinator has the following semantics.</p>\n<ul>\n<li><code>\u27e6case f g\u27e7\u27e8\u03c3\u1d38(a), c\u27e9 = \u27e6f\u27e7\u27e8a, c\u27e9</code></li>\n<li><code>\u27e6case f g\u27e7\u27e8\u03c3\u1d3f(b), c\u27e9 = \u27e6g\u27e7\u27e8b, c\u27e9</code></li>\n</ul>\n<h2><a name=\"p-5737-four-more-combinators-9\" class=\"anchor\" href=\"#p-5737-four-more-combinators-9\"></a>Four more Combinators</h2>\n<p>We are still missing a few fundamental operations on our types. For instance, we can use <code>pair</code> to produce product types, but we have no way yet to consume product types. Similarly, the <code>case</code> combinator consumes sum types, but we have no way yet to produce sum types. Four additional combinators enable the consumption of product types and production of sum types. The first two combinators extract one of the values of a pair, and execute a function on it:</p>\n<ul>\n<li>\n<pre data-code-wrap=\"none\"><code class=\"lang-none\">     f : A \u22a2 C\n------------------\ntake f : A \u00d7 B \u22a2 C\n</code></pre>\n</li>\n<li>\n<pre data-code-wrap=\"none\"><code class=\"lang-none\">     f : B \u22a2 C\n------------------\ndrop f : A \u00d7 B \u22a2 C\n</code></pre>\n</li>\n</ul>\n<p>The last two combinators execute a function and wrap the result with either a left tag or a right tag.</p>\n<ul>\n<li>\n<pre data-code-wrap=\"none\"><code class=\"lang-none\">     f : A \u22a2 B\n------------------\ninjl f : A \u22a2 B + C\n</code></pre>\n</li>\n<li>\n<pre data-code-wrap=\"none\"><code class=\"lang-none\">     f : A \u22a2 C\n------------------\ninjr f : A \u22a2 B + C\n</code></pre>\n</li>\n</ul>\n<p>These combinators have the required semantics:</p>\n<ul>\n<li><code>\u27e6take f\u27e7\u27e8a, b\u27e9 = \u27e6f\u27e7(a)</code></li>\n<li><code>\u27e6drop f\u27e7\u27e8a, b\u27e9 = \u27e6f\u27e7(b)</code></li>\n<li><code>\u27e6injl f\u27e7(a) = \u03c3\u1d38(\u27e6f\u27e7(a))</code></li>\n<li><code>\u27e6injr f\u27e7(a) = \u03c3\u1d3f(\u27e6f\u27e7(a))</code></li>\n</ul>\n<h1><a name=\"p-5737-simplicity-and-the-sequent-calculus-10\" class=\"anchor\" href=\"#p-5737-simplicity-and-the-sequent-calculus-10\"></a>Simplicity and the Sequent Calculus</h1>\n<p>Readers familiar with formal logic will find a resemblance between our set of nine rules and the conjunctive-disjunctive fragment of Gentzen\u2019s sequent calculus. The sequent calculus inspired Simplicity\u2019s language design. One can think of Simplicity as a slightly tweaked variant of the \u201cfunctional interpretation\u201d of Gentzen\u2019s sequent calculus, which is analogous to the Curry-Howard correspondence between natural deduction and the lambda calculus.</p>\n<p>Notice that the premises in the combinator rules of the core Simplicity language are typically \u201csmaller\u201d than the types in the conclusion. Later in this series we will describe \u201cthe Bit Machine\u201d, an abstract stack machine for interpreting Simplicity expressions. The Bit Machine takes advantage of this phenomenon of \u201csmaller types in the premises\u201d to minimize the amount of data copied during execution. Only the <code>iden</code> and <code>comp</code> core combinators involve moving data around, and the rest of the core combinators are implemented with just some bookkeeping.</p>\n<h1><a name=\"p-5737-values-are-not-expressions-11\" class=\"anchor\" href=\"#p-5737-values-are-not-expressions-11\"></a>Values are not Expressions</h1>\n<p>Above we gave notation for the values of the various types that Simplicity supports. It is important to note that Simplicity expressions only denote operations, and operations are functions, not values. We can construct values by starting with the <code>unit</code> function and composing it with <code>injl</code>, <code>injr</code> and <code>pair</code> combinators. To avoid writing out such tedious constructions, we introduce the following notation.</p>\n<p>Given a value of some Simplicity type, <code>b : B</code>, we write <code>scribe b : A \u22a2 B</code> for the unique Simplicity expression that always returns the value <code>b</code>. For example, <code>scribe \u27e8\u03c3\u1d38\u27e8\u27e9, \u03c3\u1d3f\u27e8\u27e9\u27e9</code> is shorthand for <code>injl unit \u25b5 injr unit : A \u22a2 \ud835\udfda \u00d7 \ud835\udfda</code>. Keep in mind that, <code>scribe</code> isn\u2019t a Simplicity combinator; it is a macro-like notional convenience.</p>\n<p>Bitcoin Script has a similar property; Bitcoin Script only contains operations. For example <code>OP_1</code> is the operation that pushes the value <code>1</code> onto the stack, but there is no Bitcoin Script expression for the value <code>1</code> itself.</p>\n<h1><a name=\"p-5737-simplicitys-completeness-theorem-12\" class=\"anchor\" href=\"#p-5737-simplicitys-completeness-theorem-12\"></a>Simplicity\u2019s Completeness Theorem</h1>\n<p>Earlier we saw that the na\u00efve realization of conditional composition would have left us unable to define the \u201cdistribution\u201d function <code>dist : (A + B) \u00d7 C \u22a2 A \u00d7 C + B \u00d7 C</code>. How do we know that we aren\u2019t missing something else?</p>\n<p>The answer is that the \u201cSimplicity Completeness theorem\u201d proves that for any function between two Simplicity types there exists some Simplicity expression that denotes it.</p>\n<p>We already saw <code>scribe</code>, which is a special case of the Simplicity Completeness theorem for constant functions. For other functions, we can build an nested set of <code>case</code> expressions to fully decompose any input of any type and compose that with a <code>scribe</code> expression for every output value. This procedure constructs what is effectively a giant lookup table to implement any function.</p>\n<p>But you don\u2019t have to trust us. The core Simplicity language is formally specified in the Rocq proof assistant (formerly named the Coq proof assistant), and the <a href=\"https://github.com/BlockstreamResearch/simplicity/blob/8adafc9b55d694111c99fa11f90c7e48376ed1e5/Coq/Simplicity/Core.v#L92-L93\" rel=\"noopener nofollow ugc\">Simplicity Completeness theorem</a> is one of the theorems we have formally verified.</p>\n<h1><a name=\"p-5737-conclusion-13\" class=\"anchor\" href=\"#p-5737-conclusion-13\"></a>Conclusion</h1>\n<p>We described Simplicity\u2019s type system, combinators, and basic expressions that make up Simplicity\u2019s core computational language. Later in this series, we will describe how Simplicity interacts with transactions and introduce a few more Simplicity combinators.</p>\n<p>But before delving into that, in Part \u2162, we will look at building data structures and computation from this seemingly meager language. While we do have the Simplicity Completeness theorem, the expressions that the theorem constructs are astronomical in size, making it only useful as a theoretical tool. The practice of generating succinct Simplicity expressions could be viewed as an exercise in compression by exploiting structure within computations.</p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 1,
  "updated_at": "2025-08-18T14:26:20.062Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 41,
  "reads": 46,
  "readers_count": 45,
  "score": 229.2,
  "yours": false,
  "topic_id": 1935,
  "topic_slug": "delving-simplicity-part-combinator-completeness-of-simplicity",
  "topic_title": "Delving Simplicity Part \u2161: Combinator Completeness of Simplicity",
  "topic_html_title": "Delving Simplicity Part \u2161: Combinator Completeness of Simplicity",
  "category_id": 7,
  "display_username": "",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "In [Part \u2160](https://delvingbitcoin.org/t/delving-simplicity-part-three-fundamental-ways-of-combining-computations/1902) of this series, we described the three methods of composition in programming: sequential, parallel, and conditional. In this part, we will see how these methods of composition are directly realized within Simplicity.\n\n# Simplicity Types\n\nParallel compositions produce an output that is a product of two types. We write this product type as `A \u00d7 B` or `A * B`. Conditional compositions consume an input that is a sum (also known as a tagged union) of two types `A + B`. In order to directly realize these forms of composition, Simplicity\u2019s type system includes these two type formers. Simplicity has only one other type: the unit type.\n\n## Unit Type\n\nSimplicity\u2019s unit type, written `\ud835\udfd9` or `ONE`, is a type with only one value. This single value is typically denoted by the empty tuple, written `\u27e8\u27e9` or `()`. Since this type consists of only a single value, values of this type contain no information; it is essentially a zero-bit data type.\n\nWe use the `:` to denote a value\u2019s type, so `\u27e8\u27e9 : \ud835\udfd9` means the empty tuple has unit type.\n\n## Sum Type\n\nThe sum of two types, `A + B`, is the tagged union of two types. The tag is either \u201cleft\u201d or \u201cright,\u201d indicating whether a given value corresponds to the left-hand type of the sum or the right-hand type. If `a : A`, then we write `\u03c3\u1d38(a)` or `inl(a)` for the left-tagged value of type `A + B` (i.e., `\u03c3\u1d38(a) : A + B`). Similarly, if `b : B`, then we write `\u03c3\u1d3f(b)` or `inr(b)` for the right-tagged value (i.e., `\u03c3\u1d3f(b) : A + B`).\n\nValues of a sum type always contains a tag, even when taking the sum of two identical types. In particular, if `a : A`, then `\u03c3\u1d38(a)` and `\u03c3\u1d3f(a)` are two distinct values of type `A + A` because they have different tags.\n\n### Boolean Type\n\nWe will discuss building data structures in more detail in the next part of this series, but as a preview, let\u2019s look at our first non-trivial type: `\ud835\udfd9 + \ud835\udfd9`. We typically denote this type using the shorthand `\ud835\udfda` or `TWO`. Keep in mind that this is purely notational convenience. This type is the tagged union of two unit types and therefore has two values: `\u03c3\u1d38\u27e8\u27e9 : \ud835\udfda` and `\u03c3\u1d3f\u27e8\u27e9 : \ud835\udfda`. This is a one-bit data type. By convention, we consider `\u03c3\u1d38\u27e8\u27e9` to be a zero or false value, which we may write as `0` or `false`. Similarly, we consider `\u03c3\u1d3f\u27e8\u27e9` to be a one or true value, which we may write as `1` or `true`. Again, this is just notational convenience.\n\n## Product Type\n\nThe product of two types, `A \u00d7 B`, contains pairs of values. If `a : A` and `b : B` are values of types `A` and `B`, then the pair, written as `\u27e8a, b\u27e9` or `(a, b)`, has type `A \u00d7 B` (i.e., `\u27e8a, b\u27e9 : A \u00d7 B`).\n\n\n\ud83d\udec8\nSimplicity only has finite types. You can read off the number of values a type has by interpreting the type using arithmetic. For example, the type `\ud835\udfda \u00d7 \ud835\udfda` has four values. The type `\ud835\udfda + \ud835\udfda` also has four values; however, they are different values from those of type `\ud835\udfda \u00d7 \ud835\udfda`.\n\n# Core Simplicity Expressions\n\nIn Part \u2160, we presumed we had some set of basic operations, and each operation had an input type and an output type. We will write `f : A \u22a2 B` or `f : A |- B` to mean that `f` has input type `A` and output type `B`. \n\n\n\u26a0\nWhile Simplicity expressions have input and output types, Simplicity\u2019s types do not include function types. Simplicity is a \u201cfirst-order\u201d programming language.\n\n## Two Basic Operations\n\nSimplicity provides several basic operations, most of which we will see later in this series when we talk about Simplicity jets. The core language provides expressions for only two basic operations: `iden : A \u22a2 A` and `unit : A \u22a2 \ud835\udfd9`. Technically, these are two families of operations, with one of each operation per Simplicity type `A`.\n\nThe `iden` operation passes its input along to its output. The `unit` operation discards its input and returns the empty tuple, `\u27e8\u27e9`.\n\nTo be more precise, we need to distinguish between programming language syntax and semantics. `iden` and `unit` are Simplicity *expressions*, which constitute the language\u2019s syntax. Simplicity expressions *denote* operations, which are functions from an input type to an output type. We use fancy square brackets to indicate what a Simplicity expression denotes:\n\n* `\u27e6iden\u27e7(a) = a` (alternatively written`|[iden]|(a) = a`)\n\n\n* `\u27e6unit\u27e7(a) = \u27e8\u27e9`\n\n## Three Composition Combinators\n\nThe sequential and parallel composition methods are directly implemented by Simplicity *combinators*. Recall that Simplicity expressions denote functions. A combinator is a function that takes functions and returns a function. We follow the usual programming language practice of defining these Simplicity expressions using typing rules:\n\n* ```none\n  f : A \u22a2 B    g : B \u22a2 C\n  ----------------------\n     comp f g : A \u22a2 C\n  ```\n* ```none\n  f : A \u22a2 B    g : A \u22a2 C\n  ----------------------\n   pair f g : A \u22a2 B \u00d7 C\n  ```\n\nThe first rule states that if `f` is a Simplicity expression with input type `A` and output type `B`, and `g` is an expression with input type `B` and output type `C`, then `comp f g` is a Simplicity expression with input type `A` and output type `C`. The second rule defines the `pair f g` expression similarly.\n\nWe may also write `comp f g` as `f \u2a3e g` or `f >>> g` and we may write `pair f g` as `f \u25b5 g` or `f &&& g`.\n\nThese combinators form expressions of exactly the right type to implement sequential and parallel composition. Accordingly, these expressions have semantics for these forms of composition.\n\n* `\u27e6f \u2a3e g\u27e7(a) = \u27e6g\u27e7(\u27e6f\u27e7(a))`\n* `\u27e6f \u25b5 g\u27e7(a) = \u27e8\u27e6f\u27e7(a), \u27e6g\u27e7(a)\u27e9`\n\n\n\u26a0\nThe version of sequential composition used in mathematics is backwards with respect to our syntax.\n\nThe other method of composition is conditional composition. The natural approach would be, given `f : A \u22a2 C` and `g : B \u22a2 C`, to define `copair f g : A + B \u22a2 C`. However, `copair` doesn\u2019t allow branches to access shared data. In particular, the distribution function,\n\n `dist : (A + B) \u00d7 C \u22a2 A \u00d7 C + B \u00d7 C`,\n\ncannot be defined in terms of `copair` alone.\n\nInstead of `copair`, we use the following `case` combinator instead.\n\n* ```none\n  f : A \u00d7 C \u22a2 D    g : B \u00d7 C \u22a2 D\n  ------------------------------\n    case f g : (A + B) \u00d7 C \u22a2 D\n  ```\n\nThis `case` combinator does conditional composition and distribution all in one. It\u2019s helpful to think of the type `C` as the type of a shared environment that both branches of the `case` expression get access to. Accordingly, the `case` combinator has the following semantics.\n\n* `\u27e6case f g\u27e7\u27e8\u03c3\u1d38(a), c\u27e9 = \u27e6f\u27e7\u27e8a, c\u27e9`\n* `\u27e6case f g\u27e7\u27e8\u03c3\u1d3f(b), c\u27e9 = \u27e6g\u27e7\u27e8b, c\u27e9`\n\n## Four more Combinators\n\nWe are still missing a few fundamental operations on our types. For instance, we can use `pair` to produce product types, but we have no way yet to consume product types. Similarly, the `case` combinator consumes sum types, but we have no way yet to produce sum types. Four additional combinators enable the consumption of product types and production of sum types. The first two combinators extract one of the values of a pair, and execute a function on it:\n\n* ```none\n       f : A \u22a2 C\n  ------------------\n  take f : A \u00d7 B \u22a2 C\n  ```\n\n\n* ```none\n       f : B \u22a2 C\n  ------------------\n  drop f : A \u00d7 B \u22a2 C\n  ```\n\nThe last two combinators execute a function and wrap the result with either a left tag or a right tag.\n\n* ```none\n       f : A \u22a2 B\n  ------------------\n  injl f : A \u22a2 B + C\n  ```\n\n\n* ```none\n       f : A \u22a2 C\n  ------------------\n  injr f : A \u22a2 B + C\n  ```\n\nThese combinators have the required semantics:\n\n* `\u27e6take f\u27e7\u27e8a, b\u27e9 = \u27e6f\u27e7(a)`\n* `\u27e6drop f\u27e7\u27e8a, b\u27e9 = \u27e6f\u27e7(b)`\n* `\u27e6injl f\u27e7(a) = \u03c3\u1d38(\u27e6f\u27e7(a))`\n* `\u27e6injr f\u27e7(a) = \u03c3\u1d3f(\u27e6f\u27e7(a))`\n\n# Simplicity and the Sequent Calculus\n\nReaders familiar with formal logic will find a resemblance between our set of nine rules and the conjunctive-disjunctive fragment of Gentzen\u2019s sequent calculus. The sequent calculus inspired Simplicity\u2019s language design. One can think of Simplicity as a slightly tweaked variant of the \u201cfunctional interpretation\u201d of Gentzen\u2019s sequent calculus, which is analogous to the Curry-Howard correspondence between natural deduction and the lambda calculus.\n\nNotice that the premises in the combinator rules of the core Simplicity language are typically \u201csmaller\u201d than the types in the conclusion. Later in this series we will describe \u201cthe Bit Machine\u201d, an abstract stack machine for interpreting Simplicity expressions. The Bit Machine takes advantage of this phenomenon of \u201csmaller types in the premises\u201d to minimize the amount of data copied during execution. Only the `iden` and `comp` core combinators involve moving data around, and the rest of the core combinators are implemented with just some bookkeeping.\n\n# Values are not Expressions\n\nAbove we gave notation for the values of the various types that Simplicity supports. It is important to note that Simplicity expressions only denote operations, and operations are functions, not values. We can construct values by starting with the `unit` function and composing it with `injl`, `injr` and `pair` combinators. To avoid writing out such tedious constructions, we introduce the following notation.\n\nGiven a value of some Simplicity type, `b : B`, we write `scribe b : A \u22a2 B` for the unique Simplicity expression that always returns the value `b`. For example, `scribe \u27e8\u03c3\u1d38\u27e8\u27e9, \u03c3\u1d3f\u27e8\u27e9\u27e9` is shorthand for `injl unit \u25b5 injr unit : A \u22a2 \ud835\udfda \u00d7 \ud835\udfda`. Keep in mind that, `scribe` isn\u2019t a Simplicity combinator; it is a macro-like notional convenience.\n\nBitcoin Script has a similar property; Bitcoin Script only contains operations. For example `OP_1` is the operation that pushes the value `1` onto the stack, but there is no Bitcoin Script expression for the value `1` itself.\n\n# Simplicity\u2019s Completeness Theorem\n\nEarlier we saw that the na\u00efve realization of conditional composition would have left us unable to define the \u201cdistribution\u201d function `dist : (A + B) \u00d7 C \u22a2 A \u00d7 C + B \u00d7 C`. How do we know that we aren\u2019t missing something else?\n\nThe answer is that the \u201cSimplicity Completeness theorem\u201d proves that for any function between two Simplicity types there exists some Simplicity expression that denotes it.\n\nWe already saw `scribe`, which is a special case of the Simplicity Completeness theorem for constant functions. For other functions, we can build an nested set of `case` expressions to fully decompose any input of any type and compose that with a `scribe` expression for every output value. This procedure constructs what is effectively a giant lookup table to implement any function.\n\nBut you don\u2019t have to trust us. The core Simplicity language is formally specified in the Rocq proof assistant (formerly named the Coq proof assistant), and the [Simplicity Completeness theorem](https://github.com/BlockstreamResearch/simplicity/blob/8adafc9b55d694111c99fa11f90c7e48376ed1e5/Coq/Simplicity/Core.v#L92-L93) is one of the theorems we have formally verified.\n\n# Conclusion\n\nWe described Simplicity\u2019s type system, combinators, and basic expressions that make up Simplicity\u2019s core computational language. Later in this series, we will describe how Simplicity interacts with transactions and introduce a few more Simplicity combinators.\n\nBut before delving into that, in Part \u2162, we will look at building data structures and computation from this seemingly meager language. While we do have the Simplicity Completeness theorem, the expressions that the theorem constructs are astronomical in size, making it only useful as a theoretical tool. The practice of generating succinct Simplicity expressions could be viewed as an exercise in compression by exploiting structure within computations.",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 351,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "In <a href=\"https://delvingbitcoin.org/t/delving-simplicity-part-three-fundamental-ways-of-combining-computations/1902\">Part \u2160</a> of this series, we described the three methods of composition in programming: sequential, parallel, and conditional. In this part, we will see how these methods of composition are directly realized within Simplicity. \n<a name=\"p-5737-simplicity-types-1\" class=\"anchor\" href=\"#p-5737-simplicity-types-1\"></a>Simplicity Types\nParallel compositions produce an output that is a produ&hellip;",
  "truncated": true,
  "post_url": "/t/delving-simplicity-part-combinator-completeness-of-simplicity/1935/1",
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}