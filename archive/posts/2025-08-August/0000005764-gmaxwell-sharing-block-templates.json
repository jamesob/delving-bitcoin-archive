{
  "id": 5764,
  "name": "",
  "username": "gmaxwell",
  "avatar_template": "/letter_avatar_proxy/v4/letter/g/fbc32d/{size}.png",
  "created_at": "2025-08-22T11:34:53.287Z",
  "cooked": "<p>Right my intuition is that you want to send some check value to confirm you got a correct decode regardless.   You could just use a hash, but using a minisketch has the advantage of letting you do more than just pass-fail.  An implementation could start by just using it as a pass/fail like a hash.</p>\n<p>When doing the math on short-id collisions it turns out that the failure rate is dominated by cases where there is just a one or two collisions (unless the short-id is woefully too small), so being able to disambiguate just a couple is potentially useful.</p>\n<p>Assuming it\u2019s all unsalted the sketch is very close to free to compute, like store w/ txn their sketch values, and you just xor them when building the template (either on the sender side or as the receiver decodes).</p>\n<p>I suggested size 8 kind of as a random example, with the thought in mind that overly small minisketches have a non-negligible probability of false decode.  Though I didn\u2019t bother to run the calculator to check (there is a function in the library), IIRC it\u2019s cryptographically negligible by size 8 for 64-bit hashes but it might also be by size 4.</p>\n<p>Information theoretically it should be possible to decode minisketch sketches well beyond the size limit if you happen to have a list of candidate elements that you expect to be more likely in the difference \u2013 like your own mempool or a list of collisions.  Unfortunately we don\u2019t currently know of a decoder that can exploit that which has subexponential complexity.  So like a 64bit * 8 element sketch could teach you 8 elements that you\u2019re missing, but it probably could tell you about removing 30 extra elements you have that you shouldn\u2019t out of a collection of 1000. (the exponential decoder is the one that just brute force tries toggling every combination of your set then runs the ordinary quadratic decoder).  I only mention it because this is a case where it would be handy to go beyond the bound, but it\u2019s really a sidebar unless someone figures out how to make it tractable <img src=\"https://delvingbitcoin.org/images/emoji/twitter/stuck_out_tongue.png?v=14\" title=\":stuck_out_tongue:\" class=\"emoji\" alt=\":stuck_out_tongue:\" loading=\"lazy\" width=\"20\" height=\"20\"></p>\n<p>If the receiver picks the salt for the ordinary short ids and has been caching it all along then it\u2019s very cheap to do the decode anyways, so I don\u2019t know that your third example is that compelling.</p>",
  "post_number": 16,
  "post_type": 1,
  "posts_count": 17,
  "updated_at": "2025-08-22T11:34:53.287Z",
  "reply_count": 1,
  "reply_to_post_number": 15,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 5,
  "readers_count": 4,
  "score": 6.0,
  "yours": false,
  "topic_id": 1906,
  "topic_slug": "sharing-block-templates",
  "topic_title": "Sharing block templates",
  "topic_html_title": "Sharing block templates",
  "category_id": 8,
  "display_username": "",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "reply_to_user": {
    "id": 3,
    "username": "ajtowns",
    "name": "Anthony Towns",
    "avatar_template": "/user_avatar/delvingbitcoin.org/ajtowns/{size}/417_2.png"
  },
  "bookmarked": false,
  "raw": "Right my intuition is that you want to send some check value to confirm you got a correct decode regardless.   You could just use a hash, but using a minisketch has the advantage of letting you do more than just pass-fail.  An implementation could start by just using it as a pass/fail like a hash.\n\nWhen doing the math on short-id collisions it turns out that the failure rate is dominated by cases where there is just a one or two collisions (unless the short-id is woefully too small), so being able to disambiguate just a couple is potentially useful.\n\nAssuming it\u2019s all unsalted the sketch is very close to free to compute, like store w/ txn their sketch values, and you just xor them when building the template (either on the sender side or as the receiver decodes).\n\nI suggested size 8 kind of as a random example, with the thought in mind that overly small minisketches have a non-negligible probability of false decode.  Though I didn\u2019t bother to run the calculator to check (there is a function in the library), IIRC it\u2019s cryptographically negligible by size 8 for 64-bit hashes but it might also be by size 4.\n\nInformation theoretically it should be possible to decode minisketch sketches well beyond the size limit if you happen to have a list of candidate elements that you expect to be more likely in the difference \u2013 like your own mempool or a list of collisions.  Unfortunately we don\u2019t currently know of a decoder that can exploit that which has subexponential complexity.  So like a 64bit \\* 8 element sketch could teach you 8 elements that you\u2019re missing, but it probably could tell you about removing 30 extra elements you have that you shouldn\u2019t out of a collection of 1000. (the exponential decoder is the one that just brute force tries toggling every combination of your set then runs the ordinary quadratic decoder).  I only mention it because this is a case where it would be handy to go beyond the bound, but it\u2019s really a sidebar unless someone figures out how to make it tractable :P\n\nIf the receiver picks the salt for the ordinary short ids and has been caching it all along then it\u2019s very cheap to do the decode anyways, so I don\u2019t know that your third example is that compelling.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 699,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "Right my intuition is that you want to send some check value to confirm you got a correct decode regardless.   You could just use a hash, but using a minisketch has the advantage of letting you do more than just pass-fail.  An implementation could start by just using it as a pass/fail like a hash. \nW&hellip;",
  "truncated": true,
  "post_url": "/t/sharing-block-templates/1906/16",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}