{
  "id": 5775,
  "name": "Bruno Garcia",
  "username": "bruno",
  "avatar_template": "/user_avatar/delvingbitcoin.org/bruno/{size}/60_2.png",
  "created_at": "2025-08-27T14:04:57.455Z",
  "cooked": "<h1><a name=\"p-5775-the-state-of-bitcoinfuzz-1\" class=\"anchor\" href=\"#p-5775-the-state-of-bitcoinfuzz-1\"></a>The state of Bitcoinfuzz</h1>\n<p><strong>bitcoinfuzz</strong> is a project that does differential fuzzing of Bitcoin protocol implementations and libraries. I originally created it as an experiment, and the first version was quite rough with a poor design.\nAs the project started gaining attention, I refactored it to follow a modular approach similar to cryptofuzz. It means that you can choose which projects you want to fuzz, and you can build the projects (we call modules) individually.</p>\n<p>The first targets that I wrote were descriptor and miniscript parsers, where we found many bugs. The first one we reported was in sipa\u2019s miniscript implementation, which incorrectly considered <code>pk()()</code> as a valid policy because it identifies <code>)(</code> as the name. Currently, we have many other targets like: script evaluation, descriptor parse, miniscript parse, addrv2, psbt, address parse, and others. We plan to expand and work on additional targets in the near future.</p>\n<p>So far, we discovered and reported over 35 bugs in projects such as btcd, rust-bitcoin, rust-miniscript, Embit, Bitcoin Core, Core Lightning, LND, etc. Examples include: many implementations using the incorrect type for the key\u2019s type value for PSBTs, the CVE-2024-44073 of rust-miniscript, panic on btcd\u2019s PSBT parser ( <a href=\"https://github.com/btcsuite/btcd/issues/2351\" class=\"inline-onebox\">[bug]: PSBT Parser Panic: Missing Bounds Check in ReadBip32Derivation() \u00b7 Issue #2351 \u00b7 btcsuite/btcd \u00b7 GitHub</a> ), Embit incorrectly pointing a miniscript as valid ( <a href=\"https://github.com/bitcoinfuzz/bitcoinfuzz/issues/113\" class=\"inline-onebox\">miniscript_parse: crash with `ttvtvtvtvtvtvtv:after(2)` \u00b7 Issue #113 \u00b7 bitcoinfuzz/bitcoinfuzz \u00b7 GitHub</a> ), Core Lightning accepting invoices with non-standard witness address fallbacks that other implementations correctly reject ( <a href=\"https://github.com/ElementsProject/lightning/pull/8219\" class=\"inline-onebox\">Enforce minimum witness program length for fallback addresses in BOLT11 parsing by erickcestari \u00b7 Pull Request #8219 \u00b7 ElementsProject/lightning \u00b7 GitHub</a> ).</p>\n<h2><a name=\"p-5775-what-are-the-current-projects-we-support-2\" class=\"anchor\" href=\"#p-5775-what-are-the-current-projects-we-support-2\"></a>What are the current projects we support?</h2>\n<p>We currently integrate and support the following projects:</p>\n<ul>\n<li>Bitcoin Core - C++</li>\n<li>rust-bitcoin - Rust</li>\n<li>rust-miniscript - Rust</li>\n<li>embit - Python</li>\n<li>btcd - Golang</li>\n<li>LDK - Rust</li>\n<li>LND - Golang</li>\n<li>Core Lightning - C</li>\n<li>NLightning - C#</li>\n<li>NBitcoin - C#</li>\n<li>Eclair - Scala</li>\n<li>lightning-kmp - Kotlin</li>\n</ul>\n<p>There is a PR (under review) that integrates libbitcoin. We welcome any PR that integrates more projects into bitcoinfuzz. However, we intend to review the support of some implementations since an immature implementation can hinder differential fuzzing with simple issues. For example, Embit\u2019s miniscript/descriptor implementation is still incomplete, with many fragments not supported. We also experimented with Mako support, but decided to remove it because the project is not currently being maintained.</p>\n<h2><a name=\"p-5775-lightning-network-on-bitcoinfuzz-3\" class=\"anchor\" href=\"#p-5775-lightning-network-on-bitcoinfuzz-3\"></a>Lightning Network on Bitcoinfuzz</h2>\n<p>Differential fuzzing of Lightning implementations is proving to be highly valuable.. To advance this effort Erick Cestari and Morehouse have joined the project. Erick began working on it as a Vinteum fellow, mentored by Bruno and Morehouse, and more recently received a full grant from Vinteum. So far, bitcoinfuzz includes targets for BOLT11 invoice decoding and BOLT12 offer decoding. There are also open pull requests adding lightning-kmp module for invoice deserialization, BOLT12 invoice request decoding, adding Eclair module for invoice deserialization, and more.</p>\n<p>One advantage of applying differential fuzzing to Lightning implementations is that the Lightning Network has a well maintained specification. It means that when we find any discrepancy, we can reference the spec to determine the correct behavior. This is not the case for Bitcoin protocol implementations, where we mostly rely on Bitcoin Core as the reference. However, we have seen that differential fuzzing is also a good tool to improve the Lightning spec itself. From our experience, the specification is not always clear and often leaves room for improvement. As an example, one of the bitcoinfuzz trophies is a fix on the bolt12 specification, where a currency UTF-8 test vector lacked the required 3-byte length. As a result, many implementations were treating it as a case of malformed currency length instead of properly validating the UTF-8 encoding.</p>\n<p>Also, bitcoinfuzz found bugs in virtually every implementation we support. E.g.</p>\n<ul>\n<li>Core Lightning was accepting invoices with non-standard witness address fallbacks that other implementations correctly reject;</li>\n<li>When deserializing an invoice with a large expiry value, LND produces a negative expiry value due to overflow;</li>\n<li>rust-lightning was not verifying whether the offer_currency field contains valid UTF-8 for invoices.</li>\n<li>Eclair was accepting bolt11 invoices with empty routing hints in the r field.</li>\n</ul>\n<h2><a name=\"p-5775-doing-differential-fuzzing-of-projects-that-do-not-have-fuzz-testing-4\" class=\"anchor\" href=\"#p-5775-doing-differential-fuzzing-of-projects-that-do-not-have-fuzz-testing-4\"></a>Doing differential fuzzing of projects that do not have fuzz testing</h2>\n<p>Some projects either lack support for fuzzing altogether or do not run their fuzz targets continuously. In these cases, we sometimes find bugs not because of the\n\u201cdifferential\u201d aspect, but simply because the project has not been fuzzed at all. As an example, we found and reported a panic on btcd when parsing a PSBT due to a bug on the <code>ReadTaprootBip32Derivation</code> functions. This type of bug could have been easily caught by a basic fuzz target and a few minutes of execution. Similar cases occurred with rust-miniscript and lightning-kmp.</p>\n<h2><a name=\"p-5775-nuances-can-also-get-in-the-way-5\" class=\"anchor\" href=\"#p-5775-nuances-can-also-get-in-the-way-5\"></a>Nuances can also get in the way</h2>\n<p>When we find a discrepancy between two implementations, it doesn\u2019t always mean there is a bug in one of them. Sometimes small differences in behavior lead to interesting cases. For example, Bitcoin Core accepted miniscripts and descriptors with integer values containing trailing zeros or a positive sign (+) - e.g. <code>older(+1)</code> or <code>older(000001)</code>, we believe that no one uses it in practice, however, since rust-miniscript rejects these cases, it would cause a discrepancy between them. That said, Bitcoin Core addressed it in <a href=\"https://github.com/bitcoin/bitcoin/pull/30577\" class=\"inline-onebox\">miniscript: Use `ToIntegral` instead of `ParseInt64` by brunoerg \u00b7 Pull Request #30577 \u00b7 bitcoin/bitcoin \u00b7 GitHub</a> by using ToIntegral instead of ParseInt64.</p>\n<h2><a name=\"p-5775-oss-fuzz-6\" class=\"anchor\" href=\"#p-5775-oss-fuzz-6\"></a>OSS-Fuzz</h2>\n<p>We recently opened a PR to integrate bitcoinfuzz into OSS-Fuzz, Google\u2019s continuous fuzzing infrastructure for open\u2011source software. We believe that it would benefit our project a lot since we currently have a limited fuzzing infrastructure.</p>\n<h2><a name=\"p-5775-corpora-7\" class=\"anchor\" href=\"#p-5775-corpora-7\"></a>Corpora</h2>\n<p>We created a repository where we share some corpora for our fuzzing targets, similar to Bitcoin Core\u2019s qa-assets. However, we might keep two folders per target. One folder with all the inputs (maximizing coverage) and another excluding inputs that we know would trigger crashes - e.g. when we\u2019re waiting for an implementation to fix a reported bug. The goal of the second folder is to make it possible to run bitcoinfuzz in CI/CD pipelines.</p>\n<h2><a name=\"p-5775-future-work-8\" class=\"anchor\" href=\"#p-5775-future-work-8\"></a>Future work</h2>\n<p>We have several directions we\u2019re eager to explore. In the short term, our focus is on expanding bitcoinfuzz to be fully agnostic and compatible with multiple fuzzing engines beyond libFuzzer. We also plan to introduce new fuzzing targets\u2014such as BOLT8, BOLT7, BOLT4 and ElligatorSwift/V2 Transport \u2014 and to strengthen our build system, with a particular emphasis on resolving linking issues.</p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 1,
  "updated_at": "2025-08-27T14:04:57.455Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 15,
  "reads": 18,
  "readers_count": 17,
  "score": 148.2,
  "yours": false,
  "topic_id": 1946,
  "topic_slug": "the-state-of-bitcoinfuzz",
  "topic_title": "The state of bitcoinfuzz",
  "topic_html_title": "The state of bitcoinfuzz",
  "category_id": 8,
  "display_username": "Bruno Garcia",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "# The state of Bitcoinfuzz\n\n**bitcoinfuzz** is a project that does differential fuzzing of Bitcoin protocol implementations and libraries. I originally created it as an experiment, and the first version was quite rough with a poor design.\nAs the project started gaining attention, I refactored it to follow a modular approach similar to cryptofuzz. It means that you can choose which projects you want to fuzz, and you can build the projects (we call modules) individually.\n\nThe first targets that I wrote were descriptor and miniscript parsers, where we found many bugs. The first one we reported was in sipa\u2019s miniscript implementation, which incorrectly considered `pk()()` as a valid policy because it identifies `)(` as the name. Currently, we have many other targets like: script evaluation, descriptor parse, miniscript parse, addrv2, psbt, address parse, and others. We plan to expand and work on additional targets in the near future.\n\nSo far, we discovered and reported over 35 bugs in projects such as btcd, rust-bitcoin, rust-miniscript, Embit, Bitcoin Core, Core Lightning, LND, etc. Examples include: many implementations using the incorrect type for the key\u2019s type value for PSBTs, the CVE-2024-44073 of rust-miniscript, panic on btcd\u2019s PSBT parser ( https://github.com/btcsuite/btcd/issues/2351 ), Embit incorrectly pointing a miniscript as valid ( https://github.com/bitcoinfuzz/bitcoinfuzz/issues/113 ), Core Lightning accepting invoices with non-standard witness address fallbacks that other implementations correctly reject ( https://github.com/ElementsProject/lightning/pull/8219 ).\n\n## What are the current projects we support?\n\nWe currently integrate and support the following projects:\n\n* Bitcoin Core - C++\n* rust-bitcoin - Rust\n* rust-miniscript - Rust\n* embit - Python\n* btcd - Golang\n* LDK - Rust\n* LND - Golang\n* Core Lightning - C\n* NLightning - C#\n* NBitcoin - C#\n* Eclair - Scala\n* lightning-kmp - Kotlin\n\nThere is a PR (under review) that integrates libbitcoin. We welcome any PR that integrates more projects into bitcoinfuzz. However, we intend to review the support of some implementations since an immature implementation can hinder differential fuzzing with simple issues. For example, Embit\u2019s miniscript/descriptor implementation is still incomplete, with many fragments not supported. We also experimented with Mako support, but decided to remove it because the project is not currently being maintained.\n\n## Lightning Network on Bitcoinfuzz\n\nDifferential fuzzing of Lightning implementations is proving to be highly valuable.. To advance this effort Erick Cestari and Morehouse have joined the project. Erick began working on it as a Vinteum fellow, mentored by Bruno and Morehouse, and more recently received a full grant from Vinteum. So far, bitcoinfuzz includes targets for BOLT11 invoice decoding and BOLT12 offer decoding. There are also open pull requests adding lightning-kmp module for invoice deserialization, BOLT12 invoice request decoding, adding Eclair module for invoice deserialization, and more.\n\nOne advantage of applying differential fuzzing to Lightning implementations is that the Lightning Network has a well maintained specification. It means that when we find any discrepancy, we can reference the spec to determine the correct behavior. This is not the case for Bitcoin protocol implementations, where we mostly rely on Bitcoin Core as the reference. However, we have seen that differential fuzzing is also a good tool to improve the Lightning spec itself. From our experience, the specification is not always clear and often leaves room for improvement. As an example, one of the bitcoinfuzz trophies is a fix on the bolt12 specification, where a currency UTF-8 test vector lacked the required 3-byte length. As a result, many implementations were treating it as a case of malformed currency length instead of properly validating the UTF-8 encoding.\n\nAlso, bitcoinfuzz found bugs in virtually every implementation we support. E.g.\n\n* Core Lightning was accepting invoices with non-standard witness address fallbacks that other implementations correctly reject;\n* When deserializing an invoice with a large expiry value, LND produces a negative expiry value due to overflow;\n* rust-lightning was not verifying whether the offer_currency field contains valid UTF-8 for invoices.\n* Eclair was accepting bolt11 invoices with empty routing hints in the r field.\n\n## Doing differential fuzzing of projects that do not have fuzz testing\n\nSome projects either lack support for fuzzing altogether or do not run their fuzz targets continuously. In these cases, we sometimes find bugs not because of the\n\u201cdifferential\u201d aspect, but simply because the project has not been fuzzed at all. As an example, we found and reported a panic on btcd when parsing a PSBT due to a bug on the `ReadTaprootBip32Derivation` functions. This type of bug could have been easily caught by a basic fuzz target and a few minutes of execution. Similar cases occurred with rust-miniscript and lightning-kmp.\n\n## Nuances can also get in the way\n\nWhen we find a discrepancy between two implementations, it doesn\u2019t always mean there is a bug in one of them. Sometimes small differences in behavior lead to interesting cases. For example, Bitcoin Core accepted miniscripts and descriptors with integer values containing trailing zeros or a positive sign (+) - e.g. `older(+1)` or `older(000001)`, we believe that no one uses it in practice, however, since rust-miniscript rejects these cases, it would cause a discrepancy between them. That said, Bitcoin Core addressed it in https://github.com/bitcoin/bitcoin/pull/30577 by using ToIntegral instead of ParseInt64.\n\n## OSS-Fuzz\n\nWe recently opened a PR to integrate bitcoinfuzz into OSS-Fuzz, Google\u2019s continuous fuzzing infrastructure for open\u2011source software. We believe that it would benefit our project a lot since we currently have a limited fuzzing infrastructure.\n\n## Corpora\n\nWe created a repository where we share some corpora for our fuzzing targets, similar to Bitcoin Core\u2019s qa-assets. However, we might keep two folders per target. One folder with all the inputs (maximizing coverage) and another excluding inputs that we know would trigger crashes - e.g. when we\u2019re waiting for an implementation to fix a reported bug. The goal of the second folder is to make it possible to run bitcoinfuzz in CI/CD pipelines.\n\n## Future work\n\nWe have several directions we\u2019re eager to explore. In the short term, our focus is on expanding bitcoinfuzz to be fully agnostic and compatible with multiple fuzzing engines beyond libFuzzer. We also plan to introduce new fuzzing targets\u2014such as BOLT8, BOLT7, BOLT4 and ElligatorSwift/V2 Transport \u2014 and to strengthen our build system, with a particular emphasis on resolving linking issues.",
  "actions_summary": [
    {
      "id": 2,
      "count": 6
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 72,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "<a name=\"p-5775-the-state-of-bitcoinfuzz-1\" class=\"anchor\" href=\"#p-5775-the-state-of-bitcoinfuzz-1\"></a>The state of Bitcoinfuzz\nbitcoinfuzz is a project that does differential fuzzing of Bitcoin protocol implementations and libraries. I originally created it as an experiment, and the first version was quite rough with a poor design.\nAs the project started gaining attention, I refactored it to follow &hellip;",
  "truncated": true,
  "post_url": "/t/the-state-of-bitcoinfuzz/1946/1",
  "reactions": [
    {
      "id": "rocket",
      "type": "emoji",
      "count": 6
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 6,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}