{
  "id": 5748,
  "name": "Hodlinator",
  "username": "hodlinator",
  "avatar_template": "/user_avatar/delvingbitcoin.org/hodlinator/{size}/905_2.png",
  "created_at": "2025-08-19T19:58:19.383Z",
  "cooked": "<p>Great to see progress in this area!</p>\n<p>Here follows first impressions from someone interested in programming languages but no expert by any means.</p>\n<hr>\n<aside class=\"quote no-group\" data-username=\"sanket1729\" data-post=\"1\" data-topic=\"1900\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/sanket1729/48/13_2.png\" class=\"avatar\"> sanket1729:</div>\n<blockquote>\n<pre><code class=\"lang-auto\">fn check_neg(v: bool) {\n    let v1: u1 = &lt;bool&gt;::into(v);\n    let v2: u64 = &lt;u1&gt;::into(v1);\n    assert!(jet::eq_8(v2, 0));\n}\n</code></pre>\n</blockquote>\n</aside>\n<p>What is happening here? Almost looks like the language has negative booleans that require a user defined function to check.</p>\n<hr>\n<p>Why does one use <code>jet::eq_8()</code> above with a <code>u64</code> parameter when the less-than operator for the same types has the <code>_64</code> suffix?</p>\n<aside class=\"quote no-group\" data-username=\"sanket1729\" data-post=\"1\" data-topic=\"1900\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/sanket1729/48/13_2.png\" class=\"avatar\"> sanket1729:</div>\n<blockquote>\n<p><code>   assert!(jet::lt_64(fees, max_fee));</code></p>\n</blockquote>\n</aside>\n<hr>\n<p>The repeated <code>let</code>-binding of <code>ctx</code> seems like it could make provability easier, but this language is meant to <em>compile down</em> to a provable language. Is there any goal to increase mutability in syntax at this higher level to gain ergonomics, <code>mut</code> without <code>let</code>, for example:</p>\n<p><code>jet::sha_256_ctx_8_add_32(mut ctx, sighash_tx_nifb());</code></p>\n<p>or is there intent behind preferring the current syntax?</p>\n<hr>\n<p>Again, I think it\u2019s phenomenal that work is being done in this area. Hope this comes off more as curious than ungrateful, and somewhat mirrors first impressions of others.</p>",
  "post_number": 5,
  "post_type": 1,
  "posts_count": 5,
  "updated_at": "2025-08-19T19:59:33.487Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 1,
  "incoming_link_count": 0,
  "reads": 10,
  "readers_count": 9,
  "score": 2.0,
  "yours": false,
  "topic_id": 1900,
  "topic_slug": "writing-simplicity-programs-with-simplicityhl",
  "topic_title": "Writing Simplicity Programs with SimplicityHL",
  "topic_html_title": "Writing Simplicity Programs with SimplicityHL",
  "category_id": 7,
  "display_username": "Hodlinator",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Great to see progress in this area!\n\nHere follows first impressions from someone interested in programming languages but no expert by any means.\n\n---\n\n[quote=\"sanket1729, post:1, topic:1900\"]\n```\nfn check_neg(v: bool) {\n    let v1: u1 = <bool>::into(v);\n    let v2: u64 = <u1>::into(v1);\n    assert!(jet::eq_8(v2, 0));\n}\n```\n\n[/quote]\n\nWhat is happening here? Almost looks like the language has negative booleans that require a user defined function to check.\n\n---\n\nWhy does one use `jet::eq_8()` above with a `u64` parameter when the less-than operator for the same types has the `_64` suffix?\n\n[quote=\"sanket1729, post:1, topic:1900\"]\n`   assert!(jet::lt_64(fees, max_fee));`\n\n[/quote]\n\n---\n\nThe repeated `let`-binding of `ctx` seems like it could make provability easier, but this language is meant to *compile down* to a provable language. Is there any goal to increase mutability in syntax at this higher level to gain ergonomics, `mut` without `let`, for example:\n\n`jet::sha_256_ctx_8_add_32(mut ctx, sighash_tx_nifb());`\n\nor is there intent behind preferring the current syntax?\n\n---\n\nAgain, I think it\u2019s phenomenal that work is being done in this area. Hope this comes off more as curious than ungrateful, and somewhat mirrors first impressions of others.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 539,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "Great to see progress in this area! \nHere follows first impressions from someone interested in programming languages but no expert by any means. \n\n\nWhat is happening here? Almost looks like the language has negative booleans that require a user defined function to check. \n\nWhy does one use jet::eq_8&hellip;",
  "truncated": true,
  "post_url": "/t/writing-simplicity-programs-with-simplicityhl/1900/5",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}