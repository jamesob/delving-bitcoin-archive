{
  "id": 5753,
  "name": "Anthony Towns",
  "username": "ajtowns",
  "avatar_template": "/user_avatar/delvingbitcoin.org/ajtowns/{size}/417_2.png",
  "created_at": "2025-08-20T05:26:23.360Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"gmaxwell\" data-post=\"8\" data-topic=\"1906\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/letter_avatar_proxy/v4/letter/g/fbc32d/48.png\" class=\"avatar\"> gmaxwell:</div>\n<blockquote>\n<p>I think my general thinking is that in the future nodes should just maintain a clone of a small (say 4-8) peers\u2019 \u201ctop two blocks\u201d (or three blocks) of mempool via deltas</p>\n</blockquote>\n</aside>\n<p>My original concept was along the lines of \u201cIt would be nice if blocks propagated quickly even if they include transactions filtered by 95% of the network\u201d \u2013 with the theory being that if 5% of the network isn\u2019t filtering them (and is a strongly connected subgraph), then that gives listening nodes a &gt;99% chance of having one of their peers be non-censoring, and thus they\u2019d be at least theoretically able to get the tx in advance. That\u2019s then good for censorship resistance, good for spam-filtering mining nodes who want to minimise their orphan rate, and good for nodes who haven\u2019t kept up with the latest policy/soft-fork changes.</p>\n<p>For that to work, I suspect you\u2019d want to continually be reviewing updated templates from all your peers, not just a select few of them, though.</p>\n<p>That only makes reducing the bandwidth and computation needed for processing updates more important, of course.</p>\n<aside class=\"quote no-group\" data-username=\"gmaxwell\" data-post=\"8\" data-topic=\"1906\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/letter_avatar_proxy/v4/letter/g/fbc32d/48.png\" class=\"avatar\"> gmaxwell:</div>\n<blockquote>\n<p>So each peer would have in memory a 2-3 block mempool tip which is the last one they shared with other peers, plus one for each of a couple peers they\u2019ve picked to remember.</p>\n</blockquote>\n</aside>\n<p>I\u2019d really like to have something reasonably widely deployed on mainnet to be able to get some data to inform these sorts of decisions, so I think something simple to start with makes sense, that can then be refined later.</p>\n<p>One idea might be to have a <code>GETTEMPLATE</code> request with no arguments just give a fresh 1MvB template encoded as a compact block, but to have something like <code>GETTEMPLATE 2 d02b1b466de4ab17a64c9dc81f7677f39e3e67fea1a83610f22dd3def6c55062</code> request a 2MvB template encoded as a delta versus a specified previous template received from this peer.</p>\n<aside class=\"quote no-group\" data-username=\"gmaxwell\" data-post=\"8\" data-topic=\"1906\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/letter_avatar_proxy/v4/letter/g/fbc32d/48.png\" class=\"avatar\"> gmaxwell:</div>\n<blockquote>\n<p>When a block comes in it can be relayed from or to any peer with a remembered template using highly efficient means.</p>\n</blockquote>\n</aside>\n<p>One of the nice things about compact blocks is that the node sending the block only has to calculate the compact block once; if they had to re-encode the block\u2019s tx list multiple times due to the different templates they\u2019d sent recently, or, worse, the different templates each peer had sent them, that might be cumbersome.</p>\n<aside class=\"quote no-group\" data-username=\"gmaxwell\" data-post=\"8\" data-topic=\"1906\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/letter_avatar_proxy/v4/letter/g/fbc32d/48.png\" class=\"avatar\"> gmaxwell:</div>\n<blockquote>\n<p>We had to use them in compact blocks because making the short IDs very short was essential to making it efficient, and without the salting we\u2019d probably want at least 128bit ids which would have put compact blocks consistently outside of TCP window sizes.</p>\n</blockquote>\n</aside>\n<p>Maybe something to think about would be having the receiver choose the salt and send it to the sender; eg <code>GETTEMPLATE 0x8c7e823d78453ad3 0xdd6e8934258433c5 2</code>. That puts some additional computational burden on the sender, but they only have to do the calculation on the txs in their template, so it shouldn\u2019t be very burdensome. Meanwhile the receiver could give the same salt to all their peers, and pre-calculate and index the short ids for everything in their mempool.</p>\n<p>That might be annoying in that it would let peers easily identify your node across distinct connections despite the use of tor/etc (though consistently providing the same templates would also do that). It might also allow adversarial nodes to construct txs that have the same shortid, resulting in reconstruction failures (if you had one of the txs but the template included the other).</p>\n<p>Another option might be to continue using 6-byte short ids with a random seed chosen fresh for each template by the sender, but for the receiver to only compare it against the template pool (including their own template which might be the top 3 MvB of their mempool) not their entire mempool. That would result in more round trips and perhaps some avoidable tx retransmissions, but maybe that\u2019s fine. If retransmissions are a problem, having a <code>GETBLOCKTXIDS</code> step to just get the missing wtxids rather going straight to getting the missing transactions could perhaps work.</p>",
  "post_number": 13,
  "post_type": 1,
  "posts_count": 24,
  "updated_at": "2025-08-20T05:26:23.360Z",
  "reply_count": 1,
  "reply_to_post_number": 8,
  "quote_count": 1,
  "incoming_link_count": 47,
  "reads": 62,
  "readers_count": 61,
  "score": 242.4,
  "yours": false,
  "topic_id": 1906,
  "topic_slug": "sharing-block-templates",
  "topic_title": "Sharing block templates",
  "topic_html_title": "Sharing block templates",
  "category_id": 8,
  "display_username": "Anthony Towns",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"gmaxwell, post:8, topic:1906\"]\nI think my general thinking is that in the future nodes should just maintain a clone of a small (say 4-8) peers\u2019 \u201ctop two blocks\u201d (or three blocks) of mempool via deltas\n[/quote]\n\nMy original concept was along the lines of \"It would be nice if blocks propagated quickly even if they include transactions filtered by 95% of the network\" -- with the theory being that if 5% of the network isn't filtering them (and is a strongly connected subgraph), then that gives listening nodes a >99% chance of having one of their peers be non-censoring, and thus they'd be at least theoretically able to get the tx in advance. That's then good for censorship resistance, good for spam-filtering mining nodes who want to minimise their orphan rate, and good for nodes who haven't kept up with the latest policy/soft-fork changes.\n\nFor that to work, I suspect you'd want to continually be reviewing updated templates from all your peers, not just a select few of them, though.\n\nThat only makes reducing the bandwidth and computation needed for processing updates more important, of course.\n\n[quote=\"gmaxwell, post:8, topic:1906\"]\nSo each peer would have in memory a 2-3 block mempool tip which is the last one they shared with other peers, plus one for each of a couple peers they\u2019ve picked to remember.\n[/quote]\n\nI'd really like to have something reasonably widely deployed on mainnet to be able to get some data to inform these sorts of decisions, so I think something simple to start with makes sense, that can then be refined later.\n\nOne idea might be to have a `GETTEMPLATE` request with no arguments just give a fresh 1MvB template encoded as a compact block, but to have something like `GETTEMPLATE 2 d02b1b466de4ab17a64c9dc81f7677f39e3e67fea1a83610f22dd3def6c55062` request a 2MvB template encoded as a delta versus a specified previous template received from this peer.\n\n[quote=\"gmaxwell, post:8, topic:1906\"]\nWhen a block comes in it can be relayed from or to any peer with a remembered template using highly efficient means.\n[/quote]\n\nOne of the nice things about compact blocks is that the node sending the block only has to calculate the compact block once; if they had to re-encode the block's tx list multiple times due to the different templates they'd sent recently, or, worse, the different templates each peer had sent them, that might be cumbersome.\n\n[quote=\"gmaxwell, post:8, topic:1906\"]\nWe had to use them in compact blocks because making the short IDs very short was essential to making it efficient, and without the salting we\u2019d probably want at least 128bit ids which would have put compact blocks consistently outside of TCP window sizes.\n[/quote]\n\nMaybe something to think about would be having the receiver choose the salt and send it to the sender; eg `GETTEMPLATE 0x8c7e823d78453ad3 0xdd6e8934258433c5 2`. That puts some additional computational burden on the sender, but they only have to do the calculation on the txs in their template, so it shouldn't be very burdensome. Meanwhile the receiver could give the same salt to all their peers, and pre-calculate and index the short ids for everything in their mempool. \n\nThat might be annoying in that it would let peers easily identify your node across distinct connections despite the use of tor/etc (though consistently providing the same templates would also do that). It might also allow adversarial nodes to construct txs that have the same shortid, resulting in reconstruction failures (if you had one of the txs but the template included the other). \n\nAnother option might be to continue using 6-byte short ids with a random seed chosen fresh for each template by the sender, but for the receiver to only compare it against the template pool (including their own template which might be the top 3 MvB of their mempool) not their entire mempool. That would result in more round trips and perhaps some avoidable tx retransmissions, but maybe that's fine. If retransmissions are a problem, having a `GETBLOCKTXIDS` step to just get the missing wtxids rather going straight to getting the missing transactions could perhaps work.",
  "actions_summary": [],
  "moderator": true,
  "admin": true,
  "staff": true,
  "user_id": 3,
  "hidden": false,
  "trust_level": 4,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "My original concept was along the lines of \u201cIt would be nice if blocks propagated quickly even if they include transactions filtered by 95% of the network\u201d \u2013 with the theory being that if 5% of the network isn\u2019t filtering them (and is a strongly connected subgraph), then that gives listening nodes &hellip;",
  "truncated": true,
  "post_url": "/t/sharing-block-templates/1906/13",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}