{
  "id": 5654,
  "name": "Anthony Towns",
  "username": "ajtowns",
  "avatar_template": "/user_avatar/delvingbitcoin.org/ajtowns/{size}/417_2.png",
  "created_at": "2025-08-05T19:08:31.704Z",
  "cooked": "<p>Over the last few years we\u2019ve started seeing significant divergence in mempool policies, particularly adoption of <a href=\"https://github.com/bitcoin/bitcoin/pull/25353\">full replace by fee</a>, <a href=\"https://github.com/bitcoinknots/bitcoin/releases/tag/v26.1.knots20240513\">various Knots spam filtering options</a>, <a href=\"https://github.com/bitcoin/bitcoin/pull/32406\">uncapped datacarrier/OP_RETURN</a> and most recently <a href=\"https://github.com/bitcoin/bitcoin/pull/32959\">0.1sat/vb minfee</a>.</p>\n<h3><a name=\"p-5654-background-1\" class=\"anchor\" href=\"#p-5654-background-1\"></a>Background</h3>\n<p>A technical aspect that has influenced those discussions is the impact on compact block relay.</p>\n<p>As a quick reminder, it\u2019s fairly important for new blocks to be relayed quickly to other miners: if there are significant delays, that can both (a) increase the orphan rate for smaller miners, leading to higher comparative returns for larger miners, leading to centralisation, and (b) make attacks such as <a href=\"https://delvingbitcoin.org/t/where-does-the-33-33-threshold-for-selfish-mining-come-from/1757\">selfish mining</a> easier to perform. Compact block relay, which was released in <a href=\"https://bitcoincore.org/en/releases/0.13.0/\">Bitcoin Core 0.13.0</a> in August 2016 provides a way to significantly improve block relay speeds, but relies on each node\u2019s mempool making an reasonably accurate prediction of what transactions will be in the next block. When it gets it right, the current tip can be updated without requiring a round-trip over the network, potentially reducing relay time to a third of what it might otherwise be. This effect can be observed in <a href=\"https://www.dsn.kastel.kit.edu/bitcoin/#propagation\">the DSN Block Propagation History charts</a>, driving block propagation times down from around 5s to very close to 0s:</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/2X/8/836776ecd335c3cda6bb995651703a4c22997080.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/836776ecd335c3cda6bb995651703a4c22997080\" title=\"image\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/2X/8/836776ecd335c3cda6bb995651703a4c22997080_2_690x345.png\" alt=\"image\" data-base62-sha1=\"iKsdFff7t3D9QCYfn6q73PpWnPG\" width=\"690\" height=\"345\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/2X/8/836776ecd335c3cda6bb995651703a4c22997080_2_690x345.png, https://delvingbitcoin.org/uploads/default/optimized/2X/8/836776ecd335c3cda6bb995651703a4c22997080_2_1035x517.png 1.5x, https://delvingbitcoin.org/uploads/default/original/2X/8/836776ecd335c3cda6bb995651703a4c22997080.png 2x\" data-dominant-color=\"F2F6F4\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">image</span><span class=\"informations\">1110\u00d7555 70.9 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>The expected orphan rate if blocks take about 5s to propagate is perhaps 1.2 per day; if they take about 300ms, it\u2019s about once every two weeks, roughly matching <a href=\"https://delvingbitcoin.org/t/where-does-the-33-33-threshold-for-selfish-mining-come-from/1757/5\">observed rates</a>.</p>\n<p>The practical impact of the adoption of diverse mempool policies by nodes and miners has been written up in another topic:</p>\n<aside class=\"quote quote-modified\" data-post=\"1\" data-topic=\"1052\">\n  <div class=\"title\">\n    <div class=\"quote-controls\"></div>\n    <img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/0xb10c/48/15_2.png\" class=\"avatar\">\n    <a href=\"https://delvingbitcoin.org/t/stats-on-compact-block-reconstructions/1052/\">Stats on compact block reconstructions</a> <a class=\"badge-category__wrapper \" href=\"/c/protocol-design/7\"><span data-category-id=\"7\" style=\"--category-badge-color: #0088CC; --category-badge-text-color: #FFFFFF;\" data-drop-close=\"true\" class=\"badge-category \" title=\"Bitcoin-related protocol proposals, or analysis or discussion thereof. For example, new P2P messages, new wallet techniques, methods for coinjoins or payment channels, etc.\"><span class=\"badge-category__name\">Protocol Design</span></span></a>\n  </div>\n  <blockquote>\n    I\u2019ve recently looked at compact block reconstruction statistics from the debug.log\u2019s of my <a href=\"https://public.peer.observer\">monitoring nodes</a>. Particularly, at how many blocks require an extra getblocktxn \u2192 blocktxn round-trip as the node does not know about transactions during block reconstruction. I thought I\u2019d share my data and a few observations here. \nMy nodes have debug=cmpctblock logging enabled. This allows me to grep for compact block reconstructions. The log output contains information on the number of transactions pre\u2026\n  </blockquote>\n</aside>\n\n<p>Last year, Greg raised the prospect of using <a href=\"https://delvingbitcoin.org/t/second-look-at-weak-blocks/805\">weak blocks</a> (including a proof of concept implementation), as one way to mitigate this \u2013 that way miners would (optionally) publish shares that didn\u2019t quite hit the proof-of-work target to the p2p network, and peers would be able to see what miners are actually working on, while still benefiting from proof-of-work to limit just how much traffic they have to deal with.</p>\n<p>To my mind, relying on proof-of-work has significant drawbacks: it biases towards groups with high hashrate, leading to a lot of repetition; and weak blocks will be spread out randomly across time, so if a miner with 10% hashrate wins the next block, their last weak block may well have been from 7 minutes ago (assuming weak blocks are 1/16th the difficulty of a real block), and thus be missing transactions, and still lead to a round-trip.</p>\n<h3><a name=\"p-5654-template-sharing-2\" class=\"anchor\" href=\"#p-5654-template-sharing-2\"></a>Template sharing</h3>\n<p>An alternative approach that I think could be made to work is simply sharing your block template with your peers. That is:</p>\n<ul>\n<li>you regularly generate a new block template from your mempool,</li>\n<li>you share that template with your peers when they ask for it</li>\n<li>you request your peers send you their template regularly</li>\n<li>you check txs in your peers\u2019 templates, adding them into your mempool if they meet your policy requirements and you didn\u2019t already have them</li>\n<li>if they don\u2019t meet your policy requirements, you keep the transactions in memory anyway, until you get a new template from that peer</li>\n<li>when you attempt to reconstruct a compact block, you use your peers\u2019 templates as a source of transactions in addition to your mempool</li>\n</ul>\n<p>This can be done fairly efficiently: using the compact block encoding, sharing a template of 3000 transactions requires a 20kB message, and because sharing templates is not particularly time sensitive, it\u2019s not much of a burden to request the missing transactions. Likewise, it\u2019s not much of a burden to just skip a template entirely if you\u2019re not able to cleanly reconstruct a template because the random numbers chosen give you conflicts.</p>\n<p>This approach has a couple of other benefits/properties too.</p>\n<p>It means that if you start up a node that either has an empty mempool or just one that\u2019s out of date, it will very quickly be populated with what your peers think are the highest fee paying transactions. That\u2019s beneficial not just for compact block relay, but also if your node is providing templates to miners, either as a pool template node, or as a datum or stratumv2 template provider for an individual miner.</p>\n<p>It also automates rebroadcasting transactions that may have dropped from default mempools, once fees have reduced and they get to the top of the mempool. This primarily has privacy benefits \u2013 rather than the only person likely to rebroadcast a transaction in that scenario being the sender or recipient, any p2p node with a large enough mempool to have kept it will include the tx in its templates, and those nodes\u2019 peers will rebroadcast the tx when they reconsider it for their mempools.</p>\n<p>It also provides a way to query the top of random nodes\u2019 mempools at fairly low cost, which may be useful for either overall analysis of network behaviour, or for detecting tx relay issues (in the event of pinning attacks, eg).</p>\n<p>I\u2019ve done a proof of concept of this approach at:</p>\n<aside class=\"onebox githubcommit\" data-onebox-src=\"https://github.com/ajtowns/bitcoin/commit/ee12518a4a5e8932175ee57c8f1ad116f675d089\">\n  <header class=\"source\">\n\n      <a href=\"https://github.com/ajtowns/bitcoin/commit/ee12518a4a5e8932175ee57c8f1ad116f675d089\" target=\"_blank\" rel=\"noopener\">github.com/ajtowns/bitcoin</a>\n  </header>\n\n  <article class=\"onebox-body\">\n    <div class=\"github-row\">\n  <div class=\"github-icon-container\" title=\"Commit\">\n    <svg width=\"60\" height=\"60\" class=\"github-icon\" viewBox=\"0 0 14 16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M10.86 7c-.45-1.72-2-3-3.86-3-1.86 0-3.41 1.28-3.86 3H0v2h3.14c.45 1.72 2 3 3.86 3 1.86 0 3.41-1.28 3.86-3H14V7h-3.14zM7 10.2c-1.22 0-2.2-.98-2.2-2.2 0-1.22.98-2.2 2.2-2.2 1.22 0 2.2.98 2.2 2.2 0 1.22-.98 2.2-2.2 2.2z\"></path></svg>\n  </div>\n\n  <div class=\"github-info-container\">\n    <h4>\n      <a href=\"https://github.com/ajtowns/bitcoin/commit/ee12518a4a5e8932175ee57c8f1ad116f675d089\" target=\"_blank\" rel=\"noopener\">wip: share template with peers</a>\n    </h4>\n\n    <div class=\"github-info\">\n      <div class=\"date\">\n        committed <span class=\"discourse-local-date\" data-format=\"ll\" data-date=\"2025-08-05\" data-time=\"07:03:16\" data-timezone=\"UTC\">07:03AM - 05 Aug 25 UTC</span>\n      </div>\n\n      <div class=\"user\">\n        <a href=\"https://github.com/ajtowns\" target=\"_blank\" rel=\"noopener\">\n          <img alt=\"\" src=\"https://delvingbitcoin.org/uploads/default/original/2X/8/8fdb4584494f0086a7873ac276d4821942b0737a.png\" class=\"onebox-avatar-inline\" width=\"20\" height=\"20\" data-dominant-color=\"BDB7AB\">\n          ajtowns\n        </a>\n      </div>\n\n      <div class=\"lines\" title=\"changed 4 files with 420 additions and 2 deletions\">\n        <a href=\"https://github.com/ajtowns/bitcoin/commit/ee12518a4a5e8932175ee57c8f1ad116f675d089\" target=\"_blank\" rel=\"noopener\">\n          <span class=\"added\">+420</span>\n          <span class=\"removed\">-2</span>\n        </a>\n      </div>\n    </div>\n  </div>\n</div>\n\n\n  </article>\n\n  <div class=\"onebox-metadata\">\n    \n    \n  </div>\n\n  <div style=\"clear: both\"></div>\n</aside>\n\n<p>It\u2019s setup to generate a template every 30s and keep the last ten generated templates (as a way of caching recently RBF\u2019ed txs), it only announces templates to peers when all the txs in the template are considered to have been announced to that peer (base on <code>last_inv</code> logic), and it requests templates from outbounds once every 2 minutes. Transactions that failed mempool policies that might succeed later will be retried every so often.</p>\n<p>It\u2019s limited in that it will only request templates from outbound/manual peers (to limit the additional memory use to something on the order of 30MB), and would need some cleverer budgeting logic to safely store txs from templates from random inbound connections. It also doesn\u2019t keep track of which transactions are actually in the mempool; doing that would likely make block reconstruction a bit more efficient, and is probably also necessary for any cleverer budgeting logic.</p>\n<p>Starting a signet node with an empty mempool (but synced blockchain) looks something like this:</p>\n<pre><code class=\"lang-auto\">2025-08-05T18:54:58Z [sharetmpl] Generated template for sharing hash=730e806fde65ec561c565bb46a7eaf858dce9603b1d4faf632325f0dabf83424 (1 txs)\n2025-08-05T18:54:58Z [net] sending sendtemplate (0 bytes) peer=0\n2025-08-05T18:54:58Z [net] received: sendtemplate (0 bytes) peer=0\n</code></pre>\n<p>At startup, we can only create an empty template and negotiate sending templates.</p>\n<pre><code class=\"lang-auto\">2025-08-05T18:54:58Z [net] sending gettemplate (0 bytes) peer=0\n2025-08-05T18:54:58Z [net] received: template (18542 bytes) peer=0\n2025-08-05T18:54:58Z [net] sending getblocktxn (3085 bytes) peer=0\n2025-08-05T18:54:59Z [net] received: blocktxn (1234572 bytes) peer=0\n2025-08-05T18:54:59Z [sharetmpl] Peer 0 sent us compact template 92b0f676a921478106506041b7695534092f7ab7a40a84ef84fda5976526d94c with 3050 transactions\n2025-08-05T18:54:59Z [sharetmpl] TemplateMan: 1 in my queue, 1 peer templates, 3052 txs\n</code></pre>\n<p>Then we pretty quickly request a template.</p>\n<pre><code class=\"lang-auto\">2025-08-05T18:55:28Z [sharetmpl] Generated template for sharing hash=2427faa7ba5bb5ab136ed6ba63c29600a82704b31892d80c2919ea861677f249 (3063 txs)\n2025-08-05T18:55:58Z [sharetmpl] Generated template for sharing hash=cf6989e8b1a1fb43422813fd5db984ed0bdbc88301b4e4a0d60cb93e01469004 (3078 txs)\n2025-08-05T18:56:28Z [sharetmpl] Generated template for sharing hash=886636973ebfe11de10e6f315d2375fe2b84b30656c5f02badd2f8305ccf84be (3083 txs)\n</code></pre>\n<p>Once we\u2019ve done that, and processed the transactions, our templates quickly become much more useful.</p>\n<pre><code class=\"lang-auto\">2025-08-05T18:56:58Z [net] sending gettemplate (0 bytes) peer=0\n2025-08-05T18:56:58Z [net] received: template (18746 bytes) peer=0\n2025-08-05T18:56:58Z [net] sending getblocktxn (61 bytes) peer=0\n2025-08-05T18:56:59Z [net] received: blocktxn (9617 bytes) peer=0\n2025-08-05T18:56:59Z [sharetmpl] Peer 0 sent us compact template 8d9d768304d48171a7c0daaefb399f6e17a2b939e6321579713ee76467ebf5fa with 26 transactions\n2025-08-05T18:56:59Z [sharetmpl] TemplateMan: 5 in my queue, 1 peer templates, 3209 txs\n</code></pre>\n<p>Then the next template from our peer still required some transactions, but much fewer.</p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 24,
  "updated_at": "2025-08-05T19:08:31.704Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 461,
  "reads": 102,
  "readers_count": 101,
  "score": 2415.0,
  "yours": false,
  "topic_id": 1906,
  "topic_slug": "sharing-block-templates",
  "topic_title": "Sharing block templates",
  "topic_html_title": "Sharing block templates",
  "category_id": 8,
  "display_username": "Anthony Towns",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Over the last few years we've started seeing significant divergence in mempool policies, particularly adoption of [full replace by fee](https://github.com/bitcoin/bitcoin/pull/25353), [various Knots spam filtering options](https://github.com/bitcoinknots/bitcoin/releases/tag/v26.1.knots20240513), [uncapped datacarrier/OP_RETURN](https://github.com/bitcoin/bitcoin/pull/32406) and most recently [0.1sat/vb minfee](https://github.com/bitcoin/bitcoin/pull/32959). \n\n### Background\n\nA technical aspect that has influenced those discussions is the impact on compact block relay.\n\nAs a quick reminder, it's fairly important for new blocks to be relayed quickly to other miners: if there are significant delays, that can both (a) increase the orphan rate for smaller miners, leading to higher comparative returns for larger miners, leading to centralisation, and (b) make attacks such as [selfish mining](https://delvingbitcoin.org/t/where-does-the-33-33-threshold-for-selfish-mining-come-from/1757) easier to perform. Compact block relay, which was released in [Bitcoin Core 0.13.0](https://bitcoincore.org/en/releases/0.13.0/) in August 2016 provides a way to significantly improve block relay speeds, but relies on each node's mempool making an reasonably accurate prediction of what transactions will be in the next block. When it gets it right, the current tip can be updated without requiring a round-trip over the network, potentially reducing relay time to a third of what it might otherwise be. This effect can be observed in [the DSN Block Propagation History charts](https://www.dsn.kastel.kit.edu/bitcoin/#propagation), driving block propagation times down from around 5s to very close to 0s:\n\n![image|690x345](upload://iKsdFff7t3D9QCYfn6q73PpWnPG.png)\n\nThe expected orphan rate if blocks take about 5s to propagate is perhaps 1.2 per day; if they take about 300ms, it's about once every two weeks, roughly matching [observed rates](https://delvingbitcoin.org/t/where-does-the-33-33-threshold-for-selfish-mining-come-from/1757/5).\n\nThe practical impact of the adoption of diverse mempool policies by nodes and miners has been written up in another topic:\n\nhttps://delvingbitcoin.org/t/stats-on-compact-block-reconstructions/1052/\n\nLast year, Greg raised the prospect of using [weak blocks](https://delvingbitcoin.org/t/second-look-at-weak-blocks/805) (including a proof of concept implementation), as one way to mitigate this -- that way miners would (optionally) publish shares that didn't quite hit the proof-of-work target to the p2p network, and peers would be able to see what miners are actually working on, while still benefiting from proof-of-work to limit just how much traffic they have to deal with. \n\nTo my mind, relying on proof-of-work has significant drawbacks: it biases towards groups with high hashrate, leading to a lot of repetition; and weak blocks will be spread out randomly across time, so if a miner with 10% hashrate wins the next block, their last weak block may well have been from 7 minutes ago (assuming weak blocks are 1/16th the difficulty of a real block), and thus be missing transactions, and still lead to a round-trip.\n\n### Template sharing\n\nAn alternative approach that I think could be made to work is simply sharing your block template with your peers. That is:\n\n * you regularly generate a new block template from your mempool, \n * you share that template with your peers when they ask for it\n * you request your peers send you their template regularly\n * you check txs in your peers' templates, adding them into your mempool if they meet your policy requirements and you didn't already have them\n * if they don't meet your policy requirements, you keep the transactions in memory anyway, until you get a new template from that peer\n * when you attempt to reconstruct a compact block, you use your peers' templates as a source of transactions in addition to your mempool\n\nThis can be done fairly efficiently: using the compact block encoding, sharing a template of 3000 transactions requires a 20kB message, and because sharing templates is not particularly time sensitive, it's not much of a burden to request the missing transactions. Likewise, it's not much of a burden to just skip a template entirely if you're not able to cleanly reconstruct a template because the random numbers chosen give you conflicts.\n\nThis approach has a couple of other benefits/properties too.\n\nIt means that if you start up a node that either has an empty mempool or just one that's out of date, it will very quickly be populated with what your peers think are the highest fee paying transactions. That's beneficial not just for compact block relay, but also if your node is providing templates to miners, either as a pool template node, or as a datum or stratumv2 template provider for an individual miner.\n\nIt also automates rebroadcasting transactions that may have dropped from default mempools, once fees have reduced and they get to the top of the mempool. This primarily has privacy benefits -- rather than the only person likely to rebroadcast a transaction in that scenario being the sender or recipient, any p2p node with a large enough mempool to have kept it will include the tx in its templates, and those nodes' peers will rebroadcast the tx when they reconsider it for their mempools.\n\nIt also provides a way to query the top of random nodes' mempools at fairly low cost, which may be useful for either overall analysis of network behaviour, or for detecting tx relay issues (in the event of pinning attacks, eg).\n\nI've done a proof of concept of this approach at:\n\nhttps://github.com/ajtowns/bitcoin/commit/ee12518a4a5e8932175ee57c8f1ad116f675d089\n\nIt's setup to generate a template every 30s and keep the last ten generated templates (as a way of caching recently RBF'ed txs), it only announces templates to peers when all the txs in the template are considered to have been announced to that peer (base on `last_inv` logic), and it requests templates from outbounds once every 2 minutes. Transactions that failed mempool policies that might succeed later will be retried every so often.\n\nIt's limited in that it will only request templates from outbound/manual peers (to limit the additional memory use to something on the order of 30MB), and would need some cleverer budgeting logic to safely store txs from templates from random inbound connections. It also doesn't keep track of which transactions are actually in the mempool; doing that would likely make block reconstruction a bit more efficient, and is probably also necessary for any cleverer budgeting logic.\n\nStarting a signet node with an empty mempool (but synced blockchain) looks something like this:\n\n```\n2025-08-05T18:54:58Z [sharetmpl] Generated template for sharing hash=730e806fde65ec561c565bb46a7eaf858dce9603b1d4faf632325f0dabf83424 (1 txs)\n2025-08-05T18:54:58Z [net] sending sendtemplate (0 bytes) peer=0\n2025-08-05T18:54:58Z [net] received: sendtemplate (0 bytes) peer=0\n```\n\nAt startup, we can only create an empty template and negotiate sending templates.\n\n```\n2025-08-05T18:54:58Z [net] sending gettemplate (0 bytes) peer=0\n2025-08-05T18:54:58Z [net] received: template (18542 bytes) peer=0\n2025-08-05T18:54:58Z [net] sending getblocktxn (3085 bytes) peer=0\n2025-08-05T18:54:59Z [net] received: blocktxn (1234572 bytes) peer=0\n2025-08-05T18:54:59Z [sharetmpl] Peer 0 sent us compact template 92b0f676a921478106506041b7695534092f7ab7a40a84ef84fda5976526d94c with 3050 transactions\n2025-08-05T18:54:59Z [sharetmpl] TemplateMan: 1 in my queue, 1 peer templates, 3052 txs\n```\n\nThen we pretty quickly request a template.\n\n```\n2025-08-05T18:55:28Z [sharetmpl] Generated template for sharing hash=2427faa7ba5bb5ab136ed6ba63c29600a82704b31892d80c2919ea861677f249 (3063 txs)\n2025-08-05T18:55:58Z [sharetmpl] Generated template for sharing hash=cf6989e8b1a1fb43422813fd5db984ed0bdbc88301b4e4a0d60cb93e01469004 (3078 txs)\n2025-08-05T18:56:28Z [sharetmpl] Generated template for sharing hash=886636973ebfe11de10e6f315d2375fe2b84b30656c5f02badd2f8305ccf84be (3083 txs)\n```\n\nOnce we've done that, and processed the transactions, our templates quickly become much more useful.\n\n```\n2025-08-05T18:56:58Z [net] sending gettemplate (0 bytes) peer=0\n2025-08-05T18:56:58Z [net] received: template (18746 bytes) peer=0\n2025-08-05T18:56:58Z [net] sending getblocktxn (61 bytes) peer=0\n2025-08-05T18:56:59Z [net] received: blocktxn (9617 bytes) peer=0\n2025-08-05T18:56:59Z [sharetmpl] Peer 0 sent us compact template 8d9d768304d48171a7c0daaefb399f6e17a2b939e6321579713ee76467ebf5fa with 26 transactions\n2025-08-05T18:56:59Z [sharetmpl] TemplateMan: 5 in my queue, 1 peer templates, 3209 txs\n```\n\nThen the next template from our peer still required some transactions, but much fewer.",
  "actions_summary": [
    {
      "id": 2,
      "count": 8
    }
  ],
  "moderator": true,
  "admin": true,
  "staff": true,
  "user_id": 3,
  "hidden": false,
  "trust_level": 4,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "Over the last few years we\u2019ve started seeing significant divergence in mempool policies, particularly adoption of <a href=\"https://github.com/bitcoin/bitcoin/pull/25353\">full replace by fee</a>, <a href=\"https://github.com/bitcoinknots/bitcoin/releases/tag/v26.1.knots20240513\">various Knots spam filtering options</a>, <a href=\"https://github.com/bitcoin/bitcoin/pull/32406\">uncapped datacarrier/OP_RETURN</a> and most recently <a href=\"https://github.com/bitcoin/bitcoin/pull/32959\">0.1sat/vb minfee</a>. \n<a name=\"p-5654-background-1\" class=\"anchor\" href=\"#p-5654-background-1\"></a>Background\nA technical aspect that has influenced those dis&hellip;",
  "truncated": true,
  "post_url": "/t/sharing-block-templates/1906/1",
  "reactions": [
    {
      "id": "eyes",
      "type": "emoji",
      "count": 4
    },
    {
      "id": "+1",
      "type": "emoji",
      "count": 3
    },
    {
      "id": "heart",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 8,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}