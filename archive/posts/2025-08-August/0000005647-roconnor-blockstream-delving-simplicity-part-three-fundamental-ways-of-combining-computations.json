{
  "id": 5647,
  "name": "",
  "username": "roconnor-blockstream",
  "avatar_template": "/user_avatar/delvingbitcoin.org/roconnor-blockstream/{size}/427_2.png",
  "created_at": "2025-08-05T14:41:08.061Z",
  "cooked": "<h1><a name=\"p-5647-series-introduction-1\" class=\"anchor\" href=\"#p-5647-series-introduction-1\"></a>Series Introduction</h1>\n<p>Now that Simplicity has been activated on the Liquid Network, I\u2019d like to do an in-depth dive into the philosophy and design of the Simplicity language.</p>\n<p>Bitcoin\u2019s transaction validation is a significantly different application from regular programming language design. Block space cost is at a premium so programs need to be compact. The programs in Bitcoin transactions are only ever executed on a single input and everyone executes the program on the same input. Also, the agent authorizing the transaction already knows the outcome of the computation in advance: that the transaction is valid.</p>\n<p>Typically the authorizing agent will run much more expensive computations to derive witness data attesting to the transaction\u2019s validity, whereas programs run on the blockchain need to check the witness data for validity. Checking validity is often much cheaper than proving validity.</p>\n<p>We\u2019ve designed Simplicity with these sorts of unique language design challenges in mind. For example, Simplicity requires unexecuted branches be pruned so they do not appear on the blockchain. Preprocessing steps are carefully designed to exhibit (quasi-)linear time complexity in the size of the Simplicity program. Static analysis is used instead of \u201cgas\u201d, which cannot be computed without executing code in a prescribed manner, so that the details of the execution model do not become consensus critical. No dynamic memory allocation during execution. And so on.</p>\n<p>Before delving into the design details of Simplicity, I want to begin this series with some programming philosophy about the general ways of combining basic building blocks to create new functionality.</p>\n<h1><a name=\"p-5647-composition-2\" class=\"anchor\" href=\"#p-5647-composition-2\"></a>Composition</h1>\n<p>Suppose one is designing a language for programmable transactions for a blockchain like Bitcoin. In particular, programs only have access to the transaction data and the UTXO data of the inputs, and execution only determines transaction validity (which lets the result of execution be cached). Let\u2019s say one starts with some set of basic operations that can perform various tasks such as basic computations, reading and/or processing data from the transaction, and signature verification. Each operation consumes some type of input (possibly empty) and returns some type of output. What are the ways we can combine these basic operations into more complex operations?</p>\n<h2><a name=\"p-5647-sequential-composition-3\" class=\"anchor\" href=\"#p-5647-sequential-composition-3\"></a>Sequential Composition</h2>\n<pre data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">graph LR\n    Input@{ shape: start } --&gt; f\n    g --&gt; Output@{ shape: stop }\n\n    subgraph Sequential Composition\n        direction LR\n        f --&gt; g \n    end    \n</code></pre>\n<p>The most fundamental composition method is sequential composition. If we have two basic operations, one whose output data type matches the input data type of the other, then we can combine these two operations into a new composite operation. This new operation runs these two basic operations in sequence, taking as input the input of the first operation, passing the output of that first operation into the input of the second operation, and ultimately returning the output of that second operation.</p>\n<p>Of course, we don\u2019t need to restrict ourselves to just combining basic operations. Now that we have some composite operations, we can combine those using functional composition as well.</p>\n<p>In mathematics, this sequential composition is often just called \u201ccomposition\u201d, and one might think that this is the only way of composing things. However, we have other ways of composing operations.</p>\n<h2><a name=\"p-5647-parallel-composition-4\" class=\"anchor\" href=\"#p-5647-parallel-composition-4\"></a>Parallel Composition</h2>\n<pre data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">graph LR\n    Input@{ shape: start } --- D@{ shape: anchor }\n    P@{ shape: circle, label: \"\u00d7\"} --&gt; Output@{ shape: stop }\n    subgraph Parallel Composition\n        direction LR\n        D --&gt; f\n        D --&gt; g\n        f --&gt; P\n        g --&gt; P\n    end\n</code></pre>\n<p>Suppose that we have two operations, they could be basic or complex operations, and they both take the same type of input. A second fundamental way of composing these two operations is to execute them both on the same input. This is called parallel composition, and the type of output is the \u201cproduct\u201d of the types of the outputs of the original operations and contains the pair of the two outputs.</p>\n<p>While this is called \u201cparallel\u201d composition, and the two operations could in principle be executed in parallel, parallel execution isn\u2019t an operational requirement. We can implement parallel composition \u201csequentially\u201d by executing one operation first and then the second operation. We don\u2019t care about the details of how parallel composition is implemented as long as the output is the same.</p>\n<h2><a name=\"p-5647-conditional-composition-5\" class=\"anchor\" href=\"#p-5647-conditional-composition-5\"></a>Conditional Composition</h2>\n<pre data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">graph LR\n    Input@{ shape: start } --&gt; D@{ shape: decision, label: \"\\\\+\" }\n    P@{ shape: anchor } --&gt; Output@{ shape: stop }\n    subgraph Conditional Composition\n        direction LR\n        D -- Left --&gt; f\n        D -- Right --&gt; g\n        f --- P\n        g --- P\n    end\n</code></pre>\n<p>Conditional composition is the dual of parallel composition. In this case we have two operations that produce the same output, and we compose them by choosing one of them to execute. The input to this composite operation is the \u201csum\u201d or \u201ctagged union\u201d of the types of the inputs of the original operation. In this instance the tag, \u201cLeft\u201d or \u201cRight\u201d, is a single bit in the input\u2019s data which determines which type of data is being carried, and hence which of the two operations can be executed.</p>\n<p>Conditional composition operates in the same way even when the input is the sum of two identical types. The sum type still contains a tag, and the value of that tag determines which of the two operations is to be executed.</p>\n<h1><a name=\"p-5647-composition-in-bitcoin-script-6\" class=\"anchor\" href=\"#p-5647-composition-in-bitcoin-script-6\"></a>Composition in Bitcoin Script</h1>\n<p>There are many ways of realizing these three kinds of composition in various programming languages. In Bitcoin Script, sequential composition is realized (approximately) by the concatenation of two routines (this is why Bitcoin Script is called a concatenative programming language) since the output of one routine is left on the stack to be consumed by the subsequent routine. Parallel composition is achieved by use of duplicate and swap operations to manipulate the stack so that two routines can be run on the same input. Things are not entirely straightforward since what we are calling the \u201cproduct\u201d of types is typically realized by utilizing multiple stack items. Hopefully you can see the general idea.</p>\n<p>Conditional composition is, of course, realized by <code>OP_IF</code> which branches based on the value on the stack. In this case the top stack item plays the role of a tag, and usually the next item or items on the stack are of different \u201ctypes\u201d that depend on the value of the tag. For each case the stack item types may only be suitable for processing by one of the branches in the <code>OP_IF</code>. However after we reach <code>OP_ENDIF</code> the stack items must be of consistent \u201ctype\u201d such that the remaining script is capable of proceeding independent of which branch was previously taken.</p>\n<h1><a name=\"p-5647-composition-in-simplicity-7\" class=\"anchor\" href=\"#p-5647-composition-in-simplicity-7\"></a>Composition in Simplicity</h1>\n<p>We designed Simplicity with combinators that directly implement these three forms of composition. Along with a few more combinators to support other basic operations related to the product and sum types, the core Simplicity language ends up consisting of nine combinators that are adequate to express any finite computation. We will discuss this in more detail in the next installment.</p>\n<h1><a name=\"p-5647-a-fourth-kind-of-composition-8\" class=\"anchor\" href=\"#p-5647-a-fourth-kind-of-composition-8\"></a>A Fourth Kind of Composition</h1>\n<p>Before ending we should mention that there is at least one more kind of composition found in Computer Science, which is \u201crecursive composition\u201d. In recursive composition one operation is iterated multiple times.</p>\n<p>Note that Bitcoin Script does not support recursive composition, and similarly, we have explicitly excluded unbounded recursion from Simplicity\u2019s design. Our thesis is that unbounded iterative computation is better implemented using recursive covenants which compute over multiple transactions. This allows users to avoid block space and standardness constraints and better predict transaction costs.</p>\n<p>That being said, there are ways of abusing Simplicity\u2019s delegation feature to provide something resembling unbounded recursive composition, which we may discuss later in this series.</p>\n<h1><a name=\"p-5647-conclusion-9\" class=\"anchor\" href=\"#p-5647-conclusion-9\"></a>Conclusion</h1>\n<p>We reviewed the three major forms of composition for transforming basic operations into complex operations:</p>\n<ul>\n<li>sequential composition</li>\n<li>parallel composition</li>\n<li>conditional composition</li>\n</ul>\n<p>We discussed how these forms of composition are realized in Bitcoin Script, and hinted at how they have influenced the design of the Simplicity language. We noted that the fourth kind of composition, recursive composition, is specifically excluded from both Simplicity and Bitcoin Script.</p>\n<p>In the next installment we will describe the nine combinators that make up the core of the Simplicity language, how they serve to directly realize these three forms of composition, and how this forms a complete language for describing any finite computation.</p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 1,
  "updated_at": "2025-08-05T14:41:08.061Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 159,
  "reads": 57,
  "readers_count": 56,
  "score": 921.4,
  "yours": false,
  "topic_id": 1902,
  "topic_slug": "delving-simplicity-part-three-fundamental-ways-of-combining-computations",
  "topic_title": "Delving Simplicity Part \u2160: Three Fundamental Ways of Combining Computations",
  "topic_html_title": "Delving Simplicity Part \u2160: Three Fundamental Ways of Combining Computations",
  "category_id": 7,
  "display_username": "",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "# Series Introduction\n\nNow that Simplicity has been activated on the Liquid Network, I\u2019d like to do an in-depth dive into the philosophy and design of the Simplicity language.\n\nBitcoin\u2019s transaction validation is a significantly different application from regular programming language design. Block space cost is at a premium so programs need to be compact. The programs in Bitcoin transactions are only ever executed on a single input and everyone executes the program on the same input. Also, the agent authorizing the transaction already knows the outcome of the computation in advance: that the transaction is valid.\n\nTypically the authorizing agent will run much more expensive computations to derive witness data attesting to the transaction\u2019s validity, whereas programs run on the blockchain need to check the witness data for validity. Checking validity is often much cheaper than proving validity.\n\nWe\u2019ve designed Simplicity with these sorts of unique language design challenges in mind. For example, Simplicity requires unexecuted branches be pruned so they do not appear on the blockchain. Preprocessing steps are carefully designed to exhibit (quasi-)linear time complexity in the size of the Simplicity program. Static analysis is used instead of \u201cgas\u201d, which cannot be computed without executing code in a prescribed manner, so that the details of the execution model do not become consensus critical. No dynamic memory allocation during execution. And so on.\n\nBefore delving into the design details of Simplicity, I want to begin this series with some programming philosophy about the general ways of combining basic building blocks to create new functionality.\n\n# Composition\n\nSuppose one is designing a language for programmable transactions for a blockchain like Bitcoin. In particular, programs only have access to the transaction data and the UTXO data of the inputs, and execution only determines transaction validity (which lets the result of execution be cached). Let\u2019s say one starts with some set of basic operations that can perform various tasks such as basic computations, reading and/or processing data from the transaction, and signature verification. Each operation consumes some type of input (possibly empty) and returns some type of output. What are the ways we can combine these basic operations into more complex operations?\n\n## Sequential Composition\n\n\n```mermaid\ngraph LR\n    Input@{ shape: start } --> f\n    g --> Output@{ shape: stop }\n\n    subgraph Sequential Composition\n        direction LR\n        f --> g \n    end    \n```\n\nThe most fundamental composition method is sequential composition. If we have two basic operations, one whose output data type matches the input data type of the other, then we can combine these two operations into a new composite operation. This new operation runs these two basic operations in sequence, taking as input the input of the first operation, passing the output of that first operation into the input of the second operation, and ultimately returning the output of that second operation.\n\nOf course, we don\u2019t need to restrict ourselves to just combining basic operations. Now that we have some composite operations, we can combine those using functional composition as well.\n\nIn mathematics, this sequential composition is often just called \u201ccomposition\u201d, and one might think that this is the only way of composing things. However, we have other ways of composing operations.\n\n## Parallel Composition\n\n```mermaid\ngraph LR\n    Input@{ shape: start } --- D@{ shape: anchor }\n    P@{ shape: circle, label: \"\u00d7\"} --> Output@{ shape: stop }\n    subgraph Parallel Composition\n        direction LR\n        D --> f\n        D --> g\n        f --> P\n        g --> P\n    end\n```\n\nSuppose that we have two operations, they could be basic or complex operations, and they both take the same type of input. A second fundamental way of composing these two operations is to execute them both on the same input. This is called parallel composition, and the type of output is the \u201cproduct\u201d of the types of the outputs of the original operations and contains the pair of the two outputs.\n\nWhile this is called \u201cparallel\u201d composition, and the two operations could in principle be executed in parallel, parallel execution isn\u2019t an operational requirement. We can implement parallel composition \u201csequentially\u201d by executing one operation first and then the second operation. We don\u2019t care about the details of how parallel composition is implemented as long as the output is the same. \n\n## Conditional Composition\n\n```mermaid\ngraph LR\n    Input@{ shape: start } --> D@{ shape: decision, label: \"\\\\+\" }\n    P@{ shape: anchor } --> Output@{ shape: stop }\n    subgraph Conditional Composition\n        direction LR\n        D -- Left --> f\n        D -- Right --> g\n        f --- P\n        g --- P\n    end\n```\n\nConditional composition is the dual of parallel composition. In this case we have two operations that produce the same output, and we compose them by choosing one of them to execute. The input to this composite operation is the \u201csum\u201d or \u201ctagged union\u201d of the types of the inputs of the original operation. In this instance the tag, \u201cLeft\u201d or \u201cRight\u201d, is a single bit in the input\u2019s data which determines which type of data is being carried, and hence which of the two operations can be executed.\n\nConditional composition operates in the same way even when the input is the sum of two identical types. The sum type still contains a tag, and the value of that tag determines which of the two operations is to be executed.\n\n# Composition in Bitcoin Script\n\nThere are many ways of realizing these three kinds of composition in various programming languages. In Bitcoin Script, sequential composition is realized (approximately) by the concatenation of two routines (this is why Bitcoin Script is called a concatenative programming language) since the output of one routine is left on the stack to be consumed by the subsequent routine. Parallel composition is achieved by use of duplicate and swap operations to manipulate the stack so that two routines can be run on the same input. Things are not entirely straightforward since what we are calling the \u201cproduct\u201d of types is typically realized by utilizing multiple stack items. Hopefully you can see the general idea.\n\nConditional composition is, of course, realized by `OP_IF` which branches based on the value on the stack. In this case the top stack item plays the role of a tag, and usually the next item or items on the stack are of different \u201ctypes\u201d that depend on the value of the tag. For each case the stack item types may only be suitable for processing by one of the branches in the `OP_IF`. However after we reach `OP_ENDIF` the stack items must be of consistent \u201ctype\u201d such that the remaining script is capable of proceeding independent of which branch was previously taken.\n\n# Composition in Simplicity\n\nWe designed Simplicity with combinators that directly implement these three forms of composition. Along with a few more combinators to support other basic operations related to the product and sum types, the core Simplicity language ends up consisting of nine combinators that are adequate to express any finite computation. We will discuss this in more detail in the next installment.\n\n# A Fourth Kind of Composition\n\nBefore ending we should mention that there is at least one more kind of composition found in Computer Science, which is \u201crecursive composition\u201d. In recursive composition one operation is iterated multiple times.\n\nNote that Bitcoin Script does not support recursive composition, and similarly, we have explicitly excluded unbounded recursion from Simplicity\u2019s design. Our thesis is that unbounded iterative computation is better implemented using recursive covenants which compute over multiple transactions. This allows users to avoid block space and standardness constraints and better predict transaction costs.\n\nThat being said, there are ways of abusing Simplicity\u2019s delegation feature to provide something resembling unbounded recursive composition, which we may discuss later in this series.\n\n# Conclusion\n\nWe reviewed the three major forms of composition for transforming basic operations into complex operations:\n\n* sequential composition\n* parallel composition\n* conditional composition\n\nWe discussed how these forms of composition are realized in Bitcoin Script, and hinted at how they have influenced the design of the Simplicity language. We noted that the fourth kind of composition, recursive composition, is specifically excluded from both Simplicity and Bitcoin Script.\n\nIn the next installment we will describe the nine combinators that make up the core of the Simplicity language, how they serve to directly realize these three forms of composition, and how this forms a complete language for describing any finite computation.",
  "actions_summary": [
    {
      "id": 2,
      "count": 8
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 351,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "<a name=\"p-5647-series-introduction-1\" class=\"anchor\" href=\"#p-5647-series-introduction-1\"></a>Series Introduction\nNow that Simplicity has been activated on the Liquid Network, I\u2019d like to do an in-depth dive into the philosophy and design of the Simplicity language. \nBitcoin\u2019s transaction validation is a significantly different application from regular programming language design. Block spac&hellip;",
  "truncated": true,
  "post_url": "/t/delving-simplicity-part-three-fundamental-ways-of-combining-computations/1902/1",
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 8
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 8,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}