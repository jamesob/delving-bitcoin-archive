{
  "id": 5770,
  "name": "",
  "username": "cmp_ancp",
  "avatar_template": "/letter_avatar_proxy/v4/letter/c/b3f665/{size}.png",
  "created_at": "2025-08-25T01:42:55.396Z",
  "cooked": "<p>Hi all!</p>\n<p>In recent weeks, I\u2019ve been thinking about a feature bitcoin script doesn\u2019t have yet: the possibility of expiration date for transactions.</p>\n<p>I made a rapid research and found out this opcode have already been proposed before (OP_EXPIRE: Mitigating replacing cycling attacks - Protocol Design - Delving Bitcoin <a href=\"https://share.google/70ClGDzIW0NONuDgx\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">OP_EXPIRE: Mitigating replacing cycling attacks - Protocol Design - Delving Bitcoin</a> ), but mainly with LN and replace-cycling attacks in mind. I thought about this feature for different reasons, and I think it hasn\u2019t been given enough credit or sufficiently stressed out by the community.</p>\n<h1><a name=\"p-5770-context-1\" class=\"anchor\" href=\"#p-5770-context-1\"></a>Context</h1>\n<p>I first had this idea after reading about the protocol level of a project I am interested in, the implementation of coinswap on Bitcoin ( <a href=\"https://github.com/citadel-tech/coinswap\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">GitHub - citadel-tech/coinswap: Functioning, minimal-viable binaries and libraries to perform a trustless, p2p Maxwell-Belcher Coinswap Protocol</a> ). AFAIK, this is the first onchain BTC to BTC atomic swap implementation so far.</p>\n<p>The protocol roughly goes:</p>\n<ul>\n<li>Participants create a closed loop of \u201cchannels\u201d made of musigs</li>\n<li>HTLCs are used to swap coins in the loop</li>\n<li>After the pre image reveal, there is a handover of private keys to the new owners</li>\n<li>The new owners use the private key to spend the musig and successfully finish the session</li>\n</ul>\n<p>If everything goes right, onchain footprints are only of musigs in the P2WSH version, and after implementing P2TR version, indistinguishable form every other P2TR.</p>\n<p>After understanding the steps, it boggled my mind the necessity of the last tx by all participants. The last tx is necessary to be certain that the former partner doesn\u2019t try to steal funds with the HTLC, so the only way a wallet wouldn\u2019t need to constantly check for steal attempts is by spending the musig.</p>\n<p>But this is suboptimal. Private keys have already been handovered, if the HTLCs didn\u2019t exist, the new owner would already have sufficient info for spending the new UTXO, and we would have a single tx swap.</p>\n<p>In order to BTC to have a safe future, we need high fees, this is crucial for hashrate maintanance. In the ideal world, txs on the blockchain need to be made minimal. In that way, I think OP_EXPIRE could reduce one tx in contracts involving swaps and privkey handover.</p>\n<h1><a name=\"p-5770-further-use-cases-2\" class=\"anchor\" href=\"#p-5770-further-use-cases-2\"></a>Further use cases</h1>\n<p>This first use case made me come with this opcode (even though, I didn\u2019t know it was already been proposed lol), but after further thinking, I found out it can be used in several other ways, and that it composes really well with OP_CSFS and OP_CTV.</p>\n<p>How would the opcode work:</p>\n<ul>\n<li>It pops up the top value on the stack, representing the expiration block or time (TBD if it could have different encodings of height, relative time, etc, but the absolute height case is essential for some cases)</li>\n<li>It asserts if the UTXO have expired or not (TBD if it would have a verify functionality or if it could push a bool in the stack, which permits IF ELSE composability, but I wonder if multiple tapleaves aren\u2019t useful enough)</li>\n</ul>\n<p>We could build scripts where the expiration height/delta on the stack is signed, allowing for diverse use cases composing with OP_CSFS, such as:</p>\n<ul>\n<li>Time restrained delegations (used together with OP_CTV)</li>\n<li>Contracts operating on real time data confirmed by an oracle (such as prices, exchange rates, etc)</li>\n<li>Short time approval of owner or associated entity</li>\n<li>Voting, elections, with restrained time for consensus</li>\n<li>More options of contracts and L2 applications</li>\n</ul>\n<p>Delegation can be implemented in a clever way, such as:</p>\n<ul>\n<li>Owner have a master key pair, and a first OP_CSFS tests agains the master pubkey</li>\n<li>Owner creates an ephemeral key pair, and signs the ephemeral pubkey, validated by the first OP_CSFS</li>\n<li>They use the ephemeral privkey to sign an expiration height and a OP_CTV hash, or any other value they wish to be used by the script. Thes values are further validated by other calls to OP_CSFS, now validating against the ephemeral pubkey</li>\n<li>After the expiration height, all approvals are revoked, and if it wasn\u2019t confirmed onchain, the delegated operator may need a new approval. The ephemeral key pair grants that chosen values are tied to the expiration, and a new expiration height cannot be used to validate an old chosen value</li>\n</ul>\n<h1><a name=\"p-5770-trust-assumptions-and-possible-drawbacks-3\" class=\"anchor\" href=\"#p-5770-trust-assumptions-and-possible-drawbacks-3\"></a>Trust assumptions and possible drawbacks</h1>\n<p>I understand that, depending on the way the opcode is used and the height is calculated, values may be burn forever. However, such assumptions already exists (in a certain degree) in any HTLC contract: if your revoke tx isn\u2019t confirmed in time, the counterparty may get your funds.</p>\n<p>Other possible attack vector I think may exist are miners holding to approve txs in order to make participants pay higher fees under pressure. However, this would only work in a centralized mining world, because otherwise miners may lose possible earnings to concurrent pools.</p>\n<p>Aside from those considerstions, I see this opcode as a simple feature that doesn\u2019t affect MEVil nor would have unpredicted outcomes. But I am interested in hearing other takes on ths subject.</p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 3,
  "updated_at": "2025-08-25T01:47:39.392Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 5,
  "reads": 16,
  "readers_count": 15,
  "score": 43.2,
  "yours": false,
  "topic_id": 1945,
  "topic_slug": "taking-a-second-look-at-op-expire",
  "topic_title": "Taking a second look at OP_EXPIRE",
  "topic_html_title": "Taking a second look at OP_EXPIRE",
  "category_id": 7,
  "display_username": "",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Hi all!\n\nIn recent weeks, I\u2019ve been thinking about a feature bitcoin script doesn\u2019t have yet: the possibility of expiration date for transactions.\n\nI made a rapid research and found out this opcode have already been proposed before (OP_EXPIRE: Mitigating replacing cycling attacks - Protocol Design - Delving Bitcoin https://share.google/70ClGDzIW0NONuDgx ), but mainly with LN and replace-cycling attacks in mind. I thought about this feature for different reasons, and I think it hasn\u2019t been given enough credit or sufficiently stressed out by the community.\n\n# Context\n\nI first had this idea after reading about the protocol level of a project I am interested in, the implementation of coinswap on Bitcoin ( https://github.com/citadel-tech/coinswap ). AFAIK, this is the first onchain BTC to BTC atomic swap implementation so far.\n\nThe protocol roughly goes:\n\n* Participants create a closed loop of \u201cchannels\u201d made of musigs\n* HTLCs are used to swap coins in the loop\n* After the pre image reveal, there is a handover of private keys to the new owners\n* The new owners use the private key to spend the musig and successfully finish the session\n\nIf everything goes right, onchain footprints are only of musigs in the P2WSH version, and after implementing P2TR version, indistinguishable form every other P2TR.\n\nAfter understanding the steps, it boggled my mind the necessity of the last tx by all participants. The last tx is necessary to be certain that the former partner doesn\u2019t try to steal funds with the HTLC, so the only way a wallet wouldn\u2019t need to constantly check for steal attempts is by spending the musig.\n\nBut this is suboptimal. Private keys have already been handovered, if the HTLCs didn\u2019t exist, the new owner would already have sufficient info for spending the new UTXO, and we would have a single tx swap.\n\nIn order to BTC to have a safe future, we need high fees, this is crucial for hashrate maintanance. In the ideal world, txs on the blockchain need to be made minimal. In that way, I think OP_EXPIRE could reduce one tx in contracts involving swaps and privkey handover.\n\n# Further use cases\n\nThis first use case made me come with this opcode (even though, I didn\u2019t know it was already been proposed lol), but after further thinking, I found out it can be used in several other ways, and that it composes really well with OP_CSFS and OP_CTV.\n\nHow would the opcode work:\n\n* It pops up the top value on the stack, representing the expiration block or time (TBD if it could have different encodings of height, relative time, etc, but the absolute height case is essential for some cases)\n* It asserts if the UTXO have expired or not (TBD if it would have a verify functionality or if it could push a bool in the stack, which permits IF ELSE composability, but I wonder if multiple tapleaves aren\u2019t useful enough)\n\nWe could build scripts where the expiration height/delta on the stack is signed, allowing for diverse use cases composing with OP_CSFS, such as:\n\n* Time restrained delegations (used together with OP_CTV)\n* Contracts operating on real time data confirmed by an oracle (such as prices, exchange rates, etc)\n* Short time approval of owner or associated entity\n* Voting, elections, with restrained time for consensus\n* More options of contracts and L2 applications\n\nDelegation can be implemented in a clever way, such as:\n\n* Owner have a master key pair, and a first OP_CSFS tests agains the master pubkey\n* Owner creates an ephemeral key pair, and signs the ephemeral pubkey, validated by the first OP_CSFS\n* They use the ephemeral privkey to sign an expiration height and a OP_CTV hash, or any other value they wish to be used by the script. Thes values are further validated by other calls to OP_CSFS, now validating against the ephemeral pubkey\n* After the expiration height, all approvals are revoked, and if it wasn\u2019t confirmed onchain, the delegated operator may need a new approval. The ephemeral key pair grants that chosen values are tied to the expiration, and a new expiration height cannot be used to validate an old chosen value\n\n# Trust assumptions and possible drawbacks\n\nI understand that, depending on the way the opcode is used and the height is calculated, values may be burn forever. However, such assumptions already exists (in a certain degree) in any HTLC contract: if your revoke tx isn\u2019t confirmed in time, the counterparty may get your funds.\n\nOther possible attack vector I think may exist are miners holding to approve txs in order to make participants pay higher fees under pressure. However, this would only work in a centralized mining world, because otherwise miners may lose possible earnings to concurrent pools.\n\nAside from those considerstions, I see this opcode as a simple feature that doesn\u2019t affect MEVil nor would have unpredicted outcomes. But I am interested in hearing other takes on ths subject.",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 898,
  "hidden": false,
  "trust_level": 0,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "Hi all! \nIn recent weeks, I\u2019ve been thinking about a feature bitcoin script doesn\u2019t have yet: the possibility of expiration date for transactions. \nI made a rapid research and found out this opcode have already been proposed before (OP_EXPIRE: Mitigating replacing cycling attacks - Protocol Design -&hellip;",
  "truncated": true,
  "post_url": "/t/taking-a-second-look-at-op-expire/1945/1",
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}