{
  "id": 2649,
  "name": "David A. Harding",
  "username": "harding",
  "avatar_template": "/user_avatar/delvingbitcoin.org/harding/{size}/6_2.png",
  "created_at": "2024-06-05T02:13:35.155Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"setavenger\" data-post=\"1\" data-topic=\"891\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/setavenger/48/573_2.png\" class=\"avatar\"> setavenger:</div>\n<blockquote>\n<ol>\n<li>Fetch the tweaks (possibly filtered for dust limit)</li>\n<li>Compute the possible pubKeys for n = 0</li>\n<li>Fetch taproot-only filter (BIP 158)</li>\n<li>Compare the pubKeys against a taproot-only filter\n<ul>\n<li>If no match: go to 1. with block_height + 1</li>\n<li>Else: continue with 5.</li>\n</ul>\n</li>\n<li>Fetch simplified UTXOs</li>\n<li>Scan according to the BIP (one could reuse pubKeys from 2. here)</li>\n<li>Collect all matched UTXOs and add to wallet</li>\n<li>Go to 1. with block_height + 1</li>\n</ol>\n</blockquote>\n</aside>\n<p>I\u2019m concerned clients only performing step 5 (fetching transaction data) in response to untrusted data from step 1 (tweaks) and step 3 (pubkeys).  If a client fetches all three pieces of data from the same server (or from different servers that are colluding), the server can potentially unmask users in step five by lying in steps 1 and 3.</p>\n<p>For example: Server operator Mallory wants to discover the IP address of a user with SP address <em>x</em>.  Mallory creates a fake payment to <em>x</em>, giving her a tweak and an output that indicate a payment to <em>x</em>.  Instead of creating the tweaks and filters for the next block honestly, Mallory creates them using only the fake payment, distributing them to all of her users.  The only user who matches on that fake data is the owner of <em>x</em>, so that person is the only person who performs step 5 (downloading transaction data); this reveals their network ID to Mallory (e.g., their IP address if they use a direct connection).</p>\n<p>Downloading tweaks and filters from different servers doesn\u2019t help.  Even if we can be sure the servers aren\u2019t colluding, whoever controls the filter distribution server can always force a match by lying.  I think whoever controls the tweak distribution server can also force a match, but I\u2019m not 100% sure on the EC math to do that.</p>\n<p>What I think is best is similar to what Wasabi does with its custom BIP158 implementation:</p>\n<ol>\n<li>Client downloads untrusted tweaks and filter from the server (ideally using something like an ephemeral Tor connection)</li>\n<li>On match, client downloads the corresponding full block from a random full node (ideally using a different network identity, such as a different ephemeral Tor connection)</li>\n</ol>\n<p>Given the large number of block-serving full nodes, this reduces the chance that the client connects to a full node controlled by the server.  Additionally, given the modestly large number of existing BIP158 clients that are already occasionally downloading arbitrary blocks from full nodes, even if the client did connect to a full node controlled by the server, the server couldn\u2019t be sure that the peer requesting a particular block was the peer it was targeting.  This is true on regular IP, with increased privacy guarantees available to users of Tor ephemeral addresses or similar protocols.</p>\n<p>Thus I think there\u2019s a lot of advantage to using full blocks and connections to regular full nodes in step 5 of this protocol.  The downside of full blocks over minimized blocks is increased bandwidth, but my guess is that most SP users will receive less than one SP payment per day, so the bandwidth cost of a full block is less than 4 MB per day. Those receiving more payments can probably easily afford the increased bandwidth costs (about 600 MB/day in the worst case).</p>",
  "post_number": 12,
  "post_type": 1,
  "updated_at": "2024-06-05T02:13:35.155Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 1,
  "incoming_link_count": 0,
  "reads": 3,
  "readers_count": 2,
  "score": 0.6,
  "yours": false,
  "topic_id": 891,
  "topic_slug": "silent-payments-light-client-protocol",
  "topic_title": "Silent Payments: Light Client Protocol",
  "topic_html_title": "Silent Payments: Light Client Protocol",
  "category_id": 12,
  "display_username": "David A. Harding",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"setavenger, post:1, topic:891\"]\n1. Fetch the tweaks (possibly filtered for dust limit)\n2. Compute the possible pubKeys for n = 0\n3. Fetch taproot-only filter (BIP 158)\n4. Compare the pubKeys against a taproot-only filter\n    - If no match: go to 1. with block_height + 1\n    - Else: continue with 5.\n5. Fetch simplified UTXOs\n6. Scan according to the BIP (one could reuse pubKeys from 2. here)\n7. Collect all matched UTXOs and add to wallet\n8. Go to 1. with block_height + 1\n[/quote]\n\nI'm concerned clients only performing step 5 (fetching transaction data) in response to untrusted data from step 1 (tweaks) and step 3 (pubkeys).  If a client fetches all three pieces of data from the same server (or from different servers that are colluding), the server can potentially unmask users in step five by lying in steps 1 and 3.\n\nFor example: Server operator Mallory wants to discover the IP address of a user with SP address _x_.  Mallory creates a fake payment to _x_, giving her a tweak and an output that indicate a payment to _x_.  Instead of creating the tweaks and filters for the next block honestly, Mallory creates them using only the fake payment, distributing them to all of her users.  The only user who matches on that fake data is the owner of _x_, so that person is the only person who performs step 5 (downloading transaction data); this reveals their network ID to Mallory (e.g., their IP address if they use a direct connection).\n\nDownloading tweaks and filters from different servers doesn't help.  Even if we can be sure the servers aren't colluding, whoever controls the filter distribution server can always force a match by lying.  I think whoever controls the tweak distribution server can also force a match, but I'm not 100% sure on the EC math to do that.\n\nWhat I think is best is similar to what Wasabi does with its custom BIP158 implementation:\n\n1. Client downloads untrusted tweaks and filter from the server (ideally using something like an ephemeral Tor connection)\n2. On match, client downloads the corresponding full block from a random full node (ideally using a different network identity, such as a different ephemeral Tor connection)\n\nGiven the large number of block-serving full nodes, this reduces the chance that the client connects to a full node controlled by the server.  Additionally, given the modestly large number of existing BIP158 clients that are already occasionally downloading arbitrary blocks from full nodes, even if the client did connect to a full node controlled by the server, the server couldn't be sure that the peer requesting a particular block was the peer it was targeting.  This is true on regular IP, with increased privacy guarantees available to users of Tor ephemeral addresses or similar protocols.\n\nThus I think there's a lot of advantage to using full blocks and connections to regular full nodes in step 5 of this protocol.  The downside of full blocks over minimized blocks is increased bandwidth, but my guess is that most SP users will receive less than one SP payment per day, so the bandwidth cost of a full block is less than 4 MB per day. Those receiving more payments can probably easily afford the increased bandwidth costs (about 600 MB/day in the worst case).",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 6,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}