{
  "id": 2740,
  "name": "josie",
  "username": "josibake",
  "avatar_template": "/user_avatar/delvingbitcoin.org/josibake/{size}/83_2.png",
  "created_at": "2024-06-18T13:07:01.640Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"achow101\" data-post=\"13\" data-topic=\"877\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/achow101/48/200_2.png\" class=\"avatar\"> achow101:</div>\n<blockquote>\n<p>I\u2019m probably forgetting a few things, but <a class=\"mention\" href=\"/u/josibake\">@josibake</a> has notes so hopefully those can cover whatever it is I\u2019ve forgotten.</p>\n</blockquote>\n</aside>\n<p>Checking over my (not so great <img src=\"https://delvingbitcoin.org/images/emoji/twitter/sweat_smile.png?v=12\" title=\":sweat_smile:\" class=\"emoji\" alt=\":sweat_smile:\" loading=\"lazy\" width=\"20\" height=\"20\">) notes, I think the only thing missing is the ordering of the silent payment addresses in cases where two or more <code>PSBT_OUT_SP_V0_INFO</code> fields contain the same scan key. In order to ensure any one of the SP aware signers can arrive at the same set of generated output scripts, each signer will need to sort the silent payment address by scan public key and spend public key, in lexicographic order. This guarantees that everyone gets the same values for <code>k</code> when creating multiple outputs for the same scan public key. As a reminder, this has nothing to with the final ordering in the transaction.</p>\n<hr>\n<p><a class=\"mention\" href=\"/u/andrewtoth\">@andrewtoth</a> - regarding <code>ANYONECANPAY</code>:</p>\n<aside class=\"quote no-group\" data-username=\"andrewtoth\" data-post=\"16\" data-topic=\"877\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/andrewtoth/48/576_2.png\" class=\"avatar\"> andrewtoth:</div>\n<blockquote>\n<p>Hmmm\u2026 but if signing with ANYONECANPAY, even with SIGHASH_ALL, then Inputs Modifiable will not be set to False. So another SP unaware constructor can add a new input that modifies the shared secret and invalidates the already signed outputs.</p>\n</blockquote>\n</aside>\n<p>These are the possible scenarios I see:</p>\n<ol>\n<li>\n<p>PSBT does not contain any <code>PSBT_OUT_SP_V0_INFO</code> fields and someone signs with <code>ALL | ACP</code>. At this point, the outputs have been committed to, making it impossible to add a silent payment recipient</p>\n</li>\n<li>\n<p>PSBT contains only <code>PSBT_OUT_SP_V0_INFO</code> fields. SP unaware signers can\u2019t sign since there are no <code>PSBT_OUT_SCRIPT</code> fields, and SP aware signers will either add their shares/proofs or generate the SP outputs and sign after checking that all shares / proofs are present</p>\n</li>\n<li>\n<p>PSBT contains a mix of <code>PSBT_OUT_SP_V0_INFO</code> and <code>PSBT_OUT_SCRIPT</code> fields. If the SP aware signers have not finished adding their SP input data outputs with <code>PSBT_OUT_SP_V0_INFO</code> set will not have a <code>PSBT_OUT_SCRIPT</code> field, which means any non-SP aware signer will fail if trying to sign with <code>ALL | ACP</code> due to seeing the PSBT as malformed. This means the last SP signer to add their share / proof MUST sign with <code>ALL</code>. Said differently, this is only a problem if an SP aware signer were to validate the shares / proofs, generate the SP output scripts and then sign with <code>ALL | ACP</code></p>\n</li>\n</ol>\n<p>I think this ends up being fine with the understanding that a non-SP aware signer cannot sign the transaction until each output has a <code>PSBT_OUT_SCRIPT</code> field. The <code>PSBT_OUT_SCRIPT</code> fields can only be set once all of the SP fields have been set, which always gives the last SP signer a chance to lock the inputs with <code>ALL</code>.</p>\n<aside class=\"quote no-group\" data-username=\"andrewtoth\" data-post=\"18\" data-topic=\"877\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/andrewtoth/48/576_2.png\" class=\"avatar\"> andrewtoth:</div>\n<blockquote>\n<p>Thinking about this more, if any fully signed transaction spending silent payments that contains an ANYONECANPAY input that spends at least the amount of the inputs it signs (could be SIGHASH_ALL), couldn\u2019t any outside observer simply strip the other inputs and rebroadcast, which would still be a valid tx but all silent payment outputs would be invalid?</p>\n</blockquote>\n</aside>\n<p>I don\u2019t see how this situation would be possible, so long as we require silent payments aware signers to never use <code>ALL | ACP</code>, right? A non-SP signer cannot sign until the <code>PSBT_OUT_SCRIPTS</code> exist and these fields cannot exist until all of the SP aware signers have added their data, which means the last SP aware signer to add will always have a chance to sign the transaction.</p>\n<hr>\n<p><a class=\"mention\" href=\"/u/achow101\">@achow101</a> , <a class=\"mention\" href=\"/u/andrewtoth\">@andrewtoth</a> regarding requiring a proof per input:</p>\n<aside class=\"quote no-group\" data-username=\"andrewtoth\" data-post=\"17\" data-topic=\"877\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/andrewtoth/48/576_2.png\" class=\"avatar\"> andrewtoth:</div>\n<blockquote>\n<p>I don\u2019t think we should dismiss this optimization. Consider the common case of a wallet with 10 small utxos, and it wants to make a single payment with all of them to a silent payment address. Without consolidating all shares and proofs, the hardware wallet signer will need to compute 10 times more shares and proofs.</p>\n</blockquote>\n</aside>\n<p>This is a good point considering this would require the signer to do 3x the work (~30 ECC mults): signature, ECDH share, DLEQ (signature) for each input. If we allow the signer to consolidate the shares / proofs, this would be one ECDH, one proof, and 10 signatures. One alternative is to allow the proof to be duplicated for inputs belong to the same signer. This removes any order dependence, but requires the verifier of the proofs / shares to be able to group them and add up the public keys for grouped inputs, i.e.,</p>\n<pre><code class=\"lang-auto\">input_0:proofA:shareA\ninput_1:proofB:shareB\ninput_2:proofA:shareA\n\n// Verifier\n\nsum(input_0_pubkey, input_3_pubkey); verify with proofA:shareA\ninput_1; verify with proofB:shareB\n</code></pre>\n<p>Seems like we can save the signers extra computation at the expense of more data in the PSBT (not really a concern imo) and more work for the verifier.</p>\n<hr>\n<p>EDIT: delving was yelling at me for posting too many small replies, so I deleted the inline replies and consolidated them into this post</p>",
  "post_number": 21,
  "post_type": 1,
  "updated_at": "2024-06-18T13:10:57.761Z",
  "reply_count": 1,
  "reply_to_post_number": 13,
  "quote_count": 4,
  "incoming_link_count": 0,
  "reads": 7,
  "readers_count": 6,
  "score": 6.4,
  "yours": false,
  "topic_id": 877,
  "topic_slug": "bip352-psbt-support",
  "topic_title": "BIP352: PSBT support",
  "topic_html_title": "BIP352: PSBT support",
  "category_id": 12,
  "display_username": "josie",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"achow101, post:13, topic:877\"]\nI\u2019m probably forgetting a few things, but @josibake has notes so hopefully those can cover whatever it is I\u2019ve forgotten.\n[/quote]\n\nChecking over my (not so great :sweat_smile:) notes, I think the only thing missing is the ordering of the silent payment addresses in cases where two or more `PSBT_OUT_SP_V0_INFO` fields contain the same scan key. In order to ensure any one of the SP aware signers can arrive at the same set of generated output scripts, each signer will need to sort the silent payment address by scan public key and spend public key, in lexicographic order. This guarantees that everyone gets the same values for `k` when creating multiple outputs for the same scan public key. As a reminder, this has nothing to with the final ordering in the transaction.\n\n---\n\n@andrewtoth - regarding `ANYONECANPAY`:\n\n[quote=\"andrewtoth, post:16, topic:877\"]\nHmmm\u2026 but if signing with ANYONECANPAY, even with SIGHASH_ALL, then Inputs Modifiable will not be set to False. So another SP unaware constructor can add a new input that modifies the shared secret and invalidates the already signed outputs.\n[/quote]\n\nThese are the possible scenarios I see:\n\n1. PSBT does not contain any `PSBT_OUT_SP_V0_INFO` fields and someone signs with `ALL | ACP`. At this point, the outputs have been committed to, making it impossible to add a silent payment recipient\n\n2. PSBT contains only `PSBT_OUT_SP_V0_INFO` fields. SP unaware signers can't sign since there are no `PSBT_OUT_SCRIPT` fields, and SP aware signers will either add their shares/proofs or generate the SP outputs and sign after checking that all shares / proofs are present\n\n3. PSBT contains a mix of `PSBT_OUT_SP_V0_INFO` and `PSBT_OUT_SCRIPT` fields. If the SP aware signers have not finished adding their SP input data outputs with `PSBT_OUT_SP_V0_INFO` set will not have a `PSBT_OUT_SCRIPT` field, which means any non-SP aware signer will fail if trying to sign with `ALL | ACP` due to seeing the PSBT as malformed. This means the last SP signer to add their share / proof MUST sign with `ALL`. Said differently, this is only a problem if an SP aware signer were to validate the shares / proofs, generate the SP output scripts and then sign with `ALL | ACP`\n\nI think this ends up being fine with the understanding that a non-SP aware signer cannot sign the transaction until each output has a `PSBT_OUT_SCRIPT` field. The `PSBT_OUT_SCRIPT` fields can only be set once all of the SP fields have been set, which always gives the last SP signer a chance to lock the inputs with `ALL`.\n\n[quote=\"andrewtoth, post:18, topic:877\"]\nThinking about this more, if any fully signed transaction spending silent payments that contains an ANYONECANPAY input that spends at least the amount of the inputs it signs (could be SIGHASH_ALL), couldn\u2019t any outside observer simply strip the other inputs and rebroadcast, which would still be a valid tx but all silent payment outputs would be invalid?\n[/quote]\n\nI don't see how this situation would be possible, so long as we require silent payments aware signers to never use `ALL | ACP`, right? A non-SP signer cannot sign until the `PSBT_OUT_SCRIPTS` exist and these fields cannot exist until all of the SP aware signers have added their data, which means the last SP aware signer to add will always have a chance to sign the transaction.\n\n---\n@achow101 , @andrewtoth regarding requiring a proof per input:\n\n[quote=\"andrewtoth, post:17, topic:877\"]\nI don\u2019t think we should dismiss this optimization. Consider the common case of a wallet with 10 small utxos, and it wants to make a single payment with all of them to a silent payment address. Without consolidating all shares and proofs, the hardware wallet signer will need to compute 10 times more shares and proofs.\n[/quote]\n\nThis is a good point considering this would require the signer to do 3x the work (~30 ECC mults): signature, ECDH share, DLEQ (signature) for each input. If we allow the signer to consolidate the shares / proofs, this would be one ECDH, one proof, and 10 signatures. One alternative is to allow the proof to be duplicated for inputs belong to the same signer. This removes any order dependence, but requires the verifier of the proofs / shares to be able to group them and add up the public keys for grouped inputs, i.e.,\n\n```\ninput_0:proofA:shareA\ninput_1:proofB:shareB\ninput_2:proofA:shareA\n\n// Verifier\n\nsum(input_0_pubkey, input_3_pubkey); verify with proofA:shareA\ninput_1; verify with proofB:shareB\n```\n\nSeems like we can save the signers extra computation at the expense of more data in the PSBT (not really a concern imo) and more work for the verifier.\n\n---\nEDIT: delving was yelling at me for posting too many small replies, so I deleted the inline replies and consolidated them into this post",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 92,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}