{
  "id": 2790,
  "name": "sCrypt",
  "username": "sCrypt-ts",
  "avatar_template": "/letter_avatar_proxy/v4/letter/s/94ad74/{size}.png",
  "created_at": "2024-06-25T21:44:13.469Z",
  "cooked": "<h1><a name=\"bitcoin-op_cat-use-cases-series-1-covenants-1\" class=\"anchor\" href=\"#bitcoin-op_cat-use-cases-series-1-covenants-1\"></a>Bitcoin OP_CAT Use Cases Series <span class=\"hashtag-raw\">#1:</span> Covenants</h1>\n<p>The OP_CAT opcode has potential to enhance the flexibility and functionality of Bitcoin, if reactivated. It allows developers to create impressive new features such as covenants. In the first of a series, we demonstrate a trustless sale of an Ordinal NFT using a layer-1 covenants made possible by re-enabling OP_CAT, without intermediaries.</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/1X/f4e205830143583ae54db8e2a24fc262d8c52026.jpeg\" data-download-href=\"https://delvingbitcoin.org/uploads/default/f4e205830143583ae54db8e2a24fc262d8c52026\" title=\"\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/1X/f4e205830143583ae54db8e2a24fc262d8c52026_2_500x500.jpeg\" alt=\"\" data-base62-sha1=\"yWkKBtwoyqXwa6qxVCH2QmDJK4K\" width=\"500\" height=\"500\" role=\"presentation\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/1X/f4e205830143583ae54db8e2a24fc262d8c52026_2_500x500.jpeg, https://delvingbitcoin.org/uploads/default/original/1X/f4e205830143583ae54db8e2a24fc262d8c52026.jpeg 1.5x, https://delvingbitcoin.org/uploads/default/original/1X/f4e205830143583ae54db8e2a24fc262d8c52026.jpeg 2x\" data-dominant-color=\"8E8B94\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\"></span><span class=\"informations\">700\u00d7700 118 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<h1><a name=\"op_cat-2\" class=\"anchor\" href=\"#op_cat-2\"></a>OP_CAT</h1>\n<p>OP_CAT stands for \u201cconcatenate\u201d in Bitcoin\u2019s scripting language. It was originally included in the scripting language but was disabled due to concerns over potential vulnerabilities. OP_CAT allows concatenation of two strings on the stack.</p>\n<p>It has been reactivated on Bitcoin Cash and SV since 2018 and has been used extensively to significantly enhance scripting capabilities while maintaining security. A few prominent use cases are:</p>\n<ul>\n<li>Quantum-resistant Lamport signatures: <a href=\"https://scryptplatform.medium.com/quantum-resistant-bitcoin-using-lamport-signatures-77a2c5030448\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">Quantum-Resistant Bitcoin using Lamport Signatures | by sCrypt | Medium</a></li>\n<li>Vaults: <a href=\"https://scryptplatform.medium.com/non-custodial-bitcoin-vaults-880c781effa7\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">Non-Custodial Bitcoin Vaults. We have developed a smart\u2026 | by sCrypt | Medium</a></li>\n<li>Tree signatures: <a href=\"https://scryptplatform.medium.com/tree-signatures-8d03a8dd3077#:~:text=Tree%20signature%20brings%20several%20salient,instead%20of%20all%20public%20keys\" rel=\"noopener nofollow ugc\">https://scryptplatform.medium.com/tree-signatures-8d03a8dd3077</a></li>\n</ul>\n<p>On BTC, the reintroduction of OP_CAT has garnered interest lately. It has been assigned the Bitcoin Improvement Proposal (BIP) <a href=\"https://github.com/bitcoin/bips/blob/5d774404790ce79d45588974b9964260a55bcbcd/bip-0347.mediawiki\" rel=\"noopener nofollow ugc\">number 347</a>, marking the first step towards potentially implementing this long-discussed software upgrade.</p>\n<h1><a name=\"scrypt-vs-script-3\" class=\"anchor\" href=\"#scrypt-vs-script-3\"></a>sCrypt vs Script</h1>\n<p>Our series will explore a wide range of use cases of OP_CAT. All of them will be implemented in <a href=\"https://scryptplatform.medium.com/introduce-scrypt-a-layer-1-smart-contract-framework-for-btc-b8b39c125c1a\" rel=\"noopener nofollow ugc\">sCrypt</a> and open sourced, for anyone to independently try and verify on signet, where <a href=\"https://delvingbitcoin.org/t/bitcoin-inquisition-25-2/838\">OP_CAT has been activated</a>.</p>\n<p>Up till now, most discussions on OP_CAT on have been hypothetical and theoretical. One primary reason for the dearth of practical demonstrations is the immense difficulty of reasoning about and coding in Bitcoin Script, which is a low-level assembly language.</p>\n<p>With sCrypt, a Typescript-based <a href=\"https://en.wikipedia.org/wiki/Domain-specific_language\" rel=\"noopener nofollow ugc\">domain specific language</a> (DSL), developers can write Bitcoin smart contracts leveraging OP_CAT directly in TypeScript, one of the world\u2019s most popular programming languages, used by millions of developers daily. sCrypt contracts are then compiled into Bitcoin Script.</p>\n<p>We demonstrate sCrypt makes previously complex and intractable Script constructions as easy as developing Web2 applications, accelerating OP_CAT-enabled innovations. These empirical experiments provide data points and insights to the ongoing OP_CAT discourse.</p>\n<h1><a name=\"covenants-4\" class=\"anchor\" href=\"#covenants-4\"></a>Covenants</h1>\n<p>In the context of Bitcoin, a covenant refers to a mechanism that can impose constraints on how future transactions involving a specific set of coins can be spent. Covenants are essentially restrictions or rules embedded within Bitcoin transactions, designed to control the conditions under which the coins can be transferred or spent. For example, they can restrict the addresses to which the coins can be sent, or require certain scripts to be included in future transactions.</p>\n<p>One straightforward way to add covenants is to introduce new opcode such as OP_CHECKTEMPLATEVERIFY (CTV) in <a href=\"https://github.com/bitcoin/bips/blob/5d774404790ce79d45588974b9964260a55bcbcd/bip-0119.mediawiki\" rel=\"noopener nofollow ugc\">BIP 119</a>. Alternatively, it turns out covenants can be implemented by using a trick if OP_CAT were reactivated.</p>\n<p>We first wrote about the introspection trick in <strong>2020</strong> using ECDSA signatures, which we called OP_PUSH_TX and its optimal variant.</p>\n<h2><a name=\"op_push_tx-5\" class=\"anchor\" href=\"#op_push_tx-5\"></a>OP_PUSH_TX</h2>\n<p>One common misconception regarding Bitcoin script is that its access is only limited to the data provided in the\u2026\n</p><aside class=\"onebox allowlistedgeneric\" data-onebox-src=\"https://scryptplatform.medium.com\">\n  <header class=\"source\">\n      <img src=\"https://delvingbitcoin.org/uploads/default/original/1X/360db83263e79cba7951e7ba15aa4495131aa0f1.png\" class=\"site-icon\" data-dominant-color=\"585858\" width=\"32\" height=\"32\">\n\n      <a href=\"https://scryptplatform.medium.com\" target=\"_blank\" rel=\"noopener nofollow ugc\">Medium</a>\n  </header>\n\n  <article class=\"onebox-body\">\n    <img width=\"500\" height=\"500\" src=\"https://delvingbitcoin.org/uploads/default/optimized/1X/458676fa2233e2e85f4718e678c5905fd8910e33_2_500x500.png\" class=\"thumbnail onebox-avatar\" data-dominant-color=\"ECA74B\">\n\n<h3><a href=\"https://scryptplatform.medium.com\" target=\"_blank\" rel=\"noopener nofollow ugc\">sCrypt \u2013 Medium</a></h3>\n\n  <p>Read writing from sCrypt on Medium. sCrypt (https://scrypt.io) is a web3 development platform specialized in UTXO-blockchains like Bitcoin. Every day, sCrypt and thousands of other voices read, write, and share important stories on Medium.</p>\n\n\n  </article>\n\n  <div class=\"onebox-metadata\">\n    \n    \n  </div>\n\n  <div style=\"clear: both\"></div>\n</aside>\n<p>\n](<a href=\"https://scryptplatform.medium.com/op-push-tx-3d3d279174c1?source=post_page-----0318052f02b2--------------------------------\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">OP_PUSH_TX. One common misconception regarding\u2026 | by sCrypt | Medium</a>)</p>\n<h2><a name=\"optimal-op_push_tx-6\" class=\"anchor\" href=\"#optimal-op_push_tx-6\"></a>Optimal OP_PUSH_TX</h2>\n<p>Since we implemented OP_PUSH_TX, a plethora of smart contracts have been built using this powerful primitive. As these\u2026\n</p><aside class=\"onebox allowlistedgeneric\" data-onebox-src=\"https://scryptplatform.medium.com\">\n  <header class=\"source\">\n      <img src=\"https://delvingbitcoin.org/uploads/default/original/1X/360db83263e79cba7951e7ba15aa4495131aa0f1.png\" class=\"site-icon\" data-dominant-color=\"585858\" width=\"32\" height=\"32\">\n\n      <a href=\"https://scryptplatform.medium.com\" target=\"_blank\" rel=\"noopener nofollow ugc\">Medium</a>\n  </header>\n\n  <article class=\"onebox-body\">\n    <img width=\"500\" height=\"500\" src=\"https://delvingbitcoin.org/uploads/default/optimized/1X/458676fa2233e2e85f4718e678c5905fd8910e33_2_500x500.png\" class=\"thumbnail onebox-avatar\" data-dominant-color=\"ECA74B\">\n\n<h3><a href=\"https://scryptplatform.medium.com\" target=\"_blank\" rel=\"noopener nofollow ugc\">sCrypt \u2013 Medium</a></h3>\n\n  <p>Read writing from sCrypt on Medium. sCrypt (https://scrypt.io) is a web3 development platform specialized in UTXO-blockchains like Bitcoin. Every day, sCrypt and thousands of other voices read, write, and share important stories on Medium.</p>\n\n\n  </article>\n\n  <div class=\"onebox-metadata\">\n    \n    \n  </div>\n\n  <div style=\"clear: both\"></div>\n</aside>\n<p>\n](<a href=\"https://scryptplatform.medium.com/optimal-op-push-tx-ded54990c76f?source=post_page-----0318052f02b2--------------------------------\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">Optimal OP_PUSH_TX. Since we implemented OP_PUSH_TX, a\u2026 | by sCrypt | Medium</a>)</p>\n<p>Later on, it was written by Andrew Poelstra in 2021 and extended to Schnorr signatures.</p>\n<h2><a name=\"so-some-railing-sail-assails-7\" class=\"anchor\" href=\"#so-some-railing-sail-assails-7\"></a>so some railing sail assails</h2>\n<p>This is the first in a series of posts about about covenants in Bitcoin using Taproot and a (hypothetical) CAT opcode\u2026\n<a href=\"http://www.wpsoftware.net\" class=\"onebox\" target=\"_blank\" rel=\"noopener nofollow ugc\">www.wpsoftware.net</a>\n](<a href=\"https://www.wpsoftware.net/andrew/blog/cat-and-schnorr-tricks-i.html?source=post_page-----0318052f02b2--------------------------------\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">so some railing sail assails</a>)</p>\n<h2><a name=\"covenants-using-schnorr-signatures-8\" class=\"anchor\" href=\"#covenants-using-schnorr-signatures-8\"></a>Covenants Using Schnorr Signatures</h2>\n<p>BTC\u2019s Taproot upgrade introduced Schnorr signatures (see <a href=\"https://github.com/bitcoin/bips/blob/5d774404790ce79d45588974b9964260a55bcbcd/bip-0340.mediawiki\" rel=\"noopener nofollow ugc\">BIP-340</a>). The signature scheme uses the same underlying elliptic curve as in ECDSA.</p>\n<p>Suppose we want to sign using the key pair <em><strong>(x, P = xG)</strong></em>. We generate an ephemeral key pair <em><strong>(k, R = kG)</strong></em>. The signature is defined as the tuple (R, s), where</p>\n<blockquote>\n<p><em><strong>s = k + xe</strong></em></p>\n</blockquote>\n<p><em><strong>e</strong></em> is a hash of three things concatenated: our public key <em><strong>P\u2019s</strong></em> x-coordinate, the x-coordinate of ephemeral <em><strong>R</strong></em>, and our transaction data/preimage.</p>\n<blockquote>\n<p><em><strong>e = H(Rx || Px || transaction)</strong></em></p>\n</blockquote>\n<p>If we choose <em>k</em> = 1 and <em>x</em> = 1, we can simplify the equation:</p>\n<blockquote>\n<p><em><strong>s = 1 + e</strong></em></p>\n</blockquote>\n<p>By constructing such a signature within script and passing it to an OP_CHECKSIG, we can constrain chunks of the transaction data. In short, we get a working covenant with OP_CAT, which allows calculating the equation in script. You can read more about this trick in the aforementioned articles.</p>\n<h1><a name=\"ordinal-locks-9\" class=\"anchor\" href=\"#ordinal-locks-9\"></a>Ordinal Locks</h1>\n<p>A seller transfers her ordinal NFT into a covenant smart contract (called an <a href=\"https://docs.1satordinals.com/ordinal-lock\" rel=\"noopener nofollow ugc\">ordinal lock</a>) in a taproot output that can only be redeemed if the spending transaction pays the seller the asking price. Traditional Ordinals marketplaces based on Partially Signed Bitcoin Transactions (PSBTs) generally do not share these PSBT listings with each other. Ordinal lock can potentially create a global shared on-chain order book with more liquidity and transparency, which is public for everyone to access.</p>\n<h2><a name=\"implementation-10\" class=\"anchor\" href=\"#implementation-10\"></a>Implementation</h2>\n<p>The signature equation above requires us to add 1 to a 256-bit integer. BTC currently only allows arithmetic in integers of 32 bits long, so we need to find a workaround.</p>\n<p>Because <em><strong>e</strong></em> is derived from our transaction data, we can malleate the transaction until it hashed to a value of <em><strong>e</strong></em> that ends with 0x01 (or any value less than 0xFF) as we did in <a href=\"https://scryptplatform.medium.com/optimal-op-push-tx-ded54990c76f\" rel=\"noopener nofollow ugc\">optimal PUSHTX</a>. This takes 256 tries on average, which is instantaneous on modern hardware. For this example, we iterate on the value of <em><strong>nLockTime</strong></em> in the transaction, starting from 0*,* which won\u2019t have an effect on the transaction\u2019s validity/finality.</p>\n<p>Once we have a value ending with 0x01, we can simply cut off the last byte and append 0x02 to it within the script to arrive at the correct value for <em><strong>s</strong></em>.</p>\n<p>Let us implement a simple function:</p>\n<pre><code class=\"lang-auto\"> @method()\n    private checkSHPreimage(shPreimage: SHPreimage): void {\n        const e = sha256(OrdListing.ePreimagePrefix + shPreimage.sigHash)\n        assert(e == shPreimage._e + toByteString('01'), 'invalid value of _e')\n        const s = OrdListing.Gx + shPreimage._e + toByteString('02')\n        assert(this.checkSig(Sig(s), PubKey(OrdListing.Gx)))\n        const sigHash = sha256(\n            OrdListing.preimagePrefix +\n                shPreimage.txVer +\n                shPreimage.nLockTime +\n                shPreimage.hashPrevouts +\n                shPreimage.hashSpentAmounts +\n                shPreimage.hashSpentScripts +\n                shPreimage.hashSequences +\n                shPreimage.hashOutputs +\n                shPreimage.spendType +\n                shPreimage.inputNumber +\n                shPreimage.hashTapLeaf +\n                shPreimage.keyVer +\n                shPreimage.codeSeparator\n        )\n        assert(sigHash == shPreimage.sigHash, 'sigHash mismatch')\n    }\n</code></pre>\n<p>If the code execution succeeds, it leaves us with a verified preimage of <em><strong>e</strong></em>, i.e., variable <em>shPreimage</em>. Line 4 enforeces <em><strong>e</strong></em> ending with 0x01.</p>\n<p>We then retrieve the <em>hashOutputs</em> field from <em>shPreimage</em>, which allows us to constrain the spending transactions\u2019 outputs.</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2024-06-25T22:35:27.000Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 7,
  "readers_count": 6,
  "score": 16.4,
  "yours": false,
  "topic_id": 990,
  "topic_slug": "bitcoin-op-cat-use-cases-series-1-covenants",
  "topic_title": "Bitcoin OP_CAT Use Cases Series #1: Covenants",
  "topic_html_title": "Bitcoin OP_CAT Use Cases Series #1: Covenants",
  "category_id": 8,
  "display_username": "sCrypt",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 4,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "# Bitcoin OP_CAT Use Cases Series #1: Covenants\n\nThe OP_CAT opcode has potential to enhance the flexibility and functionality of Bitcoin, if reactivated. It allows developers to create impressive new features such as covenants. In the first of a series, we demonstrate a trustless sale of an Ordinal NFT using a layer-1 covenants made possible by re-enabling OP_CAT, without intermediaries.\n\n![|700x700](upload://yWkKBtwoyqXwa6qxVCH2QmDJK4K.jpeg)\n\n# OP_CAT\n\nOP_CAT stands for \u201cconcatenate\u201d in Bitcoin\u2019s scripting language. It was originally included in the scripting language but was disabled due to concerns over potential vulnerabilities. OP_CAT allows concatenation of two strings on the stack.\n\nIt has been reactivated on Bitcoin Cash and SV since 2018 and has been used extensively to significantly enhance scripting capabilities while maintaining security. A few prominent use cases are:\n\n* Quantum-resistant Lamport signatures: https://scryptplatform.medium.com/quantum-resistant-bitcoin-using-lamport-signatures-77a2c5030448\n* Vaults: https://scryptplatform.medium.com/non-custodial-bitcoin-vaults-880c781effa7\n* Tree signatures: [https://scryptplatform.medium.com/tree-signatures-8d03a8dd3077](https://scryptplatform.medium.com/tree-signatures-8d03a8dd3077#:~:text=Tree%20signature%20brings%20several%20salient,instead%20of%20all%20public%20keys)\n\nOn BTC, the reintroduction of OP_CAT has garnered interest lately. It has been assigned the Bitcoin Improvement Proposal (BIP) [number 347](https://github.com/bitcoin/bips/blob/5d774404790ce79d45588974b9964260a55bcbcd/bip-0347.mediawiki), marking the first step towards potentially implementing this long-discussed software upgrade.\n\n# sCrypt vs Script\n\nOur series will explore a wide range of use cases of OP_CAT. All of them will be implemented in [sCrypt](https://scryptplatform.medium.com/introduce-scrypt-a-layer-1-smart-contract-framework-for-btc-b8b39c125c1a) and open sourced, for anyone to independently try and verify on signet, where [OP_CAT has been activated](https://delvingbitcoin.org/t/bitcoin-inquisition-25-2/838).\n\nUp till now, most discussions on OP_CAT on have been hypothetical and theoretical. One primary reason for the dearth of practical demonstrations is the immense difficulty of reasoning about and coding in Bitcoin Script, which is a low-level assembly language.\n\nWith sCrypt, a Typescript-based [domain specific language](https://en.wikipedia.org/wiki/Domain-specific_language) (DSL), developers can write Bitcoin smart contracts leveraging OP_CAT directly in TypeScript, one of the world\u2019s most popular programming languages, used by millions of developers daily. sCrypt contracts are then compiled into Bitcoin Script.\n\nWe demonstrate sCrypt makes previously complex and intractable Script constructions as easy as developing Web2 applications, accelerating OP_CAT-enabled innovations. These empirical experiments provide data points and insights to the ongoing OP_CAT discourse.\n\n# Covenants\n\nIn the context of Bitcoin, a covenant refers to a mechanism that can impose constraints on how future transactions involving a specific set of coins can be spent. Covenants are essentially restrictions or rules embedded within Bitcoin transactions, designed to control the conditions under which the coins can be transferred or spent. For example, they can restrict the addresses to which the coins can be sent, or require certain scripts to be included in future transactions.\n\nOne straightforward way to add covenants is to introduce new opcode such as OP_CHECKTEMPLATEVERIFY (CTV) in [BIP 119](https://github.com/bitcoin/bips/blob/5d774404790ce79d45588974b9964260a55bcbcd/bip-0119.mediawiki). Alternatively, it turns out covenants can be implemented by using a trick if OP_CAT were reactivated.\n\nWe first wrote about the introspection trick in **2020** using ECDSA signatures, which we called OP_PUSH_TX and its optimal variant.\n\n\n## OP_PUSH_TX\nOne common misconception regarding Bitcoin script is that its access is only limited to the data provided in the\u2026\nscryptplatform.medium.com\n](https://scryptplatform.medium.com/op-push-tx-3d3d279174c1?source=post_page-----0318052f02b2--------------------------------)\n\n## Optimal OP_PUSH_TX\nSince we implemented OP_PUSH_TX, a plethora of smart contracts have been built using this powerful primitive. As these\u2026\nscryptplatform.medium.com\n](https://scryptplatform.medium.com/optimal-op-push-tx-ded54990c76f?source=post_page-----0318052f02b2--------------------------------)\n\nLater on, it was written by Andrew Poelstra in 2021 and extended to Schnorr signatures.\n\n## so some railing sail assails\nThis is the first in a series of posts about about covenants in Bitcoin using Taproot and a (hypothetical) CAT opcode\u2026\nwww.wpsoftware.net\n](https://www.wpsoftware.net/andrew/blog/cat-and-schnorr-tricks-i.html?source=post_page-----0318052f02b2--------------------------------)\n\n## Covenants Using Schnorr Signatures\n\nBTC\u2019s Taproot upgrade introduced Schnorr signatures (see [BIP-340](https://github.com/bitcoin/bips/blob/5d774404790ce79d45588974b9964260a55bcbcd/bip-0340.mediawiki)). The signature scheme uses the same underlying elliptic curve as in ECDSA.\n\nSuppose we want to sign using the key pair ***(x, P = xG)***. We generate an ephemeral key pair ***(k, R = kG)***. The signature is defined as the tuple (R, s), where\n\n> ***s = k + xe***\n\n***e*** is a hash of three things concatenated: our public key ***P\u2019s*** x-coordinate, the x-coordinate of ephemeral ***R***, and our transaction data/preimage.\n\n> ***e = H(Rx || Px || transaction)***\n\nIf we choose *k* = 1 and *x* = 1, we can simplify the equation:\n\n> ***s = 1 + e***\n\nBy constructing such a signature within script and passing it to an OP_CHECKSIG, we can constrain chunks of the transaction data. In short, we get a working covenant with OP_CAT, which allows calculating the equation in script. You can read more about this trick in the aforementioned articles.\n\n# Ordinal Locks\n\nA seller transfers her ordinal NFT into a covenant smart contract (called an [ordinal lock](https://docs.1satordinals.com/ordinal-lock)) in a taproot output that can only be redeemed if the spending transaction pays the seller the asking price. Traditional Ordinals marketplaces based on Partially Signed Bitcoin Transactions (PSBTs) generally do not share these PSBT listings with each other. Ordinal lock can potentially create a global shared on-chain order book with more liquidity and transparency, which is public for everyone to access.\n\n## Implementation\n\nThe signature equation above requires us to add 1 to a 256-bit integer. BTC currently only allows arithmetic in integers of 32 bits long, so we need to find a workaround.\n\nBecause ***e*** is derived from our transaction data, we can malleate the transaction until it hashed to a value of ***e*** that ends with 0x01 (or any value less than 0xFF) as we did in [optimal PUSHTX](https://scryptplatform.medium.com/optimal-op-push-tx-ded54990c76f). This takes 256 tries on average, which is instantaneous on modern hardware. For this example, we iterate on the value of ***nLockTime*** in the transaction, starting from 0*,* which won\u2019t have an effect on the transaction\u2019s validity/finality.\n\nOnce we have a value ending with 0x01, we can simply cut off the last byte and append 0x02 to it within the script to arrive at the correct value for ***s***.\n\nLet us implement a simple function:\n\n```\n @method()\n    private checkSHPreimage(shPreimage: SHPreimage): void {\n        const e = sha256(OrdListing.ePreimagePrefix + shPreimage.sigHash)\n        assert(e == shPreimage._e + toByteString('01'), 'invalid value of _e')\n        const s = OrdListing.Gx + shPreimage._e + toByteString('02')\n        assert(this.checkSig(Sig(s), PubKey(OrdListing.Gx)))\n        const sigHash = sha256(\n            OrdListing.preimagePrefix +\n                shPreimage.txVer +\n                shPreimage.nLockTime +\n                shPreimage.hashPrevouts +\n                shPreimage.hashSpentAmounts +\n                shPreimage.hashSpentScripts +\n                shPreimage.hashSequences +\n                shPreimage.hashOutputs +\n                shPreimage.spendType +\n                shPreimage.inputNumber +\n                shPreimage.hashTapLeaf +\n                shPreimage.keyVer +\n                shPreimage.codeSeparator\n        )\n        assert(sigHash == shPreimage.sigHash, 'sigHash mismatch')\n    }\n```\nIf the code execution succeeds, it leaves us with a verified preimage of ***e***, i.e., variable *shPreimage*. Line 4 enforeces ***e*** ending with 0x01.\n\nWe then retrieve the *hashOutputs* field from *shPreimage*, which allows us to constrain the spending transactions\u2019 outputs.",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 477,
  "hidden": false,
  "trust_level": 0,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": "Github link was replaced with a permanent link",
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}