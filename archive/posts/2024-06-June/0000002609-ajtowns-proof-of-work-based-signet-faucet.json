{
  "id": 2609,
  "name": "Anthony Towns",
  "username": "ajtowns",
  "avatar_template": "/user_avatar/delvingbitcoin.org/ajtowns/{size}/417_2.png",
  "created_at": "2024-06-03T08:51:12.174Z",
  "cooked": "<p>With the recent activation of <a href=\"https://github.com/bitcoin-inquisition/bitcoin/pull/39\"><code>OP_CAT</code></a> on signet via the <a href=\"https://delvingbitcoin.org/t/bitcoin-inquisition-25-2/838\">bitcoin inquisition client</a>, it\u2019s at least theoretically possible to some <a href=\"https://covenants.info/extra/cat/\">weird scripting tricks</a>. One of the easier things to do with <code>OP_CAT</code> is to validate proof-of-work, since you can program that as more or less \u201ctake the non-zero bytes of a hash, cat that togethether with a bunch of zero bytes, then check that the original thing hashes to what you just catted together\u201d, ie a script something like <code>&lt;\"\\x00\\x00\\x00\" CAT SWAP SHA256 EQUALVERIFY&gt;</code>.</p>\n<p>The obvious thing to do with proof of work on the blockchain is to give people coins for it, and that\u2019s perhaps particularly interesting on signet, since as a permissioned blockchain, the only way you can normally get coins is to be given them by the signet block producers. That is, the idea is that every block, the signet block producers send some sBTC to an contract that allows funds to be claimed by providing proof of work.</p>\n<p>If you\u2019re the sort of person that skips straight to the last page when reading a murder mystery, you can see a <a href=\"https://mempool.space/signet/tx/25deff74b7775918aa6824cfeab9121a519fb419d31ea74f6cb6a53f98cc863a\">demo transaction claiming some funds</a> or mess around with the <a href=\"https://github.com/ajtowns/bitcoin/blob/634e72cbfc0aa3f657a35c7b597f688bb2bb29a6/contrib/signet/powcoins\">python script to claim funds</a>.</p>\n<p>There\u2019s a few constraints here. For example, you don\u2019t want the proof of work to be reusable \u2013 if I spend 5 minutes of CPU grinding a way to claim 1 sBTC, I don\u2019t want you to be able to just sit their watching the mempool, and replace my transaction with one sending the funds to you, without you having to do any work. But that turns out pretty straightforward: you can just make the preimage of your PoW-hash be <code>x + sig + y</code> and then check <code>p sig CHECKSIG</code>. If you try to reuse my proof of work, you have to keep the same signature, but that signature commits to where the funds go, which is to me, so you can\u2019t steal the funds. If we go a step further and check that <code>p</code> is 32 bytes, and <code>sig</code> is 64 bytes, then we know that it\u2019s a <code>SIGHASH_DEFAULT</code> signature, committing to everything about the tx, as well.</p>\n<p>Just as you don\u2019t want other people to reuse your proof of work, you don\u2019t want the same person to be able to use a single proof of work twice \u2013 eg, what if you started with <code>x + sig1 + sig2 + sig3 + y</code> and tried different values for <code>x</code> and <code>y</code> until you got a lot of zeroes? Then you\u2019d be able to reuse that single value to claim three coins: one with <code>sig1</code> (<code>x'=x</code>, <code>y'=sig2+sig3+y</code>), one with <code>sig2</code> (<code>x'=x+sig1</code>, <code>y'=sig3+y</code>) and the third with <code>sig3</code> (<code>x'=x+sig1+sig2</code>, <code>y'=y</code>). So we avoid that by committing to the length of <code>x</code> and <code>y</code> before hashing.</p>\n<p>Finally, there\u2019s a question of what sort of \u201cwork\u201d do we want \u2013 something where you can point bitcoin ASICs at it, or something where you can\u2019t? I picked something as compatible as possible with bitcoin ASICs, so the python script above constructs a 4-byte <code>x</code> and a 12-byte <code>y</code>, so that if you were to interpret <code>x+sig+y</code> as an 80-byte block header, <code>x</code> serves as <code>nVersion</code>, <code>sig</code> serves as the combination of the prev block hash and the merkle root, and <code>y</code> covers the timestamp, nBits and the nonce. The script goes a step further and sets the <code>nBits</code> value to the expected difficulty, and then passes the whole thing to a CPU miner in the form of <code>bitcoin-util grind</code>.</p>\n<p>So how\u2019s it implemented? There\u2019s more or less six parts to the script, so we\u2019ll go through them one by one.</p>\n<pre data-code-wrap=\"txt\"><code class=\"lang-txt\">OP_PUSHNUM_16 OP_SUB\nOP_DUP OP_0 OP_GREATERTHANOREQUAL OP_VERIFY\nOP_DUP OP_PUSHBYTES_1 40 OP_LESSTHAN OP_VERIFY\nOP_DUP OP_DUP OP_ADD OP_DUP OP_ADD\nOP_PUSHBYTES_2 0001 OP_SWAP OP_SUB OP_CSV OP_DROP\n</code></pre>\n<p>This first part takes a difficulty specifier from the top of the stack, subtracts 16, checks the result is between 0 and 64 (so the original was between 16 and 80), multiplies the value by 4, subtracts that from 256, and invokes <code>CHECKSEQUENCEVERIFY</code> on the result \u2013 so a difficulty specifier of 80 requires 0 blocks\u2019 delay, while a difficulty specifier of 79 requires 4 blocks delay, etc.</p>\n<pre data-code-wrap=\"txt\"><code class=\"lang-txt\">OP_PUSHBYTES_2 0000  OP_TOALTSTACK\nOP_DUP OP_PUSHBYTES_1 20 OP_GREATERTHANOREQUAL \nOP_IF OP_FROMALTSTACK OP_PUSHBYTES_4 00000000 OP_CAT OP_TOALTSTACK\nOP_PUSHBYTES_1 20 OP_SUB OP_ENDIF\nOP_DUP OP_PUSHNUM_16 OP_GREATERTHANOREQUAL\nOP_IF OP_FROMALTSTACK OP_PUSHBYTES_2 0000 OP_CAT OP_TOALTSTACK\nOP_PUSHNUM_16 OP_SUB OP_ENDIF\nOP_DUP OP_PUSHNUM_8 OP_GREATERTHANOREQUAL\nOP_IF OP_FROMALTSTACK OP_PUSHBYTES_1 00 OP_CAT OP_TOALTSTACK\nOP_PUSHNUM_8 OP_SUB OP_ENDIF\n</code></pre>\n<p>The difficulty specifier is the number of zero bits we want, so since we subtracted 16 already we start with 2 zero bytes, and if the remaining difficulty is more than 32 that\u2019s another 4 zero bytes, etc. We progressively CAT those together and leave them on the alt stack, with the remainder (a figure from 0 to 7) on the main stack.</p>\n<pre data-code-wrap=\"txt\"><code class=\"lang-txt\">OP_SWAP OP_SIZE OP_PUSHNUM_1 OP_EQUALVERIFY\nOP_DUP OP_TOALTSTACK\nOP_PUSHNUM_1 OP_CAT OP_PUSHBYTES_2 0001 OP_SUB\nOP_SWAP\nOP_DUP OP_0 OP_EQUAL OP_IF OP_PUSHBYTES_2 0001 OP_ELSE\nOP_DUP OP_PUSHNUM_1 OP_EQUAL OP_IF OP_PUSHBYTES_2 8000 OP_ELSE\nOP_DUP OP_PUSHNUM_2 OP_EQUAL OP_IF OP_PUSHBYTES_1 40 OP_ELSE\nOP_DUP OP_PUSHNUM_3 OP_EQUAL OP_IF OP_PUSHBYTES_1 20 OP_ELSE\nOP_DUP OP_PUSHNUM_4 OP_EQUAL OP_IF OP_PUSHNUM_16 OP_ELSE\nOP_DUP OP_PUSHNUM_5 OP_EQUAL OP_IF OP_PUSHNUM_8 OP_ELSE\nOP_DUP OP_PUSHNUM_6 OP_EQUAL OP_IF OP_PUSHNUM_4 OP_ELSE\nOP_PUSHNUM_2 \nOP_ENDIF OP_ENDIF OP_ENDIF OP_ENDIF OP_ENDIF OP_ENDIF OP_ENDIF\nOP_NIP OP_LESSTHAN OP_VERIFY\n</code></pre>\n<p>The second item on the stack is the first byte of the hash after the leading zero bytes. If the remaining difficulty is 0, this can be anything, if it\u2019s 1, it should be less than 0x80, if it\u2019s 2, it should be less than 0x40, etc, and if it\u2019s 7 it should be less than 0x02 (ie, 0x01 or 0x00 exactly). Unfortunately you can\u2019t just use \u201cless than\u201d here, because 0x80 would be treated as negative zero, and 0x81 through 0xFF would be treated as -1 to -127 rather than 129 to 255. To work around this, we append 0x01 and subtract 128, which gives us the correct value (minimally encoded), after copying the actual byte that we want onto the alt stack. A bunch of IFs later and we can do the comparison we want.</p>\n<pre data-code-wrap=\"txt\"><code class=\"lang-txt\">OP_FROMALTSTACK OP_FROMALTSTACK OP_CAT\nOP_CAT OP_TOALTSTACK\n</code></pre>\n<p>On the alt stack we have a string of zero bytes, and the first non-zero byte, and now the third witness item is at the top of the main stack, so catting all those together should give the full 32 byte hash that we want. Calculate that and put it on the alt stack.</p>\n<pre data-code-wrap=\"txt\"><code class=\"lang-txt\">OP_2OVER\nOP_SIZE OP_PUSHBYTES_1 20 OP_EQUALVERIFY OP_DROP\nOP_SIZE OP_PUSHBYTES_1 40 OP_EQUALVERIFY\nOP_SWAP\nOP_SIZE OP_SWAP OP_CAT\nOP_CAT\nOP_SWAP\nOP_SIZE OP_SWAP OP_CAT\nOP_SWAP\nOP_CAT\nOP_HASH256\nOP_FROMALTSTACK OP_EQUALVERIFY`\n</code></pre>\n<p>The remaining items on the stack are, from top to bottom, the preimage suffix, the preimage prefix, the pubkey and the signature. Copy the pubkey and signature to the top of the stack, check their sizes, and throw away the pubkey. Swap the signature and the suffix, calculate the size of the suffix, and cat those three things together (<code>sig + suffix_size + suffix</code>). Swap that with the prefix, cat the size of the prefix at the beginning of the prefix, then cat that at the beginning of everything for the full preimage (<code>prefix_size + prefix + sig + suffix_size + suffix</code>). Hash the preimage, and check that the result matches what we pushed onto the altstack earlier.</p>\n<pre><code class=\"lang-auto\">OP_CHECKSIG\n</code></pre>\n<p>Finally, we just have the pubkey and signature left on the stack, so check the signature.</p>\n<p>As far as the python script goes, it has two parts:</p>\n<pre data-code-wrap=\"none\"><code class=\"lang-none\">$ ./powcoins setup-wallet\n</code></pre>\n<p>The first is a short command to setup a <code>varpow</code> wallet via bitcoind that tracks the faucet coins it can spend. You can use <code>bitcoin-cli -signet -rpcwallet=varpow listunspent</code> to see what they are.</p>\n<p>The second is</p>\n<pre data-code-wrap=\"none\"><code class=\"lang-none\">$ ./powcoins claim --max-diff=16 tb1qzv66dscl3uauh5jesfem33wws747naapcgt4c5\nINFO:root:sendrawtransaction result 71fb0d9593dd7c697cf4bb595bb2f0b63a4f6cb3d675e81b6e7b6e5fd07e0027                                                                                                                                         \n</code></pre>\n<p>which will attempt to claim a coin that\u2019s currently less than the specified max difficulty, picking the coin that has the most value per unit work needed. Note that you\u2019ll need to have a bitcoin inquisition node to use this, as otherwise a script that uses <code>OP_CAT</code> will fail the <code>DISCOURAGE_OP_SUCCESS</code> checks, and you\u2019ll probably want to run that node with <code>-addnode=inquisition.bitcoin-signet.net</code> to make sure you have a peer that will actually accept transactions that use <code>OP_CAT</code>.</p>\n<p>Thanks to <a class=\"mention\" href=\"/u/thestack\">@theStack</a> for <a href=\"https://github.com/theStack/bitcoin-inquisition/issues/1\">collaborating</a> on this!</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2024-06-03T08:56:16.868Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 3,
  "reads": 6,
  "readers_count": 5,
  "score": 16.2,
  "yours": false,
  "topic_id": 937,
  "topic_slug": "proof-of-work-based-signet-faucet",
  "topic_title": "Proof-of-work based signet faucet",
  "topic_html_title": "Proof-of-work based signet faucet",
  "category_id": 8,
  "display_username": "Anthony Towns",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "With the recent activation of [`OP_CAT`](https://github.com/bitcoin-inquisition/bitcoin/pull/39) on signet via the [bitcoin inquisition client](https://delvingbitcoin.org/t/bitcoin-inquisition-25-2/838), it's at least theoretically possible to some [weird scripting tricks](https://covenants.info/extra/cat/). One of the easier things to do with `OP_CAT` is to validate proof-of-work, since you can program that as more or less \"take the non-zero bytes of a hash, cat that togethether with a bunch of zero bytes, then check that the original thing hashes to what you just catted together\", ie a script something like `<\"\\x00\\x00\\x00\" CAT SWAP SHA256 EQUALVERIFY>`.\n\nThe obvious thing to do with proof of work on the blockchain is to give people coins for it, and that's perhaps particularly interesting on signet, since as a permissioned blockchain, the only way you can normally get coins is to be given them by the signet block producers. That is, the idea is that every block, the signet block producers send some sBTC to an contract that allows funds to be claimed by providing proof of work.\n\nIf you're the sort of person that skips straight to the last page when reading a murder mystery, you can see a [demo transaction claiming some funds](https://mempool.space/signet/tx/25deff74b7775918aa6824cfeab9121a519fb419d31ea74f6cb6a53f98cc863a) or mess around with the [python script to claim funds](https://github.com/ajtowns/bitcoin/blob/634e72cbfc0aa3f657a35c7b597f688bb2bb29a6/contrib/signet/powcoins).\n\nThere's a few constraints here. For example, you don't want the proof of work to be reusable -- if I spend 5 minutes of CPU grinding a way to claim 1 sBTC, I don't want you to be able to just sit their watching the mempool, and replace my transaction with one sending the funds to you, without you having to do any work. But that turns out pretty straightforward: you can just make the preimage of your PoW-hash be `x + sig + y` and then check `p sig CHECKSIG`. If you try to reuse my proof of work, you have to keep the same signature, but that signature commits to where the funds go, which is to me, so you can't steal the funds. If we go a step further and check that `p` is 32 bytes, and `sig` is 64 bytes, then we know that it's a `SIGHASH_DEFAULT` signature, committing to everything about the tx, as well.\n\nJust as you don't want other people to reuse your proof of work, you don't want the same person to be able to use a single proof of work twice -- eg, what if you started with `x + sig1 + sig2 + sig3 + y` and tried different values for `x` and `y` until you got a lot of zeroes? Then you'd be able to reuse that single value to claim three coins: one with `sig1` (`x'=x`, `y'=sig2+sig3+y`), one with `sig2` (`x'=x+sig1`, `y'=sig3+y`) and the third with `sig3` (`x'=x+sig1+sig2`, `y'=y`). So we avoid that by committing to the length of `x` and `y` before hashing.\n\nFinally, there's a question of what sort of \"work\" do we want -- something where you can point bitcoin ASICs at it, or something where you can't? I picked something as compatible as possible with bitcoin ASICs, so the python script above constructs a 4-byte `x` and a 12-byte `y`, so that if you were to interpret `x+sig+y` as an 80-byte block header, `x` serves as `nVersion`, `sig` serves as the combination of the prev block hash and the merkle root, and `y` covers the timestamp, nBits and the nonce. The script goes a step further and sets the `nBits` value to the expected difficulty, and then passes the whole thing to a CPU miner in the form of `bitcoin-util grind`.\n\nSo how's it implemented? There's more or less six parts to the script, so we'll go through them one by one.\n\n```txt\nOP_PUSHNUM_16 OP_SUB\nOP_DUP OP_0 OP_GREATERTHANOREQUAL OP_VERIFY\nOP_DUP OP_PUSHBYTES_1 40 OP_LESSTHAN OP_VERIFY\nOP_DUP OP_DUP OP_ADD OP_DUP OP_ADD\nOP_PUSHBYTES_2 0001 OP_SWAP OP_SUB OP_CSV OP_DROP\n```\n\nThis first part takes a difficulty specifier from the top of the stack, subtracts 16, checks the result is between 0 and 64 (so the original was between 16 and 80), multiplies the value by 4, subtracts that from 256, and invokes `CHECKSEQUENCEVERIFY` on the result -- so a difficulty specifier of 80 requires 0 blocks' delay, while a difficulty specifier of 79 requires 4 blocks delay, etc.\n\n```txt\nOP_PUSHBYTES_2 0000  OP_TOALTSTACK\nOP_DUP OP_PUSHBYTES_1 20 OP_GREATERTHANOREQUAL \nOP_IF OP_FROMALTSTACK OP_PUSHBYTES_4 00000000 OP_CAT OP_TOALTSTACK\nOP_PUSHBYTES_1 20 OP_SUB OP_ENDIF\nOP_DUP OP_PUSHNUM_16 OP_GREATERTHANOREQUAL\nOP_IF OP_FROMALTSTACK OP_PUSHBYTES_2 0000 OP_CAT OP_TOALTSTACK\nOP_PUSHNUM_16 OP_SUB OP_ENDIF\nOP_DUP OP_PUSHNUM_8 OP_GREATERTHANOREQUAL\nOP_IF OP_FROMALTSTACK OP_PUSHBYTES_1 00 OP_CAT OP_TOALTSTACK\nOP_PUSHNUM_8 OP_SUB OP_ENDIF\n```\n\nThe difficulty specifier is the number of zero bits we want, so since we subtracted 16 already we start with 2 zero bytes, and if the remaining difficulty is more than 32 that's another 4 zero bytes, etc. We progressively CAT those together and leave them on the alt stack, with the remainder (a figure from 0 to 7) on the main stack.\n\n```txt\nOP_SWAP OP_SIZE OP_PUSHNUM_1 OP_EQUALVERIFY\nOP_DUP OP_TOALTSTACK\nOP_PUSHNUM_1 OP_CAT OP_PUSHBYTES_2 0001 OP_SUB\nOP_SWAP\nOP_DUP OP_0 OP_EQUAL OP_IF OP_PUSHBYTES_2 0001 OP_ELSE\nOP_DUP OP_PUSHNUM_1 OP_EQUAL OP_IF OP_PUSHBYTES_2 8000 OP_ELSE\nOP_DUP OP_PUSHNUM_2 OP_EQUAL OP_IF OP_PUSHBYTES_1 40 OP_ELSE\nOP_DUP OP_PUSHNUM_3 OP_EQUAL OP_IF OP_PUSHBYTES_1 20 OP_ELSE\nOP_DUP OP_PUSHNUM_4 OP_EQUAL OP_IF OP_PUSHNUM_16 OP_ELSE\nOP_DUP OP_PUSHNUM_5 OP_EQUAL OP_IF OP_PUSHNUM_8 OP_ELSE\nOP_DUP OP_PUSHNUM_6 OP_EQUAL OP_IF OP_PUSHNUM_4 OP_ELSE\nOP_PUSHNUM_2 \nOP_ENDIF OP_ENDIF OP_ENDIF OP_ENDIF OP_ENDIF OP_ENDIF OP_ENDIF\nOP_NIP OP_LESSTHAN OP_VERIFY\n```\n\nThe second item on the stack is the first byte of the hash after the leading zero bytes. If the remaining difficulty is 0, this can be anything, if it's 1, it should be less than 0x80, if it's 2, it should be less than 0x40, etc, and if it's 7 it should be less than 0x02 (ie, 0x01 or 0x00 exactly). Unfortunately you can't just use \"less than\" here, because 0x80 would be treated as negative zero, and 0x81 through 0xFF would be treated as -1 to -127 rather than 129 to 255. To work around this, we append 0x01 and subtract 128, which gives us the correct value (minimally encoded), after copying the actual byte that we want onto the alt stack. A bunch of IFs later and we can do the comparison we want.\n\n```txt\nOP_FROMALTSTACK OP_FROMALTSTACK OP_CAT\nOP_CAT OP_TOALTSTACK\n```\n\nOn the alt stack we have a string of zero bytes, and the first non-zero byte, and now the third witness item is at the top of the main stack, so catting all those together should give the full 32 byte hash that we want. Calculate that and put it on the alt stack.\n\n```txt\nOP_2OVER\nOP_SIZE OP_PUSHBYTES_1 20 OP_EQUALVERIFY OP_DROP\nOP_SIZE OP_PUSHBYTES_1 40 OP_EQUALVERIFY\nOP_SWAP\nOP_SIZE OP_SWAP OP_CAT\nOP_CAT\nOP_SWAP\nOP_SIZE OP_SWAP OP_CAT\nOP_SWAP\nOP_CAT\nOP_HASH256\nOP_FROMALTSTACK OP_EQUALVERIFY`\n```\n\nThe remaining items on the stack are, from top to bottom, the preimage suffix, the preimage prefix, the pubkey and the signature. Copy the pubkey and signature to the top of the stack, check their sizes, and throw away the pubkey. Swap the signature and the suffix, calculate the size of the suffix, and cat those three things together (`sig + suffix_size + suffix`). Swap that with the prefix, cat the size of the prefix at the beginning of the prefix, then cat that at the beginning of everything for the full preimage (`prefix_size + prefix + sig + suffix_size + suffix`). Hash the preimage, and check that the result matches what we pushed onto the altstack earlier.\n\n```\nOP_CHECKSIG\n```\n\nFinally, we just have the pubkey and signature left on the stack, so check the signature.\n\nAs far as the python script goes, it has two parts:\n\n```none\n$ ./powcoins setup-wallet\n```\n\nThe first is a short command to setup a `varpow` wallet via bitcoind that tracks the faucet coins it can spend. You can use `bitcoin-cli -signet -rpcwallet=varpow listunspent` to see what they are.\n\nThe second is\n\n```none\n$ ./powcoins claim --max-diff=16 tb1qzv66dscl3uauh5jesfem33wws747naapcgt4c5\nINFO:root:sendrawtransaction result 71fb0d9593dd7c697cf4bb595bb2f0b63a4f6cb3d675e81b6e7b6e5fd07e0027                                                                                                                                         \n```\n\nwhich will attempt to claim a coin that's currently less than the specified max difficulty, picking the coin that has the most value per unit work needed. Note that you'll need to have a bitcoin inquisition node to use this, as otherwise a script that uses `OP_CAT` will fail the `DISCOURAGE_OP_SUCCESS` checks, and you'll probably want to run that node with `-addnode=inquisition.bitcoin-signet.net` to make sure you have a peer that will actually accept transactions that use `OP_CAT`.\n\nThanks to @theStack for [collaborating](https://github.com/theStack/bitcoin-inquisition/issues/1) on this!",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": true,
  "admin": true,
  "staff": true,
  "user_id": 3,
  "hidden": false,
  "trust_level": 4,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": "Github link was replaced with a permanent link",
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "rocket",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}