{
  "id": 2616,
  "name": "Sebastian Falbesoner",
  "username": "theStack",
  "avatar_template": "/user_avatar/delvingbitcoin.org/thestack/{size}/420_2.png",
  "created_at": "2024-06-03T18:01:35.559Z",
  "cooked": "<p><a class=\"mention\" href=\"/u/liz.lightning\">@Liz.Lightning</a></p>\n<blockquote>\n<p><a class=\"mention\" href=\"/u/thestack\">@theStack</a> thank you for sharing your bip324 proxy work, looks very interesting. I started coding a Golang version and your repo has been very helpful, I hope to share the first version soon and also make available the bip324 implementation as a library.</p>\n</blockquote>\n<p>Nice, glad to hear that the idea is picked up and looking forward to see an implementation of bip324-proxy in another language soon! I\u2019m curious how advanced the golang ecosystem is w.r.t. the needed cryptographic primitives (e.g., are there even proper secp256k1 bindings available for doing the EllSwift pubkey encoding? I\u2019m aware that btcd uses a custom secp256k1 library from the <a href=\"https://github.com/btcsuite/btcd/blob/de4182589bfe0d1e2a6b45348ce283e7035b5d3d/btcec/btcec.go#L22-L24\">decred project</a>, as I just stumbled upon that recently, but I don\u2019t know if it is up-to-date and how performant and well-written it is).</p>\n<blockquote>\n<p>One question: your approach relies on patching the existing clients which could be hurdle to usage. I had one idea to let the user configure proxy with peer1, peer2, peer3, etc and then listen on port 1 which proxies msgs to peer1, port 2 which proxies to peer 2 and so on. In that way the bitcoin software (for example btcd or anything really) can configure localhost:port1 and localhost:port2 as peers and then proxy will send bip324 msgs to peer1 and peer2. No patching of software. One downside is that peer discovery would need to move to proxy or peer config is static but it could work with dns-seed to discover peers on the fly.</p>\n</blockquote>\n<p>Interesting idea, haven\u2019t thought about doing static configuration yet. Not needing to patch the light client is a plus of course, but I imagine this approach also could have some problems:</p>\n<ul>\n<li>do light clients allow to add multiple peers with the same IP address (even if the port is different)? Note that the proposed light client patches change the destination address at a low socket level, so the higher-layer logic of the client doesn\u2019t even notice that there is a proxy in-between. If there are checks in the code that e.g. don\u2019t allow to add local addresses or multiple addresses with the same IP, that could be a problem.</li>\n<li>how would a user know which remote peers to configure? Every light client might have slightly different requirements for peers in terms of required services, so discovering peers that fit the used client could be non-trivial.</li>\n</ul>\n<p>That said, I think it\u2019s worth it to try it out and experiment with that idea.</p>",
  "post_number": 15,
  "post_type": 1,
  "updated_at": "2024-06-03T18:01:35.559Z",
  "reply_count": 1,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 5,
  "readers_count": 4,
  "score": 6.0,
  "yours": false,
  "topic_id": 678,
  "topic_slug": "bip324-proxy-easy-integration-of-v2-transport-protocol-for-light-clients-poc",
  "topic_title": "BIP324 Proxy: easy integration of v2 transport protocol for light clients (PoC)",
  "topic_html_title": "BIP324 Proxy: easy integration of v2 transport protocol for light clients (PoC)",
  "category_id": 8,
  "display_username": "Sebastian Falbesoner",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "@Liz.Lightning \n> @theStack thank you for sharing your bip324 proxy work, looks very interesting. I started coding a Golang version and your repo has been very helpful, I hope to share the first version soon and also make available the bip324 implementation as a library.\n\nNice, glad to hear that the idea is picked up and looking forward to see an implementation of bip324-proxy in another language soon! I'm curious how advanced the golang ecosystem is w.r.t. the needed cryptographic primitives (e.g., are there even proper secp256k1 bindings available for doing the EllSwift pubkey encoding? I'm aware that btcd uses a custom secp256k1 library from the [decred project](https://github.com/btcsuite/btcd/blob/de4182589bfe0d1e2a6b45348ce283e7035b5d3d/btcec/btcec.go#L22-L24), as I just stumbled upon that recently, but I don't know if it is up-to-date and how performant and well-written it is).\n\n> One question: your approach relies on patching the existing clients which could be hurdle to usage. I had one idea to let the user configure proxy with peer1, peer2, peer3, etc and then listen on port 1 which proxies msgs to peer1, port 2 which proxies to peer 2 and so on. In that way the bitcoin software (for example btcd or anything really) can configure localhost:port1 and localhost:port2 as peers and then proxy will send bip324 msgs to peer1 and peer2. No patching of software. One downside is that peer discovery would need to move to proxy or peer config is static but it could work with dns-seed to discover peers on the fly.\n\nInteresting idea, haven't thought about doing static configuration yet. Not needing to patch the light client is a plus of course, but I imagine this approach also could have some problems:\n* do light clients allow to add multiple peers with the same IP address (even if the port is different)? Note that the proposed light client patches change the destination address at a low socket level, so the higher-layer logic of the client doesn't even notice that there is a proxy in-between. If there are checks in the code that e.g. don't allow to add local addresses or multiple addresses with the same IP, that could be a problem.\n* how would a user know which remote peers to configure? Every light client might have slightly different requirements for peers in terms of required services, so discovering peers that fit the used client could be non-trivial.\n\nThat said, I think it's worth it to try it out and experiment with that idea.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 346,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}