{
  "id": 2607,
  "name": "Liz",
  "username": "Liz.Lightning",
  "avatar_template": "/letter_avatar_proxy/v4/letter/l/c89c15/{size}.png",
  "created_at": "2024-06-03T04:55:43.903Z",
  "cooked": "<p><a class=\"mention\" href=\"/u/thestack\">@theStack</a> thank you for sharing your bip324 proxy work, looks very interesting. I started coding a Golang version and your repo has been very helpful, I hope to share the first version soon and also make available the bip324 implementation as a library.</p>\n<p>One question: your approach relies on patching the existing clients which could be hurdle to usage. I had one idea to let the user configure proxy with peer1, peer2, peer3, etc and then listen on port 1 which proxies msgs to peer1, port 2 which proxies to peer 2 and so on.\nIn that way the bitcoin software (for example btcd or anything really) can configure localhost:port1 and localhost:port2 as peers and then proxy will send bip324 msgs to peer1 and peer2. No patching of software. One downside is that peer discovery would need to move to proxy or peer config is static but it could work with dns-seed to discover peers on the fly.</p>\n<p>Proxy would work like this:</p>\n<pre><code class=\"lang-auto\">./bip324-proxy --peers=a.b.c.d:8333,e.f.g.h:8333,m.n.o.p:8333\nproxy to a.b.c.d:8333 listening on 127.0.0.1:38401\nproxy to e.f.g.h:8333 listening on 127.0.0.1:38402\n...\nProxy server listening on 127.0.0.1:38400\n</code></pre>\n<p>Maybe that makes it more usable? What do you think?</p>",
  "post_number": 14,
  "post_type": 1,
  "updated_at": "2024-06-03T04:55:43.903Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 8,
  "readers_count": 7,
  "score": 1.6,
  "yours": false,
  "topic_id": 678,
  "topic_slug": "bip324-proxy-easy-integration-of-v2-transport-protocol-for-light-clients-poc",
  "topic_title": "BIP324 Proxy: easy integration of v2 transport protocol for light clients (PoC)",
  "topic_html_title": "BIP324 Proxy: easy integration of v2 transport protocol for light clients (PoC)",
  "category_id": 8,
  "display_username": "Liz",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "@theStack thank you for sharing your bip324 proxy work, looks very interesting. I started coding a Golang version and your repo has been very helpful, I hope to share the first version soon and also make available the bip324 implementation as a library.\n\nOne question: your approach relies on patching the existing clients which could be hurdle to usage. I had one idea to let the user configure proxy with peer1, peer2, peer3, etc and then listen on port 1 which proxies msgs to peer1, port 2 which proxies to peer 2 and so on.\nIn that way the bitcoin software (for example btcd or anything really) can configure localhost:port1 and localhost:port2 as peers and then proxy will send bip324 msgs to peer1 and peer2. No patching of software. One downside is that peer discovery would need to move to proxy or peer config is static but it could work with dns-seed to discover peers on the fly.\n\nProxy would work like this:\n```\n./bip324-proxy --peers=a.b.c.d:8333,e.f.g.h:8333,m.n.o.p:8333\nproxy to a.b.c.d:8333 listening on 127.0.0.1:38401\nproxy to e.f.g.h:8333 listening on 127.0.0.1:38402\n...\nProxy server listening on 127.0.0.1:38400\n```\nMaybe that makes it more usable? What do you think?",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 258,
  "hidden": false,
  "trust_level": 0,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}