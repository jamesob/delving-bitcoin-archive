{
  "id": 2778,
  "name": "josie",
  "username": "josibake",
  "avatar_template": "/user_avatar/delvingbitcoin.org/josibake/{size}/83_2.png",
  "created_at": "2024-06-21T14:07:17.974Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"andrewtoth\" data-post=\"26\" data-topic=\"877\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/andrewtoth/48/576_2.png\" class=\"avatar\"> andrewtoth:</div>\n<blockquote>\n<p>I think I see the confusion. What I meant was the silent payment aware signers must check for any <code>ACP</code> on any inputs <em>they will sign for</em> and fail if there are any silent payment outputs</p>\n</blockquote>\n</aside>\n<p>Gotcha! I had read this as \u201cfail if <code>ACP</code> was used on outputs that are not your own.\u201d</p>\n<aside class=\"quote no-group\" data-username=\"andrewtoth\" data-post=\"26\" data-topic=\"877\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/andrewtoth/48/576_2.png\" class=\"avatar\"> andrewtoth:</div>\n<blockquote>\n<p>Actually, the signer should probably fail if there is any sighash flag other than <code>ALL</code> if there are any silent payment outputs</p>\n</blockquote>\n</aside>\n<p>I think \u201cIf a sighash type is provided, the signer must check that the sighash is acceptable. If unacceptable, they must fail\u201d is sufficient, perhaps with a footnote that explains what unacceptable is for a silent payments transaction?</p>\n<aside class=\"quote no-group\" data-username=\"andrewtoth\" data-post=\"26\" data-topic=\"877\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/andrewtoth/48/576_2.png\" class=\"avatar\"> andrewtoth:</div>\n<blockquote>\n<p>One other possibility that could simplify things. If a signer is able to sign for all inputs, they could add a global share and proof covering all inputs with the key data being the scan key. If a signer is unable to sign for all inputs, then they add a per input share and proof covering only that input</p>\n</blockquote>\n</aside>\n<p>In the case of multiple signers where each signer has multiple inputs, this would require the signer to compute the ECDH shares individually (vs summing up the private keys and then doing the ECDH step. If we imagine something like a coinjoin, this could recreate the problem of \u201cI have 10 inputs, so now I need to do ~30 ECC mults.\u201d Another alternative would be:</p>\n<ul>\n<li>Global proof is the signer owns all inputs</li>\n<li>Proof per group of inputs (proof is duplicated on each input)</li>\n</ul>\n<p>In the case where each signer owns their own input, this would be the same as <a class=\"mention\" href=\"/u/achow101\">@achow101</a> 's proposal. This does add more data to the PSBT in the form of duplicate proofs in the case of multiple signers signing for multiple inputs, but that seems better to me than requiring the signers to do more CPU intensive work. That being said, I\u2019m not sure which is better. If a signer has low compute power, doing 30 ECC mults can be annoying. On the flipside, if the signer has low memory and we want to require a signer to verify proofs on each input before signing, the inline proofs for each input seems better.</p>",
  "post_number": 27,
  "post_type": 1,
  "updated_at": "2024-06-21T14:07:17.974Z",
  "reply_count": 0,
  "reply_to_post_number": 26,
  "quote_count": 1,
  "incoming_link_count": 0,
  "reads": 8,
  "readers_count": 7,
  "score": 1.6,
  "yours": false,
  "topic_id": 877,
  "topic_slug": "bip352-psbt-support",
  "topic_title": "BIP352: PSBT support",
  "topic_html_title": "BIP352: PSBT support",
  "category_id": 12,
  "display_username": "josie",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"andrewtoth, post:26, topic:877\"]\nI think I see the confusion. What I meant was the silent payment aware signers must check for any `ACP` on any inputs *they will sign for* and fail if there are any silent payment outputs\n[/quote]\n\nGotcha! I had read this as \"fail if `ACP` was used on outputs that are not your own.\"\n\n[quote=\"andrewtoth, post:26, topic:877\"]\nActually, the signer should probably fail if there is any sighash flag other than `ALL` if there are any silent payment outputs\n[/quote]\n\nI think \"If a sighash type is provided, the signer must check that the sighash is acceptable. If unacceptable, they must fail\" is sufficient, perhaps with a footnote that explains what unacceptable is for a silent payments transaction?\n\n[quote=\"andrewtoth, post:26, topic:877\"]\nOne other possibility that could simplify things. If a signer is able to sign for all inputs, they could add a global share and proof covering all inputs with the key data being the scan key. If a signer is unable to sign for all inputs, then they add a per input share and proof covering only that input\n[/quote]\n\nIn the case of multiple signers where each signer has multiple inputs, this would require the signer to compute the ECDH shares individually (vs summing up the private keys and then doing the ECDH step. If we imagine something like a coinjoin, this could recreate the problem of \"I have 10 inputs, so now I need to do ~30 ECC mults.\" Another alternative would be:\n\n* Global proof is the signer owns all inputs\n* Proof per group of inputs (proof is duplicated on each input)\n\nIn the case where each signer owns their own input, this would be the same as @achow101 's proposal. This does add more data to the PSBT in the form of duplicate proofs in the case of multiple signers signing for multiple inputs, but that seems better to me than requiring the signers to do more CPU intensive work. That being said, I'm not sure which is better. If a signer has low compute power, doing 30 ECC mults can be annoying. On the flipside, if the signer has low memory and we want to require a signer to verify proofs on each input before signing, the inline proofs for each input seems better.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 92,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}