{
  "id": 3507,
  "name": "ZmnSCPxj jxPCSnmZ",
  "username": "ZmnSCPxj",
  "avatar_template": "/letter_avatar_proxy/v4/letter/z/ee7513/{size}.png",
  "created_at": "2024-11-11T16:24:40.356Z",
  "cooked": "<p>As proposed in my SuperScalar document, I want to create an extension supported by common node software for \u201cpluggable channel factories\u201d.</p>\n<h1><a name=\"p-3507-introduction-1\" class=\"anchor\" href=\"#p-3507-introduction-1\"></a>Introduction</h1>\n<p>Several existing Lightning Network node software (CLN, LDK, Eclair, LND) have some concept of \u201cplugin\u201d or \u201cextension\u201d that allows users of the software to extend the base node software in various ways.</p>\n<p>Now, channel factories allow channels to be hosted in constructions that are themselves offchain, including my SuperScalar proposal.  In most such designs, the channels in a multiparty channel factory would look just like the current BOLT-specified blockchain-backed channels.  Thus, the existing code for managing channel state and forwarding payments would still work with channels inside channel factories.  However, the channels themselves would be effectively \u201c0-conf\u201d as far as the existing software would know about it; that is, the funding transaction \u2014 the transaction that directly instantiates the channel \u2014 would be unconfirmed, or in other words, kept offchain.</p>\n<p>Thus, I propose that we create a general protocol for pluggable channel factories, where the base BOLT-talking node software agree that some 0-conf channel is actually hosted by a channel factory under some instance of some channel factory protocol.  For most operations in BOLT2, the channel software will work without modification, only treating the channel as 0-conf.</p>\n<p>My concrete proposal is to include new TLVs for <code>open_channel</code> (i.,e. the openv1 flow) that indicate that a new channel is actually hosted in a channel factory, and requiring that the base node software be connected to a channel factory plugin (<em><strong>how</strong></em> is unspecified, only that it is somehow plugged in; it could be a built-in supported channel factory, for instance) of a specific channel factory protocol.  Then, when events becomes necessary, the channel factory plugin can be contacted by the base software to e.g. unilaterally close due to an impending HTLC timeout.</p>\n<h1><a name=\"p-3507-establishing-channels-inside-channel-factory-2\" class=\"anchor\" href=\"#p-3507-establishing-channels-inside-channel-factory-2\"></a>Establishing Channels Inside Channel Factory</h1>\n<p>A channel can be established with a new <code>channel_factory</code> even TLV for <code>open_channel</code>. The TLV indicates:</p>\n<ol>\n<li>A protocol identifier.  This differentiates e.g. SuperScalar from other novel channel-hosting protocols.</li>\n<li>An instance-of-the-protocol identifier. This differentiates one instance of SuperScalar from another instance,</li>\n<li>A number-of-blocks-early count.</li>\n</ol>\n<ul>\n<li>Normally, if an HTLC timelock will expire \u201csoon\u201d, the base node software will unilaterally clsoe the channel.</li>\n<li>However, some factory protocols may require relative timelocks along the path to an actual channel.  This means that the channel factory plugin would need to initiate unilateral exit <em><strong>earlier</strong></em> than normal.</li>\n<li>So, in case of an HTLC timelock, this number-of-blocks-early count would impose a minimum timelock allowed, and when the base software needs to signal the channel factory plugin to begin unilateral exit in time to enforce the HTLC.</li>\n<li>This needs to be established between the base software nodes, as this imposes a shared minimum timelock allowed between them.</li>\n</ul>\n<p>If the open is accepted and the initial commitment signing is completed, the channel factory plugins can continue with the establishment of the channel factory (or if the establishment fails (i.e. a potential participant goes offline before it can give necessary signatures) the hosted channels can be cancelled with an <code>error</code>).  The <code>channel_ready</code> messages would have to be deferred until the plugin actually indicates completion of the factory establishment.</p>\n<h1><a name=\"p-3507-riding-channel-factories-off-splicing-code-3\" class=\"anchor\" href=\"#p-3507-riding-channel-factories-off-splicing-code-3\"></a>Riding Channel Factories Off Splicing Code</h1>\n<p>An important fact of channel factories is that as the channel factory state changes, the funding transaction for channels changes.  Thus, a piece of code that handles channel state and forwarding across channels would need to be able to adapt to changes in state.  And because the factory will have more than 2 parties, there is a chance that a change in factory state does not complete due to a lack of full consensus among all parties (i.e. a participant goes offline just before it can send a signature for the new channel factory state).  Thus, when moving between old channel  factory state to new channel factory state, the code that handles channel states needs to handle multiple possible channel funding outpoints simultaneously, at least until the factory protocol has established whether to move to the new state or revert to the current state.</p>\n<p>So in summary, in order to support channel factories of any kind, the code that handles channel state:</p>\n<ol>\n<li>Needs to be able to change the funding outpoint of the channel.</li>\n<li>Needs to be able to have multiple funding outpoints of the channel as \u201cvalid\u201d simultaneously, until the channel factory can resolve which one is \u201creal\u201d.</li>\n</ol>\n<p>As it happens, splicing <em><strong>has the same problems</strong></em>:</p>\n<ol>\n<li>After splicing, the funding outpoint of the channel changes.</li>\n<li>Until the splicing transaction confirms, the channel may be unilaterally closed using the old funding outpoint or the post-splicing funding outpoint, until the blockchain is able to resolve which one is \u201creal\u201d.</li>\n</ol>\n<p>Thus, I propose to reuse parts of the channel splicing process for channel factory state changes:</p>\n<ol>\n<li>Quiesce the channel first (<code>stfu</code>)</li>\n<li>Message that says \u201cthe factory protocol software plugin connected to me said we should go to this new funding outpoint X\u201d and a reply that agrees.</li>\n</ol>\n<ul>\n<li>This ends the  quiescence state, just like in splicing when the participants have agreed on the new transaction inputs and outputs.</li>\n</ul>\n<ol start=\"6\">\n<li>In the meantime, use multiple <code>commitment_signed</code> messages with <code>batch</code> TLVs to sign for both the current factory state and the new factory state.</li>\n<li>Message that says \u201cthe factory prtocol software plugin connected to me said it was able to decide to use the old/new funding outpoint\u201d and a reply that agrees</li>\n</ol>\n<ul>\n<li>This ends the multi-<code>commitment_signed</code> state, just like in splicing when the splice transaction is confirmed or it becomes invalid due to an input being spent in an alternative way.</li>\n</ul>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2024-11-11T16:24:40.356Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 9,
  "reads": 8,
  "readers_count": 7,
  "score": 46.4,
  "yours": false,
  "topic_id": 1252,
  "topic_slug": "pluggable-channel-factories",
  "topic_title": "Pluggable Channel Factories",
  "topic_html_title": "Pluggable Channel Factories",
  "category_id": 7,
  "display_username": "ZmnSCPxj jxPCSnmZ",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "As proposed in my SuperScalar document, I want to create an extension supported by common node software for \"pluggable channel factories\".\n\nIntroduction\n=========\n\nSeveral existing Lightning Network node software (CLN, LDK, Eclair, LND) have some concept of \"plugin\" or \"extension\" that allows users of the software to extend the base node software in various ways.\n\nNow, channel factories allow channels to be hosted in constructions that are themselves offchain, including my SuperScalar proposal.  In most such designs, the channels in a multiparty channel factory would look just like the current BOLT-specified blockchain-backed channels.  Thus, the existing code for managing channel state and forwarding payments would still work with channels inside channel factories.  However, the channels themselves would be effectively \"0-conf\" as far as the existing software would know about it; that is, the funding transaction --- the transaction that directly instantiates the channel --- would be unconfirmed, or in other words, kept offchain.\n\nThus, I propose that we create a general protocol for pluggable channel factories, where the base BOLT-talking node software agree that some 0-conf channel is actually hosted by a channel factory under some instance of some channel factory protocol.  For most operations in BOLT2, the channel software will work without modification, only treating the channel as 0-conf.\n\nMy concrete proposal is to include new TLVs for `open_channel` (i.,e. the openv1 flow) that indicate that a new channel is actually hosted in a channel factory, and requiring that the base node software be connected to a channel factory plugin (***how*** is unspecified, only that it is somehow plugged in; it could be a built-in supported channel factory, for instance) of a specific channel factory protocol.  Then, when events becomes necessary, the channel factory plugin can be contacted by the base software to e.g. unilaterally close due to an impending HTLC timeout.\n\nEstablishing Channels Inside Channel Factory\n=====\n\nA channel can be established with a new `channel_factory` even TLV for `open_channel`. The TLV indicates:\n\n1. A protocol identifier.  This differentiates e.g. SuperScalar from other novel channel-hosting protocols.\n2. An instance-of-the-protocol identifier. This differentiates one instance of SuperScalar from another instance,\n3. A number-of-blocks-early count.\n  - Normally, if an HTLC timelock will expire \"soon\", the base node software will unilaterally clsoe the channel.\n  - However, some factory protocols may require relative timelocks along the path to an actual channel.  This means that the channel factory plugin would need to initiate unilateral exit ***earlier*** than normal.\n  - So, in case of an HTLC timelock, this number-of-blocks-early count would impose a minimum timelock allowed, and when the base software needs to signal the channel factory plugin to begin unilateral exit in time to enforce the HTLC.\n  - This needs to be established between the base software nodes, as this imposes a shared minimum timelock allowed between them.\n\nIf the open is accepted and the initial commitment signing is completed, the channel factory plugins can continue with the establishment of the channel factory (or if the establishment fails (i.e. a potential participant goes offline before it can give necessary signatures) the hosted channels can be cancelled with an `error`).  The `channel_ready` messages would have to be deferred until the plugin actually indicates completion of the factory establishment.\n\nRiding Channel Factories Off Splicing Code\n=====\n\nAn important fact of channel factories is that as the channel factory state changes, the funding transaction for channels changes.  Thus, a piece of code that handles channel state and forwarding across channels would need to be able to adapt to changes in state.  And because the factory will have more than 2 parties, there is a chance that a change in factory state does not complete due to a lack of full consensus among all parties (i.e. a participant goes offline just before it can send a signature for the new channel factory state).  Thus, when moving between old channel  factory state to new channel factory state, the code that handles channel states needs to handle multiple possible channel funding outpoints simultaneously, at least until the factory protocol has established whether to move to the new state or revert to the current state.\n\nSo in summary, in order to support channel factories of any kind, the code that handles channel state:\n\n1.  Needs to be able to change the funding outpoint of the channel.\n5. Needs to be able to have multiple funding outpoints of the channel as \"valid\" simultaneously, until the channel factory can resolve which one is \"real\".\n\nAs it happens, splicing ***has the same problems***:\n\n1. After splicing, the funding outpoint of the channel changes.\n2. Until the splicing transaction confirms, the channel may be unilaterally closed using the old funding outpoint or the post-splicing funding outpoint, until the blockchain is able to resolve which one is \"real\".\n\nThus, I propose to reuse parts of the channel splicing process for channel factory state changes:\n\n1.  Quiesce the channel first (`stfu`)\n2. Message that says \"the factory protocol software plugin connected to me said we should go to this new funding outpoint X\" and a reply that agrees.\n  - This ends the  quiescence state, just like in splicing when the participants have agreed on the new transaction inputs and outputs.\n6. In the meantime, use multiple `commitment_signed` messages with `batch` TLVs to sign for both the current factory state and the new factory state.\n7. Message that says \"the factory prtocol software plugin connected to me said it was able to decide to use the old/new funding outpoint\" and a reply that agrees\n  - This ends the multi-`commitment_signed` state, just like in splicing when the splice transaction is confirmed or it becomes invalid due to an input being spent in an alternative way.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 104,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}