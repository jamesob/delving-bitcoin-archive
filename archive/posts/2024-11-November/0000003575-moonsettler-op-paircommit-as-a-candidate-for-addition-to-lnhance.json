{
  "id": 3575,
  "name": "moonsettler",
  "username": "moonsettler",
  "avatar_template": "/user_avatar/delvingbitcoin.org/moonsettler/{size}/38_2.png",
  "created_at": "2024-11-23T15:41:32.161Z",
  "cooked": "<p>To try to keep the <a href=\"https://gist.github.com/moonsettler/d7f1fb88e3e54ee7ecb6d69ff126433b\" rel=\"noopener nofollow ugc\">BIP</a> as short and to the point as possible, an in depth discussion of the design rationale especially regarding alternatives was omitted. I\u2019m posting these here, so that they are available for those interested.</p>\n<h2><a name=\"p-3575-background-1\" class=\"anchor\" href=\"#p-3575-background-1\"></a>Background</h2>\n<p>LNhance at it\u2019s core is <code>CTV</code> + <code>CSFS</code> with the primary intent of not only enabling more scalable less interactive timeout tree and covenant pool constructions, but also to enable LN-Symmetry (formerly known as eltoo). <code>IKEY</code> was added to access the internal public key from the control block (which would be a 2-of-2 MuSig key in case of a lightning channel allowing for cooperative closes on the taproot keypath) making the contract more efficient.</p>\n<p>As I recall, later on <a class=\"mention\" href=\"/u/instagibbs\">@instagibbs</a> discovered in an attempt to implement Symmetry, that one of the main benefits of not having to keep all backups is lost when the channel peer can not reconstruct the script that spends an intermediate state pushed on chain. While most pieces are deterministic, the specific distribution of funds for that particular state is not. We call this the \u201cdata availability problem\u201d of LN-Symmetry. For APO the alternative solution discussed was to use the taproot annex.</p>\n<h2><a name=\"p-3575-rationale-2\" class=\"anchor\" href=\"#p-3575-rationale-2\"></a>Rationale</h2>\n<p>If <code>OP_CAT</code> was available, it could be used to combine multiple stack elements,\nthat get verified with <code>OP_CHECKSIGFROMSTACK</code> as a valid state update.</p>\n<p><code>OP_PAIRCOMMIT</code> solves this specific problem without introducing a wide range\nof potentially controversial new behaviors, such as novel 2-way peg mechanisms.</p>\n<h3><a name=\"p-3575-alternatives-discussed-3\" class=\"anchor\" href=\"#p-3575-alternatives-discussed-3\"></a>Alternatives discussed</h3>\n<h4><a name=\"p-3575-op_cat-4\" class=\"anchor\" href=\"#p-3575-op_cat-4\"></a>OP_CAT</h4>\n<p><code>OP_CAT</code> allows for fine grained introspection possibly bigint operations and\nextending the arithmetic capabilities of bitcoin script using lookup tables.</p>\n<h4><a name=\"p-3575-sha256-streaming-opcodes-5\" class=\"anchor\" href=\"#p-3575-sha256-streaming-opcodes-5\"></a>SHA256 streaming opcodes</h4>\n<p>These would predictably allow for the same functionality as <code>OP_CAT</code> for\nintrospection purposes, since verification of a computation is largely\nequivalent with carrying it out. Bigint and new arithmetic operations would\nbe hard or even impossible.</p>\n<p>Naively implemented they relax the script limitations on what is possible both the limitation of stack element size that can get hashed with CAT only and without CAT it allows for custom construction of \u2018sighashes\u2019 like CTV templates or with CSFS pretty much everything CAT enables in terms of introspection.</p>\n<h4><a name=\"p-3575-merkle-operation-opcodes-6\" class=\"anchor\" href=\"#p-3575-merkle-operation-opcodes-6\"></a>Merkle operation opcodes</h4>\n<p>These would be of very limited general use and hard to rationalize without OP_CAT. Their complexity and resource cost is hard to justified for vector\ncommitments only.</p>\n<h4><a name=\"p-3575-kitty-cat-result-or-inputs-limited-in-size-7\" class=\"anchor\" href=\"#p-3575-kitty-cat-result-or-inputs-limited-in-size-7\"></a>\u2018Kitty\u2019 CAT (result or inputs limited in size)</h4>\n<p>The original idea would have limited the maximum size of <code>OP_CAT</code> output to a\nsize that is smaller than the smallest sighash preimage, thus disabling the\nintrospection capabilities and trivial ways to extend the arithmetic repertoire\nof bitcoin script. This turned out to be an awkward, arbitrary and offering\nweak .</p>\n<h4><a name=\"p-3575-op_checktemplateverify-committing-to-the-taproot-annex-in-tapscript-8\" class=\"anchor\" href=\"#p-3575-op_checktemplateverify-committing-to-the-taproot-annex-in-tapscript-8\"></a>OP_CHECKTEMPLATEVERIFY committing to the taproot annex in tapscript</h4>\n<p>A CTV template can be considered a sighash, however relaxing the relay policy\nto take advantage of this change would make various endogenous asset protocols\nmore efficient, and therefore be controversial. There is also no consensus on\nhow to use or how to structure the annex.</p>\n<h4><a name=\"p-3575-op_checksigfromstack-on-n-elements-as-message-9\" class=\"anchor\" href=\"#p-3575-op_checksigfromstack-on-n-elements-as-message-9\"></a>OP_CHECKSIGFROMSTACK on n elements as message</h4>\n<p>This was previously discussed and also implemented, it complicates the code\nand is a pretty arbitrary coupling of behaviors.</p>\n<h4><a name=\"p-3575-op_vectorcommit-10\" class=\"anchor\" href=\"#p-3575-op_vectorcommit-10\"></a>OP_VECTORCOMMIT</h4>\n<p>The obvious generalized solution for committing to n &gt; 2 stack elements, however\nit involves looping and hard to argue about setting the proper limits to it. It could be forked in later with for example <code>OP_CHECKCONTRACTVERIFY</code>.</p>\n<p>It\u2019s impossible to predict what would be more optimal for the user a) leave the items on the stack and only consume the number of items, or b) consume the items from the stack.</p>\n<p>We could probably do <code>&lt;vch1&gt; .. &lt;vchn&gt; &lt;n&gt; VECTORCOMMIT</code> where n as a signed char can be <code>2..127</code> or <code>-2..-127</code>, and if it\u2019s positive the stack elements are left on stack, if negative they are consumed.</p>\n<h3><a name=\"p-3575-possible-future-improvements-11\" class=\"anchor\" href=\"#p-3575-possible-future-improvements-11\"></a>Possible future improvements</h3>\n<p>LNhance + <code>OP_CHECKCONTRACTVERIFY</code> (aka <code>CCV</code> the centerpiece of MATT by <a class=\"mention\" href=\"/u/salvatoshi\">@salvatoshi</a>) or <code>OP_VAULT/RECOVER</code> (aka BIP-345 by <a class=\"mention\" href=\"/u/jamesob\">@jamesob</a>) would enable good vaults with flexible amount withdrawal and immediate re-vault of change. The both assume <code>OP_CHECKTEMPLATEVERIFY</code> as an available building block, and <code>OP_CHECKCONTRACTVERIFY</code> especially benefits from <code>OP_PAIRCOMMIT</code> as a means to carry multiple stack elements.</p>",
  "post_number": 13,
  "post_type": 1,
  "updated_at": "2024-11-23T15:47:36.827Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 1,
  "reads": 6,
  "readers_count": 5,
  "score": 6.2,
  "yours": false,
  "topic_id": 1216,
  "topic_slug": "op-paircommit-as-a-candidate-for-addition-to-lnhance",
  "topic_title": "OP_PAIRCOMMIT as a candidate for addition to LNhance",
  "topic_html_title": "OP_PAIRCOMMIT as a candidate for addition to LNhance",
  "category_id": 7,
  "display_username": "moonsettler",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "To try to keep the [BIP](https://gist.github.com/moonsettler/d7f1fb88e3e54ee7ecb6d69ff126433b) as short and to the point as possible, an in depth discussion of the design rationale especially regarding alternatives was omitted. I'm posting these here, so that they are available for those interested.\n\n## Background\n\nLNhance at it's core is `CTV` + `CSFS` with the primary intent of not only enabling more scalable less interactive timeout tree and covenant pool constructions, but also to enable LN-Symmetry (formerly known as eltoo). `IKEY` was added to access the internal public key from the control block (which would be a 2-of-2 MuSig key in case of a lightning channel allowing for cooperative closes on the taproot keypath) making the contract more efficient.\n\nAs I recall, later on @instagibbs discovered in an attempt to implement Symmetry, that one of the main benefits of not having to keep all backups is lost when the channel peer can not reconstruct the script that spends an intermediate state pushed on chain. While most pieces are deterministic, the specific distribution of funds for that particular state is not. We call this the \"data availability problem\" of LN-Symmetry. For APO the alternative solution discussed was to use the taproot annex.\n\n## Rationale\n\nIf `OP_CAT` was available, it could be used to combine multiple stack elements,\nthat get verified with `OP_CHECKSIGFROMSTACK` as a valid state update.\n\n`OP_PAIRCOMMIT` solves this specific problem without introducing a wide range\nof potentially controversial new behaviors, such as novel 2-way peg mechanisms.\n\n### Alternatives discussed\n\n#### OP_CAT\n\n`OP_CAT` allows for fine grained introspection possibly bigint operations and\nextending the arithmetic capabilities of bitcoin script using lookup tables.\n\n#### SHA256 streaming opcodes\n\nThese would predictably allow for the same functionality as `OP_CAT` for\nintrospection purposes, since verification of a computation is largely\nequivalent with carrying it out. Bigint and new arithmetic operations would\nbe hard or even impossible.\n\nNaively implemented they relax the script limitations on what is possible both the limitation of stack element size that can get hashed with CAT only and without CAT it allows for custom construction of 'sighashes' like CTV templates or with CSFS pretty much everything CAT enables in terms of introspection.\n\n#### Merkle operation opcodes\n\nThese would be of very limited general use and hard to rationalize without OP_CAT. Their complexity and resource cost is hard to justified for vector\ncommitments only.\n\n#### 'Kitty' CAT (result or inputs limited in size)\n\nThe original idea would have limited the maximum size of `OP_CAT` output to a\nsize that is smaller than the smallest sighash preimage, thus disabling the\nintrospection capabilities and trivial ways to extend the arithmetic repertoire\nof bitcoin script. This turned out to be an awkward, arbitrary and offering\nweak .\n\n#### OP_CHECKTEMPLATEVERIFY committing to the taproot annex in tapscript\n\nA CTV template can be considered a sighash, however relaxing the relay policy\nto take advantage of this change would make various endogenous asset protocols\nmore efficient, and therefore be controversial. There is also no consensus on\nhow to use or how to structure the annex.\n\n#### OP_CHECKSIGFROMSTACK on n elements as message\n\nThis was previously discussed and also implemented, it complicates the code\nand is a pretty arbitrary coupling of behaviors.\n\n#### OP_VECTORCOMMIT\n\nThe obvious generalized solution for committing to n > 2 stack elements, however\nit involves looping and hard to argue about setting the proper limits to it. It could be forked in later with for example `OP_CHECKCONTRACTVERIFY`.\n\nIt's impossible to predict what would be more optimal for the user a) leave the items on the stack and only consume the number of items, or b) consume the items from the stack.\n\nWe could probably do `<vch1> .. <vchn> <n> VECTORCOMMIT` where n as a signed char can be `2..127` or `-2..-127`, and if it's positive the stack elements are left on stack, if negative they are consumed.\n\n### Possible future improvements\n\nLNhance + `OP_CHECKCONTRACTVERIFY` (aka `CCV` the centerpiece of MATT by @salvatoshi) or `OP_VAULT/RECOVER` (aka BIP-345 by @jamesob) would enable good vaults with flexible amount withdrawal and immediate re-vault of change. The both assume `OP_CHECKTEMPLATEVERIFY` as an available building block, and `OP_CHECKCONTRACTVERIFY` especially benefits from `OP_PAIRCOMMIT` as a means to carry multiple stack elements.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 48,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}