{
  "id": 3654,
  "name": "sCrypt",
  "username": "sCrypt-ts",
  "avatar_template": "/user_avatar/delvingbitcoin.org/scrypt-ts/{size}/746_2.png",
  "created_at": "2024-11-30T09:29:54.742Z",
  "cooked": "<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/1X/6237184880cae03e6432132350e41e4410af8e78.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/6237184880cae03e6432132350e41e4410af8e78\" title=\"Implementing a Bridge Covenant on OP_CAT-Enabled Bitcoin: A Proof of Concept\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/1X/6237184880cae03e6432132350e41e4410af8e78_2_690x388.png\" alt=\"Implementing a Bridge Covenant on OP_CAT-Enabled Bitcoin: A Proof of Concept\" data-base62-sha1=\"e0QPBjPFVfGUjhL6N6KKVE5yCXm\" width=\"690\" height=\"388\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/1X/6237184880cae03e6432132350e41e4410af8e78_2_690x388.png, https://delvingbitcoin.org/uploads/default/optimized/1X/6237184880cae03e6432132350e41e4410af8e78_2_1035x582.png 1.5x, https://delvingbitcoin.org/uploads/default/optimized/1X/6237184880cae03e6432132350e41e4410af8e78_2_1380x776.png 2x\" data-dominant-color=\"3F315E\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">Implementing a Bridge Covenant on OP_CAT-Enabled Bitcoin: A Proof of Concept</span><span class=\"informations\">1456\u00d7819 157 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<h1><a name=\"p-3654-implementing-a-bridge-covenant-on-op_cat-enabled-bitcoin-a-proof-of-concept-1\" class=\"anchor\" href=\"#p-3654-implementing-a-bridge-covenant-on-op_cat-enabled-bitcoin-a-proof-of-concept-1\"></a>Implementing a Bridge Covenant on OP_CAT-Enabled Bitcoin: A Proof of Concept</h1>\n<p>In this article, we explore how <strong>sCrypt</strong>, in collaboration with <strong>StarkWare</strong>, has developed a demo bridge covenant on Bitcoin. This proof-of-concept implementation is designed to serve as a foundational framework for a production-grade bridge connecting the Bitcoin blockchain to the Starknet Layer 2 (L2) network.</p>\n<p>The bridge introduces a sophisticated mechanism for handling multiple deposit and withdrawal requests. It allows for the batching of these transactions into a single root transaction. This transaction is then integrated into the main bridge covenant, updating its state seamlessly. The state is maintained as a set of accounts, organized within a secure and efficient Merkle tree structure.</p>\n<p>Given the inherent complexity of the bridge\u2019s covenant scripts, sCrypt has employed its advanced domain-specific language (DSL) to construct the implementation.</p>\n<h2><a name=\"p-3654-overview-2\" class=\"anchor\" href=\"#p-3654-overview-2\"></a>Overview</h2>\n<p>The bridge consists of a recursive covenant Bitcoin script. Here, \u201ccovenant\u201d means that the locking script is capable of enforcing conditions on the spending transaction, and \u201crecursive\u201d means that the rules above are sufficiently powerful to enable persistent logic and state onchain (a requirement for any onchain smart contract).</p>\n<p>This script exists in a chain of transactions, each enforcing the structure of the subsequent transaction that unlocks an output from the current one. Each time a new transaction is added to this chain, it represents an update of the bridge\u2019s state. Hence, the tip of this chain holds the current bridge state.</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/1X/d6bc91b6826c36e4bb7e872480fea16317b03d22.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/d6bc91b6826c36e4bb7e872480fea16317b03d22\" title=\"\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/1X/d6bc91b6826c36e4bb7e872480fea16317b03d22_2_690x135.png\" alt=\"\" data-base62-sha1=\"uDEby9EyIOU9BwGDec8IxuSVgEq\" width=\"690\" height=\"135\" role=\"presentation\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/1X/d6bc91b6826c36e4bb7e872480fea16317b03d22_2_690x135.png, https://delvingbitcoin.org/uploads/default/original/1X/d6bc91b6826c36e4bb7e872480fea16317b03d22.png 1.5x, https://delvingbitcoin.org/uploads/default/original/1X/d6bc91b6826c36e4bb7e872480fea16317b03d22.png 2x\" data-dominant-color=\"E4EDE1\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\"></span><span class=\"informations\">1024\u00d7201 16.5 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>The covenant\u2019s state\u2014specifically, its hash\u2014is stored in an unspendable OP_RETURN output. While we\u2019re not spending this UTXO, its data can be inspected while executing a covenant script. More concretely, the state holds the root hash of the Merkle tree containing account data, as follows:</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/1X/cb21f3a3428cb6291d1c4399999f9f45041296ac.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/cb21f3a3428cb6291d1c4399999f9f45041296ac\" title=\"\"><img src=\"https://delvingbitcoin.org/uploads/default/original/1X/cb21f3a3428cb6291d1c4399999f9f45041296ac.png\" alt=\"\" data-base62-sha1=\"sYZFoEAGZLdRXEfCuJzIqdSlzeA\" width=\"666\" height=\"500\" role=\"presentation\" data-dominant-color=\"F7F8F7\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\"></span><span class=\"informations\">733\u00d7550 8.51 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>The tree holds data about a fixed set of account slots. The leaves contain the hash of the respective account data, which consists of an address and a balance. To signify empty account slots, they are marked with zero bytes.</p>\n<p>Each update of the bridge results in a change to the accounts tree. To facilitate such an update, we rely upon Merkle proofs, the verification of which is efficient within Bitcoin script. An update essentially consists of two steps. First, we verify a Merkle proof that proves the inclusion of a particular account\u2019s current state. Then, after calculating the new state of this account, we use the same auxiliary nodes from the aforementioned Merkle proof to derive the new root hash.</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/1X/7a313fd1fa188d52b43106cc681c534ec3c876b9.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/7a313fd1fa188d52b43106cc681c534ec3c876b9\" title=\"\"><img src=\"https://delvingbitcoin.org/uploads/default/original/1X/7a313fd1fa188d52b43106cc681c534ec3c876b9.png\" alt=\"\" data-base62-sha1=\"hqXLAnxYcxGU7XqYjvE4Ek3wL9v\" width=\"690\" height=\"429\" role=\"presentation\" data-dominant-color=\"F8F6F7\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\"></span><span class=\"informations\">812\u00d7505 7.29 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>The update can be either a deposit or a withdrawal. The bridge can perform a batch of these updates within a single transaction.</p>\n<h2><a name=\"p-3654-deposits-3\" class=\"anchor\" href=\"#p-3654-deposits-3\"></a>Deposits</h2>\n<p>We aim to enable users to submit deposits or withdrawal requests independently. To achieve this, users create separate transactions that pay to a deposit or withdrawal aggregation covenant, respectively. This covenant aggregates a batch of these requests into a Merkle tree. The root of this tree can be merged into the main bridge covenant, which then processes each deposit or withdrawal.</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/1X/b8584fb584c355fb411f082ddab1aa3960af5d9a.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/b8584fb584c355fb411f082ddab1aa3960af5d9a\" title=\"\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/1X/b8584fb584c355fb411f082ddab1aa3960af5d9a_2_690x357.png\" alt=\"\" data-base62-sha1=\"qiN3LF58JXshTDXV0lNEgDw05GW\" width=\"690\" height=\"357\" role=\"presentation\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/1X/b8584fb584c355fb411f082ddab1aa3960af5d9a_2_690x357.png, https://delvingbitcoin.org/uploads/default/original/1X/b8584fb584c355fb411f082ddab1aa3960af5d9a.png 1.5x, https://delvingbitcoin.org/uploads/default/original/1X/b8584fb584c355fb411f082ddab1aa3960af5d9a.png 2x\" data-dominant-color=\"EEF4EC\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\"></span><span class=\"informations\">1024\u00d7531 50.8 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>In deposit transactions, besides hashing the deposit data and constructing a Merkle tree, the covenant also ensures that the deposited satoshis locked into the covenant\u2019s outputs accumulate correctly up to the tree\u2019s root. The aggregation covenant makes it so the funds are only spendable by the correct onchain smart contract. (Of course, in a production system, we will also enable a user to cancel her deposit transaction.)</p>\n<p>This kind of tree design results from a limitation of how covenant scripts are constructed, not allowing transactions with too many inputs and outputs. A tree structure allows us to scale to potentially arbitrary throughput.</p>\n<h2><a name=\"p-3654-withdrawal-requests-4\" class=\"anchor\" href=\"#p-3654-withdrawal-requests-4\"></a>Withdrawal Requests</h2>\n<p>The aggregation of withdrawal requests is similar but differs in a few ways. First, we need an authentication method for a user to withdraw funds from their account. This contrasts with deposits, where anyone is allowed to deposit into anyone\u2019s account, similar to Bitcoin addresses in general. Authentication is done at the leaf level of the aggregation tree. The withdrawal request aggregation covenant checks that the address being withdrawn from matches the P2WPKH address of the first input in the leaf transaction.</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/1X/f3d4d94e08eae449dc7ff3d515b46c6b283165f4.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/f3d4d94e08eae449dc7ff3d515b46c6b283165f4\" title=\"\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/1X/f3d4d94e08eae449dc7ff3d515b46c6b283165f4_2_690x311.png\" alt=\"\" data-base62-sha1=\"yN23dod2H8A3nLwR6k6Mr0T0hXS\" width=\"690\" height=\"311\" role=\"presentation\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/1X/f3d4d94e08eae449dc7ff3d515b46c6b283165f4_2_690x311.png, https://delvingbitcoin.org/uploads/default/original/1X/f3d4d94e08eae449dc7ff3d515b46c6b283165f4.png 1.5x, https://delvingbitcoin.org/uploads/default/original/1X/f3d4d94e08eae449dc7ff3d515b46c6b283165f4.png 2x\" data-dominant-color=\"EFF4EC\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\"></span><span class=\"informations\">1024\u00d7462 46.6 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>This ensures that the owner of the address approves the withdrawal since they signed the transaction requesting it. Another subtle difference compared to deposit aggregation is that we also hash intermediate sum amounts up the tree. This is done because we\u2019ll need this data when expanding the withdrawals, but more on that later.</p>\n<p>An astute reader might notice a potential problem with this model of authenticating withdrawal requests. What if the operator decides to cheat and creates a root transaction of an aggregation tree where the tree\u2019s data is fabricated locally with fake withdrawal requests that weren\u2019t authenticated? We need an efficient way to verify that this root transaction originates from valid leaf transactions.</p>\n<p>To address this, we perform what is called a \u201cgenesis check.\u201d Essentially, we make the aggregation covenant check its previous transaction and the transaction preceding that one \u2014 that is, its ancestor transactions. The covenant verifies that these transactions contain the same covenant script and perform the same checks. In this way, we achieve an inductive transaction history check. Because both of the previous transactions performed the same checks as this covenant does, we know that the ancestors of that transaction did the same, all the way back to the leaf (i.e., the genesis transaction).</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/1X/99395560d9ece2aee7fccce76fc65da6c7e20c44.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/99395560d9ece2aee7fccce76fc65da6c7e20c44\" title=\"\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/1X/99395560d9ece2aee7fccce76fc65da6c7e20c44_2_690x89.png\" alt=\"\" data-base62-sha1=\"lRtT947Qs2gDQ3M3qJwDgaymeCE\" width=\"690\" height=\"89\" role=\"presentation\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/1X/99395560d9ece2aee7fccce76fc65da6c7e20c44_2_690x89.png, https://delvingbitcoin.org/uploads/default/original/1X/99395560d9ece2aee7fccce76fc65da6c7e20c44.png 1.5x, https://delvingbitcoin.org/uploads/default/original/1X/99395560d9ece2aee7fccce76fc65da6c7e20c44.png 2x\" data-dominant-color=\"F7EDCD\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\"></span><span class=\"informations\">1024\u00d7133 20.3 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>Naturally, we perform this validation for both branches of the tree. So each aggregation node transaction checks up to six transactions in total.</p>\n<h2><a name=\"p-3654-expansion-of-withdrawals-5\" class=\"anchor\" href=\"#p-3654-expansion-of-withdrawals-5\"></a>Expansion of Withdrawals</h2>\n<p>Now let\u2019s move to the last part of our solution: the expansion of the withdrawals. Upon processing a batch of withdrawal requests, the main bridge covenant enforces an output that pays the total amount withdrawn to an expander covenant. We can think of this covenant as essentially performing the inverse of what the withdrawal request aggregation covenant did. It starts with the withdrawal tree\u2019s root and expands it into two branches, each containing the appropriate amount of withdrawn funds that should go to that branch. It continues this process all the way down to the withdrawal tree\u2019s leaves. The leaf transactions are enforced to have a simple payment output that pays the account owner\u2019s address the amount they requested to withdraw.</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/1X/0a9f0d4d08cc0183461a372bcfbaad7b85a93074.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/0a9f0d4d08cc0183461a372bcfbaad7b85a93074\" title=\"\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/1X/0a9f0d4d08cc0183461a372bcfbaad7b85a93074_2_690x270.png\" alt=\"\" data-base62-sha1=\"1vXxBfT56OfTywXmRNegQxHTFoE\" width=\"690\" height=\"270\" role=\"presentation\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/1X/0a9f0d4d08cc0183461a372bcfbaad7b85a93074_2_690x270.png, https://delvingbitcoin.org/uploads/default/original/1X/0a9f0d4d08cc0183461a372bcfbaad7b85a93074.png 1.5x, https://delvingbitcoin.org/uploads/default/original/1X/0a9f0d4d08cc0183461a372bcfbaad7b85a93074.png 2x\" data-dominant-color=\"F3F6EC\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\"></span><span class=\"informations\">1024\u00d7401 31.6 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<h2><a name=\"p-3654-implementation-6\" class=\"anchor\" href=\"#p-3654-implementation-6\"></a>Implementation</h2>\n<p>To bring our bridge covenant to life, we\u2019ve implemented four sCrypt smart contracts that handle different aspects of the system. In this section, we\u2019ll provide a high-level overview of each contract.</p>\n<h3><a name=\"p-3654-depositaggregator-contract-7\" class=\"anchor\" href=\"#p-3654-depositaggregator-contract-7\"></a>DepositAggregator Contract</h3>\n<p>The DepositAggregator contract aggregates individual deposits into a single Merkle tree, which can then be merged into the main bridge covenant. This aggregation allows for batch deposit processing, reducing the number of transactions that need to be individually processed by the bridge. Additionally, it allows users to independently submit deposits, which will be later picked up by an operator.</p>\n<pre><code class=\"lang-auto\">class DepositAggregator extends SmartContract {\n  @prop()\n  operator: PubKey\n\n  @prop()\n  bridgeSPK: ByteString\n  /**\n    * Covenant used for the aggregation of deposits.\n    *\n    * @param operator - Public key of bridge operator.\n    * @param bridgeSPK - P2TR script of the bridge state covenant. Includes length prefix!\n    */\n  constructor(operator: PubKey, bridgeSPK: ByteString) {\n      super(...arguments)\n      this.operator = operator\n      this.bridgeSPK = bridgeSPK\n  }\n  @method()\n  public aggregate(\n      shPreimage: SHPreimage,\n      isPrevTxLeaf: boolean,\n      sigOperator: Sig,\n      prevTx0: AggregatorTransaction,\n      prevTx1: AggregatorTransaction,\n      // Additional parameters...\n  ) {\n      // Validation steps...\n  }\n  @method()\n  public finalize(\n      shPreimage: SHPreimage,\n      sigOperator: Sig,\n      prevTx: AggregatorTransaction,\n      ancestorTx0: AggregatorTransaction,\n      ancestorTx1: AggregatorTransaction,\n      bridgeTxId: Sha256,\n      fundingPrevout: ByteString\n  ) {\n      // Finalization steps...\n  }\n}\n</code></pre>\n<p>The contract constructor takes in two parameters:</p>\n<ul>\n<li><em>operator</em> : The public key of the bridge operator who is authorized to aggregate deposits.</li>\n<li><em>bridgeSPK</em> : The script public key (SPK) of the main bridge covenant, ensuring that the aggregated deposits are merged correctly.</li>\n</ul>\n<p>The core functionality of the <em>DepositAggregator</em> is encapsulated in the <em>aggregate</em> method. This method performs the following steps:</p>\n<p><strong>Validation of Sighash Preimage and Operator Signature:</strong> Ensures the transaction is authorized by the bridge operator and that the sighash preimage is correctly formatted and belongs to the executing transaction. Read more about sighash preimage validation in <a href=\"https://medium.com/@scryptplatform/trustless-ordinal-sales-using-op-cat-enabled-covenants-on-bitcoin-0318052f02b2\" rel=\"noopener nofollow ugc\">this article</a>.</p>\n<pre><code class=\"lang-auto\">// Check sighash preimage.\nconst s = SigHashUtils.checkSHPreimage(shPreimage)\nassert(this.checkSig(s, SigHashUtils.Gx))\n\n// Check operator signature.\nassert(this.checkSig(sigOperator, this.operator))\n</code></pre>\n<p><strong>Construction and Verification of Previous Transaction IDs</strong> : Checks that the previous transactions aggregated are valid and correctly referenced.</p>\n<pre><code class=\"lang-auto\">// Construct previous transaction ID.\nconst prevTxId = AggregatorUtils.getTxId(prevTx, false)\n\n// Verify that the transaction unlocks the specified outputs.\nconst hashPrevouts = AggregatorUtils.getHashPrevouts(\n  bridgeTxId,\n  prevTxId,\n  fundingPrevout\n)\nassert(hashPrevouts == shPreimage.hashPrevouts)\n</code></pre>\n<p><strong>Merkle Tree Aggregation</strong> : This verifies that the deposit data passed as witness hashes match the state stored in the previous transactions.</p>\n<pre><code class=\"lang-auto\">const hashData0 = DepositAggregator.hashDepositData(depositData0)\nconst hashData1 = DepositAggregator.hashDepositData(depositData1)\n\nassert(hashData0 == prevTx0.hashData)\nassert(hashData1 == prevTx1.hashData)\n</code></pre>\n<p><strong>Amount Verification</strong> : Confirms that the amounts in the previous outputs match the specified deposit amounts, ensuring funds are correctly accounted for in the aggregation.</p>\n<pre><code class=\"lang-auto\">// Check that the prev outputs actually carry the specified amount\n// of satoshis. The amount values can also carry aggregated amounts,\n// in case we're not aggregating leaves anymore.\nassert(\n  GeneralUtils.padAmt(depositData0.amount) ==\n  prevTx0.outputContractAmt\n)\nassert(\n  GeneralUtils.padAmt(depositData1.amount) ==\n  prevTx1.outputContractAmt\n)\n</code></pre>\n<p><strong>State Update</strong> : Computes a new hash by concatenating the hashes of the previous transactions and updates the state in the OP_RETURN output.</p>\n<pre><code class=\"lang-auto\">// Concatinate hashes from previous aggregation txns (or leaves)\n// and compute new hash. Store this new hash in the state OP_RETURN\n// output.\nconst newHash = hash256(prevTx0.hashData + prevTx1.hashData)\nconst stateOut = GeneralUtils.getStateOutput(newHash)\n</code></pre>\n<p><strong>Re-entrance Prevention</strong> : Enforces strict output scripts and amounts to prevent unauthorized modifications or double-spending.</p>\n<pre><code class=\"lang-auto\">// Sum up aggregated amounts and construct contract output.\nconst contractOut = GeneralUtils.getContractOutput(\n  depositData0.amount + depositData1.amount,\n  prevTx0.outputContractSPK\n)\n\n// Recurse. Send to aggregator with updated hash.\nconst outputs = contractOut + stateOut\nassert(\n  sha256(outputs) == shPreimage.hashOutputs\n)\n</code></pre>\n<p>Once the deposits are aggregated, they must be merged into the main bridge covenant. This is handled by the <em>finalize</em> method, whose steps include:</p>\n<ul>\n<li><strong>Validation of Previous Transactions</strong> : Similar to the aggregate method, it verifies the previous transactions to ensure the integrity of the data being merged.</li>\n<li><strong>Integration with Bridge Covenant</strong> : Checks that the aggregated deposits are correctly merged into the main bridge covenant by referencing the bridge\u2019s transaction ID and script public key.</li>\n</ul>\n<p>The full source code of the deposit aggregation contract can be found <a href=\"https://github.com/Bitcoin-Wildlife-Sanctuary/scrypt-poc-bridge/blob/dad6aae8601d469d788fb1fa5d89ad233258d057/src/contracts/depositAggregator.ts\" rel=\"noopener nofollow ugc\">on GitHub</a>.</p>\n<h3><a name=\"p-3654-withdrawalaggregator-contract-8\" class=\"anchor\" href=\"#p-3654-withdrawalaggregator-contract-8\"></a>WithdrawalAggregator Contract</h3>\n<p>The <em>WithdrawalAggregator</em> contract is designed to aggregate individual withdrawal requests into a single Merkle tree, similar to how the <em>DepositAggregator</em> handles deposits. However, withdrawals require additional authentication to ensure that only the rightful owners can withdraw funds from their accounts.</p>\n<pre><code class=\"lang-auto\">class WithdrawalAggregator extends SmartContract {\n  @prop()\n  operator: PubKey\n\n  @prop()\n  bridgeSPK: ByteString\n\n  /**\n    * Covenant used for the aggregation of withdrawal requests.\n    *\n    * @param operator - Public key of bridge operator.\n    * @param bridgeSPK - P2TR script of the bridge state covenant. Includes length prefix!\n    */\n  constructor(operator: PubKey, bridgeSPK: ByteString) {\n      super(...arguments)\n      this.operator = operator\n      this.bridgeSPK = bridgeSPK\n  }\n\n  @method()\n  public aggregate(\n      shPreimage: SHPreimage,\n      isPrevTxLeaf: boolean,\n      sigOperator: Sig,\n      prevTx0: AggregatorTransaction,\n      prevTx1: AggregatorTransaction,\n      // Additional parameters...\n  ) {\n      // Validation and aggregation logic...\n  }\n\n  @method()\n  public finalize(\n      shPreimage: SHPreimage,\n      sigOperator: Sig,\n      prevTx: AggregatorTransaction,\n      ancestorTx0: AggregatorTransaction,\n      ancestorTx1: AggregatorTransaction,\n      bridgeTxId: Sha256,\n      fundingPrevout: ByteString\n  ) {\n      // Validation logic...\n  }\n}\n</code></pre>\n<p>The core functionality of the <em>WithdrawalAggregator</em> is encapsulated in the <em>aggregate</em> method, which performs the following steps:</p>\n<pre><code class=\"lang-auto\">// Check sighash preimage.\nconst s = SigHashUtils.checkSHPreimage(shPreimage)\nassert(this.checkSig(s, SigHashUtils.Gx))\n\n// Check operator signature.\nassert(this.checkSig(sigOperator, this.operator))\n</code></pre>\n<p><strong>Construction and Verification of Previous Transaction IDs</strong> : This process verifies that the previous transactions being aggregated are valid and correctly referenced.</p>\n<pre><code class=\"lang-auto\">// Construct previous transaction IDs.\nconst prevTxId0 = AggregatorUtils.getTxId(prevTx0, isPrevTxLeaf)\nconst prevTxId1 = AggregatorUtils.getTxId(prevTx1, isPrevTxLeaf)\n\n// Verify that the previous transactions are unlocked by the current transaction.\nconst hashPrevouts = AggregatorUtils.getHashPrevouts(\n  prevTxId0,\n  prevTxId1,\n  fundingPrevout\n)\nassert(hashPrevouts == shPreimage.hashPrevouts)\n</code></pre>\n<p><strong>Ownership Proof Verification</strong> : Verifying an ownership proof transaction ensures that only the rightful owner can withdraw funds from an account.</p>\n<ul>\n<li><strong>Ownership Proof Transaction</strong> : A transaction that proves control of the withdrawal address. The contract checks that the address in the withdrawal request matches the address in the ownership proof transaction.</li>\n</ul>\n<pre><code class=\"lang-auto\">if (isPrevTxLeaf) {\n  // Construct ownership proof transaction IDs.\n  const ownershipProofTxId0 = WithdrawalAggregator.getOwnershipProofTxId(ownProofTx0)\n  const ownershipProofTxId1 = WithdrawalAggregator.getOwnershipProofTxId(ownProofTx1)\n\n  // Check that the leaf transactions unlock the ownership proof transactions.\n  assert(ownershipProofTxId0 + toByteString('0000000000ffffffff') == prevTx0.inputContract0)\n  assert(ownershipProofTxId1 + toByteString('0000000000ffffffff') == prevTx1.inputContract0)\n\n  // Verify that the withdrawal addresses match the addresses in the ownership proof transactions.\n  assert(withdrawalData0.address == ownProofTx0.outputAddrP2WPKH)\n  assert(withdrawalData1.address == ownProofTx1.outputAddrP2WPKH)\n}\n</code></pre>\n<p><strong>Genesis Check via Ancestor Transactions</strong> : Similar to the <em>DepositAggregator</em> , the contract performs an inductive check by verifying ancestor transactions. This ensures the integrity of the transaction history and prevents the operator from injecting unauthorized withdrawal requests.</p>\n<pre><code class=\"lang-auto\">if (!isPrevTxLeaf) {\n  // Construct ancestor transaction IDs.\n  const ancestorTxId0 = AggregatorUtils.getTxId(ancestorTx0, isAncestorLeaf)\n  const ancestorTxId1 = AggregatorUtils.getTxId(ancestorTx1, isAncestorLeaf)\n  const ancestorTxId2 = AggregatorUtils.getTxId(ancestorTx2, isAncestorLeaf)\n  const ancestorTxId3 = AggregatorUtils.getTxId(ancestorTx3, isAncestorLeaf)\n\n  // Verify that previous transactions unlock the ancestor transactions.\n  assert(prevTx0.inputContract0 == ancestorTxId0 + toByteString('0000000000ffffffff'))\n  assert(prevTx0.inputContract1 == ancestorTxId1 + toByteString('0000000000ffffffff'))\n  assert(prevTx1.inputContract0 == ancestorTxId2 + toByteString('0000000000ffffffff'))\n  assert(prevTx1.inputContract1 == ancestorTxId3 + toByteString('0000000000ffffffff'))\n\n  // Ensure that the ancestor transactions have the same contract SPK.\n  assert(prevTx0.outputContractSPK == ancestorTx0.outputContractSPK)\n  assert(prevTx0.outputContractSPK == ancestorTx1.outputContractSPK)\n  assert(prevTx0.outputContractSPK == ancestorTx2.outputContractSPK)\n  assert(prevTx0.outputContractSPK == ancestorTx3.outputContractSPK)\n}\n</code></pre>\n<p><strong>Amount Verification and Sum Calculation</strong> : This method calculates the total amount to be withdrawn by summing the amounts from the withdrawal requests or previous aggregations.</p>\n<pre><code class=\"lang-auto\">let sumAmt = 0n\nif (isPrevTxLeaf) {\n  sumAmt = withdrawalData0.amount + withdrawalData1.amount\n} else {\n  sumAmt = aggregationData0.sumAmt + aggregationData1.sumAmt\n}\n</code></pre>\n<p><strong>State Update</strong> : Computes a new hash that includes the hashes of the previous transactions and the sum of the withdrawal amounts. This hash is stored in the OP_RETURN output to update the state.</p>\n<pre><code class=\"lang-auto\">// Create new aggregation data.\nconst newAggregationData: AggregationData = {\n  prevH0: prevTx0.hashData,\n  prevH1: prevTx1.hashData,\n  sumAmt\n}\nconst newHash = WithdrawalAggregator.hashAggregationData(newAggregationData)\nconst stateOut = GeneralUtils.getStateOutput(newHash)\n</code></pre>\n<p><strong>Re-entrance Prevention and Output Enforcement</strong> : Ensures that outputs are strictly defined to prevent unauthorized modifications or re-entrance attacks.</p>\n<pre><code class=\"lang-auto\">// Construct contract output with the minimum dust amount.\nconst contractOut = GeneralUtils.getContractOutput(\n  546n,\n  prevTx0.outputContractSPK\n)\n\n// Ensure outputs match the expected format.\nconst outputs = contractOut + stateOut\nassert(\n  sha256(outputs) == shPreimage.hashOutputs,\n)\n</code></pre>\n<p>Full code of the withdrawal aggregation contract can be found <a href=\"https://github.com/Bitcoin-Wildlife-Sanctuary/scrypt-poc-bridge/blob/dad6aae8601d469d788fb1fa5d89ad233258d057/src/contracts/withdrawalAggregator.ts\" rel=\"noopener nofollow ugc\">here</a>.</p>\n<h3><a name=\"p-3654-bridge-contract-9\" class=\"anchor\" href=\"#p-3654-bridge-contract-9\"></a>Bridge Contract</h3>\n<p>The <em>Bridge</em> contract is the core component of our system, acting as the main covenant that maintains the state of the bridge, including the accounts and their balances organized in a Merkle tree. It handles both deposits and withdrawals by integrating with the aggregator contracts we\u2019ve previously discussed.</p>\n<pre><code class=\"lang-auto\">class Bridge extends SmartContract {\n  @prop()\n  operator: PubKey\n\n  @prop()\n  expanderSPK: ByteString\n\n  constructor(\n      operator: PubKey,\n      expanderSPK: ByteString\n  ) {\n      super(...arguments)\n      this.operator = operator\n      this.expanderSPK = expanderSPK\n  }\n\n  @method()\n  public deposit(\n      shPreimage: SHPreimage,\n      sigOperator: Sig,\n      prevTx: BridgeTransaction,           // Previous bridge update transaction.\n      aggregatorTx: AggregatorTransaction, // Root aggregator transaction.\n      fundingPrevout: ByteString,\n \n      deposits: FixedArray&lt;DepositData, typeof MAX_NODES_AGGREGATED&gt;,\n      accounts: FixedArray&lt;AccountData, typeof MAX_NODES_AGGREGATED&gt;,\n \n      depositProofs: FixedArray&lt;MerkleProof, typeof MAX_NODES_AGGREGATED&gt;,\n      accountProofs: FixedArray&lt;MerkleProof, typeof MAX_NODES_AGGREGATED&gt;\n  ) {\n      // Method implementation...\n  }\n\n  @method()\n  public withdrawal(\n      shPreimage: SHPreimage,\n      sigOperator: Sig,\n      prevTx: BridgeTransaction,           // Previous bridge update transaction.\n      aggregatorTx: AggregatorTransaction, // Root aggregator transaction.\n      fundingPrevout: ByteString,\n \n      withdrawals: FixedArray&lt;WithdrawalData, typeof MAX_NODES_AGGREGATED&gt;,\n      accounts: FixedArray&lt;AccountData, typeof MAX_NODES_AGGREGATED&gt;,\n \n      intermediateSumsArr: FixedArray&lt;IntermediateValues, typeof MAX_NODES_AGGREGATED&gt;,\n \n      withdrawalProofs: FixedArray&lt;MerkleProof, typeof MAX_NODES_AGGREGATED&gt;,\n      accountProofs: FixedArray&lt;MerkleProof, typeof MAX_NODES_AGGREGATED&gt;\n  ) {\n      // Method implementation...\n  }\n\n}\n</code></pre>\n<p>The contract constructor takes two parameters:</p>\n<ul>\n<li><em>operator</em> : The public key of the bridge operator authorized to update the bridge state.</li>\n<li><em>expanderSPK</em> : The script public key (SPK) of the <em>WithdrawalExpander</em> contract, used during the withdrawal process.</li>\n</ul>\n<p>The <em>deposit</em> method handles the processing of aggregated deposit transactions, updating the accounts\u2019 balances accordingly.</p>\n<pre><code class=\"lang-auto\">@method()\npublic deposit(\n  shPreimage: SHPreimage,\n  sigOperator: Sig,\n  prevTx: BridgeTransaction,           // Previous bridge update transaction.\n  aggregatorTx: AggregatorTransaction, // Root aggregator transaction.\n  fundingPrevout: ByteString,\n\n  deposits: FixedArray&lt;DepositData, typeof MAX_NODES_AGGREGATED&gt;,\n  accounts: FixedArray&lt;AccountData, typeof MAX_NODES_AGGREGATED&gt;,\n\n  depositProofs: FixedArray&lt;MerkleProof, typeof MAX_NODES_AGGREGATED&gt;,\n  accountProofs: FixedArray&lt;MerkleProof, typeof MAX_NODES_AGGREGATED&gt;\n) {\n  // Common validation steps...\n  // (Same as in previous contracts: sighash preimage check, operator signature verification, prevouts verification)\n\n  // Ensure this method is called from the first input.\n  assert(shPreimage.inputNumber == toByteString('00000000'))\n\n  // Verify that the second input unlocks the correct aggregator script.\n  assert(prevTx.depositAggregatorSPK == aggregatorTx.outputContractSPK)\n\n  // Process deposits and update accounts.\n  let accountsRootNew: Sha256 = prevTx.accountsRoot\n  let totalAmtDeposited = 0n\n  for (let i = 0; i &lt; MAX_NODES_AGGREGATED; i++) {\n      const deposit = deposits[i]\n      if (deposit.address != toByteString('')) {\n          accountsRootNew = this.applyDeposit(\n              deposits[i],\n              depositProofs[i],\n              aggregatorTx.hashData,\n              accounts[i],\n              accountProofs[i],\n              accountsRootNew\n          )\n      }\n      totalAmtDeposited += deposit.amount\n  }\n\n  // Update the bridge state and outputs.\n  // (Compute new state hash, construct contract output, enforce outputs)\n}\n</code></pre>\n<p>The steps performed by the <em>deposit</em> method include:</p>\n<p><strong>Processing Deposits and Updating Accounts</strong> :</p>\n<ul>\n<li>Iterates over the deposits and applies each one to the corresponding account using the <em>applyDeposit</em> method.</li>\n</ul>\n<p><strong>Updating the Bridge State and Outputs</strong> :</p>\n<ul>\n<li>Computes the new accounts Merkle root after processing the deposits.</li>\n<li>Creates a new state hash to represent the updated bridge state.</li>\n<li>Constructs the contract output, adding the total deposited amount to the bridge\u2019s balance.</li>\n<li>Enforces that the outputs match the expected format to maintain integrity.</li>\n</ul>\n<p>The <em>withdrawal</em> method processes aggregated withdrawal transactions, updates the accounts\u2019 balances, and prepares the funds for distribution through the <em>WithdrawalExpander</em> .</p>\n<pre><code class=\"lang-auto\">@method()\npublic withdrawal(\n  shPreimage: SHPreimage,\n  sigOperator: Sig,\n  prevTx: BridgeTransaction,           // Previous bridge update transaction.\n  aggregatorTx: AggregatorTransaction, // Root aggregator transaction.\n  fundingPrevout: ByteString,\n\n  withdrawals: FixedArray&lt;WithdrawalData, typeof MAX_NODES_AGGREGATED&gt;,\n  accounts: FixedArray&lt;AccountData, typeof MAX_NODES_AGGREGATED&gt;,\n\n  intermediateSumsArr: FixedArray&lt;IntermediateValues, typeof MAX_NODES_AGGREGATED&gt;,\n\n  withdrawalProofs: FixedArray&lt;MerkleProof, typeof MAX_NODES_AGGREGATED&gt;,\n  accountProofs: FixedArray&lt;MerkleProof, typeof MAX_NODES_AGGREGATED&gt;\n) {\n  // Common validation steps...\n  // (Same as in previous contracts: sighash preimage check, operator signature verification, prevouts verification)\n\n  // Ensure this method is called from the first input.\n  assert(shPreimage.inputNumber == toByteString('00000000'))\n\n  // Verify that the second input unlocks the correct aggregator script.\n  assert(prevTx.withdrawalAggregatorSPK == aggregatorTx.outputContractSPK)\n\n  // Process withdrawals and update accounts.\n  let accountsRootNew: Sha256 = prevTx.accountsRoot\n  let totalAmtWithdrawn = 0n\n  for (let i = 0; i &lt; MAX_NODES_AGGREGATED; i++) {\n      const withdrawal = withdrawals[i]\n      if (withdrawal.address != toByteString('')) {\n          accountsRootNew = this.applyWithdrawal(\n              withdrawal,\n              withdrawalProofs[i],\n              intermediateSumsArr[i],\n              aggregatorTx.hashData,\n              accounts[i],\n              accountProofs[i],\n              accountsRootNew\n          )\n      }\n      totalAmtWithdrawn += withdrawal.amount\n  }\n\n  // Update the bridge state and outputs.\n  // (Compute new state hash, construct contract output, create expander output, enforce outputs)\n}\n</code></pre>\n<p>Steps performed by the <em>withdrawal</em> method include:</p>\n<p><strong>Processing withdrawal requests and updating accounts:</strong></p>\n<ul>\n<li>Iterates over the withdrawals and applies each one to the corresponding account using the <em>applyWithdrawal</em> method.</li>\n</ul>\n<p><strong>Updating the Bridge State and Outputs</strong> :</p>\n<ul>\n<li>Computes the new accounts Merkle root after processing the withdrawals.</li>\n<li>Creates a new state hash to represent the updated bridge state.</li>\n<li>Constructs the contract output, subtracting the total withdrawn amount from the bridge\u2019s balance.</li>\n<li>Creates an expander output for the <em>WithdrawalExpander</em> contract, carrying the total amount withdrawn.</li>\n<li>Enforces that the outputs match the expected format to maintain integrity.</li>\n</ul>\n<p>The full source code is accessible <a href=\"https://github.com/Bitcoin-Wildlife-Sanctuary/scrypt-poc-bridge/blob/dad6aae8601d469d788fb1fa5d89ad233258d057/src/contracts/bridge.ts\" rel=\"noopener nofollow ugc\">here</a>.</p>\n<h3><a name=\"p-3654-withdrawalexpander-contract-10\" class=\"anchor\" href=\"#p-3654-withdrawalexpander-contract-10\"></a>WithdrawalExpander Contract</h3>\n<p>The <em>WithdrawalExpander</em> contract is the final component in our bridge system, responsible for distributing the aggregated withdrawal amounts back to individual users based on their withdrawal requests. It reverses the aggregation process performed by the <em>WithdrawalAggregator</em> , expanding the aggregated withdrawal data back into individual user payments.</p>\n<pre><code class=\"lang-auto\">class WithdrawalExpander extends SmartContract {\n  @prop()\n  operator: PubKey\n\n  constructor(\n      operator: PubKey\n  ) {\n      super(...arguments)\n      this.operator = operator\n  }\n\n  @method()\n  public expand(\n      shPreimage: SHPreimage,\n      sigOperator: Sig,\n      // Additional parameters...\n  ) {\n      // Expansion logic...\n  }\n\n}\n</code></pre>\n<p>The core functionality of the <em>WithdrawalExpander</em> is encapsulated in the <em>expand</em> method. This method takes the aggregated withdrawal data and recursively expands it into individual withdrawal transactions that pay out to users.</p>\n<p><strong>Expanding to Leaves</strong> : If the method expands to leaf nodes (individual withdrawals), it verifies the withdrawal data and constructs outputs that pay directly to the users\u2019 addresses.</p>\n<pre><code class=\"lang-auto\">if (isExpandingLeaves) {\n  // If expanding to leaves, verify the withdrawal data.\n  if (isExpandingPrevTxFirstOutput) {\n      const hashWithdrawalData = WithdrawalAggregator.hashWithdrawalData(withdrawalData0)\n      assert(hashWithdrawalData == prevAggregationData.prevH0)\n      hashOutputs = sha256(\n          WithdrawalExpander.getP2WPKHOut(\n              GeneralUtils.padAmt(withdrawalData0.amount),\n              withdrawalData0.address\n          )\n      )\n  } else {\n      const hashWithdrawalData = WithdrawalAggregator.hashWithdrawalData(withdrawalData1)\n      assert(hashWithdrawalData == prevAggregationData.prevH1)\n      hashOutputs = sha256(\n          WithdrawalExpander.getP2WPKHOut(\n              GeneralUtils.padAmt(withdrawalData1.amount),\n              withdrawalData1.address\n          )\n      )\n  }\n}\n</code></pre>\n<p>Further Expansion: If the method is not yet at the leaf level, it continues expanding by splitting the aggregation data into two branches and creating outputs that further expansion transactions will consume.</p>\n<pre><code class=\"lang-auto\">else {\n  // Verify current aggregation data matches previous aggregation data.\n  const hashCurrentAggregationData = WithdrawalAggregator.hashAggregationData(currentAggregationData)\n  if (isPrevTxBridge) {\n      assert(hashCurrentAggregationData == prevTxBridge.expanderRoot)\n  } else if (isExpandingPrevTxFirstOutput) {\n      assert(hashCurrentAggregationData == prevAggregationData.prevH0)\n  } else {\n      assert(hashCurrentAggregationData == prevAggregationData.prevH1)\n  }\n\n  // Prepare outputs for the next level of expansion.\n  let outAmt0 = 0n\n  let outAmt1 = 0n\n  if (isLastAggregationLevel) {\n      const hashWithdrawalData0 = WithdrawalAggregator.hashWithdrawalData(withdrawalData0)\n      const hashWithdrawalData1 = WithdrawalAggregator.hashWithdrawalData(withdrawalData1)\n      assert(hashWithdrawalData0 == currentAggregationData.prevH0)\n      assert(hashWithdrawalData1 == currentAggregationData.prevH1)\n      outAmt0 = withdrawalData0.amount\n      outAmt1 = withdrawalData1.amount\n  } else {\n      const hashNextAggregationData0 = WithdrawalAggregator.hashAggregationData(nextAggregationData0)\n      const hashNextAggregationData1 = WithdrawalAggregator.hashAggregationData(nextAggregationData1)\n      assert(hashNextAggregationData0 == currentAggregationData.prevH0)\n      assert(hashNextAggregationData1 == currentAggregationData.prevH1)\n      outAmt0 = nextAggregationData0.sumAmt\n      outAmt1 = nextAggregationData1.sumAmt\n  }\n\n  // Construct outputs for further expansion.\n  let expanderSPK = prevTxExpander.contractSPK\n  if (isPrevTxBridge) {\n      expanderSPK = prevTxBridge.expanderSPK\n  }\n\n  hashOutputs = sha256(\n      GeneralUtils.getContractOutput(outAmt0, expanderSPK) +\n      GeneralUtils.getContractOutput(outAmt1, expanderSPK) +\n      GeneralUtils.getStateOutput(hashCurrentAggregationData)\n  )\n}\n</code></pre>\n<h2><a name=\"p-3654-conclusion-11\" class=\"anchor\" href=\"#p-3654-conclusion-11\"></a>Conclusion</h2>\n<p>In this proof-of-concept implementation, we developed a bridge covenant on OP_CAT-enabled Bitcoin using the <a href=\"https://docs.scrypt.io/\" rel=\"noopener nofollow ugc\">sCrypt</a> embedded DSL. The bridge leverages recursive covenants and Merkle trees to efficiently batch and process deposit and withdrawal requests while maintaining the integrity and security of user accounts. By designing and implementing four smart contracts \u2014 <strong>DepositAggregator</strong> , <strong>WithdrawalAggregator</strong> , <strong>Bridge</strong> , and <strong>WithdrawalExpander</strong> \u2014 we provided a method to manage stateful interactions on Bitcoin, facilitating interoperability with Layer 2 networks like Starknet. This work establishes a technical foundation for building production-grade bridges, potentially enhancing scalability and functionality within the Bitcoin ecosystem.</p>\n<p>All of the code implementation, along with an end-to-end test, is <a href=\"https://github.com/Bitcoin-Wildlife-Sanctuary/scrypt-poc-bridge\" rel=\"noopener nofollow ugc\">available on GitHub</a>.</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2024-11-30T09:35:11.771Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 3,
  "reads": 5,
  "readers_count": 4,
  "score": 15.8,
  "yours": false,
  "topic_id": 1291,
  "topic_slug": "implementing-a-bridge-covenant-on-op-cat-enabled-bitcoin-a-proof-of-concept",
  "topic_title": "Implementing a Bridge Covenant on OP_CAT-Enabled Bitcoin: A Proof of Concept",
  "topic_html_title": "Implementing a Bridge Covenant on OP_CAT-Enabled Bitcoin: A Proof of Concept",
  "category_id": 8,
  "display_username": "sCrypt",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 3,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": "",
  "bookmarked": false,
  "raw": "![Implementing a Bridge Covenant on OP_CAT-Enabled Bitcoin: A Proof of Concept|1456x819](upload://e0QPBjPFVfGUjhL6N6KKVE5yCXm.png)\n\n\n# Implementing a Bridge Covenant on OP_CAT-Enabled Bitcoin: A Proof of Concept\n\nIn this article, we explore how **sCrypt**, in collaboration with **StarkWare**, has developed a demo bridge covenant on Bitcoin. This proof-of-concept implementation is designed to serve as a foundational framework for a production-grade bridge connecting the Bitcoin blockchain to the Starknet Layer 2 (L2) network.\n\nThe bridge introduces a sophisticated mechanism for handling multiple deposit and withdrawal requests. It allows for the batching of these transactions into a single root transaction. This transaction is then integrated into the main bridge covenant, updating its state seamlessly. The state is maintained as a set of accounts, organized within a secure and efficient Merkle tree structure.\n\nGiven the inherent complexity of the bridge's covenant scripts, sCrypt has employed its advanced domain-specific language (DSL) to construct the implementation.\n\n## Overview\n\nThe bridge consists of a recursive covenant Bitcoin script. Here, \u201ccovenant\u201d means that the locking script is capable of enforcing conditions on the spending transaction, and \u201crecursive\u201d means that the rules above are sufficiently powerful to enable persistent logic and state onchain (a requirement for any onchain smart contract).\n\nThis script exists in a chain of transactions, each enforcing the structure of the subsequent transaction that unlocks an output from the current one. Each time a new transaction is added to this chain, it represents an update of the bridge\u2019s state. Hence, the tip of this chain holds the current bridge state.\n\n![|1024x201](upload://uDEby9EyIOU9BwGDec8IxuSVgEq.png)\n\nThe covenant\u2019s state\u2014specifically, its hash\u2014is stored in an unspendable OP_RETURN output. While we\u2019re not spending this UTXO, its data can be inspected while executing a covenant script. More concretely, the state holds the root hash of the Merkle tree containing account data, as follows:\n\n![|733x550](upload://sYZFoEAGZLdRXEfCuJzIqdSlzeA.png)\n\nThe tree holds data about a fixed set of account slots. The leaves contain the hash of the respective account data, which consists of an address and a balance. To signify empty account slots, they are marked with zero bytes.\n\nEach update of the bridge results in a change to the accounts tree. To facilitate such an update, we rely upon Merkle proofs, the verification of which is efficient within Bitcoin script. An update essentially consists of two steps. First, we verify a Merkle proof that proves the inclusion of a particular account\u2019s current state. Then, after calculating the new state of this account, we use the same auxiliary nodes from the aforementioned Merkle proof to derive the new root hash.\n\n![|812x505](upload://hqXLAnxYcxGU7XqYjvE4Ek3wL9v.png)\n\nThe update can be either a deposit or a withdrawal. The bridge can perform a batch of these updates within a single transaction.\n\n## Deposits\n\nWe aim to enable users to submit deposits or withdrawal requests independently. To achieve this, users create separate transactions that pay to a deposit or withdrawal aggregation covenant, respectively. This covenant aggregates a batch of these requests into a Merkle tree. The root of this tree can be merged into the main bridge covenant, which then processes each deposit or withdrawal.\n\n![|1024x531](upload://qiN3LF58JXshTDXV0lNEgDw05GW.png)\n\nIn deposit transactions, besides hashing the deposit data and constructing a Merkle tree, the covenant also ensures that the deposited satoshis locked into the covenant\u2019s outputs accumulate correctly up to the tree\u2019s root. The aggregation covenant makes it so the funds are only spendable by the correct onchain smart contract. (Of course, in a production system, we will also enable a user to cancel her deposit transaction.)\n\nThis kind of tree design results from a limitation of how covenant scripts are constructed, not allowing transactions with too many inputs and outputs. A tree structure allows us to scale to potentially arbitrary throughput.\n\n## Withdrawal Requests\n\nThe aggregation of withdrawal requests is similar but differs in a few ways. First, we need an authentication method for a user to withdraw funds from their account. This contrasts with deposits, where anyone is allowed to deposit into anyone\u2019s account, similar to Bitcoin addresses in general. Authentication is done at the leaf level of the aggregation tree. The withdrawal request aggregation covenant checks that the address being withdrawn from matches the P2WPKH address of the first input in the leaf transaction.\n\n![|1024x462](upload://yN23dod2H8A3nLwR6k6Mr0T0hXS.png)\n\nThis ensures that the owner of the address approves the withdrawal since they signed the transaction requesting it. Another subtle difference compared to deposit aggregation is that we also hash intermediate sum amounts up the tree. This is done because we\u2019ll need this data when expanding the withdrawals, but more on that later.\n\nAn astute reader might notice a potential problem with this model of authenticating withdrawal requests. What if the operator decides to cheat and creates a root transaction of an aggregation tree where the tree\u2019s data is fabricated locally with fake withdrawal requests that weren\u2019t authenticated? We need an efficient way to verify that this root transaction originates from valid leaf transactions.\n\nTo address this, we perform what is called a \u201cgenesis check.\u201d Essentially, we make the aggregation covenant check its previous transaction and the transaction preceding that one \u2014 that is, its ancestor transactions. The covenant verifies that these transactions contain the same covenant script and perform the same checks. In this way, we achieve an inductive transaction history check. Because both of the previous transactions performed the same checks as this covenant does, we know that the ancestors of that transaction did the same, all the way back to the leaf (i.e., the genesis transaction).\n\n![|1024x133](upload://lRtT947Qs2gDQ3M3qJwDgaymeCE.png)\n\nNaturally, we perform this validation for both branches of the tree. So each aggregation node transaction checks up to six transactions in total.\n\n## Expansion of Withdrawals\n\nNow let\u2019s move to the last part of our solution: the expansion of the withdrawals. Upon processing a batch of withdrawal requests, the main bridge covenant enforces an output that pays the total amount withdrawn to an expander covenant. We can think of this covenant as essentially performing the inverse of what the withdrawal request aggregation covenant did. It starts with the withdrawal tree\u2019s root and expands it into two branches, each containing the appropriate amount of withdrawn funds that should go to that branch. It continues this process all the way down to the withdrawal tree\u2019s leaves. The leaf transactions are enforced to have a simple payment output that pays the account owner\u2019s address the amount they requested to withdraw.\n\n![|1024x401](upload://1vXxBfT56OfTywXmRNegQxHTFoE.png)\n\n## Implementation\n\nTo bring our bridge covenant to life, we\u2019ve implemented four sCrypt smart contracts that handle different aspects of the system. In this section, we\u2019ll provide a high-level overview of each contract.\n\n### DepositAggregator Contract\n\nThe DepositAggregator contract aggregates individual deposits into a single Merkle tree, which can then be merged into the main bridge covenant. This aggregation allows for batch deposit processing, reducing the number of transactions that need to be individually processed by the bridge. Additionally, it allows users to independently submit deposits, which will be later picked up by an operator.\n\n```\nclass DepositAggregator extends SmartContract {\n  @prop()\n  operator: PubKey\n\n  @prop()\n  bridgeSPK: ByteString\n  /**\n    * Covenant used for the aggregation of deposits.\n    *\n    * @param operator - Public key of bridge operator.\n    * @param bridgeSPK - P2TR script of the bridge state covenant. Includes length prefix!\n    */\n  constructor(operator: PubKey, bridgeSPK: ByteString) {\n      super(...arguments)\n      this.operator = operator\n      this.bridgeSPK = bridgeSPK\n  }\n  @method()\n  public aggregate(\n      shPreimage: SHPreimage,\n      isPrevTxLeaf: boolean,\n      sigOperator: Sig,\n      prevTx0: AggregatorTransaction,\n      prevTx1: AggregatorTransaction,\n      // Additional parameters...\n  ) {\n      // Validation steps...\n  }\n  @method()\n  public finalize(\n      shPreimage: SHPreimage,\n      sigOperator: Sig,\n      prevTx: AggregatorTransaction,\n      ancestorTx0: AggregatorTransaction,\n      ancestorTx1: AggregatorTransaction,\n      bridgeTxId: Sha256,\n      fundingPrevout: ByteString\n  ) {\n      // Finalization steps...\n  }\n}\n```\n\nThe contract constructor takes in two parameters:\n\n* *operator* : The public key of the bridge operator who is authorized to aggregate deposits.\n* *bridgeSPK* : The script public key (SPK) of the main bridge covenant, ensuring that the aggregated deposits are merged correctly.\n\nThe core functionality of the *DepositAggregator* is encapsulated in the *aggregate* method. This method performs the following steps:\n\n**Validation of Sighash Preimage and Operator Signature:** Ensures the transaction is authorized by the bridge operator and that the sighash preimage is correctly formatted and belongs to the executing transaction. Read more about sighash preimage validation in [this article](https://medium.com/@scryptplatform/trustless-ordinal-sales-using-op-cat-enabled-covenants-on-bitcoin-0318052f02b2).\n\n```\n// Check sighash preimage.\nconst s = SigHashUtils.checkSHPreimage(shPreimage)\nassert(this.checkSig(s, SigHashUtils.Gx))\n\n// Check operator signature.\nassert(this.checkSig(sigOperator, this.operator))\n```\n\n**Construction and Verification of Previous Transaction IDs** : Checks that the previous transactions aggregated are valid and correctly referenced.\n\n```\n// Construct previous transaction ID.\nconst prevTxId = AggregatorUtils.getTxId(prevTx, false)\n\n// Verify that the transaction unlocks the specified outputs.\nconst hashPrevouts = AggregatorUtils.getHashPrevouts(\n  bridgeTxId,\n  prevTxId,\n  fundingPrevout\n)\nassert(hashPrevouts == shPreimage.hashPrevouts)\n```\n\n**Merkle Tree Aggregation** : This verifies that the deposit data passed as witness hashes match the state stored in the previous transactions.\n\n```\nconst hashData0 = DepositAggregator.hashDepositData(depositData0)\nconst hashData1 = DepositAggregator.hashDepositData(depositData1)\n\nassert(hashData0 == prevTx0.hashData)\nassert(hashData1 == prevTx1.hashData)\n```\n\n**Amount Verification** : Confirms that the amounts in the previous outputs match the specified deposit amounts, ensuring funds are correctly accounted for in the aggregation.\n\n```\n// Check that the prev outputs actually carry the specified amount\n// of satoshis. The amount values can also carry aggregated amounts,\n// in case we're not aggregating leaves anymore.\nassert(\n  GeneralUtils.padAmt(depositData0.amount) ==\n  prevTx0.outputContractAmt\n)\nassert(\n  GeneralUtils.padAmt(depositData1.amount) ==\n  prevTx1.outputContractAmt\n)\n```\n\n**State Update** : Computes a new hash by concatenating the hashes of the previous transactions and updates the state in the OP_RETURN output.\n\n```\n// Concatinate hashes from previous aggregation txns (or leaves)\n// and compute new hash. Store this new hash in the state OP_RETURN\n// output.\nconst newHash = hash256(prevTx0.hashData + prevTx1.hashData)\nconst stateOut = GeneralUtils.getStateOutput(newHash)\n```\n\n**Re-entrance Prevention** : Enforces strict output scripts and amounts to prevent unauthorized modifications or double-spending.\n\n```\n// Sum up aggregated amounts and construct contract output.\nconst contractOut = GeneralUtils.getContractOutput(\n  depositData0.amount + depositData1.amount,\n  prevTx0.outputContractSPK\n)\n\n// Recurse. Send to aggregator with updated hash.\nconst outputs = contractOut + stateOut\nassert(\n  sha256(outputs) == shPreimage.hashOutputs\n)\n```\n\nOnce the deposits are aggregated, they must be merged into the main bridge covenant. This is handled by the *finalize* method, whose steps include:\n\n* **Validation of Previous Transactions** : Similar to the aggregate method, it verifies the previous transactions to ensure the integrity of the data being merged.\n* **Integration with Bridge Covenant** : Checks that the aggregated deposits are correctly merged into the main bridge covenant by referencing the bridge\u2019s transaction ID and script public key.\n\nThe full source code of the deposit aggregation contract can be found [on GitHub](https://github.com/Bitcoin-Wildlife-Sanctuary/scrypt-poc-bridge/blob/dad6aae8601d469d788fb1fa5d89ad233258d057/src/contracts/depositAggregator.ts).\n\n### WithdrawalAggregator Contract\n\nThe *WithdrawalAggregator* contract is designed to aggregate individual withdrawal requests into a single Merkle tree, similar to how the *DepositAggregator* handles deposits. However, withdrawals require additional authentication to ensure that only the rightful owners can withdraw funds from their accounts.\n\n```\nclass WithdrawalAggregator extends SmartContract {\n  @prop()\n  operator: PubKey\n\n  @prop()\n  bridgeSPK: ByteString\n\n  /**\n    * Covenant used for the aggregation of withdrawal requests.\n    *\n    * @param operator - Public key of bridge operator.\n    * @param bridgeSPK - P2TR script of the bridge state covenant. Includes length prefix!\n    */\n  constructor(operator: PubKey, bridgeSPK: ByteString) {\n      super(...arguments)\n      this.operator = operator\n      this.bridgeSPK = bridgeSPK\n  }\n\n  @method()\n  public aggregate(\n      shPreimage: SHPreimage,\n      isPrevTxLeaf: boolean,\n      sigOperator: Sig,\n      prevTx0: AggregatorTransaction,\n      prevTx1: AggregatorTransaction,\n      // Additional parameters...\n  ) {\n      // Validation and aggregation logic...\n  }\n\n  @method()\n  public finalize(\n      shPreimage: SHPreimage,\n      sigOperator: Sig,\n      prevTx: AggregatorTransaction,\n      ancestorTx0: AggregatorTransaction,\n      ancestorTx1: AggregatorTransaction,\n      bridgeTxId: Sha256,\n      fundingPrevout: ByteString\n  ) {\n      // Validation logic...\n  }\n}\n```\n\nThe core functionality of the *WithdrawalAggregator* is encapsulated in the *aggregate* method, which performs the following steps:\n\n```\n// Check sighash preimage.\nconst s = SigHashUtils.checkSHPreimage(shPreimage)\nassert(this.checkSig(s, SigHashUtils.Gx))\n\n// Check operator signature.\nassert(this.checkSig(sigOperator, this.operator))\n```\n\n**Construction and Verification of Previous Transaction IDs** : This process verifies that the previous transactions being aggregated are valid and correctly referenced.\n\n```\n// Construct previous transaction IDs.\nconst prevTxId0 = AggregatorUtils.getTxId(prevTx0, isPrevTxLeaf)\nconst prevTxId1 = AggregatorUtils.getTxId(prevTx1, isPrevTxLeaf)\n\n// Verify that the previous transactions are unlocked by the current transaction.\nconst hashPrevouts = AggregatorUtils.getHashPrevouts(\n  prevTxId0,\n  prevTxId1,\n  fundingPrevout\n)\nassert(hashPrevouts == shPreimage.hashPrevouts)\n```\n\n**Ownership Proof Verification** : Verifying an ownership proof transaction ensures that only the rightful owner can withdraw funds from an account.\n\n* **Ownership Proof Transaction** : A transaction that proves control of the withdrawal address. The contract checks that the address in the withdrawal request matches the address in the ownership proof transaction.\n\n```\nif (isPrevTxLeaf) {\n  // Construct ownership proof transaction IDs.\n  const ownershipProofTxId0 = WithdrawalAggregator.getOwnershipProofTxId(ownProofTx0)\n  const ownershipProofTxId1 = WithdrawalAggregator.getOwnershipProofTxId(ownProofTx1)\n\n  // Check that the leaf transactions unlock the ownership proof transactions.\n  assert(ownershipProofTxId0 + toByteString('0000000000ffffffff') == prevTx0.inputContract0)\n  assert(ownershipProofTxId1 + toByteString('0000000000ffffffff') == prevTx1.inputContract0)\n\n  // Verify that the withdrawal addresses match the addresses in the ownership proof transactions.\n  assert(withdrawalData0.address == ownProofTx0.outputAddrP2WPKH)\n  assert(withdrawalData1.address == ownProofTx1.outputAddrP2WPKH)\n}\n```\n\n**Genesis Check via Ancestor Transactions** : Similar to the *DepositAggregator* , the contract performs an inductive check by verifying ancestor transactions. This ensures the integrity of the transaction history and prevents the operator from injecting unauthorized withdrawal requests.\n\n```\nif (!isPrevTxLeaf) {\n  // Construct ancestor transaction IDs.\n  const ancestorTxId0 = AggregatorUtils.getTxId(ancestorTx0, isAncestorLeaf)\n  const ancestorTxId1 = AggregatorUtils.getTxId(ancestorTx1, isAncestorLeaf)\n  const ancestorTxId2 = AggregatorUtils.getTxId(ancestorTx2, isAncestorLeaf)\n  const ancestorTxId3 = AggregatorUtils.getTxId(ancestorTx3, isAncestorLeaf)\n\n  // Verify that previous transactions unlock the ancestor transactions.\n  assert(prevTx0.inputContract0 == ancestorTxId0 + toByteString('0000000000ffffffff'))\n  assert(prevTx0.inputContract1 == ancestorTxId1 + toByteString('0000000000ffffffff'))\n  assert(prevTx1.inputContract0 == ancestorTxId2 + toByteString('0000000000ffffffff'))\n  assert(prevTx1.inputContract1 == ancestorTxId3 + toByteString('0000000000ffffffff'))\n\n  // Ensure that the ancestor transactions have the same contract SPK.\n  assert(prevTx0.outputContractSPK == ancestorTx0.outputContractSPK)\n  assert(prevTx0.outputContractSPK == ancestorTx1.outputContractSPK)\n  assert(prevTx0.outputContractSPK == ancestorTx2.outputContractSPK)\n  assert(prevTx0.outputContractSPK == ancestorTx3.outputContractSPK)\n}\n```\n\n**Amount Verification and Sum Calculation** : This method calculates the total amount to be withdrawn by summing the amounts from the withdrawal requests or previous aggregations.\n\n```\nlet sumAmt = 0n\nif (isPrevTxLeaf) {\n  sumAmt = withdrawalData0.amount + withdrawalData1.amount\n} else {\n  sumAmt = aggregationData0.sumAmt + aggregationData1.sumAmt\n}\n```\n\n**State Update** : Computes a new hash that includes the hashes of the previous transactions and the sum of the withdrawal amounts. This hash is stored in the OP_RETURN output to update the state.\n\n```\n// Create new aggregation data.\nconst newAggregationData: AggregationData = {\n  prevH0: prevTx0.hashData,\n  prevH1: prevTx1.hashData,\n  sumAmt\n}\nconst newHash = WithdrawalAggregator.hashAggregationData(newAggregationData)\nconst stateOut = GeneralUtils.getStateOutput(newHash)\n```\n\n**Re-entrance Prevention and Output Enforcement** : Ensures that outputs are strictly defined to prevent unauthorized modifications or re-entrance attacks.\n\n```\n// Construct contract output with the minimum dust amount.\nconst contractOut = GeneralUtils.getContractOutput(\n  546n,\n  prevTx0.outputContractSPK\n)\n\n// Ensure outputs match the expected format.\nconst outputs = contractOut + stateOut\nassert(\n  sha256(outputs) == shPreimage.hashOutputs,\n)\n```\n\nFull code of the withdrawal aggregation contract can be found [here](https://github.com/Bitcoin-Wildlife-Sanctuary/scrypt-poc-bridge/blob/dad6aae8601d469d788fb1fa5d89ad233258d057/src/contracts/withdrawalAggregator.ts).\n\n### Bridge Contract\n\nThe *Bridge* contract is the core component of our system, acting as the main covenant that maintains the state of the bridge, including the accounts and their balances organized in a Merkle tree. It handles both deposits and withdrawals by integrating with the aggregator contracts we\u2019ve previously discussed.\n\n```\nclass Bridge extends SmartContract {\n  @prop()\n  operator: PubKey\n\n  @prop()\n  expanderSPK: ByteString\n\n  constructor(\n      operator: PubKey,\n      expanderSPK: ByteString\n  ) {\n      super(...arguments)\n      this.operator = operator\n      this.expanderSPK = expanderSPK\n  }\n\n  @method()\n  public deposit(\n      shPreimage: SHPreimage,\n      sigOperator: Sig,\n      prevTx: BridgeTransaction,           // Previous bridge update transaction.\n      aggregatorTx: AggregatorTransaction, // Root aggregator transaction.\n      fundingPrevout: ByteString,\n \n      deposits: FixedArray<DepositData, typeof MAX_NODES_AGGREGATED>,\n      accounts: FixedArray<AccountData, typeof MAX_NODES_AGGREGATED>,\n \n      depositProofs: FixedArray<MerkleProof, typeof MAX_NODES_AGGREGATED>,\n      accountProofs: FixedArray<MerkleProof, typeof MAX_NODES_AGGREGATED>\n  ) {\n      // Method implementation...\n  }\n\n  @method()\n  public withdrawal(\n      shPreimage: SHPreimage,\n      sigOperator: Sig,\n      prevTx: BridgeTransaction,           // Previous bridge update transaction.\n      aggregatorTx: AggregatorTransaction, // Root aggregator transaction.\n      fundingPrevout: ByteString,\n \n      withdrawals: FixedArray<WithdrawalData, typeof MAX_NODES_AGGREGATED>,\n      accounts: FixedArray<AccountData, typeof MAX_NODES_AGGREGATED>,\n \n      intermediateSumsArr: FixedArray<IntermediateValues, typeof MAX_NODES_AGGREGATED>,\n \n      withdrawalProofs: FixedArray<MerkleProof, typeof MAX_NODES_AGGREGATED>,\n      accountProofs: FixedArray<MerkleProof, typeof MAX_NODES_AGGREGATED>\n  ) {\n      // Method implementation...\n  }\n\n}\n```\n\nThe contract constructor takes two parameters:\n\n* *operator* : The public key of the bridge operator authorized to update the bridge state.\n* *expanderSPK* : The script public key (SPK) of the *WithdrawalExpander* contract, used during the withdrawal process.\n\nThe *deposit* method handles the processing of aggregated deposit transactions, updating the accounts\u2019 balances accordingly.\n\n```\n@method()\npublic deposit(\n  shPreimage: SHPreimage,\n  sigOperator: Sig,\n  prevTx: BridgeTransaction,           // Previous bridge update transaction.\n  aggregatorTx: AggregatorTransaction, // Root aggregator transaction.\n  fundingPrevout: ByteString,\n\n  deposits: FixedArray<DepositData, typeof MAX_NODES_AGGREGATED>,\n  accounts: FixedArray<AccountData, typeof MAX_NODES_AGGREGATED>,\n\n  depositProofs: FixedArray<MerkleProof, typeof MAX_NODES_AGGREGATED>,\n  accountProofs: FixedArray<MerkleProof, typeof MAX_NODES_AGGREGATED>\n) {\n  // Common validation steps...\n  // (Same as in previous contracts: sighash preimage check, operator signature verification, prevouts verification)\n\n  // Ensure this method is called from the first input.\n  assert(shPreimage.inputNumber == toByteString('00000000'))\n\n  // Verify that the second input unlocks the correct aggregator script.\n  assert(prevTx.depositAggregatorSPK == aggregatorTx.outputContractSPK)\n\n  // Process deposits and update accounts.\n  let accountsRootNew: Sha256 = prevTx.accountsRoot\n  let totalAmtDeposited = 0n\n  for (let i = 0; i < MAX_NODES_AGGREGATED; i++) {\n      const deposit = deposits[i]\n      if (deposit.address != toByteString('')) {\n          accountsRootNew = this.applyDeposit(\n              deposits[i],\n              depositProofs[i],\n              aggregatorTx.hashData,\n              accounts[i],\n              accountProofs[i],\n              accountsRootNew\n          )\n      }\n      totalAmtDeposited += deposit.amount\n  }\n\n  // Update the bridge state and outputs.\n  // (Compute new state hash, construct contract output, enforce outputs)\n}\n```\n\nThe steps performed by the *deposit* method include:\n\n**Processing Deposits and Updating Accounts** :\n\n* Iterates over the deposits and applies each one to the corresponding account using the *applyDeposit* method.\n\n**Updating the Bridge State and Outputs** :\n\n* Computes the new accounts Merkle root after processing the deposits.\n* Creates a new state hash to represent the updated bridge state.\n* Constructs the contract output, adding the total deposited amount to the bridge\u2019s balance.\n* Enforces that the outputs match the expected format to maintain integrity.\n\nThe *withdrawal* method processes aggregated withdrawal transactions, updates the accounts\u2019 balances, and prepares the funds for distribution through the *WithdrawalExpander* .\n\n```\n@method()\npublic withdrawal(\n  shPreimage: SHPreimage,\n  sigOperator: Sig,\n  prevTx: BridgeTransaction,           // Previous bridge update transaction.\n  aggregatorTx: AggregatorTransaction, // Root aggregator transaction.\n  fundingPrevout: ByteString,\n\n  withdrawals: FixedArray<WithdrawalData, typeof MAX_NODES_AGGREGATED>,\n  accounts: FixedArray<AccountData, typeof MAX_NODES_AGGREGATED>,\n\n  intermediateSumsArr: FixedArray<IntermediateValues, typeof MAX_NODES_AGGREGATED>,\n\n  withdrawalProofs: FixedArray<MerkleProof, typeof MAX_NODES_AGGREGATED>,\n  accountProofs: FixedArray<MerkleProof, typeof MAX_NODES_AGGREGATED>\n) {\n  // Common validation steps...\n  // (Same as in previous contracts: sighash preimage check, operator signature verification, prevouts verification)\n\n  // Ensure this method is called from the first input.\n  assert(shPreimage.inputNumber == toByteString('00000000'))\n\n  // Verify that the second input unlocks the correct aggregator script.\n  assert(prevTx.withdrawalAggregatorSPK == aggregatorTx.outputContractSPK)\n\n  // Process withdrawals and update accounts.\n  let accountsRootNew: Sha256 = prevTx.accountsRoot\n  let totalAmtWithdrawn = 0n\n  for (let i = 0; i < MAX_NODES_AGGREGATED; i++) {\n      const withdrawal = withdrawals[i]\n      if (withdrawal.address != toByteString('')) {\n          accountsRootNew = this.applyWithdrawal(\n              withdrawal,\n              withdrawalProofs[i],\n              intermediateSumsArr[i],\n              aggregatorTx.hashData,\n              accounts[i],\n              accountProofs[i],\n              accountsRootNew\n          )\n      }\n      totalAmtWithdrawn += withdrawal.amount\n  }\n\n  // Update the bridge state and outputs.\n  // (Compute new state hash, construct contract output, create expander output, enforce outputs)\n}\n```\n\nSteps performed by the *withdrawal* method include:\n\n**Processing withdrawal requests and updating accounts:**\n\n* Iterates over the withdrawals and applies each one to the corresponding account using the *applyWithdrawal* method.\n\n**Updating the Bridge State and Outputs** :\n\n* Computes the new accounts Merkle root after processing the withdrawals.\n* Creates a new state hash to represent the updated bridge state.\n* Constructs the contract output, subtracting the total withdrawn amount from the bridge\u2019s balance.\n* Creates an expander output for the *WithdrawalExpander* contract, carrying the total amount withdrawn.\n* Enforces that the outputs match the expected format to maintain integrity.\n\nThe full source code is accessible [here](https://github.com/Bitcoin-Wildlife-Sanctuary/scrypt-poc-bridge/blob/dad6aae8601d469d788fb1fa5d89ad233258d057/src/contracts/bridge.ts).\n\n### WithdrawalExpander Contract\n\nThe *WithdrawalExpander* contract is the final component in our bridge system, responsible for distributing the aggregated withdrawal amounts back to individual users based on their withdrawal requests. It reverses the aggregation process performed by the *WithdrawalAggregator* , expanding the aggregated withdrawal data back into individual user payments.\n\n```\nclass WithdrawalExpander extends SmartContract {\n  @prop()\n  operator: PubKey\n\n  constructor(\n      operator: PubKey\n  ) {\n      super(...arguments)\n      this.operator = operator\n  }\n\n  @method()\n  public expand(\n      shPreimage: SHPreimage,\n      sigOperator: Sig,\n      // Additional parameters...\n  ) {\n      // Expansion logic...\n  }\n\n}\n```\n\nThe core functionality of the *WithdrawalExpander* is encapsulated in the *expand* method. This method takes the aggregated withdrawal data and recursively expands it into individual withdrawal transactions that pay out to users.\n\n**Expanding to Leaves** : If the method expands to leaf nodes (individual withdrawals), it verifies the withdrawal data and constructs outputs that pay directly to the users\u2019 addresses.\n\n```\nif (isExpandingLeaves) {\n  // If expanding to leaves, verify the withdrawal data.\n  if (isExpandingPrevTxFirstOutput) {\n      const hashWithdrawalData = WithdrawalAggregator.hashWithdrawalData(withdrawalData0)\n      assert(hashWithdrawalData == prevAggregationData.prevH0)\n      hashOutputs = sha256(\n          WithdrawalExpander.getP2WPKHOut(\n              GeneralUtils.padAmt(withdrawalData0.amount),\n              withdrawalData0.address\n          )\n      )\n  } else {\n      const hashWithdrawalData = WithdrawalAggregator.hashWithdrawalData(withdrawalData1)\n      assert(hashWithdrawalData == prevAggregationData.prevH1)\n      hashOutputs = sha256(\n          WithdrawalExpander.getP2WPKHOut(\n              GeneralUtils.padAmt(withdrawalData1.amount),\n              withdrawalData1.address\n          )\n      )\n  }\n}\n```\n\nFurther Expansion: If the method is not yet at the leaf level, it continues expanding by splitting the aggregation data into two branches and creating outputs that further expansion transactions will consume.\n\n```\nelse {\n  // Verify current aggregation data matches previous aggregation data.\n  const hashCurrentAggregationData = WithdrawalAggregator.hashAggregationData(currentAggregationData)\n  if (isPrevTxBridge) {\n      assert(hashCurrentAggregationData == prevTxBridge.expanderRoot)\n  } else if (isExpandingPrevTxFirstOutput) {\n      assert(hashCurrentAggregationData == prevAggregationData.prevH0)\n  } else {\n      assert(hashCurrentAggregationData == prevAggregationData.prevH1)\n  }\n\n  // Prepare outputs for the next level of expansion.\n  let outAmt0 = 0n\n  let outAmt1 = 0n\n  if (isLastAggregationLevel) {\n      const hashWithdrawalData0 = WithdrawalAggregator.hashWithdrawalData(withdrawalData0)\n      const hashWithdrawalData1 = WithdrawalAggregator.hashWithdrawalData(withdrawalData1)\n      assert(hashWithdrawalData0 == currentAggregationData.prevH0)\n      assert(hashWithdrawalData1 == currentAggregationData.prevH1)\n      outAmt0 = withdrawalData0.amount\n      outAmt1 = withdrawalData1.amount\n  } else {\n      const hashNextAggregationData0 = WithdrawalAggregator.hashAggregationData(nextAggregationData0)\n      const hashNextAggregationData1 = WithdrawalAggregator.hashAggregationData(nextAggregationData1)\n      assert(hashNextAggregationData0 == currentAggregationData.prevH0)\n      assert(hashNextAggregationData1 == currentAggregationData.prevH1)\n      outAmt0 = nextAggregationData0.sumAmt\n      outAmt1 = nextAggregationData1.sumAmt\n  }\n\n  // Construct outputs for further expansion.\n  let expanderSPK = prevTxExpander.contractSPK\n  if (isPrevTxBridge) {\n      expanderSPK = prevTxBridge.expanderSPK\n  }\n\n  hashOutputs = sha256(\n      GeneralUtils.getContractOutput(outAmt0, expanderSPK) +\n      GeneralUtils.getContractOutput(outAmt1, expanderSPK) +\n      GeneralUtils.getStateOutput(hashCurrentAggregationData)\n  )\n}\n```\n\n## Conclusion\n\nIn this proof-of-concept implementation, we developed a bridge covenant on OP_CAT-enabled Bitcoin using the [sCrypt](https://docs.scrypt.io/) embedded DSL. The bridge leverages recursive covenants and Merkle trees to efficiently batch and process deposit and withdrawal requests while maintaining the integrity and security of user accounts. By designing and implementing four smart contracts \u2014 **DepositAggregator** , **WithdrawalAggregator** , **Bridge** , and **WithdrawalExpander** \u2014 we provided a method to manage stateful interactions on Bitcoin, facilitating interoperability with Layer 2 networks like Starknet. This work establishes a technical foundation for building production-grade bridges, potentially enhancing scalability and functionality within the Bitcoin ecosystem.\n\nAll of the code implementation, along with an end-to-end test, is [available on GitHub](https://github.com/Bitcoin-Wildlife-Sanctuary/scrypt-poc-bridge).",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 477,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": "Github link was replaced with a permanent link",
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}