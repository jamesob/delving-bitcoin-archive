{
  "id": 3512,
  "name": "Anthony Towns",
  "username": "ajtowns",
  "avatar_template": "/user_avatar/delvingbitcoin.org/ajtowns/{size}/417_2.png",
  "created_at": "2024-11-13T08:01:55.334Z",
  "cooked": "<p>Jonas Nick tweeted about an implementation of <a href=\"https://eprint.iacr.org/2017/965.pdf\">WOTS+</a> via the expanded script opcodes proposed for <a href=\"https://github.com/rustyrussell/bips/pull/1\">the GSR project</a>:</p>\n<aside class=\"onebox twitterstatus\" data-onebox-src=\"https://x.com/n1ckler/status/1854552545084977320\">\n  <header class=\"source\">\n\n      <a href=\"https://x.com/n1ckler/status/1854552545084977320\" target=\"_blank\" rel=\"noopener\">x.com</a>\n  </header>\n\n  <article class=\"onebox-body\">\n    \n<h4><a href=\"https://x.com/n1ckler/status/1854552545084977320\" target=\"_blank\" rel=\"noopener\">ncklr (@n1ckler) on X</a></h4>\n<div class=\"twitter-screen-name\"><a href=\"https://x.com/n1ckler/status/1854552545084977320\" target=\"_blank\" rel=\"noopener\">@n1ckler</a></div>\n\n<div class=\"tweet\">\n  <span class=\"tweet-description\">.@rusty_twit's Great Script Restoration (GSR) offers a potential path toward post-quantum secure Bitcoin. I just published an experimental tool that produces post-quantum Bitcoin Script and signatures. While primarily an exploratory project, this tool provides valuable insights:</span>\n</div>\n\n<div class=\"date\">\n  <a href=\"https://x.com/n1ckler/status/1854552545084977320\" class=\"timestamp\" target=\"_blank\" rel=\"noopener\"></a>\n\n\n</div>\n\n  </article>\n\n  <div class=\"onebox-metadata\">\n    \n    \n  </div>\n\n  <div style=\"clear: both\"></div>\n</aside>\n\n<p>It\u2019s very interesting and worth looking at. The basic idea is:</p>\n<ul>\n<li>You generate a WOTS+ secret/public key pair (67 secrets, 1 seed, and 15 randomizers; each of which are 256 bits; the 67 secrets correspond to 67 hash-images that serve as the public key)<pre data-code-wrap=\"txt\"><code class=\"lang-txt\">$ .lake/build/bin/wots seckeygen mysecrets\n</code></pre>\n</li>\n<li>Using these, you generate a very large script that encodes the pubkey, seed and randomizers, and can be used to verify a signature:<pre data-code-wrap=\"txt\"><code class=\"lang-txt\">$ .lake/build/bin/wots scriptgen mysecrets myscript\n$ .lake/build/bin/wots scriptparse myscript | cat | head -c60; echo\n(some [OP_DUP, OP_1ADD, OP_PUSH(79be667ef9dcbbac55a06295ce87\n$ du -h ./myscript\n24K\t./myscript\n</code></pre>\n</li>\n<li>You can then pretend that you\u2019ve created a bitcoin transaction spending some funds, and calculated the appropriate message to sign, eg following the BIP 342 rules, for demo purposes, we imagine it is <code>0xabababab...ab</code>. This is then hashed following the BIP 340 rules, so that it can be validated via a CHECKSIG via the <code>s=m+1</code> <a href=\"https://medium.com/blockstream/cat-and-schnorr-tricks-i-faf1b59bd298\">CAT trick</a>. Thus the tx signature is a witness stack consisting of the CAT-trick hash, and 67 256-bit signature hashes, one for each of the secrets/hash-images.<pre data-code-wrap=\"txt\"><code class=\"lang-txt\">$ SIGHASH=abababababababababababababababababababababababababababababababab\n$ .lake/build/bin/wots witnessgen mysecrets $SIGHASH mywitness\n</code></pre>\n</li>\n<li>Finally you can run the script against your witness, and see if it worked:<pre data-code-wrap=\"txt\"><code class=\"lang-txt\">$ .lake/build/bin/wots verify myscript $SIGHASH mywitness\nvalid\n</code></pre>\n</li>\n</ul>\n<p>The tweet raises two concerns:</p>\n<blockquote>\n<ul>\n<li>[\u2026] Stack management remains very challenging, as GSR doesn\u2019t address this aspect.</li>\n<li>A significant limitation is the size: the script is 22kB, with a 2kB witness. This represents a roughly 375-fold increase over a Schnorr signature witness and would substantially change the nature of Bitcoin. I believe there\u2019s limited room for optimization using the standard W-OTS scheme.</li>\n</ul>\n</blockquote>\n<p>These are pretty parallel to the idea <a href=\"https://delvingbitcoin.org/t/chia-lisp-for-bitcoiners/636\">I raised in March</a>: namely \u201cthere are two things that as a language [bitcoin script] can\u2019t do well: looping and structured data.\u201d Not handling structured data is what makes stack management challenging, and in this case not being able to loop means having to repeat the same lines of hashing code 15 times for each of the 67 sigs/pubkeys you need to verify, giving you an immediate 1000 times increase in code size.</p>\n<p>Redoing the same logic in <a href=\"https://delvingbitcoin.org/t/debuggable-lisp-scripts/1224/\">bllsh</a> gives a much smaller script, of about 3600 bytes. This could be further reduced by ~2200 bytes if the pubkeys were hashed together, rather than included literally, bringing the script down to about 1400 bytes (about 40 times larger than p2wpkh, which when combined with the 2200 bytes of witness data is about 35 times larger than a p2wpkh in total). If you also generated the randomization data from the seed, I suspect you could probably reduce the script by up to a further 480 bytes without much loss in security (down to about 30 times larger than p2wpkh in total). Improvements in the serialization format might also make a difference.</p>\n<p>The source is <a href=\"https://github.com/ajtowns/bllsh/blob/3ed435a56ca1331da18567fbfee4d30e515bb947/examples/test-winternitz\">available as an example in the bllsh tree</a>, but it\u2019s probably short enough to run through directly:</p>\n<ul>\n<li>\n<p>WOTS+ has a seeded/randomized hash function, so we make a function for that with our seed hardcoded. We also hardcode the randomization constants, and the pubkey data.</p>\n<pre data-code-wrap=\"txt\"><code class=\"lang-txt\">def (HASH R X) (sha256 0xb10dce54185a124a89cf3432ea7eb0475d993cf767b3ee93da70d2a8408e7834 (^ X R))`\ndef RANDOMIZATION (q 0x9bc6d76b5c9d462db42274e2d8218a8fe4437ee11f26a1073109896d373883b0 ...)\ndef HASHES (q 0xe7a848b9a2176261b38d952ff6d9cc982e9330f903c4e49df0254ce99c5fe710 ...)\n</code></pre>\n</li>\n<li>\n<p>The main Winternitz function is chaining the hash function, which looks like:</p>\n<pre data-code-wrap=\"txt\"><code class=\"lang-txt\">def (CHAIN N RRAND X) (if N (HASH (h RRAND) (CHAIN (- N 1) (t RRAND) X)) X)\n</code></pre>\n<p>This isn\u2019t tail recursive (which sucks), but when verifying a signature, it means we can just set N to the correct number of hashes, and have the RRAND list be ordered so that the last randomizer comes first, and it all works out.</p>\n</li>\n<li>\n<p>The parameters we choose for WOTS+ means it operates on hexidecimal digits or half-bytes, so we need to convert the strings we start with into lists of hexidecimal digits to operate on. We also need to calculate a checksum in order for the signature scheme to be remotely secure. That occurs like this:</p>\n<pre data-code-wrap=\"txt\"><code class=\"lang-txt\">def (REVERSE L TAIL) (if L (REVERSE (t L) (rc TAIL (h L))) TAIL)\ndef (HEXPAIR BYTE TAIL) (rc TAIL (shift BYTE -4) (&amp; BYTE 0x0f))\ndef (HEXDIGITS STR TAIL) (if STR (HEXDIGITS (substr STR 1) (HEXPAIR (substr STR 0 1) TAIL)) TAIL)\ndef (HEXTRIP SHORT) (rc nil (+ (shift SHORT -8)) (+ (shift (&amp; SHORT 0xf0) -4)) (+ (&amp; SHORT 0x0f)))\ndef (CHECKSUM W C REVDIG TAIL) (if REVDIG (CHECKSUM W (- (+ C W) 1 (h REVDIG)) (t REVDIG) (rc TAIL (h REVDIG))) (REVERSE (HEXTRIP C) TAIL))\n</code></pre>\n</li>\n<li>\n<p>Beyond that, there\u2019s the CAT trick calculation:</p>\n<pre data-code-wrap=\"txt\"><code class=\"lang-txt\">def (SIGMSG_ M SECP_G) (sha256 SECP_G SECP_G M)\ndef (SIGMSG M) (SIGMSG_ M 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798)\n</code></pre>\n</li>\n<li>\n<p>And then it can all be put together:</p>\n<pre data-code-wrap=\"txt\"><code class=\"lang-txt\">def (WOTSCHECK_ W PUBKEY SIG DIGITS RESULT) (if PUBKEY (WOTSCHECK_ W (t PUBKEY) (t SIG) (t DIGITS) (all RESULT (= (h PUBKEY) (CHAIN (- W (h DIGITS)) (RANDOMIZATION) (h SIG))))) RESULT)\n\ndef (WOTSCHECK SIGHASH WITNESS) (WOTSCHECK_ 15 (HASHES) (t WITNESS) (CHECKSUM 16 0 (HEXDIGITS (h WITNESS) nil) nil) (= (h WITNESS) (SIGMSG SIGHASH)))\n</code></pre>\n</li>\n</ul>\n<p>That is not necessarily all that simple to follow, but most of it is already fairly analogous to the functional lean4 implementation code in <a href=\"https://github.com/jonasnick/GreatRSI/blob/664be9d7f0de4df5c56e91c5a1f8c13ccde12eec/GreatRSI/Winternitz.lean\">Winternitz.lean</a> (see f_k/chain vs HASH/CHAIN, base16/checksum vs HEXDIGITS/CHECKSUM, winternitz vs WOTSCHECK, and challenge_cat_trick from Schnorr.lean vs SIGMSG). That seems substantially easier to deal with than the complexity of <a href=\"https://github.com/jonasnick/GreatRSI/blob/664be9d7f0de4df5c56e91c5a1f8c13ccde12eec/GreatRSI/Winternitz.lean\">ScriptBuilder.lean</a>, and, as a consequence, perhaps also more amenable to formal verification?</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2024-11-13T08:07:02.515Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 24,
  "reads": 9,
  "readers_count": 8,
  "score": 136.6,
  "yours": false,
  "topic_id": 1255,
  "topic_slug": "winternitz-one-time-signatures-contrasting-between-lisp-and-script",
  "topic_title": "Winternitz One Time Signatures, contrasting between Lisp and Script",
  "topic_html_title": "Winternitz One Time Signatures, contrasting between Lisp and Script",
  "category_id": 7,
  "display_username": "Anthony Towns",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Jonas Nick tweeted about an implementation of [WOTS+](https://eprint.iacr.org/2017/965.pdf) via the expanded script opcodes proposed for [the GSR project](https://github.com/rustyrussell/bips/pull/1):\n\nhttps://x.com/n1ckler/status/1854552545084977320\n\nIt's very interesting and worth looking at. The basic idea is:\n\n * You generate a WOTS+ secret/public key pair (67 secrets, 1 seed, and 15 randomizers; each of which are 256 bits; the 67 secrets correspond to 67 hash-images that serve as the public key)\n    ```txt\n   $ .lake/build/bin/wots seckeygen mysecrets\n   ```\n * Using these, you generate a very large script that encodes the pubkey, seed and randomizers, and can be used to verify a signature:\n   ```txt\n   $ .lake/build/bin/wots scriptgen mysecrets myscript\n   $ .lake/build/bin/wots scriptparse myscript | cat | head -c60; echo\n   (some [OP_DUP, OP_1ADD, OP_PUSH(79be667ef9dcbbac55a06295ce87\n   $ du -h ./myscript\n   24K\t./myscript\n   ```\n * You can then pretend that you've created a bitcoin transaction spending some funds, and calculated the appropriate message to sign, eg following the BIP 342 rules, for demo purposes, we imagine it is `0xabababab...ab`. This is then hashed following the BIP 340 rules, so that it can be validated via a CHECKSIG via the `s=m+1` [CAT trick](https://medium.com/blockstream/cat-and-schnorr-tricks-i-faf1b59bd298). Thus the tx signature is a witness stack consisting of the CAT-trick hash, and 67 256-bit signature hashes, one for each of the secrets/hash-images.\n   ```txt\n   $ SIGHASH=abababababababababababababababababababababababababababababababab\n   $ .lake/build/bin/wots witnessgen mysecrets $SIGHASH mywitness\n   ```\n * Finally you can run the script against your witness, and see if it worked:\n   ```txt\n   $ .lake/build/bin/wots verify myscript $SIGHASH mywitness\n   valid\n   ```\n\nThe tweet raises two concerns:\n\n> * [...] Stack management remains very challenging, as GSR doesn't address this aspect.\n> * A significant limitation is the size: the script is 22kB, with a 2kB witness. This represents a roughly 375-fold increase over a Schnorr signature witness and would substantially change the nature of Bitcoin. I believe there's limited room for optimization using the standard W-OTS scheme.\n\nThese are pretty parallel to the idea [I raised in March](https://delvingbitcoin.org/t/chia-lisp-for-bitcoiners/636): namely \"there are two things that as a language [bitcoin script] can\u2019t do well: looping and structured data.\" Not handling structured data is what makes stack management challenging, and in this case not being able to loop means having to repeat the same lines of hashing code 15 times for each of the 67 sigs/pubkeys you need to verify, giving you an immediate 1000 times increase in code size.\n\nRedoing the same logic in [bllsh](https://delvingbitcoin.org/t/debuggable-lisp-scripts/1224/) gives a much smaller script, of about 3600 bytes. This could be further reduced by ~2200 bytes if the pubkeys were hashed together, rather than included literally, bringing the script down to about 1400 bytes (about 40 times larger than p2wpkh, which when combined with the 2200 bytes of witness data is about 35 times larger than a p2wpkh in total). If you also generated the randomization data from the seed, I suspect you could probably reduce the script by up to a further 480 bytes without much loss in security (down to about 30 times larger than p2wpkh in total). Improvements in the serialization format might also make a difference.\n\nThe source is [available as an example in the bllsh tree](https://github.com/ajtowns/bllsh/blob/3ed435a56ca1331da18567fbfee4d30e515bb947/examples/test-winternitz), but it's probably short enough to run through directly:\n\n * WOTS+ has a seeded/randomized hash function, so we make a function for that with our seed hardcoded. We also hardcode the randomization constants, and the pubkey data.\n   ```txt\n   def (HASH R X) (sha256 0xb10dce54185a124a89cf3432ea7eb0475d993cf767b3ee93da70d2a8408e7834 (^ X R))`\n   def RANDOMIZATION (q 0x9bc6d76b5c9d462db42274e2d8218a8fe4437ee11f26a1073109896d373883b0 ...)\n   def HASHES (q 0xe7a848b9a2176261b38d952ff6d9cc982e9330f903c4e49df0254ce99c5fe710 ...)\n   ```\n * The main Winternitz function is chaining the hash function, which looks like:\n   ```txt\n   def (CHAIN N RRAND X) (if N (HASH (h RRAND) (CHAIN (- N 1) (t RRAND) X)) X)\n   ```\n   This isn't tail recursive (which sucks), but when verifying a signature, it means we can just set N to the correct number of hashes, and have the RRAND list be ordered so that the last randomizer comes first, and it all works out.\n\n * The parameters we choose for WOTS+ means it operates on hexidecimal digits or half-bytes, so we need to convert the strings we start with into lists of hexidecimal digits to operate on. We also need to calculate a checksum in order for the signature scheme to be remotely secure. That occurs like this:\n   ```txt\n   def (REVERSE L TAIL) (if L (REVERSE (t L) (rc TAIL (h L))) TAIL)\n   def (HEXPAIR BYTE TAIL) (rc TAIL (shift BYTE -4) (& BYTE 0x0f))\n   def (HEXDIGITS STR TAIL) (if STR (HEXDIGITS (substr STR 1) (HEXPAIR (substr STR 0 1) TAIL)) TAIL)\n   def (HEXTRIP SHORT) (rc nil (+ (shift SHORT -8)) (+ (shift (& SHORT 0xf0) -4)) (+ (& SHORT 0x0f)))\n   def (CHECKSUM W C REVDIG TAIL) (if REVDIG (CHECKSUM W (- (+ C W) 1 (h REVDIG)) (t REVDIG) (rc TAIL (h REVDIG))) (REVERSE (HEXTRIP C) TAIL))\n   ```\n * Beyond that, there's the CAT trick calculation:\n   ```txt\n   def (SIGMSG_ M SECP_G) (sha256 SECP_G SECP_G M)\n   def (SIGMSG M) (SIGMSG_ M 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798)\n   ```\n * And then it can all be put together:\n   ```txt\n   def (WOTSCHECK_ W PUBKEY SIG DIGITS RESULT) (if PUBKEY (WOTSCHECK_ W (t PUBKEY) (t SIG) (t DIGITS) (all RESULT (= (h PUBKEY) (CHAIN (- W (h DIGITS)) (RANDOMIZATION) (h SIG))))) RESULT)\n\n   def (WOTSCHECK SIGHASH WITNESS) (WOTSCHECK_ 15 (HASHES) (t WITNESS) (CHECKSUM 16 0 (HEXDIGITS (h WITNESS) nil) nil) (= (h WITNESS) (SIGMSG SIGHASH)))\n   ```\n\nThat is not necessarily all that simple to follow, but most of it is already fairly analogous to the functional lean4 implementation code in [Winternitz.lean](https://github.com/jonasnick/GreatRSI/blob/664be9d7f0de4df5c56e91c5a1f8c13ccde12eec/GreatRSI/Winternitz.lean) (see f_k/chain vs HASH/CHAIN, base16/checksum vs HEXDIGITS/CHECKSUM, winternitz vs WOTSCHECK, and challenge_cat_trick from Schnorr.lean vs SIGMSG). That seems substantially easier to deal with than the complexity of [ScriptBuilder.lean](https://github.com/jonasnick/GreatRSI/blob/664be9d7f0de4df5c56e91c5a1f8c13ccde12eec/GreatRSI/Winternitz.lean), and, as a consequence, perhaps also more amenable to formal verification?",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": true,
  "admin": true,
  "staff": true,
  "user_id": 3,
  "hidden": false,
  "trust_level": 4,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": "Github link was replaced with a permanent link",
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "rocket",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}