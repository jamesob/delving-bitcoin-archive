{
  "id": 3611,
  "name": null,
  "username": "mpch",
  "avatar_template": "/letter_avatar_proxy/v4/letter/m/0ea827/{size}.png",
  "created_at": "2024-11-27T11:36:53.864Z",
  "cooked": "<p>Hello all <img src=\"https://delvingbitcoin.org/images/emoji/twitter/wave.png?v=12\" title=\":wave:\" class=\"emoji\" alt=\":wave:\" loading=\"lazy\" width=\"20\" height=\"20\">,</p>\n<p>I\u2019m currently working towards prototypes and implementations to fix replacement cycling attacks.</p>\n<h1><a name=\"p-3611-why-is-this-important-1\" class=\"anchor\" href=\"#p-3611-why-is-this-important-1\"></a><strong>Why is this important?</strong></h1>\n<p>As the current state of the lightning network, malicious actors have a capacity to bribe miners on channel resolutions, consequently, have a capacity to steal funds from peers.</p>\n<h1><a name=\"p-3611-what-are-replacement-cycling-attacks-2\" class=\"anchor\" href=\"#p-3611-what-are-replacement-cycling-attacks-2\"></a><strong>What are Replacement Cycling attacks?</strong></h1>\n<p>Replacement cycling attack is a method that makes use of transaction input replacements and HTLCs scripts conditions, to make forcefully stuck HTLCs not be confirmed until CLTV delta from the HTLC on a previous (malicious) hop timeout. After the timeout, as the attacker has the preimage, spend the funds from the stuck payment, stealing the payment that went through the HTLC.</p>\n<p>In other words, as Peter Todd points out in the mailing list <a href=\"https://gnusha.org/pi/bitcoindev/ZTMWrJ6DjxtslJBn@petertodd.org/\" rel=\"noopener nofollow ugc\">[link]</a> , the problem here is that after the HTLC-timeout path becomes spendable, the HTLC-preimage path remains spendable.</p>\n<p>We need to find solutions to this issue.</p>\n<h1><a name=\"p-3611-proposed-and-implemented-mitigations-3\" class=\"anchor\" href=\"#p-3611-proposed-and-implemented-mitigations-3\"></a><strong>Proposed and implemented mitigations</strong></h1>\n<p>Antonie Riard in his paper proposed five mitigations related to mempool monitoring and how the HTLC-timeout transaction is rebroadcasted <a href=\"https://gnusha.org/pi/bitcoindev/CALZpt+GdyfDotdhrrVkjTALg5DbxJyiS8ruO2S7Ggmi9Ra5B9g@mail.gmail.com/\" rel=\"noopener nofollow ugc\">[link]</a>: Local Mempool and transaction relay traffic monitoring, miner mempool monitoring, defensive fee broadcasting, aggressive broadcasting and per hop packet delay bumping. All of them, attempt to mitigate the issue doing either:</p>\n<ul>\n<li>Trying to win the race</li>\n<li>Trying to make the race not worthwhile.</li>\n</ul>\n<p>Some of them, local-mempool and aggressive rebroadcasting, were implemented by the different node implementations to fix this issue.</p>\n<h1><a name=\"p-3611-why-we-dont-want-races-in-lightning-protocol-4\" class=\"anchor\" href=\"#p-3611-why-we-dont-want-races-in-lightning-protocol-4\"></a><strong>Why we don\u2019t want races in Lightning Protocol</strong></h1>\n<p>Every time there is a dispute or want to <em>end a relationship</em>, nodes go on-chain. Both cases depend on what the contract between the parties says. I think anyone can see a problem with the \u201cwhoever comes first, was right\u201d type of contract. Incentivises cheating. Also makes it so whoever has more capital (therefore, better machine or connection) will probably end up winning.</p>\n<p>better contracts == better infrastructure</p>\n<p><strong>OP_EXPIRE enters the scene.</strong></p>\n<p>My goal is to build a prototype demonstrating the usefulness of this opcode to the lightning protocol, through a proposed patch to bitcoin-core and the required updates to the lightning spec and CLN, to demonstrate how the softfork proposal is useful for resolving HTLC timeouts off chain.</p>\n<p>OP_EXPIRE, AKA, OP_ANTICHECKLOCKTIMEVERIFY lets us build better contracts so node implementations don\u2019t need to go on-chain to be sure that funds are safe.</p>\n<p>As the name says, it lets a branch or the script expire after certain block or delta blocks. This means that the HTLC-preimage branch would expire after a delta, previously negotiated, amount of blocks, making it an urgent thing. Now after a certain amount of block an HTLC is not returned, the channel wouldn\u2019t need to be closed, implementation would need to make the HTLC-preimage become not spendable to return the error back to the network.</p>\n<p>If someone has a problem, it wouldn\u2019t mean chaos on-chain given automatic unilateral closures.</p>\n<p>If you see your peer down and you want to really want to close the channel, you would manually (or programmatically) take action and not be part of the protocol.</p>\n<p>We can see the changes on the script here (extracted from Elle Mouton blog <a href=\"https://ellemouton.com/posts/htlc-deep-dive/\" rel=\"noopener nofollow ugc\">[link]</a>):</p>\n<p><strong>Current offering HTLC</strong></p>\n<pre><code class=\"lang-auto\"># To remote node with revocation key\nOP_DUP OP_HASH160 &lt;RIPEMD160(SHA256(revocationpubkey))&gt; OP_EQUAL\nOP_IF\n    OP_CHECKSIG\nOP_ELSE\n    &lt;remote_htlcpubkey&gt; OP_SWAP OP_SIZE 32 OP_EQUAL\n    OP_NOTIF\n     # To local node via HTLC-timeout transaction (timelocked). OP_DROP 2                           OP_SWAP &lt;local_htlcpubkey&gt; 2 OP_CHECKMULTISIG\n    OP_ELSE\n           # To remote node with preimage\n           &lt;expire block height&gt; OP_EXPIRE OP_DROP OP_HASH160\n           &lt;RIPEMD160(payment_hash)&gt; OP_EQUALVERIFY OP_CHECKSIG\n    OP_ENDIF\nOP_ENDIF\n</code></pre>\n<p><strong>New offering HTLC</strong></p>\n<p>When going to remote or pre image, after specified blockheight the script would fail, leaving only the first two branches as possible way to unlock the funds.</p>\n<pre><code class=\"lang-auto\"># To remote node with revocation key\nOP_DUP OP_HASH160 &lt;RIPEMD160(SHA256(revocationpubkey))&gt; OP_EQUAL\nOP_IF\n    OP_CHECKSIG\nOP_ELSE\n    &lt;remote_htlcpubkey&gt; OP_SWAP OP_SIZE 32 OP_EQUAL\n    OP_NOTIF\n     # To local node via HTLC-timeout transaction (timelocked). OP_DROP 2                           OP_SWAP &lt;local_htlcpubkey&gt; 2 OP_CHECKMULTISIG\n    OP_ELSE\n           # To remote node with preimage that expires on expire block height.                                    &lt;expire block height&gt; OP_EXPIRE OP_DROP OP_HASH160\n           &lt;RIPEMD160(payment_hash)&gt; OP_EQUALVERIFY OP_CHECKSIG\n    OP_ENDIF\nOP_ENDIF\n</code></pre>\n<p><strong>How could it be implemented?</strong></p>\n<p>Peter Todd suggested a few ways of implementing this solution <a href=\"https://gnusha.org/pi/bitcoindev/ZTMWrJ6DjxtslJBn@petertodd.org/\" rel=\"noopener nofollow ugc\">[link]</a> <a href=\"https://www.youtube.com/watch?v=HXnNRmhCpNM\" rel=\"noopener nofollow ugc\">[link]</a>:</p>\n<ol>\n<li>Coinbase Bit: modify the nVersion to enable transactions to have tx outputs to be spendable like the coinbase transaction output.</li>\n<li>Delta encoding expiration: encodes the a delta expiration in the nVersion that applied to the nLockTime, acts like a new factor \u201cAbsoluteExpireHeight\u201d to be checked as the OP_CLTV.</li>\n<li>Taproot Annex: use the annex as nExpiryHeight that would work as the same of the \u201cAbsoluteExpireHeight\u201d.</li>\n</ol>\n<p>I took the liberty to implement the second one.</p>\n<p>All transactions using this op_code would need to use nLockTime greater than 0 and do not use sequence_final.</p>\n<p>We take the first 16 bytes of the nVersion field of the transaction (now nDeltaExpireHeight), this would signal the maximum delta of all OP_EXPIRE in scripts inside the transaction from the nLockTime field.</p>\n<p>So the actual script takes the first element of the stack and compares it to the AbsoluteExpireHeight (nDeltaExpireHeight + nLockTime).</p>\n<p>The script would fail then in the following cases:</p>\n<ol>\n<li>The stack is empty</li>\n<li>The top item on the stack is less or equal than 0</li>\n<li>The lock time type of the stack item is not block height</li>\n<li>The lock time type of the nLockTime is not height</li>\n<li>The top stack item is greater than AbsoluteExpireHeight</li>\n<li>the nSequence field of the txin is sequence_final</li>\n</ol>\n<p><a href=\"https://github.com/bitcoin/bitcoin/commit/7b3cc52e55e7f942bed8afe73ee33ac652b1c3ce\" rel=\"noopener nofollow ugc\"><strong>You can see a draft implementation in bitcoin core here</strong></a></p>\n<p><a href=\"https://github.com/a-mpch/bitcoin/commits/2024-11-op-expire/\" rel=\"noopener nofollow ugc\">Branch with test from Antoine Riard and modified version of this HTLC\n</a></p>\n<h2><a name=\"p-3611-summary-5\" class=\"anchor\" href=\"#p-3611-summary-5\"></a>Summary</h2>\n<p>Having OP_EXPIRE as a possibility in Bitcoin Script enable us:</p>\n<ul>\n<li>To solve Lightning open problem of replacement cycling attacks</li>\n<li>Have a less automated unilateral closure of channels, less footprint in base chain</li>\n<li>Better scripts for other projects: Auction bids, Vaults, Time-limited delegation (rough list from Peter Todd\u2019s presentation)</li>\n<li>We don\u2019t introduce a that different script as it is more-or-less a negation of OP_CLTV</li>\n</ul>\n<p>Possible cons:</p>\n<ul>\n<li>We need would need to find consensus on what\u2019s the nExpireHeight field would be. Version? Annex? That\u2019s a long conversation to have. For now Version and have a delta works best.</li>\n</ul>\n<p><em>Side notes:</em></p>\n<p><em>Next steps are doing a CLN draft implementation making use of this HTLC script.</em></p>\n<p><em>This is a extract of a <a href=\"https://world.hey.com/mpch/mitigating-replacement-cycling-attacks-with-some-magic-part-i-4a76ad45\" rel=\"noopener nofollow ugc\">blog post</a> so this post would be concise,  If you need more details, graphical example of the problem or explanation of possible mitigations, you can checkout the blog itself.</em></p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2024-11-27T11:36:53.864Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 18,
  "reads": 17,
  "readers_count": 16,
  "score": 108.2,
  "yours": false,
  "topic_id": 1282,
  "topic_slug": "op-expire-mitigating-replacing-cycling-attacks",
  "topic_title": "OP_EXPIRE: Mitigating replacing cycling attacks",
  "topic_html_title": "OP_EXPIRE: Mitigating replacing cycling attacks",
  "category_id": 7,
  "display_username": null,
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Hello all :wave:,\n\nI'm currently working towards prototypes and implementations to fix replacement cycling attacks.\n\n# **Why is this important?**\n\nAs the current state of the lightning network, malicious actors have a capacity to bribe miners on channel resolutions, consequently, have a capacity to steal funds from peers.\n\n# **What are Replacement Cycling attacks?**\n\nReplacement cycling attack is a method that makes use of transaction input replacements and HTLCs scripts conditions, to make forcefully stuck HTLCs not be confirmed until CLTV delta from the HTLC on a previous (malicious) hop timeout. After the timeout, as the attacker has the preimage, spend the funds from the stuck payment, stealing the payment that went through the HTLC.\n\nIn other words, as Peter Todd points out in the mailing list [[link]](https://gnusha.org/pi/bitcoindev/ZTMWrJ6DjxtslJBn@petertodd.org/) , the problem here is that after the HTLC-timeout path becomes spendable, the HTLC-preimage path remains spendable.\n\nWe need to find solutions to this issue.\n\n# **Proposed and implemented mitigations**\n\nAntonie Riard in his paper proposed five mitigations related to mempool monitoring and how the HTLC-timeout transaction is rebroadcasted [[link]](https://gnusha.org/pi/bitcoindev/CALZpt+GdyfDotdhrrVkjTALg5DbxJyiS8ruO2S7Ggmi9Ra5B9g@mail.gmail.com/): Local Mempool and transaction relay traffic monitoring, miner mempool monitoring, defensive fee broadcasting, aggressive broadcasting and per hop packet delay bumping. All of them, attempt to mitigate the issue doing either:\n\n* Trying to win the race\n* Trying to make the race not worthwhile.\n\nSome of them, local-mempool and aggressive rebroadcasting, were implemented by the different node implementations to fix this issue.\n\n# **Why we don't want races in Lightning Protocol**\n\nEvery time there is a dispute or want to *end a relationship*, nodes go on-chain. Both cases depend on what the contract between the parties says. I think anyone can see a problem with the \"whoever comes first, was right\" type of contract. Incentivises cheating. Also makes it so whoever has more capital (therefore, better machine or connection) will probably end up winning.\n\nbetter contracts == better infrastructure\n\n**OP_EXPIRE enters the scene.**\n\nMy goal is to build a prototype demonstrating the usefulness of this opcode to the lightning protocol, through a proposed patch to bitcoin-core and the required updates to the lightning spec and CLN, to demonstrate how the softfork proposal is useful for resolving HTLC timeouts off chain.\n\nOP_EXPIRE, AKA, OP_ANTICHECKLOCKTIMEVERIFY lets us build better contracts so node implementations don\u2019t need to go on-chain to be sure that funds are safe.\n\nAs the name says, it lets a branch or the script expire after certain block or delta blocks. This means that the HTLC-preimage branch would expire after a delta, previously negotiated, amount of blocks, making it an urgent thing. Now after a certain amount of block an HTLC is not returned, the channel wouldn\u2019t need to be closed, implementation would need to make the HTLC-preimage become not spendable to return the error back to the network.\n\nIf someone has a problem, it wouldn't mean chaos on-chain given automatic unilateral closures.\n\nIf you see your peer down and you want to really want to close the channel, you would manually (or programmatically) take action and not be part of the protocol.\n\nWe can see the changes on the script here (extracted from Elle Mouton blog [[link]](https://ellemouton.com/posts/htlc-deep-dive/)):\n\n**Current offering HTLC**\n```\n# To remote node with revocation key\nOP_DUP OP_HASH160 <RIPEMD160(SHA256(revocationpubkey))> OP_EQUAL\nOP_IF\n    OP_CHECKSIG\nOP_ELSE\n    <remote_htlcpubkey> OP_SWAP OP_SIZE 32 OP_EQUAL\n    OP_NOTIF\n     # To local node via HTLC-timeout transaction (timelocked). OP_DROP 2                           OP_SWAP <local_htlcpubkey> 2 OP_CHECKMULTISIG\n    OP_ELSE\n           # To remote node with preimage\n           <expire block height> OP_EXPIRE OP_DROP OP_HASH160\n           <RIPEMD160(payment_hash)> OP_EQUALVERIFY OP_CHECKSIG\n    OP_ENDIF\nOP_ENDIF\n```\n\n\n**New offering HTLC**\n\nWhen going to remote or pre image, after specified blockheight the script would fail, leaving only the first two branches as possible way to unlock the funds.\n\n```\n# To remote node with revocation key\nOP_DUP OP_HASH160 <RIPEMD160(SHA256(revocationpubkey))> OP_EQUAL\nOP_IF\n    OP_CHECKSIG\nOP_ELSE\n    <remote_htlcpubkey> OP_SWAP OP_SIZE 32 OP_EQUAL\n    OP_NOTIF\n     # To local node via HTLC-timeout transaction (timelocked). OP_DROP 2                           OP_SWAP <local_htlcpubkey> 2 OP_CHECKMULTISIG\n    OP_ELSE\n           # To remote node with preimage that expires on expire block height.                                    <expire block height> OP_EXPIRE OP_DROP OP_HASH160\n           <RIPEMD160(payment_hash)> OP_EQUALVERIFY OP_CHECKSIG\n    OP_ENDIF\nOP_ENDIF\n```\n\n**How could it be implemented?**\n\nPeter Todd suggested a few ways of implementing this solution [[link]](https://gnusha.org/pi/bitcoindev/ZTMWrJ6DjxtslJBn@petertodd.org/) [[link]](https://www.youtube.com/watch?v=HXnNRmhCpNM):\n\n1. Coinbase Bit: modify the nVersion to enable transactions to have tx outputs to be spendable like the coinbase transaction output.\n2. Delta encoding expiration: encodes the a delta expiration in the nVersion that applied to the nLockTime, acts like a new factor \u201cAbsoluteExpireHeight\u201d to be checked as the OP_CLTV.\n3. Taproot Annex: use the annex as nExpiryHeight that would work as the same of the \u201cAbsoluteExpireHeight\u201d.\n\nI took the liberty to implement the second one.\n\nAll transactions using this op_code would need to use nLockTime greater than 0 and do not use sequence_final.\n\nWe take the first 16 bytes of the nVersion field of the transaction (now nDeltaExpireHeight), this would signal the maximum delta of all OP_EXPIRE in scripts inside the transaction from the nLockTime field.\n\nSo the actual script takes the first element of the stack and compares it to the AbsoluteExpireHeight (nDeltaExpireHeight + nLockTime).\n\nThe script would fail then in the following cases:\n\n1. The stack is empty\n2. The top item on the stack is less or equal than 0\n3. The lock time type of the stack item is not block height\n4. The lock time type of the nLockTime is not height\n5. The top stack item is greater than AbsoluteExpireHeight\n6. the nSequence field of the txin is sequence_final\n\n[**You can see a draft implementation in bitcoin core here**](https://github.com/bitcoin/bitcoin/commit/7b3cc52e55e7f942bed8afe73ee33ac652b1c3ce)\n\n[Branch with test from Antoine Riard and modified version of this HTLC\n](https://github.com/a-mpch/bitcoin/commits/2024-11-op-expire/)\n\n## Summary\n\nHaving OP_EXPIRE as a possibility in Bitcoin Script enable us:\n- To solve Lightning open problem of replacement cycling attacks\n- Have a less automated unilateral closure of channels, less footprint in base chain\n- Better scripts for other projects: Auction bids, Vaults, Time-limited delegation (rough list from Peter Todd's presentation)\n- We don't introduce a that different script as it is more-or-less a negation of OP_CLTV\n\nPossible cons:\n- We need would need to find consensus on what's the nExpireHeight field would be. Version? Annex? That's a long conversation to have. For now Version and have a delta works best. \n\n*Side notes:*\n\n*Next steps are doing a CLN draft implementation making use of this HTLC script.*\n\n*This is a extract of a [blog post](https://world.hey.com/mpch/mitigating-replacement-cycling-attacks-with-some-magic-part-i-4a76ad45) so this post would be concise,  If you need more details, graphical example of the problem or explanation of possible mitigations, you can checkout the blog itself.*",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 588,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}