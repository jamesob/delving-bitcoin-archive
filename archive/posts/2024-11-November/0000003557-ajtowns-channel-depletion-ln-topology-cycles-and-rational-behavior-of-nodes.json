{
  "id": 3557,
  "name": "Anthony Towns",
  "username": "ajtowns",
  "avatar_template": "/user_avatar/delvingbitcoin.org/ajtowns/{size}/417_2.png",
  "created_at": "2024-11-18T05:11:13.029Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"renepickhardt\" data-post=\"3\" data-topic=\"1259\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/renepickhardt/48/7_2.png\" class=\"avatar\"> renepickhardt:</div>\n<blockquote>\n<ul>\n<li>The red channels are those where the liquidity is on the cheaper end of the channel (contradicting your intuition that I have just created a \u201cmost expensive\u201d spanning tree.</li>\n</ul>\n</blockquote>\n</aside>\n<p>Ah, don\u2019t worry; I misunderstood the \u201cspanning tree\u201d part entirely.</p>\n<p>In your example there are two cycles remaining: (B pays A pays C pays B), and (D pays A pays C pays D) \u2013 I think my intuition is more along the lines of those being the minimally most expensive cycles? Is there such a thing as a spanning cycle, ie a cycle that touches every node? In this case I think my intuition would be that the remaining spanning cycle CDACBAC is more expensive than any other possible spanning cycle? (Perhaps provable by noting that any payment along that cycle will create a cheaper spanning cycle, providing a cheaper path from some node X to Y, than existed previously, so the next payment from X to Y will break that cheaper spanning cycle?)</p>\n<aside class=\"quote no-group\" data-username=\"renepickhardt\" data-post=\"3\" data-topic=\"1259\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/renepickhardt/48/7_2.png\" class=\"avatar\"> renepickhardt:</div>\n<blockquote>\n<p>I am not sure about your proposed simulation.</p>\n</blockquote>\n</aside>\n<p>Agreed: that would only be interesting if nodes were ending up depleted, rather than just channels.</p>\n<aside class=\"quote no-group\" data-username=\"renepickhardt\" data-post=\"3\" data-topic=\"1259\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/renepickhardt/48/7_2.png\" class=\"avatar\"> renepickhardt:</div>\n<blockquote>\n<p>Instead of focusing on such a mixed model wouldn\u2019t it be more interesting to focus on how node operators should adjust their fees to help with flow control and adjust to channel depletion</p>\n</blockquote>\n</aside>\n<p>I think you\u2019ve already \u201csolved\u201d this (ok, without proof, perhaps)? The only way you avoid channel depletion is if your channel appears in the \u201cspanning tree in which the network is balanced\u201d, so you either need to be structurally critical, or manage your fees with far more precision than is reasonably feasible. Otherwise you\u2019re just trying to drive straight by alternating between steering hard left and hard right\u2026 which okay, it might work, particularly if you can make the adjustments at high frequency, but sure seems pretty annoying.</p>\n<p>To me, it makes sense that a policy of \u201ceveryone will keep using the cheapest path that works\u201d will naturally exhaust the cheapest channels until the only ones that work are the \u201cmost expensive\u201d, per some global metric.</p>\n<p>To me, it seems logical that the only way to avoid that resulting in channel depletion and routing errors/retries, is to have some way of having some payments \u201cnot work\u201d for reasons other than channel depletion, in a way that is predictable when constructing the payment route. I continue to think <a href=\"https://web.archive.org/web/20231114193403/https://lists.linuxfoundation.org/pipermail/lightning-dev/2022-September/003686.html\"><code>max_msat</code> valves</a> are the way to solve this.</p>\n<p>Actually an additional thought on that topic: as a forwarding node, if you advertise a <code>max_msat</code> value, then you could/should use that (or a small multiple of it) as a cap on the total value of payments you\u2019ll allow to be (recently) pending across that channel. If (in the usual case) the payment resolves \u201cimmediately\u201d that\u2019s no constraint at all, which is great; but if someone splits their payment into 100 <code>max_msat</code> HTLCs and forwards them all over your channel, you\u2019ll immediately reject almost all of them, so there\u2019s ~no advantage in users attempting to finesse the signal to minimise fees. (\u201crecently\u201d \u2013 if a payment has been unresolved for more than a few seconds, it\u2019s probably hung, and you don\u2019t want to continue to reject new payments because of it).</p>",
  "post_number": 4,
  "post_type": 1,
  "updated_at": "2024-11-18T05:11:13.029Z",
  "reply_count": 0,
  "reply_to_post_number": 3,
  "quote_count": 1,
  "incoming_link_count": 0,
  "reads": 14,
  "readers_count": 13,
  "score": 17.2,
  "yours": false,
  "topic_id": 1259,
  "topic_slug": "channel-depletion-ln-topology-cycles-and-rational-behavior-of-nodes",
  "topic_title": "Channel depletion, LN Topology, Cycles and rational behavior of nodes",
  "topic_html_title": "Channel depletion, LN Topology, Cycles and rational behavior of nodes",
  "category_id": 7,
  "display_username": "Anthony Towns",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"renepickhardt, post:3, topic:1259\"]\n* The red channels are those where the liquidity is on the cheaper end of the channel (contradicting your intuition that I have just created a \u201cmost expensive\u201d spanning tree.\n[/quote]\n\nAh, don't worry; I misunderstood the \"spanning tree\" part entirely.\n\nIn your example there are two cycles remaining: (B pays A pays C pays B), and (D pays A pays C pays D) -- I think my intuition is more along the lines of those being the minimally most expensive cycles? Is there such a thing as a spanning cycle, ie a cycle that touches every node? In this case I think my intuition would be that the remaining spanning cycle CDACBAC is more expensive than any other possible spanning cycle? (Perhaps provable by noting that any payment along that cycle will create a cheaper spanning cycle, providing a cheaper path from some node X to Y, than existed previously, so the next payment from X to Y will break that cheaper spanning cycle?)\n\n[quote=\"renepickhardt, post:3, topic:1259\"]\nI am not sure about your proposed simulation.\n[/quote]\n\nAgreed: that would only be interesting if nodes were ending up depleted, rather than just channels.\n\n[quote=\"renepickhardt, post:3, topic:1259\"]\nInstead of focusing on such a mixed model wouldn\u2019t it be more interesting to focus on how node operators should adjust their fees to help with flow control and adjust to channel depletion\n[/quote]\n\nI think you've already \"solved\" this (ok, without proof, perhaps)? The only way you avoid channel depletion is if your channel appears in the \"spanning tree in which the network is balanced\", so you either need to be structurally critical, or manage your fees with far more precision than is reasonably feasible. Otherwise you're just trying to drive straight by alternating between steering hard left and hard right... which okay, it might work, particularly if you can make the adjustments at high frequency, but sure seems pretty annoying.\n\nTo me, it makes sense that a policy of \"everyone will keep using the cheapest path that works\" will naturally exhaust the cheapest channels until the only ones that work are the \"most expensive\", per some global metric.\n\nTo me, it seems logical that the only way to avoid that resulting in channel depletion and routing errors/retries, is to have some way of having some payments \"not work\" for reasons other than channel depletion, in a way that is predictable when constructing the payment route. I continue to think [`max_msat` valves](https://web.archive.org/web/20231114193403/https://lists.linuxfoundation.org/pipermail/lightning-dev/2022-September/003686.html) are the way to solve this.\n\nActually an additional thought on that topic: as a forwarding node, if you advertise a `max_msat` value, then you could/should use that (or a small multiple of it) as a cap on the total value of payments you'll allow to be (recently) pending across that channel. If (in the usual case) the payment resolves \"immediately\" that's no constraint at all, which is great; but if someone splits their payment into 100 `max_msat` HTLCs and forwards them all over your channel, you'll immediately reject almost all of them, so there's ~no advantage in users attempting to finesse the signal to minimise fees. (\"recently\" -- if a payment has been unresolved for more than a few seconds, it's probably hung, and you don't want to continue to reject new payments because of it).",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": true,
  "admin": true,
  "staff": true,
  "user_id": 3,
  "hidden": false,
  "trust_level": 4,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "heart",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}