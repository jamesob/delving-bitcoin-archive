{
  "id": 6650,
  "name": "",
  "username": "conduition",
  "avatar_template": "/user_avatar/delvingbitcoin.org/conduition/{size}/384_2.png",
  "created_at": "2026-01-20T01:32:00.101Z",
  "cooked": "<blockquote>\n<p>Just to clarify the intended SHRINCS functionality as currently described: when a device imports a wallet seed, it must always use the stateless signing path.</p>\n</blockquote>\n<p>Unfortunately wallet software can\u2019t always be 100% certainty whether its seed is in use on multiple devices. Users can copy wallet data files between computers, or even do so accidentally, such as when cloning an entire operating system during a recovery from full-disk backup. As a real-world case-study, consider the unfortunate souls who\u2019ve lost coins to punishment transactions, as a result of restoring outdated states for lightning channels.</p>\n<p>Unlike with lightning though, a SHRINCS wallet may have <em>some</em> indication that state has been lost or corrupted. E.g. the wallet comes online and sees 10 new outgoing transactions created <em>after</em> the wallet was last opened. The wallet would probably have a chance to react before any grave errors are made.</p>\n<p>Another thing to consider is that state management only matters for keys which may have issued XMSS signatures. If state gets corrupted or the seed is imported, hot-wallets could heuristically guess things like: \u201cthis address never received any coins before, so we probably have never signed any messages with its XMSS key. Should be safe to use XMSS for this address if we ever end up with UTXOs there\u201d. Obviously this is fraught with risky assumptions on user behavior\u2026 but still, neat to have engineering options.</p>\n<blockquote>\n<p>One downside of letting wallets decide the tree structure is that it can leave fingerprints on the blockchain that are harmful to privacy. It\u2019s also slightly less efficient compared to <code>OP_SHRINCS</code> (because of the 16-byte hashes at NIST level one, compared to 32-byte hashes in the Taproot tree).</p>\n</blockquote>\n<p>Fair point. Simple solution for that: Instead of OP_WOTS, deploy OP_XMSS, and set the XMSS protocol to use NIST-1 length hashes with proper tweaking. Though i\u2019m unsure if the savings would be worthwhile given that most wallets should be effectively incentivized to avoid address reuse either way.</p>\n<blockquote>\n<p>Are there other use cases you have in mind that would particularly benefit from this modularity?</p>\n</blockquote>\n<p>Not particularly. It\u2019s an aesthetic/organizational preference from my PoV: Why introduce an opcode which is basically <code>OR(unbalanced_xmss_key, sphincs_key)</code>, if we already have tools to handle such binary logic for payment conditions already?</p>",
  "post_number": 9,
  "post_type": 1,
  "posts_count": 10,
  "updated_at": "2026-01-20T01:32:00.101Z",
  "reply_count": 1,
  "reply_to_post_number": 8,
  "quote_count": 0,
  "incoming_link_count": 1,
  "reads": 8,
  "readers_count": 7,
  "score": 26.6,
  "yours": false,
  "topic_id": 2158,
  "topic_slug": "shrincs-324-byte-stateful-post-quantum-signatures-with-static-backups",
  "topic_title": "SHRINCS: 324-byte stateful post-quantum signatures with static backups",
  "topic_html_title": "SHRINCS: 324-byte stateful post-quantum signatures with static backups",
  "category_id": 7,
  "display_username": "",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": "",
  "reply_to_user": {
    "id": 632,
    "username": "jonasnick",
    "name": "",
    "avatar_template": "/user_avatar/delvingbitcoin.org/jonasnick/{size}/1518_2.png"
  },
  "bookmarked": false,
  "raw": "> Just to clarify the intended SHRINCS functionality as currently described: when a device imports a wallet seed, it must always use the stateless signing path.\n\nUnfortunately wallet software can't always be 100% certainty whether its seed is in use on multiple devices. Users can copy wallet data files between computers, or even do so accidentally, such as when cloning an entire operating system during a recovery from full-disk backup. As a real-world case-study, consider the unfortunate souls who've lost coins to punishment transactions, as a result of restoring outdated states for lightning channels.\n\nUnlike with lightning though, a SHRINCS wallet may have _some_ indication that state has been lost or corrupted. E.g. the wallet comes online and sees 10 new outgoing transactions created _after_ the wallet was last opened. The wallet would probably have a chance to react before any grave errors are made.\n\nAnother thing to consider is that state management only matters for keys which may have issued XMSS signatures. If state gets corrupted or the seed is imported, hot-wallets could heuristically guess things like: \"this address never received any coins before, so we probably have never signed any messages with its XMSS key. Should be safe to use XMSS for this address if we ever end up with UTXOs there\". Obviously this is fraught with risky assumptions on user behavior... but still, neat to have engineering options.\n\n> One downside of letting wallets decide the tree structure is that it can leave fingerprints on the blockchain that are harmful to privacy. It\u2019s also slightly less efficient compared to `OP_SHRINCS` (because of the 16-byte hashes at NIST level one, compared to 32-byte hashes in the Taproot tree).\n\nFair point. Simple solution for that: Instead of OP_WOTS, deploy OP_XMSS, and set the XMSS protocol to use NIST-1 length hashes with proper tweaking. Though i'm unsure if the savings would be worthwhile given that most wallets should be effectively incentivized to avoid address reuse either way.\n\n> Are there other use cases you have in mind that would particularly benefit from this modularity?\n\nNot particularly. It's an aesthetic/organizational preference from my PoV: Why introduce an opcode which is basically `OR(unbalanced_xmss_key, sphincs_key)`, if we already have tools to handle such binary logic for payment conditions already?",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 129,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "Just to clarify the intended SHRINCS functionality as currently described: when a device imports a wallet seed, it must always use the stateless signing path. \n\nUnfortunately wallet software can\u2019t always be 100% certainty whether its seed is in use on multiple devices. Users can copy wallet data fi&hellip;",
  "truncated": true,
  "post_url": "/t/shrincs-324-byte-stateful-post-quantum-signatures-with-static-backups/2158/9",
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}