{
  "id": 6656,
  "name": "",
  "username": "jonasnick",
  "avatar_template": "/user_avatar/delvingbitcoin.org/jonasnick/{size}/1518_2.png",
  "created_at": "2026-01-21T07:53:06.011Z",
  "cooked": "<blockquote>\n<p>Users can copy wallet data files between computers, or even do so accidentally, such as when cloning an entire operating system during a recovery from full-disk backup.</p>\n</blockquote>\n<p>Yes, this is why I mentioned \u201cassume key generation happens on a signing device that is able to keep state securely.\u201d in the original post. It follows that the main deployment target for SHRINCS is dedicated signing devices where users do not have the ability to interfere with the state (intentionally or accidentally).</p>\n<p>Thinking out lout (half-baked idea follows): To use SHRINCS wallet on a desktop wallet it seems to be sufficient to find some place to store state that cannot be accidentally backed up. This is not my area of expertise, but it seems like a storage slot on the TPM could potentially be used for that. It provides the following functionality:</p>\n<ul>\n<li><code>Initialize(secret)</code>: Initializes the slot such that it can only be read or written to when the secret is presented.</li>\n<li><code>Write(secret, data)</code></li>\n<li><code>Read(secret) -&gt; data</code></li>\n</ul>\n<p>For security, we require that that the slot can really only be read/written with the secret. Thus, the data won\u2019t be part of a disk backup. Additionally, a <code>Read</code> will never return data that has been written to the slot before the last <code>Write</code>. For efficiency, we want that the slot is persistent (e.g., across reboots).</p>\n<p>On my Intel CPU, this sort of slot appears to be relatively easy to instantiate after installing <code>tpm2-tools</code>:</p>\n<ul>\n<li><code>tpm2_nvdefine \"$NV_INDEX\" -C o -s \"$MAX_SIZE\" -a \"authread|authwrite|no_da\" -p \"$AUTH_VALUE\"</code> initializes the slot at <code>$NV_INDEX</code> such that the string <code>$AUTH_VALUE</code> is required to read/write.</li>\n<li><code>echo -n \"$DATA_TO_WRITE\" | tpm2_nvwrite \"$NV_INDEX\" -C \"$NV_INDEX\" -P \"$AUTH_VALUE\" -i -</code> writes the data.</li>\n<li><code>tpm2_nvread \"$NV_INDEX\" -C \"$NV_INDEX\" -P \"$AUTH_VALUE\" -o \"$OUTPUT_FILE\"</code> reads the data.</li>\n</ul>\n<p>On NixOS, running the tool from a non-root user requires the user to be in the <code>tss</code> group.</p>\n<p>Using the secure slot, the software wallet could work as follows:</p>\n<ul>\n<li><code>Initialize()</code>: The wallet runs <code>(seed, pk, state) &lt;- SHRINCS.KeyGen()</code>, draws an authentication token <code>t</code> for the secure slot, runs <code>Slot.Initialize(t)</code>, <code>Slot.Write(t, hash(state))</code> and stores <code>(seed, pk, state, t)</code> on disk.</li>\n<li><code>Sign(m) -&gt; sig</code>: Read <code>(seed, pk, state, t)</code> from disk.\n<ul>\n<li>If <code>state != LOST</code>: Read <code>h' &lt;- Slot.Read(t)</code>. If <code>h' != hash(state)</code>, write <code>state := LOST</code> to disk and rerun <code>Sign(m)</code>. Otherwise, run <code>(state', sig) &lt;- SHRINCS.Sign(seed, state, m)</code>, write <code>hash(state') to the slot, write the updated </code>state\u2019` to disk and return the signature.</li>\n<li>Else, return SHRINCS.Sign(seed, state, m).</li>\n</ul>\n</li>\n</ul>\n<p>Unfortunately, this isn\u2019t really secure, because the user may run <code>Wallet.Sign</code> in parallel with different messages. Without some sort of lock, both invocations may load the same state from disk and get the same result from the slot.</p>",
  "post_number": 11,
  "post_type": 1,
  "posts_count": 11,
  "updated_at": "2026-01-21T07:53:06.011Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 10,
  "readers_count": 9,
  "score": 2.0,
  "yours": false,
  "topic_id": 2158,
  "topic_slug": "shrincs-324-byte-stateful-post-quantum-signatures-with-static-backups",
  "topic_title": "SHRINCS: 324-byte stateful post-quantum signatures with static backups",
  "topic_html_title": "SHRINCS: 324-byte stateful post-quantum signatures with static backups",
  "category_id": 7,
  "display_username": "",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "> Users can copy wallet data files between computers, or even do so accidentally, such as when cloning an entire operating system during a recovery from full-disk backup.\n\nYes, this is why I mentioned \"assume key generation happens on a signing device that is able to keep state securely.\" in the original post. It follows that the main deployment target for SHRINCS is dedicated signing devices where users do not have the ability to interfere with the state (intentionally or accidentally).\n\nThinking out lout (half-baked idea follows): To use SHRINCS wallet on a desktop wallet it seems to be sufficient to find some place to store state that cannot be accidentally backed up. This is not my area of expertise, but it seems like a storage slot on the TPM could potentially be used for that. It provides the following functionality:\n\n- `Initialize(secret)`: Initializes the slot such that it can only be read or written to when the secret is presented.\n- `Write(secret, data)`\n- `Read(secret) -> data`\n\nFor security, we require that that the slot can really only be read/written with the secret. Thus, the data won't be part of a disk backup. Additionally, a `Read` will never return data that has been written to the slot before the last `Write`. For efficiency, we want that the slot is persistent (e.g., across reboots).\n\nOn my Intel CPU, this sort of slot appears to be relatively easy to instantiate after installing `tpm2-tools`:\n- `tpm2_nvdefine \"$NV_INDEX\" -C o -s \"$MAX_SIZE\" -a \"authread|authwrite|no_da\" -p \"$AUTH_VALUE\"` initializes the slot at `$NV_INDEX` such that the string `$AUTH_VALUE` is required to read/write.\n- `echo -n \"$DATA_TO_WRITE\" | tpm2_nvwrite \"$NV_INDEX\" -C \"$NV_INDEX\" -P \"$AUTH_VALUE\" -i -` writes the data.\n- `tpm2_nvread \"$NV_INDEX\" -C \"$NV_INDEX\" -P \"$AUTH_VALUE\" -o \"$OUTPUT_FILE\"` reads the data.\n\nOn NixOS, running the tool from a non-root user requires the user to be in the `tss` group.\n\nUsing the secure slot, the software wallet could work as follows:\n\n- `Initialize()`: The wallet runs `(seed, pk, state) <- SHRINCS.KeyGen()`, draws an authentication token `t` for the secure slot, runs `Slot.Initialize(t)`, `Slot.Write(t, hash(state))` and stores `(seed, pk, state, t)` on disk.\n- `Sign(m) -> sig`: Read `(seed, pk, state, t)` from disk.\n  - If `state != LOST`: Read `h' <- Slot.Read(t)`. If `h' != hash(state)`, write `state := LOST` to disk and rerun `Sign(m)`. Otherwise, run `(state', sig) <- SHRINCS.Sign(seed, state, m)`, write `hash(state') to the slot, write the updated `state'` to disk and return the signature.\n  - Else, return SHRINCS.Sign(seed, state, m).\n\nUnfortunately, this isn't really secure, because the user may run `Wallet.Sign` in parallel with different messages. Without some sort of lock, both invocations may load the same state from disk and get the same result from the slot.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 632,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "Users can copy wallet data files between computers, or even do so accidentally, such as when cloning an entire operating system during a recovery from full-disk backup. \n\nYes, this is why I mentioned \u201cassume key generation happens on a signing device that is able to keep state securely.\u201d in the ori&hellip;",
  "truncated": true,
  "post_url": "/t/shrincs-324-byte-stateful-post-quantum-signatures-with-static-backups/2158/11",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}