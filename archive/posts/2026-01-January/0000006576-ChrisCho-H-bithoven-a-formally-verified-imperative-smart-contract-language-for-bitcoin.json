{
  "id": 6576,
  "name": "Chris Hyunhum Cho",
  "username": "ChrisCho-H",
  "avatar_template": "/user_avatar/delvingbitcoin.org/chrischo-h/{size}/1744_2.png",
  "created_at": "2026-01-06T18:23:50.652Z",
  "cooked": "<p>Hi everyone,</p>\n<p>I\u2019ve been working on a new smart contract language called <strong>Bithoven</strong>, and I wanted to share the v0.0.1 release along with an implementation, Web IDE, and the formal verification paper we just published on arXiv.</p>\n<p>While Miniscript excels at policy analysis and structural correctness, its grammar and syntax can feel difficult for developers used to imperative control flow. I wanted to see if we could have a C-like imperative syntax (<code>if/else</code>, explicit variables) that still compiles down to safe, optimized Bitcoin Script.</p>\n<h3><a name=\"p-6576-the-approach-1\" class=\"anchor\" href=\"#p-6576-the-approach-1\"></a>The Approach</h3>\n<p>Bithoven uses an <code>LR(1)</code> parser and static analysis to enforce type safety and prevent some known security bug(e.g. no sig required to spend) before compilation. The compiler handles the stack management(e.g. <code>OP_SWAP</code>), opcode optimization(e.g. <code>OP_EQUAL + OP_VERIFY = OP_EQUALVERIFY</code>) and target separation(e.g. <code>legacy</code>, <code>segwit</code> and <code>taproot</code>). To ensure we aren\u2019t introducing undefined behavior during that translation, we formally defined the language\u2019s semantics and proved its safety properties.</p>\n<h3><a name=\"p-6576-example-htlc-2\" class=\"anchor\" href=\"#p-6576-example-htlc-2\"></a>Example (HTLC)</h3>\n<p>Here is a quick look at how it handles conditional paths. The stack inputs are defined explicitly at the top to guide the compiler:</p>\n<pre data-code-wrap=\"solidity\"><code class=\"lang-solidity\">pragma bithoven version 0.0.1;\npragma bithoven target segwit;\n\n/* * Stack Input Definitions\n * Each line defines a valid input stack configuration for a spending path.\n */\n(condition: bool, sig_alice: signature)\n(condition: bool, preimage: string, sig_bob: signature)\n\n{\n    // If 'condition' is true, we enter the Refund Path (Alice)\n    if condition {\n        // Enforce relative timelock of 1000 blocks\n        older 1000;\n\n        // If timelock is satisfied, Alice can spend with her signature\n        return checksig(sig_alice, \"0245a6b3f8eeab8e88501a9a25391318dce9bf35e24c377ee82799543606bf5212\");\n\n    } else {\n        // Redeem Path (Bob)\n        // Bob must reveal the secret preimage that hashes to the expected value\n        verify sha256(sha256(preimage)) == \"53de742e2e323e3290234052a702458589c30d2c813bf9f866bef1b651c4e45f\";\n\n        // If hash matches, Bob can spend with his signature\n        return checksig(sig_bob, \"0345a6b3f8eeab8e88501a9a25391318dce9bf35e24c377ee82799543606bf5212\");\n    }\n}\n</code></pre>\n<h3><a name=\"p-6576-design-philosophy-syntax-and-grammar-3\" class=\"anchor\" href=\"#p-6576-design-philosophy-syntax-and-grammar-3\"></a>Design Philosophy (Syntax and Grammar)</h3>\n<p>To maintain safety, Bithoven enforces a strict distinction between Statements and Expressions:</p>\n<p>Statements must start with followings</p>\n<ul>\n<li><code>verify</code>: This compiles down to <code>OP_VERIFY</code>. I designed statements to consume stack items without leaving leftovers. This simplifies stack management, ensuring that after every statement, the stack is clean. As every statement starts with <code>verify</code>, any expression argument of <code>verify</code> is available, which is evaluated to value(pushing the item on the stack, but removed by <code>verify</code> at the end).</li>\n<li><code>older</code> and <code>after</code>: This is same with miniscript policy. I allowed it as statement as it doesn\u2019t leave any on the stack(if with <code>OP_DROP</code>), similar to <code>verify</code>.</li>\n<li><code>return</code>: The terminal statement for each branch. It ensures the final top stack item is not empty, making the UTXO spendable.</li>\n</ul>\n<p>Expressions can express most of bitcoin opcodes except stack managment opcode(excluded intentionally as it\u2019s a high level language), with intuitive syntax.</p>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Category</th>\n<th style=\"text-align:left\">Bithoven Syntax</th>\n<th style=\"text-align:left\">Bitcoin Opcode</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>Mathematics</strong></td>\n<td style=\"text-align:left\"><code>+</code></td>\n<td style=\"text-align:left\"><code>OP_ADD</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>-</code></td>\n<td style=\"text-align:left\"><code>OP_SUB</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>++</code></td>\n<td style=\"text-align:left\"><code>OP_1ADD</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>--</code></td>\n<td style=\"text-align:left\"><code>OP_1SUB</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>max</code></td>\n<td style=\"text-align:left\"><code>OP_MAX</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>min</code></td>\n<td style=\"text-align:left\"><code>OP_MIN</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>negate</code></td>\n<td style=\"text-align:left\"><code>OP_NEGATE</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>abs</code></td>\n<td style=\"text-align:left\"><code>OP_ABS</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Logic &amp; Comparison</strong></td>\n<td style=\"text-align:left\"><code>&amp;&amp;</code></td>\n<td style=\"text-align:left\"><code>OP_BOOLAND</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>||</code></td>\n<td style=\"text-align:left\"><code>OP_BOOLOR</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>==</code></td>\n<td style=\"text-align:left\"><code>OP_(NUM)EQUAL</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>!=</code></td>\n<td style=\"text-align:left\"><code>OP_(NUM)NOTEQUAL</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>&lt;</code></td>\n<td style=\"text-align:left\"><code>OP_LESSTHAN</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>&gt;</code></td>\n<td style=\"text-align:left\"><code>OP_GREATERTHAN</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>&lt;=</code></td>\n<td style=\"text-align:left\"><code>OP_LESSTHANOREQUAL</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>&gt;=</code></td>\n<td style=\"text-align:left\"><code>OP_GREATERTHANOREQUAL</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>!</code></td>\n<td style=\"text-align:left\"><code>OP_NOT</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Cryptography</strong></td>\n<td style=\"text-align:left\"><code>sha256</code></td>\n<td style=\"text-align:left\"><code>OP_SHA256</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>ripemd160</code></td>\n<td style=\"text-align:left\"><code>OP_RIPEMD160</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Byte Operations</strong></td>\n<td style=\"text-align:left\"><code>len</code></td>\n<td style=\"text-align:left\"><code>OP_SIZE</code></td>\n</tr>\n</tbody>\n</table>\n</div><h3><a name=\"p-6576-resources-4\" class=\"anchor\" href=\"#p-6576-resources-4\"></a>Resources</h3>\n<ul>\n<li><strong>Repo:</strong> <a href=\"https://github.com/ChrisCho-H/bithoven\" rel=\"noopener nofollow ugc\">https://github.com/ChrisCho-H/bithoven</a></li>\n<li><strong>Web IDE:</strong> <a href=\"https://bithoven-lang.github.io/bithoven/ide/\" rel=\"noopener nofollow ugc\">https://bithoven-lang.github.io/bithoven/ide/</a></li>\n<li><strong>Docs:</strong> <a href=\"https://bithoven-lang.github.io/bithoven/docs/\" rel=\"noopener nofollow ugc\">https://bithoven-lang.github.io/bithoven/docs/</a></li>\n<li><strong>Paper (arXiv):</strong> <a href=\"https://arxiv.org/abs/2601.01436\" rel=\"noopener nofollow ugc\">https://arxiv.org/abs/2601.01436</a> (Contains the operational semantics and correctness proofs)</li>\n</ul>\n<p>I would appreciate any feedback regarding the implementation, compiler design, and the formal proofs in the paper. As this is very early stage beta implementation, there could be specific edge cases that we\u2019ve missed.</p>\n<p>Thanks!</p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 1,
  "updated_at": "2026-01-06T18:23:50.652Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 14,
  "readers_count": 13,
  "score": 17.6,
  "yours": false,
  "topic_id": 2189,
  "topic_slug": "bithoven-a-formally-verified-imperative-smart-contract-language-for-bitcoin",
  "topic_title": "Bithoven: A Formally Verified, Imperative Smart Contract Language for Bitcoin",
  "topic_html_title": "Bithoven: A Formally Verified, Imperative Smart Contract Language for Bitcoin",
  "category_id": 8,
  "display_username": "Chris Hyunhum Cho",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Hi everyone,\n\nI\u2019ve been working on a new smart contract language called **Bithoven**, and I wanted to share the v0.0.1 release along with an implementation, Web IDE, and the formal verification paper we just published on arXiv.\n\nWhile Miniscript excels at policy analysis and structural correctness, its grammar and syntax can feel difficult for developers used to imperative control flow. I wanted to see if we could have a C-like imperative syntax (`if/else`, explicit variables) that still compiles down to safe, optimized Bitcoin Script.\n\n### The Approach\n\nBithoven uses an `LR(1)` parser and static analysis to enforce type safety and prevent some known security bug(e.g. no sig required to spend) before compilation. The compiler handles the stack management(e.g. `OP_SWAP`), opcode optimization(e.g. `OP_EQUAL + OP_VERIFY = OP_EQUALVERIFY`) and target separation(e.g. `legacy`, `segwit` and `taproot`). To ensure we aren't introducing undefined behavior during that translation, we formally defined the language's semantics and proved its safety properties.\n\n### Example (HTLC)\n\nHere is a quick look at how it handles conditional paths. The stack inputs are defined explicitly at the top to guide the compiler:\n\n```solidity\npragma bithoven version 0.0.1;\npragma bithoven target segwit;\n\n/* * Stack Input Definitions\n * Each line defines a valid input stack configuration for a spending path.\n */\n(condition: bool, sig_alice: signature)\n(condition: bool, preimage: string, sig_bob: signature)\n\n{\n    // If 'condition' is true, we enter the Refund Path (Alice)\n    if condition {\n        // Enforce relative timelock of 1000 blocks\n        older 1000;\n\n        // If timelock is satisfied, Alice can spend with her signature\n        return checksig(sig_alice, \"0245a6b3f8eeab8e88501a9a25391318dce9bf35e24c377ee82799543606bf5212\");\n\n    } else {\n        // Redeem Path (Bob)\n        // Bob must reveal the secret preimage that hashes to the expected value\n        verify sha256(sha256(preimage)) == \"53de742e2e323e3290234052a702458589c30d2c813bf9f866bef1b651c4e45f\";\n\n        // If hash matches, Bob can spend with his signature\n        return checksig(sig_bob, \"0345a6b3f8eeab8e88501a9a25391318dce9bf35e24c377ee82799543606bf5212\");\n    }\n}\n```\n\n### Design Philosophy (Syntax and Grammar) \n\nTo maintain safety, Bithoven enforces a strict distinction between Statements and Expressions:\n\nStatements must start with followings\n- `verify`: This compiles down to `OP_VERIFY`. I designed statements to consume stack items without leaving leftovers. This simplifies stack management, ensuring that after every statement, the stack is clean. As every statement starts with `verify`, any expression argument of `verify` is available, which is evaluated to value(pushing the item on the stack, but removed by `verify` at the end).\n- `older` and `after`: This is same with miniscript policy. I allowed it as statement as it doesn't leave any on the stack(if with `OP_DROP`), similar to `verify`.\n- `return`: The terminal statement for each branch. It ensures the final top stack item is not empty, making the UTXO spendable.\n\nExpressions can express most of bitcoin opcodes except stack managment opcode(excluded intentionally as it's a high level language), with intuitive syntax.\n\n| Category | Bithoven Syntax | Bitcoin Opcode |\n| :--- | :--- | :--- |\n| **Mathematics** | `+` | `OP_ADD` |\n| | `-` | `OP_SUB` |\n| | `++` | `OP_1ADD` |\n| | `--` | `OP_1SUB` |\n| | `max` | `OP_MAX` |\n| | `min` | `OP_MIN` |\n| | `negate` | `OP_NEGATE` |\n| | `abs` | `OP_ABS` |\n| **Logic & Comparison** | `&&` | `OP_BOOLAND` |\n| | `\\|\\|` | `OP_BOOLOR` |\n| | `==` | `OP_(NUM)EQUAL` |\n| | `!=` | `OP_(NUM)NOTEQUAL` |\n| | `<` | `OP_LESSTHAN` |\n| | `>` | `OP_GREATERTHAN` |\n| | `<=` | `OP_LESSTHANOREQUAL` |\n| | `>=` | `OP_GREATERTHANOREQUAL` |\n| | `!` | `OP_NOT` |\n| **Cryptography** | `sha256` | `OP_SHA256` |\n| | `ripemd160` | `OP_RIPEMD160` |\n| **Byte Operations** | `len` | `OP_SIZE` |\n\n\n### Resources\n\n* **Repo:** [https://github.com/ChrisCho-H/bithoven](https://github.com/ChrisCho-H/bithoven)\n* **Web IDE:** [https://bithoven-lang.github.io/bithoven/ide/](https://bithoven-lang.github.io/bithoven/ide/)\n* **Docs:** [https://bithoven-lang.github.io/bithoven/docs/](https://bithoven-lang.github.io/bithoven/docs/)\n* **Paper (arXiv):** [https://arxiv.org/abs/2601.01436](https://arxiv.org/abs/2601.01436) (Contains the operational semantics and correctness proofs)\n\n\nI would appreciate any feedback regarding the implementation, compiler design, and the formal proofs in the paper. As this is very early stage beta implementation, there could be specific edge cases that we've missed. \n\nThanks!",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 1024,
  "hidden": false,
  "trust_level": 0,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "Hi everyone, \nI\u2019ve been working on a new smart contract language called Bithoven, and I wanted to share the v0.0.1 release along with an implementation, Web IDE, and the formal verification paper we just published on arXiv. \nWhile Miniscript excels at policy analysis and structural correctness, its &hellip;",
  "truncated": true,
  "post_url": "/t/bithoven-a-formally-verified-imperative-smart-contract-language-for-bitcoin/2189/1",
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}