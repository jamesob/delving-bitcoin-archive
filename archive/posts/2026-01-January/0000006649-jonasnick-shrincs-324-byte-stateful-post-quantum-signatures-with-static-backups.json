{
  "id": 6649,
  "name": "",
  "username": "jonasnick",
  "avatar_template": "/user_avatar/delvingbitcoin.org/jonasnick/{size}/1518_2.png",
  "created_at": "2026-01-19T17:14:29.961Z",
  "cooked": "<p>Thanks <a class=\"mention\" href=\"/u/conduition\">@conduition</a> for the feedback.</p>\n<blockquote>\n<p>Or consider cases where users duplicate the same wallet seed onto different devices.</p>\n</blockquote>\n<p>Just to clarify the intended SHRINCS functionality as currently described: when a device imports a wallet seed, it must always use the stateless signing path. Only the device that originally generated the seed is permitted to use the stateful path. This is definitely a restriction which would need to be relaxed to allow fully offline seed generation, for example.</p>\n<blockquote>\n<p>host computer could cause a hardware wallet to accidentally reset its state by strategic power-cycling</p>\n</blockquote>\n<p>I agree that there are still pitfalls like this. It would be very interesting to hear from hardware wallet developers about how feasible it is in practice to keep state securely.</p>\n<blockquote>\n<p>Another way to frame SHRINCS would be to standardize two schemes in tapscript and let wallets decide which to use and how to structure them inside script trees</p>\n</blockquote>\n<p>So this would effectively introduce <code>OP_SPHINCS</code> and <code>OP_WOTS</code> rather than a single <code>OP_SHRINCS</code>, and let wallets implement the <code>SHRINCS</code> scheme via the Taproot tree. I agree this is a valid approach.</p>\n<p>I also think a standalone <code>OP_SPHINCS</code> could be valuable on its own, since some wallets may want to use a hash-based signature scheme but cannot keep state at all. Are there other use cases you have in mind that would particularly benefit from this modularity?</p>\n<p>One downside of letting wallets decide the tree structure is that it can leave fingerprints on the blockchain that are harmful to privacy. It\u2019s also slightly less efficient compared to <code>OP_SHRINCS</code> (because of the 16-byte hashes at NIST level one, compared to 32-byte hashes in the Taproot tree).</p>",
  "post_number": 8,
  "post_type": 1,
  "posts_count": 8,
  "updated_at": "2026-01-19T17:14:29.961Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 7,
  "readers_count": 6,
  "score": 1.2,
  "yours": false,
  "topic_id": 2158,
  "topic_slug": "shrincs-324-byte-stateful-post-quantum-signatures-with-static-backups",
  "topic_title": "SHRINCS: 324-byte stateful post-quantum signatures with static backups",
  "topic_html_title": "SHRINCS: 324-byte stateful post-quantum signatures with static backups",
  "category_id": 7,
  "display_username": "",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Thanks @conduition for the feedback.\n\n> Or consider cases where users duplicate the same wallet seed onto different devices.\n\nJust to clarify the intended SHRINCS functionality as currently described: when a device imports a wallet seed, it must always use the stateless signing path. Only the device that originally generated the seed is permitted to use the stateful path. This is definitely a restriction which would need to be relaxed to allow fully offline seed generation, for example.\n\n> host computer could cause a hardware wallet to accidentally reset its state by strategic power-cycling\n\nI agree that there are still pitfalls like this. It would be very interesting to hear from hardware wallet developers about how feasible it is in practice to keep state securely.\n\n> Another way to frame SHRINCS would be to standardize two schemes in tapscript and let wallets decide which to use and how to structure them inside script trees\n\nSo this would effectively introduce `OP_SPHINCS` and `OP_WOTS` rather than a single `OP_SHRINCS`, and let wallets implement the `SHRINCS` scheme via the Taproot tree. I agree this is a valid approach.\n\nI also think a standalone `OP_SPHINCS` could be valuable on its own, since some wallets may want to use a hash-based signature scheme but cannot keep state at all. Are there other use cases you have in mind that would particularly benefit from this modularity?\n\nOne downside of letting wallets decide the tree structure is that it can leave fingerprints on the blockchain that are harmful to privacy. It's also slightly less efficient compared to `OP_SHRINCS` (because of the 16-byte hashes at NIST level one, compared to 32-byte hashes in the Taproot tree).",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 632,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "Thanks <a class=\"mention\" href=\"/u/conduition\">@conduition</a> for the feedback. \n\nOr consider cases where users duplicate the same wallet seed onto different devices. \n\nJust to clarify the intended SHRINCS functionality as currently described: when a device imports a wallet seed, it must always use the stateless signing path. Only the device&hellip;",
  "truncated": true,
  "post_url": "/t/shrincs-324-byte-stateful-post-quantum-signatures-with-static-backups/2158/8",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}