{
  "id": 4751,
  "name": "salvatoshi",
  "username": "salvatoshi",
  "avatar_template": "/user_avatar/delvingbitcoin.org/salvatoshi/{size}/72_2.png",
  "created_at": "2025-04-12T15:37:45.129Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"AntoineP\" data-post=\"6\" data-topic=\"1527\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/antoinep/48/483_2.png\" class=\"avatar\"> AntoineP:</div>\n<blockquote>\n<p>However i think we should try to avoid the spillover effect across inputs you are introducing with the amount checks. I know there already exist some spillover effects through <code>CLTV</code>, but i think adding more such cases is the wrong direction to go.</p>\n</blockquote>\n</aside>\n<p>Can you elaborate on why?\nValidity is necessarily meaningful only at transaction-level. So I don\u2019t know what you mean by \u201cspill-over\u201d - these new validation rules are by definition at transaction-level, the same way that CHECKSIG is.</p>\n<p>On the opposite direction, it might be interesting to attempt a refactoring/simplification of the validation code so that jobs in <code>ConnectBlock</code> receive <em>transactions</em> to validate, rather than input scripts. That\u2019s where the implementation complexity of any kind of cross-input logic stems from (because of the added synchronization code), and I strongly suspect that input-level parallelism doesn\u2019t bring any measurable improvement in performance. Of course, this would need to be validated with benchmarks.</p>\n<aside class=\"quote no-group\" data-username=\"AntoineP\" data-post=\"6\" data-topic=\"1527\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/antoinep/48/483_2.png\" class=\"avatar\"> AntoineP:</div>\n<blockquote>\n<p>I think it\u2019s possible to avoid by using an indirection akin to that of <code>CSV</code> for instance. The constraint(s) set on output amounts could be enforced as a new field in each input. Say in the annex. The field would specify a list of (constraint type, output index, optional amount) per input. For your use here the constraint types would be either sweep or deduct (equivalent to your <em>default</em> and <em>deduct</em>).</p>\n</blockquote>\n</aside>\n<p>Thanks for demonstrating the approach. It would of course work, although I do see some downsides, while it\u2019s not too yet clear to me what are the benefits.</p>\n<p>I think you can remove the optional amount from the constraint (which is not used in CCV, since in the <em>deduct</em> mode, the amount must equal exactly the output\u2019s amount).</p>\n<p>The annex is only enforced by a signature, but signatures already cover output Scripts and amounts.\nSo this is only meaningful if the constraints are <em>also</em> enforced in full by the opcode (CCV or any other new opcodes that might want to use this feature). Therefore, the opcode has to repeat in full the constraint as it appears in the annex, doubling the number of bytes needed to express it. That can be reduced to just a couple of bytes per constraint, so maybe that\u2019s not too bad for CCV in terms of byte cost.</p>\n<p>Some care would also need to be taken to make sure that the annex is not malleable (as the input Script could use CCV without any signature).</p>\n<p>As a side note, I think a solution using the annex would be very similar in implementation complexity to my previous attempt in <a href=\"https://github.com/bitcoin-inquisition/bitcoin/compare/4e23c3a9867eedadb9e20387936ec9f0eca6e918...Merkleize:bitcoin:34f05028661932b417b59bdcdd58f4453f19cec5\" rel=\"noopener nofollow ugc\">this diff</a>, on inquisition, based on the <em>deferred checks framework</em> from James O\u2019Beirne\u2019s OP_VAULT PR (particularly, <a href=\"https://github.com/bitcoin-inquisition/bitcoin/commit/32c9b122d72b3748051c979ce2d46f07a48c44cc\" rel=\"noopener nofollow ugc\">this commit</a>). While that avoids the explicit synchronization, it\u2019s quite a bit more complex than the code based on the mutex.</p>\n<p>For an implementation based on the annex, I\u2019d expect very similar complexity, as what\u2019s accumulated in the deferred checks is isomorphic to what would be in the annex in your approach.</p>",
  "post_number": 7,
  "post_type": 1,
  "posts_count": 13,
  "updated_at": "2025-04-12T15:37:45.129Z",
  "reply_count": 2,
  "reply_to_post_number": 6,
  "quote_count": 1,
  "incoming_link_count": 2,
  "reads": 29,
  "readers_count": 28,
  "score": 25.8,
  "yours": false,
  "topic_id": 1527,
  "topic_slug": "op-checkcontractverify-and-its-amount-semantic",
  "topic_title": "OP_CHECKCONTRACTVERIFY and its amount semantic",
  "topic_html_title": "OP_CHECKCONTRACTVERIFY and its amount semantic",
  "category_id": 7,
  "display_username": "salvatoshi",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"AntoineP, post:6, topic:1527\"]\nHowever i think we should try to avoid the spillover effect across inputs you are introducing with the amount checks. I know there already exist some spillover effects through `CLTV`, but i think adding more such cases is the wrong direction to go.\n[/quote]\n\nCan you elaborate on why?\nValidity is necessarily meaningful only at transaction-level. So I don't know what you mean by \"spill-over\" - these new validation rules are by definition at transaction-level, the same way that CHECKSIG is.\n\nOn the opposite direction, it might be interesting to attempt a refactoring/simplification of the validation code so that jobs in `ConnectBlock` receive _transactions_ to validate, rather than input scripts. That's where the implementation complexity of any kind of cross-input logic stems from (because of the added synchronization code), and I strongly suspect that input-level parallelism doesn't bring any measurable improvement in performance. Of course, this would need to be validated with benchmarks.\n\n\n[quote=\"AntoineP, post:6, topic:1527\"]\nI think it\u2019s possible to avoid by using an indirection akin to that of `CSV` for instance. The constraint(s) set on output amounts could be enforced as a new field in each input. Say in the annex. The field would specify a list of (constraint type, output index, optional amount) per input. For your use here the constraint types would be either sweep or deduct (equivalent to your *default* and *deduct*).\n[/quote]\n\nThanks for demonstrating the approach. It would of course work, although I do see some downsides, while it's not too yet clear to me what are the benefits.\n\nI think you can remove the optional amount from the constraint (which is not used in CCV, since in the *deduct* mode, the amount must equal exactly the output's amount).\n\nThe annex is only enforced by a signature, but signatures already cover output Scripts and amounts.\nSo this is only meaningful if the constraints are _also_ enforced in full by the opcode (CCV or any other new opcodes that might want to use this feature). Therefore, the opcode has to repeat in full the constraint as it appears in the annex, doubling the number of bytes needed to express it. That can be reduced to just a couple of bytes per constraint, so maybe that's not too bad for CCV in terms of byte cost.\n\nSome care would also need to be taken to make sure that the annex is not malleable (as the input Script could use CCV without any signature).\n\nAs a side note, I think a solution using the annex would be very similar in implementation complexity to my previous attempt in [this diff](https://github.com/bitcoin-inquisition/bitcoin/compare/4e23c3a9867eedadb9e20387936ec9f0eca6e918...Merkleize:bitcoin:34f05028661932b417b59bdcdd58f4453f19cec5), on inquisition, based on the *deferred checks framework* from James O'Beirne's OP_VAULT PR (particularly, [this commit](https://github.com/bitcoin-inquisition/bitcoin/commit/32c9b122d72b3748051c979ce2d46f07a48c44cc)). While that avoids the explicit synchronization, it's quite a bit more complex than the code based on the mutex.\n\nFor an implementation based on the annex, I'd expect very similar complexity, as what's accumulated in the deferred checks is isomorphic to what would be in the annex in your approach.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 81,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "Can you elaborate on why?\nValidity is necessarily meaningful only at transaction-level. So I don\u2019t know what you mean by \u201cspill-over\u201d - these new validation rules are by definition at transaction-level, the same way that CHECKSIG is. \nOn the opposite direction, it might be interesting to attempt a &hellip;",
  "truncated": true,
  "post_url": "/t/op-checkcontractverify-and-its-amount-semantic/1527/7",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}