{
  "id": 4826,
  "name": "Pieter Wuille",
  "username": "sipa",
  "avatar_template": "/user_avatar/delvingbitcoin.org/sipa/{size}/1100_2.png",
  "created_at": "2025-04-18T12:31:09.945Z",
  "cooked": "<p>I have <a href=\"https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303/68\">posted</a> a comparison of this algorithm (SFL) with the GGT parametric min-cut algorithm, and the existing candidate set searching (CSS) algorithm from the other thread.</p>\n<hr>\n<p>Here are some of the open problems still with SFL:</p>\n<ul>\n<li><strong>Termination</strong>: there is a proof that if SFL terminates, the result is an optimal linearization. <s>However, there is no proof that it always will, even though fuzzing seems to indicate that the \u201cmerge chunks by maximum feerate difference\u201d heuristic is sufficient to never cause the same state to be repeated (which would suffice for termination, as there is only a finite number of possible states).</s> EDIT: it is not guaranteed to terminate.\n<ul>\n<li><strong>Complexity bound</strong>: it would be good to have some bound on how many iterations the algorithm can go through. If the above observation (no repeated states) holds, then there is some bound on the number of iterations, as there are at most <span class=\"math\">2^m</span> states, but this is not a very interesting bound. Somewhat stronger bounds are possible by taking into account that no more than <span class=\"math\">n-1</span> dependencies can be active, and that they form a spanning forest, but it remains exponential.</li>\n</ul>\n</li>\n<li><s><strong>Equal-feerate chunk splitting</strong>: The algorithm works if splits are applied whenever the top subset has <em>strictly</em> higher feerate than the bottom, and merges whenever the bottom has <em>higher or equal</em> feerate as the top. If instead splits are done when the top has higher-or-equal feerate, the algorithm may loop forever. If instead merged are only done when the bottom has strictly higher feerate than the top, the result may not be topological. The result of this is that the chunks that come out may be contain multiple equal-feerate components that could be split in a topologically-valid manner, i.e., become separate equal-feerate chunks. It would be nice to find an algorithm that can efficiently find these, whether that\u2019s done as part of SFL, or as a separate post-processing step. Note that this is not simply finding connected components within the chunks: the SFL chunks are <em>always</em> connected already.</s> EDIT: solved, see <a href=\"https://delvingbitcoin.org/t/spanning-forest-cluster-linearization/1419/9\">post</a> below.\n<ul>\n<li><strong>Sub-chunk linearization</strong>: Somewhat related, SFL provides no way to order the transactions within a chunk. This only matters for block building with <a href=\"https://delvingbitcoin.org/t/cluster-mempool-block-building-with-sub-chunk-granularity/1044\">sub-chunk granularity</a>, but intuitively, it feels like there is some information within the SFL state that may be useful. When a chunk is repeatedly split and re-merges with itself, it feels to me like it is really improving some implied sub-chunk linearization, until that sub-chunk linearization becomes good enough that it permanently splits the chunk in two. An \u201coptimal sub-chunk linearization\u201d would imply splitting equal-feerate chunks too, though beyond that, it\u2019s not clear how to define optimality here.</li>\n</ul>\n</li>\n<li><strong>LIMO-like improvements</strong>: It would be useful if one could take an SFL state, and a topologically-valid subset, and make directed improvement steps such that the corresponding linearization is at least as good as moving that subset to the front of the linearization. This would permit things like mixing in ancestor sets into the state.\n<ul>\n<li><strong>Merging states</strong>: a more general question is, can one, given two SFL states (sets of active dependencies) efficiently find a third SFL state whose linearization is at least as good as both linearizations corresponding to the input states? This is trivially possibly by extracting linearizations from both, applying the <a href=\"https://delvingbitcoin.org/t/merging-incomparable-linearizations/209/1\">linearization merging</a> algorithm, and converting those back to SFL, which is all possible in <span class=\"math\">\\mathcal{O}(n^2)</span>, but this loses valuable information. A final SFL state lets one decide that the corresponding linearization is optimal (by not having any more splits or merges to apply) in <span class=\"math\">\\mathcal{O}(n^2)</span> time, while doing that for just a linearization is as far I know equivalent to computing a (single) min-cut, which is <span class=\"math\">\\mathcal{O}(n^3)</span> even with the most state-of-the-art algorithms.</li>\n</ul>\n</li>\n</ul>",
  "post_number": 3,
  "post_type": 1,
  "posts_count": 9,
  "updated_at": "2025-05-24T14:34:59.246Z",
  "reply_count": 1,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 2,
  "reads": 31,
  "readers_count": 30,
  "score": 21.2,
  "yours": false,
  "topic_id": 1419,
  "topic_slug": "spanning-forest-cluster-linearization",
  "topic_title": "Spanning-forest cluster linearization",
  "topic_html_title": "Spanning-forest cluster linearization",
  "category_id": 8,
  "display_username": "Pieter Wuille",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 4,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "I have [posted](https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303/68) a comparison of this algorithm (SFL) with the GGT parametric min-cut algorithm, and the existing candidate set searching (CSS) algorithm from the other thread.\n\n---\n\nHere are some of the open problems still with SFL:\n* **Termination**: there is a proof that if SFL terminates, the result is an optimal linearization. ~~However, there is no proof that it always will, even though fuzzing seems to indicate that the \"merge chunks by maximum feerate difference\" heuristic is sufficient to never cause the same state to be repeated (which would suffice for termination, as there is only a finite number of possible states).~~ EDIT: it is not guaranteed to terminate.\n  * **Complexity bound**: it would be good to have some bound on how many iterations the algorithm can go through. If the above observation (no repeated states) holds, then there is some bound on the number of iterations, as there are at most $2^m$ states, but this is not a very interesting bound. Somewhat stronger bounds are possible by taking into account that no more than $n-1$ dependencies can be active, and that they form a spanning forest, but it remains exponential.\n* ~~**Equal-feerate chunk splitting**: The algorithm works if splits are applied whenever the top subset has *strictly* higher feerate than the bottom, and merges whenever the bottom has *higher or equal* feerate as the top. If instead splits are done when the top has higher-or-equal feerate, the algorithm may loop forever. If instead merged are only done when the bottom has strictly higher feerate than the top, the result may not be topological. The result of this is that the chunks that come out may be contain multiple equal-feerate components that could be split in a topologically-valid manner, i.e., become separate equal-feerate chunks. It would be nice to find an algorithm that can efficiently find these, whether that's done as part of SFL, or as a separate post-processing step. Note that this is not simply finding connected components within the chunks: the SFL chunks are *always* connected already.~~ EDIT: solved, see [post](https://delvingbitcoin.org/t/spanning-forest-cluster-linearization/1419/9) below.\n  * **Sub-chunk linearization**: Somewhat related, SFL provides no way to order the transactions within a chunk. This only matters for block building with [sub-chunk granularity](https://delvingbitcoin.org/t/cluster-mempool-block-building-with-sub-chunk-granularity/1044), but intuitively, it feels like there is some information within the SFL state that may be useful. When a chunk is repeatedly split and re-merges with itself, it feels to me like it is really improving some implied sub-chunk linearization, until that sub-chunk linearization becomes good enough that it permanently splits the chunk in two. An \"optimal sub-chunk linearization\" would imply splitting equal-feerate chunks too, though beyond that, it's not clear how to define optimality here.\n* **LIMO-like improvements**: It would be useful if one could take an SFL state, and a topologically-valid subset, and make directed improvement steps such that the corresponding linearization is at least as good as moving that subset to the front of the linearization. This would permit things like mixing in ancestor sets into the state.\n  * **Merging states**: a more general question is, can one, given two SFL states (sets of active dependencies) efficiently find a third SFL state whose linearization is at least as good as both linearizations corresponding to the input states? This is trivially possibly by extracting linearizations from both, applying the [linearization merging](https://delvingbitcoin.org/t/merging-incomparable-linearizations/209/1) algorithm, and converting those back to SFL, which is all possible in $\\mathcal{O}(n^2)$, but this loses valuable information. A final SFL state lets one decide that the corresponding linearization is optimal (by not having any more splits or merges to apply) in $\\mathcal{O}(n^2)$ time, while doing that for just a linearization is as far I know equivalent to computing a (single) min-cut, which is $\\mathcal{O}(n^3)$ even with the most state-of-the-art algorithms.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 96,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "I have <a href=\"https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303/68\">posted</a> a comparison of this algorithm (SFL) with the GGT parametric min-cut algorithm, and the existing candidate set searching (CSS) algorithm from the other thread. \n\nHere are some of the open problems still with SFL: \n\nTermination: there is a proof that if SFL terminates, the result is an &hellip;",
  "truncated": true,
  "post_url": "/t/spanning-forest-cluster-linearization/1419/3",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}