{
  "id": 4717,
  "name": "Sebastian Falbesoner",
  "username": "theStack",
  "avatar_template": "/user_avatar/delvingbitcoin.org/thestack/{size}/420_2.png",
  "created_at": "2025-04-06T23:38:42.713Z",
  "cooked": "<p>Thanks for the update and the resources, that all sounds very promising! I\u2019ll focus on the non-assumevalid version with my reply for now, since I still haven\u2019t fully processed the assumevalid one yet.</p>\n<aside class=\"quote no-group\" data-username=\"RubenSomsen\" data-post=\"2\" data-topic=\"1562\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/rubensomsen/48/188_2.png\" class=\"avatar\"> RubenSomsen:</div>\n<blockquote>\n<p>Second, MuHash is not strictly required. We can use a regular hash function like sha256 and do modular arithmetic, provided we add a salt to prevent birthday attacks. So it\u2019d be <code>hash(utxo_data_A||salt) + hash(utxo_data_B||salt) - hash(utxo_data_C||salt) - hash(utxo_data_D||salt) == 0</code> (thus proving <code>(A==C &amp;&amp; B==D) || (A==D &amp;&amp; B==C)</code>). This should be faster than MuHash.</p>\n</blockquote>\n</aside>\n<p>Nice idea! As already noted in private, I\u2019m wondering though if only adding a salt is really enough to provide the same security guarantees as MuHash would do? Reducing the modulo field size from 3072 bits to 256 bits and using simple addition instead multiplication as basic operation seem to be quite drastic cuts. This is more \u201cgut-feeling\u201d and far away from a mathematical sound argument, but it feels to me that this was too good to be true if there aren\u2019t any significant downsides to this approach. (That said, I hope I\u2019m wrong, and even if there is a reduction in security, it\u2019s maybe still good enough for the SwiftSync use-case, since the goals of MuHash and the aggregate hash here are different.)</p>\n<p>Since it was relatively easy to do, I adapted the implementation above to take use of that suggestion (by abusing secp256k1 scalars for the aggregate hash type): <a href=\"https://github.com/theStack/bitcoin/tree/ibd_booster_v1_addsub_sha256\" class=\"inline-onebox\">GitHub - theStack/bitcoin at ibd_booster_v1_addsub_sha256</a> (commit <a href=\"https://github.com/theStack/bitcoin/commit/494692ebc57e159c36b0a2042abca59f539ca0c2\" class=\"inline-onebox\">[HACK] use modular arithmetic and SHA256 for aggregate hash \u00b7 theStack/bitcoin@494692e \u00b7 GitHub</a>)</p>\n<p>The results are pleasant, with this I\u2019m now already observing a ~5x IBD speed-up compared to the assumevalid run (again, up to block 850900, and using <code>-reindex-chainstate</code>), and this is still without any parallel block validation involved:</p>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th>assumevalid only</th>\n<th>SwiftSync (MuHash for aggregate hash)</th>\n<th>SwiftSync (salted sha256 add/sub for aggregate hash)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>time</td>\n<td>2454m37.039s</td>\n<td>1094m31.100s</td>\n<td>464m37.234s</td>\n</tr>\n<tr>\n<td>speed-up</td>\n<td>-</td>\n<td>~2.24x</td>\n<td>~5.28x</td>\n</tr>\n</tbody>\n</table>\n</div><p>Doing parallel block validation as next proof-of-concept step would be very nice, but that needs of course much more invasive changes in the codebase.</p>",
  "post_number": 7,
  "post_type": 1,
  "posts_count": 7,
  "updated_at": "2025-04-06T23:38:42.713Z",
  "reply_count": 0,
  "reply_to_post_number": 2,
  "quote_count": 1,
  "incoming_link_count": 1,
  "reads": 11,
  "readers_count": 10,
  "score": 7.2,
  "yours": false,
  "topic_id": 1562,
  "topic_slug": "ibd-booster-speeding-up-ibd-with-pre-generated-hints-poc",
  "topic_title": "IBD Booster -- Speeding up IBD with pre-generated hints (PoC)",
  "topic_html_title": "IBD Booster &ndash; Speeding up IBD with pre-generated hints (PoC)",
  "category_id": 8,
  "display_username": "Sebastian Falbesoner",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Thanks for the update and the resources, that all sounds very promising! I'll focus on the non-assumevalid version with my reply for now, since I still haven't fully processed the assumevalid one yet.\n\n[quote=\"RubenSomsen, post:2, topic:1562\"]\nSecond, MuHash is not strictly required. We can use a regular hash function like sha256 and do modular arithmetic, provided we add a salt to prevent birthday attacks. So it\u2019d be `hash(utxo_data_A||salt) + hash(utxo_data_B||salt) - hash(utxo_data_C||salt) - hash(utxo_data_D||salt) == 0` (thus proving `(A==C && B==D) || (A==D && B==C)`). This should be faster than MuHash.\n[/quote]\n\nNice idea! As already noted in private, I'm wondering though if only adding a salt is really enough to provide the same security guarantees as MuHash would do? Reducing the modulo field size from 3072 bits to 256 bits and using simple addition instead multiplication as basic operation seem to be quite drastic cuts. This is more \"gut-feeling\" and far away from a mathematical sound argument, but it feels to me that this was too good to be true if there aren't any significant downsides to this approach. (That said, I hope I'm wrong, and even if there is a reduction in security, it's maybe still good enough for the SwiftSync use-case, since the goals of MuHash and the aggregate hash here are different.)\n\nSince it was relatively easy to do, I adapted the implementation above to take use of that suggestion (by abusing secp256k1 scalars for the aggregate hash type): https://github.com/theStack/bitcoin/tree/ibd_booster_v1_addsub_sha256 (commit https://github.com/theStack/bitcoin/commit/494692ebc57e159c36b0a2042abca59f539ca0c2)\n\nThe results are pleasant, with this I'm now already observing a ~5x IBD speed-up compared to the assumevalid run (again, up to block 850900, and using `-reindex-chainstate`), and this is still without any parallel block validation involved:\n\n| | assumevalid only | SwiftSync (MuHash for aggregate hash) | SwiftSync (salted sha256 add/sub for aggregate hash) |\n|--- | --- | --- | ---|\n|time | 2454m37.039s | 1094m31.100s | 464m37.234s |\n|speed-up | - | ~2.24x | ~5.28x |\n\nDoing parallel block validation as next proof-of-concept step would be very nice, but that needs of course much more invasive changes in the codebase.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 346,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "Thanks for the update and the resources, that all sounds very promising! I\u2019ll focus on the non-assumevalid version with my reply for now, since I still haven\u2019t fully processed the assumevalid one yet. \n\nNice idea! As already noted in private, I\u2019m wondering though if only adding a salt is really enou&hellip;",
  "truncated": true,
  "post_url": "/t/ibd-booster-speeding-up-ibd-with-pre-generated-hints-poc/1562/7",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}