{
  "id": 4808,
  "name": "",
  "username": "josh",
  "avatar_template": "/user_avatar/delvingbitcoin.org/josh/{size}/95_2.png",
  "created_at": "2025-04-16T15:19:35.524Z",
  "cooked": "<p><a class=\"mention\" href=\"/u/reardencode\">@reardencode</a> Thanks for the shoutout!</p>\n<p><a class=\"mention\" href=\"/u/salvatoshi\">@salvatoshi</a> I\u2019d love to share a tool I built that does something similar and perhaps collaborate on getting a multisig backup scheme standardized. I agree that this is a problem that needs to be solved.</p>\n<p>The scheme you propose is simple and would appear to work, assuming SHA256 can be used as a secure KDF where the key is derived from a large subset of the data it is encrypting. There is at least one drawback, though:</p>\n<p>If the encrypted descriptor is stored publicly or on a compromised server, an attacker who gains access to one secret gains knowledge of the existence of the multisig. This is not ideal if a user wants to protect themselves with a decoy single-sig wallet.</p>\n<p>The scheme I\u2019m using makes one significant change. In a <span class=\"math\">k</span>-of-<span class=\"math\">n</span> multisig descriptor, the secret <span class=\"math\">s</span> is split into <span class=\"math\">n</span> shares using shamir secret sharing, where <span class=\"math\">k</span> shares are needed to recover. Each share is then encrypted with one xpub, so that <span class=\"math\">k</span> xpubs are needed to decrypt.</p>\n<p>The other minor difference is that I leave the derivation paths in plaintext, so that a user knows how to derive their xpubs. Only the sensitive data is encrypted (the xpubs and master fingerprints).</p>\n<p>As of now, the scheme only supports standard (non-taproot) multisig descriptors. In the future, I hope to generalize it to support decaying and non-decaying P2TR multisigs.</p>\n<p>Here\u2019s the <a href=\"https://github.com/joshdoman/multisig-backup\" rel=\"noopener nofollow ugc\">GitHub repo</a> and the corresponding <a href=\"https://delvingbitcoin.org/t/multisigbackup-com-backup-and-recover-a-k-of-n-descriptor-using-only-n-seeds/1430/4\">Delving post</a>. The slides I presented at BitDevs ATL can be found <a href=\"https://docs.google.com/presentation/d/1S6XN2jyeQsAkPeT4zvOaFIrOkGyzBnO8fbvcqg2Jlwk/edit?usp=sharing\" rel=\"noopener nofollow ugc\">here</a>.</p>\n<p>Let me know if you\u2019d like to discuss!</p>",
  "post_number": 3,
  "post_type": 1,
  "posts_count": 6,
  "updated_at": "2025-04-16T15:57:46.287Z",
  "reply_count": 1,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 4,
  "reads": 11,
  "readers_count": 10,
  "score": 42.2,
  "yours": false,
  "topic_id": 1607,
  "topic_slug": "a-simple-backup-scheme-for-wallet-accounts",
  "topic_title": "A simple backup scheme for wallet accounts",
  "topic_html_title": "A simple backup scheme for wallet accounts",
  "category_id": 8,
  "display_username": "",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "@reardencode Thanks for the shoutout!\n\n@salvatoshi I'd love to share a tool I built that does something similar and perhaps collaborate on getting a multisig backup scheme standardized. I agree that this is a problem that needs to be solved.\n\nThe scheme you propose is simple and would appear to work, assuming SHA256 can be used as a secure KDF where the key is derived from a large subset of the data it is encrypting. There is at least one drawback, though:\n\nIf the encrypted descriptor is stored publicly or on a compromised server, an attacker who gains access to one secret gains knowledge of the existence of the multisig. This is not ideal if a user wants to protect themselves with a decoy single-sig wallet.\n\nThe scheme I'm using makes one significant change. In a $k$-of-$n$ multisig descriptor, the secret $s$ is split into $n$ shares using shamir secret sharing, where $k$ shares are needed to recover. Each share is then encrypted with one xpub, so that $k$ xpubs are needed to decrypt.\n\nThe other minor difference is that I leave the derivation paths in plaintext, so that a user knows how to derive their xpubs. Only the sensitive data is encrypted (the xpubs and master fingerprints).\n\nAs of now, the scheme only supports standard (non-taproot) multisig descriptors. In the future, I hope to generalize it to support decaying and non-decaying P2TR multisigs.\n\nHere's the [GitHub repo](https://github.com/joshdoman/multisig-backup) and the corresponding [Delving post](https://delvingbitcoin.org/t/multisigbackup-com-backup-and-recover-a-k-of-n-descriptor-using-only-n-seeds/1430/4). The slides I presented at BitDevs ATL can be found [here](https://docs.google.com/presentation/d/1S6XN2jyeQsAkPeT4zvOaFIrOkGyzBnO8fbvcqg2Jlwk/edit?usp=sharing).\n\nLet me know if you'd like to discuss!",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 98,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "<a class=\"mention\" href=\"/u/reardencode\">@reardencode</a> Thanks for the shoutout! \n<a class=\"mention\" href=\"/u/salvatoshi\">@salvatoshi</a> I\u2019d love to share a tool I built that does something similar and perhaps collaborate on getting a multisig backup scheme standardized. I agree that this is a problem that needs to be solved. \nThe scheme you propose is simple and would appear to work&hellip;",
  "truncated": true,
  "post_url": "/t/a-simple-backup-scheme-for-wallet-accounts/1607/3",
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}