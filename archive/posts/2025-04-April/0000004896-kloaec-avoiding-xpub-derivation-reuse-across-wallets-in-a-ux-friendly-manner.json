{
  "id": 4896,
  "name": "Kevin Loaec",
  "username": "kloaec",
  "avatar_template": "/user_avatar/delvingbitcoin.org/kloaec/{size}/1191_2.png",
  "created_at": "2025-04-29T17:54:43.553Z",
  "cooked": "<h1><a name=\"p-4896-introduction-1\" class=\"anchor\" href=\"#p-4896-introduction-1\"></a>Introduction:</h1>\n<p>Signing devices can be reused for multiple wallets, but xpubs+derivation should not.\nSome simple examples are when rotating to a different wallet to change one key in a multisig setup, or when rotating the wallet to push an absolute timelock date. For privacy, it is important to not reuse xpubs+derivation even if the same devices are still present in the setup.</p>\n<p>Moreover, it is unreasonable to assume users (will) stick to a single software, they might use a multisig on one, a timelocked wallet on another\u2026</p>\n<p>It is also unreasonable to assume a user remembers or knows every (any?) paths they have used, and to remember to increase their derivation path each time they create a new wallet.</p>\n<p>I\u2019m writing this post as we are implementing \u201cmulti wallet\u201d in <a href=\"https://github.com/wizardsardine/liana\" rel=\"noopener nofollow ugc\">Liana</a> and I am not happy with any commonly used solution to avoid xpub reuse.</p>\n<h1><a name=\"p-4896-the-issue-2\" class=\"anchor\" href=\"#p-4896-the-issue-2\"></a>The issue:</h1>\n<p>One should not reuse xpubs+derivation across different wallets, it is bad for privacy.\nA signing device should be easy to reuse for different wallets without requiring the user to switch keys (passphrase or other), as a different derivation path is enough.</p>\n<p>An extra layer of complexity is when dealing with air-gapped signers, the user is now expected to understand the difference between BIP numbers and wallet types.</p>\n<h3><a name=\"p-4896-the-current-ways-this-is-addressed-3\" class=\"anchor\" href=\"#p-4896-the-current-ways-this-is-addressed-3\"></a>The current ways this is addressed:</h3>\n<ul>\n<li>ask the user to select their \u201caccount\u201d number</li>\n<li>or keep a state of the last account used in that specific software wallet (typically on a wallet company server, or sometimes locally)</li>\n</ul>\n<p>The first is yet another confusing thing users need to learn and keep track of, the second is specific to one software. Key reuse can still happen if reused on a different software.</p>\n<p>I am not aware of other solutions currently used in prod, let me know if there are some.</p>\n<h1><a name=\"p-4896-better-ux-to-avoid-key-reuse-ideas-4\" class=\"anchor\" href=\"#p-4896-better-ux-to-avoid-key-reuse-ideas-4\"></a>Better UX to avoid key reuse - ideas</h1>\n<p>Since <a href=\"https://bitcoinops.org/en/topics/output-script-descriptors/\" rel=\"noopener nofollow ugc\">output descriptors</a> technically supersede \u201cBIPxx\u201d standard derivation paths by explicitly recording the derivation paths used, and because multisig and more advanced/complex wallets shouldn\u2019t rely on brute force reproduction of the script anyway, I believe it is time to think of a better UX than \u201cincrease your account number\u201d of <a href=\"https://en.bitcoin.it/wiki/BIP_0048#Account\" rel=\"noopener nofollow ugc\">BIP48</a>.</p>\n<p>That being said, output descriptors also apply to single sig wallets\u2026 where users have been taught that keeping their Mnemonic is enough. Moving away from this for single sig wallets will not be trivial. This post is mainly intended at multisig or more advanced wallets, but if we can fix single sig key reuse too, that\u2019d be a win.</p>\n<p>I would like to define yet another \u201cstandard\u201d that would reasonably guarantee that a user will not reuse keys, even on different software wallets, when they reuse a signing device.</p>\n<h3><a name=\"p-4896-desired-properties-5\" class=\"anchor\" href=\"#p-4896-desired-properties-5\"></a>Desired properties:</h3>\n<ul>\n<li><strong>Works across vendors</strong>. Different software following the \u201cstandard\u201d will always generate wallets with different xpubs, avoiding key reuse</li>\n<li><strong>Does not depend on others implementing it</strong>. A software <strong>NOT</strong> following the \u201cstandard\u201d will not use the same xpub as a wallet created with a software following the spec (unless malicious)</li>\n<li><strong>Should work with current wallet flows</strong>. Some multisig software wallets already offer \u201cone click\u201d wallet rotation, without requiring access to the signing device. Others might generate multiple xpubs per seconds. Both of these use-cases should be covered, and more if we find them</li>\n<li><strong>Should be fool proof</strong>, the point is to improve UX without breaking privacy</li>\n</ul>\n<h3><a name=\"p-4896-some-proposed-ideas-6\" class=\"anchor\" href=\"#p-4896-some-proposed-ideas-6\"></a>Some proposed ideas</h3>\n<p>Hardened path, requires the signing device to generate the wallet</p>\n<ol>\n<li>\n<p><strong>Random path</strong>. As \u201cstandard\u201d derivation paths are irrelevant to output descriptors, we can simply randomize the paths. [FINGERPRINT/xx\u2019/Random\u2019].\nThis is the simplest of all solutions and would work pretty great for all cases. For very large signers (belonging to many thousands of wallets, typically cosigners), another derivation layer could be added. [FINGERPRINT/xx\u2019/Random\u2019/Random2\u2019]</p>\n</li>\n<li>\n<p><strong>Deterministic path</strong>. For example using UNIX time at the time the xpub is requested to the device. [FINGERPRINT/xx\u2019/1745925\u2019/432\u2019]. In this example I used the UNIX time. I arbitrarily split it at the 1 000sec digit. It would fit in a single level but will hit the 32-bits limit in 80 years.\nAnother approach would be to use a human readable date, for example [FINGERPRINT/xx\u2019/20250429\u2019/124630\u2019], where the first level is the date, the second is the time in Hours Minutes Seconds. This is quite easy from a UX perspective</p>\n</li>\n<li>\n<p><strong>Storing state at each xpub request to the signing device</strong>. As the same seed can be imported to multiple hardware devices, this state has to be synchronized, therefore be shared with a server (public or not). The \u201caccount\u201d can then be increased by 1 for each request. [FINGERPRINT/48\u2019/0\u2019/x\u2019/2\u2019] or whatever format, where x is increased. This method would need to be multi-vendor compatible</p>\n</li>\n</ol>\n<p>Out of these options, my preferred is 2, followed by 1.</p>\n<p>1- Random path:</p>\n<ul>\n<li>Some malware used random derivations in the past, creating stigma</li>\n<li>It works all the time, even if you generate 1000s of xpubs per seconds (co-signers?)</li>\n<li>Doesn\u2019t rely on any state</li>\n<li>Hardware don\u2019t like \u201cnon-standard paths\u201d</li>\n</ul>\n<p>2- Deterministic:</p>\n<ul>\n<li>Can be made user-friendly, understanding why the path looks like it does (date/time)</li>\n<li>Works for humans, but might not work for a machine as-is. If more than 1 xpub is needed per second, another level needs to be added (or more precision, fractions of seconds)</li>\n<li>Hardware don\u2019t like \u201cnon-standard paths\u201d</li>\n</ul>\n<p>3- State is synchronized:</p>\n<ul>\n<li>Wallet software needs to be connected to such server, bad for privacy and UX</li>\n<li>Needs to be vendor-agnostic, and persistent</li>\n<li>Might conflict with non-compatible wallet paths, depending on what path is incremented</li>\n</ul>\n<p>Other considerations:</p>\n<p>For the deterministic wallet, we cannot assume the software will be at the correct time/date. I believe with precision level at the second it should be OK, but it is simple to increase this to a millisec if believed useful.\nOne UX issue I am aware of is that some hardware wallets will display a warning for \u201cnon-standard\u201d derivation paths. This is definitely a drawback of these methods, but a much lesser evil than reusing xpubs.</p>\n<h3><a name=\"p-4896-non-hardened-paths-to-rotate-without-access-to-the-signing-device-7\" class=\"anchor\" href=\"#p-4896-non-hardened-paths-to-rotate-without-access-to-the-signing-device-7\"></a>Non-hardened paths, to rotate without access to the signing device</h3>\n<p>One use-case that multiple wallets are offering now (Casa, Nunchuk, Keeper, Unchained\u2026) is to rotate/migrate wallets for key replacement or timelock management. To make the UX \u201cone click\u201d, some of these wallets are using a non-hardened path, and incrementing that counter.</p>\n<p>While this is acceptable, it is currently not a fit for our cross-vendor compatibility. One should be able to import a wallet created on a software, to another, and then rotate.\nThe main issue here is that if a user wants to import a backup from one vendor to another, each vendor will potentially know about all other such wallets of this user (unhardened paths).</p>\n<p>I suppose for this specific use case, the Random option is the best one but is becoming quite heavy, adding a few extra levels of non-hardened paths, preventing brute forcing.</p>\n<p>Or just avoid rotations without the signing device being present: we stick to hardened paths.</p>\n<h3><a name=\"p-4896-what-about-single-sig-8\" class=\"anchor\" href=\"#p-4896-what-about-single-sig-8\"></a>What about single sig!?</h3>\n<p>That one is a tough one. The problem persists for single sig, as you may reuse a signing device across software/wallets.</p>\n<p>Getting rid of the \u201cstandard\u201d derivation paths is a battle I know won\u2019t be worth it. If people don\u2019t want descriptors, then they will have to sacrifice something: privacy if they need a sync server for example.\nBut in that case (sync server), why not just use said server to <a href=\"https://delvingbitcoin.org/t/a-simple-backup-scheme-for-wallet-accounts/1607/1\">keep an encrypted backup of your descriptor</a> instead?</p>\n<h3><a name=\"p-4896-other-discarded-ideas-from-myself-and-others-were-9\" class=\"anchor\" href=\"#p-4896-other-discarded-ideas-from-myself-and-others-were-9\"></a>Other discarded ideas (from myself and others) were:</h3>\n<ul>\n<li>State stored in the signing device, which wouldn\u2019t persist in case the secret needs to be imported again, and which wouldn\u2019t be synchronized across devices of the same seed</li>\n<li>Checking on-chain for prior use of a key, which assumes a key has been used/revealed. For a wallet like <a href=\"https://wizardsardine.com/liana/\" rel=\"noopener nofollow ugc\">Liana</a> or similar using multiple Taproot branches, using a wallet might not reveal a key was used. Or even just depositing funds to a wallet does not imply spending from it for a while, so an xpub could be already part of a setup without having yet revealed any key on-chain</li>\n<li>Tying the path to a \u201cname\u201d of the wallet, as names may not be unique either</li>\n</ul>\n<hr>\n<hr>\n<p>Thanks for reading, I hope we can find a good way to move forward without the risk of users reusing keys across wallets.\nThe idea here is to come up with a best practice for wallet devs. I don\u2019t pretend to have the perfect answer.</p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 2,
  "updated_at": "2025-04-29T17:54:43.553Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 37,
  "reads": 10,
  "readers_count": 9,
  "score": 186.8,
  "yours": false,
  "topic_id": 1644,
  "topic_slug": "avoiding-xpub-derivation-reuse-across-wallets-in-a-ux-friendly-manner",
  "topic_title": "Avoiding xpub+derivation reuse across wallets, in a UX-friendly manner",
  "topic_html_title": "Avoiding xpub+derivation reuse across wallets, in a UX-friendly manner",
  "category_id": 8,
  "display_username": "Kevin Loaec",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "# Introduction:\nSigning devices can be reused for multiple wallets, but xpubs+derivation should not.\nSome simple examples are when rotating to a different wallet to change one key in a multisig setup, or when rotating the wallet to push an absolute timelock date. For privacy, it is important to not reuse xpubs+derivation even if the same devices are still present in the setup.\n\nMoreover, it is unreasonable to assume users (will) stick to a single software, they might use a multisig on one, a timelocked wallet on another... \n\nIt is also unreasonable to assume a user remembers or knows every (any?) paths they have used, and to remember to increase their derivation path each time they create a new wallet.\n\nI'm writing this post as we are implementing \"multi wallet\" in [Liana](https://github.com/wizardsardine/liana) and I am not happy with any commonly used solution to avoid xpub reuse.\n\n\n# The issue:\nOne should not reuse xpubs+derivation across different wallets, it is bad for privacy.\nA signing device should be easy to reuse for different wallets without requiring the user to switch keys (passphrase or other), as a different derivation path is enough.\n\nAn extra layer of complexity is when dealing with air-gapped signers, the user is now expected to understand the difference between BIP numbers and wallet types.\n\n### The current ways this is addressed:\n\n* ask the user to select their \"account\" number\n* or keep a state of the last account used in that specific software wallet (typically on a wallet company server, or sometimes locally)\n\nThe first is yet another confusing thing users need to learn and keep track of, the second is specific to one software. Key reuse can still happen if reused on a different software.\n\nI am not aware of other solutions currently used in prod, let me know if there are some.\n\n# Better UX to avoid key reuse - ideas\n\nSince [output descriptors](https://bitcoinops.org/en/topics/output-script-descriptors/) technically supersede \"BIPxx\" standard derivation paths by explicitly recording the derivation paths used, and because multisig and more advanced/complex wallets shouldn't rely on brute force reproduction of the script anyway, I believe it is time to think of a better UX than \"increase your account number\" of [BIP48](https://en.bitcoin.it/wiki/BIP_0048#Account).\n\nThat being said, output descriptors also apply to single sig wallets... where users have been taught that keeping their Mnemonic is enough. Moving away from this for single sig wallets will not be trivial. This post is mainly intended at multisig or more advanced wallets, but if we can fix single sig key reuse too, that'd be a win.\n\nI would like to define yet another \"standard\" that would reasonably guarantee that a user will not reuse keys, even on different software wallets, when they reuse a signing device.\n\n### Desired properties:\n\n- **Works across vendors**. Different software following the \"standard\" will always generate wallets with different xpubs, avoiding key reuse\n- **Does not depend on others implementing it**. A software **NOT** following the \"standard\" will not use the same xpub as a wallet created with a software following the spec (unless malicious)\n- **Should work with current wallet flows**. Some multisig software wallets already offer \"one click\" wallet rotation, without requiring access to the signing device. Others might generate multiple xpubs per seconds. Both of these use-cases should be covered, and more if we find them\n- **Should be fool proof**, the point is to improve UX without breaking privacy\n\n\n### Some proposed ideas\n\nHardened path, requires the signing device to generate the wallet\n\n1. **Random path**. As \"standard\" derivation paths are irrelevant to output descriptors, we can simply randomize the paths. [FINGERPRINT/xx'/Random'].\nThis is the simplest of all solutions and would work pretty great for all cases. For very large signers (belonging to many thousands of wallets, typically cosigners), another derivation layer could be added. [FINGERPRINT/xx'/Random'/Random2']\n\n2. **Deterministic path**. For example using UNIX time at the time the xpub is requested to the device. [FINGERPRINT/xx'/1745925'/432']. In this example I used the UNIX time. I arbitrarily split it at the 1 000sec digit. It would fit in a single level but will hit the 32-bits limit in 80 years.\nAnother approach would be to use a human readable date, for example [FINGERPRINT/xx'/20250429'/124630'], where the first level is the date, the second is the time in Hours Minutes Seconds. This is quite easy from a UX perspective\n3. **Storing state at each xpub request to the signing device**. As the same seed can be imported to multiple hardware devices, this state has to be synchronized, therefore be shared with a server (public or not). The \"account\" can then be increased by 1 for each request. [FINGERPRINT/48'/0'/x'/2'] or whatever format, where x is increased. This method would need to be multi-vendor compatible\n\nOut of these options, my preferred is 2, followed by 1.\n\n1- Random path:\n\n- Some malware used random derivations in the past, creating stigma\n- It works all the time, even if you generate 1000s of xpubs per seconds (co-signers?)\n- Doesn't rely on any state\n- Hardware don't like \"non-standard paths\"\n\n2- Deterministic:\n\n- Can be made user-friendly, understanding why the path looks like it does (date/time)\n- Works for humans, but might not work for a machine as-is. If more than 1 xpub is needed per second, another level needs to be added (or more precision, fractions of seconds)\n- Hardware don't like \"non-standard paths\"\n\n3- State is synchronized:\n\n- Wallet software needs to be connected to such server, bad for privacy and UX\n- Needs to be vendor-agnostic, and persistent\n- Might conflict with non-compatible wallet paths, depending on what path is incremented\n\nOther considerations:\n\nFor the deterministic wallet, we cannot assume the software will be at the correct time/date. I believe with precision level at the second it should be OK, but it is simple to increase this to a millisec if believed useful.\nOne UX issue I am aware of is that some hardware wallets will display a warning for \"non-standard\" derivation paths. This is definitely a drawback of these methods, but a much lesser evil than reusing xpubs.\n\n### Non-hardened paths, to rotate without access to the signing device\n\nOne use-case that multiple wallets are offering now (Casa, Nunchuk, Keeper, Unchained...) is to rotate/migrate wallets for key replacement or timelock management. To make the UX \"one click\", some of these wallets are using a non-hardened path, and incrementing that counter.\n\nWhile this is acceptable, it is currently not a fit for our cross-vendor compatibility. One should be able to import a wallet created on a software, to another, and then rotate.\nThe main issue here is that if a user wants to import a backup from one vendor to another, each vendor will potentially know about all other such wallets of this user (unhardened paths).\n\nI suppose for this specific use case, the Random option is the best one but is becoming quite heavy, adding a few extra levels of non-hardened paths, preventing brute forcing.\n\nOr just avoid rotations without the signing device being present: we stick to hardened paths.\n\n### What about single sig!?\n\nThat one is a tough one. The problem persists for single sig, as you may reuse a signing device across software/wallets.\n\nGetting rid of the \"standard\" derivation paths is a battle I know won't be worth it. If people don't want descriptors, then they will have to sacrifice something: privacy if they need a sync server for example.\nBut in that case (sync server), why not just use said server to [keep an encrypted backup of your descriptor](https://delvingbitcoin.org/t/a-simple-backup-scheme-for-wallet-accounts/1607/1) instead?\n\n### Other discarded ideas (from myself and others) were:\n\n- State stored in the signing device, which wouldn't persist in case the secret needs to be imported again, and which wouldn't be synchronized across devices of the same seed\n- Checking on-chain for prior use of a key, which assumes a key has been used/revealed. For a wallet like [Liana](https://wizardsardine.com/liana/) or similar using multiple Taproot branches, using a wallet might not reveal a key was used. Or even just depositing funds to a wallet does not imply spending from it for a while, so an xpub could be already part of a setup without having yet revealed any key on-chain\n- Tying the path to a \"name\" of the wallet, as names may not be unique either\n\n---\n---\nThanks for reading, I hope we can find a good way to move forward without the risk of users reusing keys across wallets.\nThe idea here is to come up with a best practice for wallet devs. I don't pretend to have the perfect answer.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 754,
  "hidden": false,
  "trust_level": 0,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "<a name=\"p-4896-introduction-1\" class=\"anchor\" href=\"#p-4896-introduction-1\"></a>Introduction:\nSigning devices can be reused for multiple wallets, but xpubs+derivation should not.\nSome simple examples are when rotating to a different wallet to change one key in a multisig setup, or when rotating the wallet to push an absolute timelock date. For privacy, it is important to not re&hellip;",
  "truncated": true,
  "post_url": "/t/avoiding-xpub-derivation-reuse-across-wallets-in-a-ux-friendly-manner/1644/1",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}