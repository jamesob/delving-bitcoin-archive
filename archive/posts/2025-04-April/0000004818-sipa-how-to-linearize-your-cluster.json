{
  "id": 4818,
  "name": "Pieter Wuille",
  "username": "sipa",
  "avatar_template": "/user_avatar/delvingbitcoin.org/sipa/{size}/1100_2.png",
  "created_at": "2025-04-17T20:33:21.744Z",
  "cooked": "<p>I\u2019m beginning to think that the <a href=\"https://delvingbitcoin.org/t/spanning-forest-cluster-linearization/1419\">spanning-forest linearization</a> (SFL) algorithm is a better choice in general than the min-cut GGT algorithm, because while asymptotic complexity is worse (it can in theory run forever, though randomization makes this unlikely), it\u2019s actually a lot more practical. It\u2019s of course possible to combine the two, e.g., use GGT just for linearizing very hard clusters in a background thread, but it\u2019ll practically be barely used I expect.</p>\n<p>The reasons for choosing SFL over <a href=\"https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303/9\">GGT</a> and CSS (candidate set search, the old exponential algorithm which <a href=\"https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303/1\">this thread</a> was originally about) are:</p>\n<ul>\n<li><strong><a href=\"https://en.wikipedia.org/wiki/Anytime_algorithm\">Anytime algorithm</a></strong>: it is possible to interrupt SFL at any point, and get a linearization out. The longer it runs, the better the result gets. This is also true for CSS, but less so for GGT as any min-cut that has not been computed completely may not result in an improvement (and the entire runtime may consist of just a single cut).</li>\n<li><strong>Improving existing linearizations</strong>: it is possible to initialize SFL with an existing linearization as input, and any output it gives will be a linearization that\u2019s better or equal. In some, but not all, practical cases it makes the algorithm also find the optimal faster when provided with a good input linearization already. This avoids the need to use the <a href=\"https://delvingbitcoin.org/t/merging-incomparable-linearizations/209\">linearization merging</a> algorithm to combine with existing linearization, or the <a href=\"https://delvingbitcoin.org/t/limo-combining-the-best-parts-of-linearization-search-and-merging/825\">LIMO algorithm</a> to combine candidate finding with improvement of an existing linearization.</li>\n<li><strong>Load balancing</strong>: both GGT and CSS subdivide the problem in different ways. When trying to turn them into anytime algorithms, there is a question of how to subdivide the computation budget over these subproblems. In contrast, SFL always just operates on a single state which it keeps improving, so no such budgetting decisions are necessary.</li>\n<li><strong>Fairness</strong>: Related to the previous point, it is easy to make SFL spread its work over all transactions in the cluster in a more-or-less fair way, for example by trying going through the transactions in a round-robin fashion to find dependencies to improve. GGT works by subdividing the cluster in a divide-and-conquer manner, but choices need to be made about which part to attempt to subdivide next. CSS fundamentally works from highest-feerate to lowest-feerate chunks, so if time runs after only some part is done, the (transactions in) the first chunk will have had more effort on them. I think that\u2019s concerning, because it risks an attacker attaching a very complex set of transactions to an honest CPFP or so, and have the algorithm spend all its time on the attacker\u2019s transactions, running out before even considering the steps necessary to recognize the CPFP.</li>\n<li><strong>Runtime</strong>: when benchmarking using replayed mempool data of previous years (credit to <a class=\"mention\" href=\"/u/sdaftuar\">@sdaftuar</a>), my SFL implementation seems somewhat (~2x) faster than the GGT one.</li>\n<li><strong>Integer arithmetic</strong>: GGT needs to represent flows and feerates as <a href=\"https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303/50\">approximate integers</a>, which need to be scaled such that they are sufficiently precise. If <span class=\"math\">F</span> is the sum of the (absolute values of) fees in the graph and <span class=\"math\">S</span> the sum of the sizes in the graph, then GGT needs integers large enough to represent <span class=\"math\">4S^2F</span> if exactly optimal solutions are desired. SFL and CSS only need integers large enough to represent <span class=\"math\">2SF</span> and <span class=\"math\">SF</span>. Of course, perhaps we don\u2019t care about exactness of solutions for huge clusters that pay enormous feerates, and in either case, this isn\u2019t a very hard problem, just complicates the implementation somewhat.</li>\n</ul>\n<p>The downsides of SFL compared to GGT are:</p>\n<ul>\n<li><strong>Complexity bounds</strong>: <s>there is no known bound for the runtime of SFL, and it may be infinite</s> SFL may in theory run forever, while GGT is proven to be <span class=\"math\">\\mathcal{O}(n^3)</span>. However, even that cubic runtime is probably too much in the worst case to run at transaction relay time. Also note that we don\u2019t really need optimal linearization. They\u2019re nice, because they\u2019re obviously the most incentive-compatible ones, but in practice, the bar is really a \u201cgood enough for what people actually use\u201d, which is hard to define, and interacts in difficult ways with adversial models (see fairness above).</li>\n</ul>\n<p>The downsides of SFL compared to CSS are:</p>\n<ul>\n<li><strong>Mix with ancestor sort</strong>: CSS, when used through LIMO, can include arbitrary additional sources for finding good topological sets to move to the front. In the current implementation, optimal ancestor sets are used as additional inputs. There are no well-defined properties that this gives the linearization, but at least intuitively, this provides a \u201clinearization always has at least ancestor-set like quality\u201d property, regardless of how much time was spent in candidate finding. I don\u2019t know how to do anything like this in SFL (nor in GGT). If we believe that this quality is important, despite not being well-defined, then switching to SFL in theory means we could lose it in clusters that cannot be linearized optimally in time. My thinking is that combined with the SFL fairness, and the fact that it is just so much faster overall, it is unlikely to be an issue. Further, if we <em>really</em> wanted ancestor-sort quality, it would be possible to compute, in addition to running SFL, an ancestor sort linearization from scratch, and then merge the two if SFL doesn\u2019t find an optimal result. However, I suspect that the time this would take is better spent on performing more SFL iterations.</li>\n<li><s><strong>Minimal chunks</strong>: CSS finds a linearization by actively searching for good chunks to move to the front, and in doing so, it can prefer smaller chunks over bigger ones. This guarantees that (if it completes) it will find the linearization with <em>minimal</em> possible chunks among all feerate-diagram-optimal linearizations. SFL (and GGT) on the other hand really just find groups of connected transactions with equal chunk feerate, and thus can\u2019t guarantee to pull equal-feerate chunks apart.</s> EDIT: with an <a href=\"https://delvingbitcoin.org/t/spanning-forest-cluster-linearization/1419/9\">extra step</a>, SFL can find the minimal chunks.</li>\n<li><strong>Complexity bounds</strong>: SFL may in theory run forever, while CSS is trivially bounded by <span class=\"math\">\\mathcal{O}(n \\cdot 2^n)</span>, although I believe it may be <span class=\"math\">\\mathcal{O}(n \\cdot \\sqrt{2^n})</span> instead. These bounds are obviously impractical.</li>\n</ul>\n<p>All 3 above issues are open questions, and solutions/improvements could be found to them.</p>\n<hr>\n<p>In table form:</p>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th>Trait</th>\n<th></th>\n<th><a href=\"https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303/1\">CSS</a></th>\n<th></th>\n<th><a href=\"https://delvingbitcoin.org/t/spanning-forest-cluster-linearization/1419/1\">SFL</a></th>\n<th></th>\n<th><a href=\"https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303/9\">GGT</a></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Proven worst-case</strong></td>\n<td><img src=\"https://delvingbitcoin.org/images/emoji/twitter/red_square.png?v=14\" title=\":red_square:\" class=\"emoji only-emoji\" alt=\":red_square:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td><span class=\"math\">\\mathcal{O}(n \\cdot 2^n)</span></td>\n<td><img src=\"https://delvingbitcoin.org/images/emoji/twitter/red_square.png?v=14\" title=\":red_square:\" class=\"emoji only-emoji\" alt=\":red_square:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td><span class=\"math\">\\mathcal{O}(\\infty)</span></td>\n<td><img src=\"https://delvingbitcoin.org/images/emoji/twitter/green_square.png?v=14\" title=\":green_square:\" class=\"emoji only-emoji\" alt=\":green_square:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td><span class=\"math\">\\mathcal{O}(n^3)</span></td>\n</tr>\n<tr>\n<td><strong>Conjectured worst complexity</strong></td>\n<td><img src=\"https://delvingbitcoin.org/images/emoji/twitter/red_square.png?v=14\" title=\":red_square:\" class=\"emoji only-emoji\" alt=\":red_square:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td><span class=\"math\">\\mathcal{O}(n \\cdot \\sqrt{2^n})</span></td>\n<td><img src=\"https://delvingbitcoin.org/images/emoji/twitter/orange_square.png?v=14\" title=\":orange_square:\" class=\"emoji only-emoji\" alt=\":orange_square:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td><span class=\"math\">\\mathcal{O}(\\infty)</span></td>\n<td><img src=\"https://delvingbitcoin.org/images/emoji/twitter/green_square.png?v=14\" title=\":green_square:\" class=\"emoji only-emoji\" alt=\":green_square:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td><span class=\"math\">\\mathcal{O}(n^3)</span></td>\n</tr>\n<tr>\n<td><strong>Historical avg. runtime (\u00b5s)</strong> <span class=\"math\">(n \\leq 64)</span></td>\n<td><img src=\"https://delvingbitcoin.org/images/emoji/twitter/red_square.png?v=14\" title=\":red_square:\" class=\"emoji only-emoji\" alt=\":red_square:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td>80</td>\n<td><img src=\"https://delvingbitcoin.org/images/emoji/twitter/green_square.png?v=14\" title=\":green_square:\" class=\"emoji only-emoji\" alt=\":green_square:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td>10</td>\n<td><img src=\"https://delvingbitcoin.org/images/emoji/twitter/orange_square.png?v=14\" title=\":orange_square:\" class=\"emoji only-emoji\" alt=\":orange_square:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td>22</td>\n</tr>\n<tr>\n<td><strong>Historical worst runtime (\u00b5s)</strong> <span class=\"math\">(n \\leq 64)</span></td>\n<td><img src=\"https://delvingbitcoin.org/images/emoji/twitter/red_square.png?v=14\" title=\":red_square:\" class=\"emoji only-emoji\" alt=\":red_square:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td>31500</td>\n<td><img src=\"https://delvingbitcoin.org/images/emoji/twitter/green_square.png?v=14\" title=\":green_square:\" class=\"emoji only-emoji\" alt=\":green_square:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td>26</td>\n<td><img src=\"https://delvingbitcoin.org/images/emoji/twitter/orange_square.png?v=14\" title=\":orange_square:\" class=\"emoji only-emoji\" alt=\":orange_square:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td>33</td>\n</tr>\n<tr>\n<td><strong>Extrapolated worst runtime (\u00b5s)</strong> <span class=\"math\">(n \\leq 64)</span></td>\n<td><img src=\"https://delvingbitcoin.org/images/emoji/twitter/orange_square.png?v=14\" title=\":orange_square:\" class=\"emoji only-emoji\" alt=\":orange_square:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td>700,000,000</td>\n<td><img src=\"https://delvingbitcoin.org/images/emoji/twitter/red_square.png?v=14\" title=\":red_square:\" class=\"emoji only-emoji\" alt=\":red_square:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td><span class=\"math\">\\infty</span></td>\n<td><img src=\"https://delvingbitcoin.org/images/emoji/twitter/green_square.png?v=14\" title=\":green_square:\" class=\"emoji only-emoji\" alt=\":green_square:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td>10,000</td>\n</tr>\n<tr>\n<td><strong>Anytime algorithm</strong></td>\n<td><img src=\"https://delvingbitcoin.org/images/emoji/twitter/orange_square.png?v=14\" title=\":orange_square:\" class=\"emoji only-emoji\" alt=\":orange_square:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td>Needs budgeting</td>\n<td><img src=\"https://delvingbitcoin.org/images/emoji/twitter/green_square.png?v=14\" title=\":green_square:\" class=\"emoji only-emoji\" alt=\":green_square:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td>Natively</td>\n<td><img src=\"https://delvingbitcoin.org/images/emoji/twitter/red_square.png?v=14\" title=\":red_square:\" class=\"emoji only-emoji\" alt=\":red_square:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td>May lose progress</td>\n</tr>\n<tr>\n<td><strong>Improving existing</strong></td>\n<td><img src=\"https://delvingbitcoin.org/images/emoji/twitter/orange_square.png?v=14\" title=\":orange_square:\" class=\"emoji only-emoji\" alt=\":orange_square:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td>Through <a href=\"https://delvingbitcoin.org/t/limo-combining-the-best-parts-of-linearization-search-and-merging/825\">LIMO</a></td>\n<td><img src=\"https://delvingbitcoin.org/images/emoji/twitter/green_square.png?v=14\" title=\":green_square:\" class=\"emoji only-emoji\" alt=\":green_square:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td>Natively</td>\n<td><img src=\"https://delvingbitcoin.org/images/emoji/twitter/red_square.png?v=14\" title=\":red_square:\" class=\"emoji only-emoji\" alt=\":red_square:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td><a>Merging</a> afterwards</td>\n</tr>\n<tr>\n<td><strong>Fairness</strong></td>\n<td><img src=\"https://delvingbitcoin.org/images/emoji/twitter/red_square.png?v=14\" title=\":red_square:\" class=\"emoji only-emoji\" alt=\":red_square:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td>Hard</td>\n<td><img src=\"https://delvingbitcoin.org/images/emoji/twitter/green_square.png?v=14\" title=\":green_square:\" class=\"emoji only-emoji\" alt=\":green_square:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td>Easy</td>\n<td><img src=\"https://delvingbitcoin.org/images/emoji/twitter/red_square.png?v=14\" title=\":red_square:\" class=\"emoji only-emoji\" alt=\":red_square:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td>Hard</td>\n</tr>\n<tr>\n<td><strong>Integer sizes</strong></td>\n<td><img src=\"https://delvingbitcoin.org/images/emoji/twitter/green_square.png?v=14\" title=\":green_square:\" class=\"emoji only-emoji\" alt=\":green_square:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td><span class=\"math\">SF</span> <span class=\"math\">(\\times,&lt;)</span></td>\n<td><img src=\"https://delvingbitcoin.org/images/emoji/twitter/green_square.png?v=14\" title=\":green_square:\" class=\"emoji only-emoji\" alt=\":green_square:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td><span class=\"math\">2SF</span> <span class=\"math\">(\\times,&lt;,-)</span></td>\n<td><img src=\"https://delvingbitcoin.org/images/emoji/twitter/orange_square.png?v=14\" title=\":orange_square:\" class=\"emoji only-emoji\" alt=\":orange_square:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td><span class=\"math\">4S^2F</span> <span class=\"math\">(\\times,/,&lt;,+,-)</span></td>\n</tr>\n<tr>\n<td><strong>Ancestor sort mix</strong></td>\n<td><img src=\"https://delvingbitcoin.org/images/emoji/twitter/green_square.png?v=14\" title=\":green_square:\" class=\"emoji only-emoji\" alt=\":green_square:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td>Yes</td>\n<td><img src=\"https://delvingbitcoin.org/images/emoji/twitter/red_square.png?v=14\" title=\":red_square:\" class=\"emoji only-emoji\" alt=\":red_square:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td>No</td>\n<td><img src=\"https://delvingbitcoin.org/images/emoji/twitter/red_square.png?v=14\" title=\":red_square:\" class=\"emoji only-emoji\" alt=\":red_square:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td>No</td>\n</tr>\n<tr>\n<td><strong>Minimal chunks</strong></td>\n<td><img src=\"https://delvingbitcoin.org/images/emoji/twitter/green_square.png?v=14\" title=\":green_square:\" class=\"emoji only-emoji\" alt=\":green_square:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td>Natively</td>\n<td><img src=\"https://delvingbitcoin.org/images/emoji/twitter/orange_square.png?v=14\" title=\":orange_square:\" class=\"emoji only-emoji\" alt=\":orange_square:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td>Extra step</td>\n<td><img src=\"https://delvingbitcoin.org/images/emoji/twitter/red_square.png?v=14\" title=\":red_square:\" class=\"emoji only-emoji\" alt=\":red_square:\" loading=\"lazy\" width=\"20\" height=\"20\"></td>\n<td>No</td>\n</tr>\n</tbody>\n</table>\n</div>",
  "post_number": 68,
  "post_type": 1,
  "posts_count": 78,
  "updated_at": "2025-05-24T14:33:01.804Z",
  "reply_count": 1,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 105,
  "reads": 41,
  "readers_count": 40,
  "score": 528.2,
  "yours": false,
  "topic_id": 303,
  "topic_slug": "how-to-linearize-your-cluster",
  "topic_title": "How to linearize your cluster",
  "topic_html_title": "How to linearize your cluster",
  "category_id": 8,
  "display_username": "Pieter Wuille",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 14,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "I'm beginning to think that the [spanning-forest linearization](https://delvingbitcoin.org/t/spanning-forest-cluster-linearization/1419) (SFL) algorithm is a better choice in general than the min-cut GGT algorithm, because while asymptotic complexity is worse (it can in theory run forever, though randomization makes this unlikely), it's actually a lot more practical. It's of course possible to combine the two, e.g., use GGT just for linearizing very hard clusters in a background thread, but it'll practically be barely used I expect.\n\nThe reasons for choosing SFL over [GGT](https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303/9) and CSS (candidate set search, the old exponential algorithm which [this thread](https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303/1) was originally about) are:\n* **[Anytime algorithm](https://en.wikipedia.org/wiki/Anytime_algorithm)**: it is possible to interrupt SFL at any point, and get a linearization out. The longer it runs, the better the result gets. This is also true for CSS, but less so for GGT as any min-cut that has not been computed completely may not result in an improvement (and the entire runtime may consist of just a single cut).\n* **Improving existing linearizations**: it is possible to initialize SFL with an existing linearization as input, and any output it gives will be a linearization that's better or equal. In some, but not all, practical cases it makes the algorithm also find the optimal faster when provided with a good input linearization already. This avoids the need to use the [linearization merging](https://delvingbitcoin.org/t/merging-incomparable-linearizations/209) algorithm to combine with existing linearization, or the [LIMO algorithm](https://delvingbitcoin.org/t/limo-combining-the-best-parts-of-linearization-search-and-merging/825) to combine candidate finding with improvement of an existing linearization.\n* **Load balancing**: both GGT and CSS subdivide the problem in different ways. When trying to turn them into anytime algorithms, there is a question of how to subdivide the computation budget over these subproblems. In contrast, SFL always just operates on a single state which it keeps improving, so no such budgetting decisions are necessary.\n* **Fairness**: Related to the previous point, it is easy to make SFL spread its work over all transactions in the cluster in a more-or-less fair way, for example by trying going through the transactions in a round-robin fashion to find dependencies to improve. GGT works by subdividing the cluster in a divide-and-conquer manner, but choices need to be made about which part to attempt to subdivide next. CSS fundamentally works from highest-feerate to lowest-feerate chunks, so if time runs after only some part is done, the (transactions in) the first chunk will have had more effort on them. I think that's concerning, because it risks an attacker attaching a very complex set of transactions to an honest CPFP or so, and have the algorithm spend all its time on the attacker's transactions, running out before even considering the steps necessary to recognize the CPFP.\n* **Runtime**: when benchmarking using replayed mempool data of previous years (credit to @sdaftuar), my SFL implementation seems somewhat (~2x) faster than the GGT one.\n* **Integer arithmetic**: GGT needs to represent flows and feerates as [approximate integers](https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303/50), which need to be scaled such that they are sufficiently precise. If $F$ is the sum of the (absolute values of) fees in the graph and $S$ the sum of the sizes in the graph, then GGT needs integers large enough to represent $4S^2F$ if exactly optimal solutions are desired. SFL and CSS only need integers large enough to represent $2SF$ and $SF$. Of course, perhaps we don't care about exactness of solutions for huge clusters that pay enormous feerates, and in either case, this isn't a very hard problem, just complicates the implementation somewhat.\n\nThe downsides of SFL compared to GGT are:\n* **Complexity bounds**: ~~there is no known bound for the runtime of SFL, and it may be infinite~~ SFL may in theory run forever, while GGT is proven to be $\\mathcal{O}(n^3)$. However, even that cubic runtime is probably too much in the worst case to run at transaction relay time. Also note that we don't really need optimal linearization. They're nice, because they're obviously the most incentive-compatible ones, but in practice, the bar is really a \"good enough for what people actually use\", which is hard to define, and interacts in difficult ways with adversial models (see fairness above).\n\nThe downsides of SFL compared to CSS are:\n* **Mix with ancestor sort**: CSS, when used through LIMO, can include arbitrary additional sources for finding good topological sets to move to the front. In the current implementation, optimal ancestor sets are used as additional inputs. There are no well-defined properties that this gives the linearization, but at least intuitively, this provides a \"linearization always has at least ancestor-set like quality\" property, regardless of how much time was spent in candidate finding. I don't know how to do anything like this in SFL (nor in GGT). If we believe that this quality is important, despite not being well-defined, then switching to SFL in theory means we could lose it in clusters that cannot be linearized optimally in time. My thinking is that combined with the SFL fairness, and the fact that it is just so much faster overall, it is unlikely to be an issue. Further, if we *really* wanted ancestor-sort quality, it would be possible to compute, in addition to running SFL, an ancestor sort linearization from scratch, and then merge the two if SFL doesn't find an optimal result. However, I suspect that the time this would take is better spent on performing more SFL iterations.\n* ~~**Minimal chunks**: CSS finds a linearization by actively searching for good chunks to move to the front, and in doing so, it can prefer smaller chunks over bigger ones. This guarantees that (if it completes) it will find the linearization with *minimal* possible chunks among all feerate-diagram-optimal linearizations. SFL (and GGT) on the other hand really just find groups of connected transactions with equal chunk feerate, and thus can't guarantee to pull equal-feerate chunks apart.~~ EDIT: with an [extra step](https://delvingbitcoin.org/t/spanning-forest-cluster-linearization/1419/9), SFL can find the minimal chunks.\n* **Complexity bounds**: SFL may in theory run forever, while CSS is trivially bounded by $\\mathcal{O}(n \\cdot 2^n)$, although I believe it may be $\\mathcal{O}(n \\cdot \\sqrt{2^n})$ instead. These bounds are obviously impractical.\n\nAll 3 above issues are open questions, and solutions/improvements could be found to them.\n\n---\n\nIn table form:\n\n|Trait | | [CSS](https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303/1) | | [SFL](https://delvingbitcoin.org/t/spanning-forest-cluster-linearization/1419/1) | | [GGT](https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303/9)|\n|--- | --- | --- | ---| --- | --- | --- |\n|**Proven worst-case** | \ud83d\udfe5 | $\\mathcal{O}(n \\cdot 2^n)$ | \ud83d\udfe5 | $\\mathcal{O}(\\infty)$ | \ud83d\udfe9| $\\mathcal{O}(n^3)$|\n|**Conjectured worst complexity** | \ud83d\udfe5| $\\mathcal{O}(n \\cdot \\sqrt{2^n})$ | \ud83d\udfe7 | $\\mathcal{O}(\\infty)$ | \ud83d\udfe9 | $\\mathcal{O}(n^3)$|\n|**Historical avg. runtime (\u00b5s)** $(n \\leq 64)$ | \ud83d\udfe5|80 | \ud83d\udfe9|10 | \ud83d\udfe7|22|\n|**Historical worst runtime (\u00b5s)** $(n \\leq 64)$ | \ud83d\udfe5|31500 | \ud83d\udfe9|26 | \ud83d\udfe7|33|\n|**Extrapolated worst runtime (\u00b5s)** $(n \\leq 64)$ | \ud83d\udfe7|700,000,000 | \ud83d\udfe5|$\\infty$ | \ud83d\udfe9|10,000|\n|**Anytime algorithm** | \ud83d\udfe7|Needs budgeting | \ud83d\udfe9|Natively | \ud83d\udfe5|May lose progress |\n|**Improving existing** | \ud83d\udfe7|Through [LIMO](https://delvingbitcoin.org/t/limo-combining-the-best-parts-of-linearization-search-and-merging/825) | \ud83d\udfe9|Natively | \ud83d\udfe5|[Merging]((https://delvingbitcoin.org/t/merging-incomparable-linearizations/209)) afterwards|\n|**Fairness** | \ud83d\udfe5|Hard | \ud83d\udfe9|Easy | \ud83d\udfe5|Hard|\n**Integer sizes**|\ud83d\udfe9|$SF$ $(\\times,<)$ |\ud83d\udfe9|$2SF$ $(\\times,<,-)$ |\ud83d\udfe7 |$4S^2F$ $(\\times,/,<,+,-)$|\n|**Ancestor sort mix** | \ud83d\udfe9|Yes | \ud83d\udfe5|No | \ud83d\udfe5|No|\n|**Minimal chunks** | \ud83d\udfe9|Natively | \ud83d\udfe7|Extra step | \ud83d\udfe5|No|",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 96,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "I\u2019m beginning to think that the <a href=\"https://delvingbitcoin.org/t/spanning-forest-cluster-linearization/1419\">spanning-forest linearization</a> (SFL) algorithm is a better choice in general than the min-cut GGT algorithm, because while asymptotic complexity is worse (it can in theory run forever, though randomization makes this unlikely), it\u2019s actually a lot more practical. It\u2019s &hellip;",
  "truncated": true,
  "post_url": "/t/how-to-linearize-your-cluster/303/68",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}