{
  "id": 4681,
  "name": "Ruben Somsen",
  "username": "RubenSomsen",
  "avatar_template": "/user_avatar/delvingbitcoin.org/rubensomsen/{size}/188_2.png",
  "created_at": "2025-04-02T19:38:57.396Z",
  "cooked": "<p>Nice work! Really great to see such a large speedup already on the initial benchmark, especially considering this is without parallel block validation. Btw I now call this \u201cSwiftSync\u201d and I\u2019ve been working on a full write-up. I\u2019ll send you the unpublished draft, but I already published an initial overview <a href=\"https://gist.github.com/RubenSomsen/82ccd0f913057e05353b437457f68a11?permalink_comment_id=5510301#gistcomment-5510301\">here</a> (along with the coredev session notes). I also gave a presentation on it at the recent Amsterdam bitdevs. Slides are <a href=\"https://docs.google.com/presentation/d/1sqZIW3tBubaZRpTHJzgkiW1Vln-aDvrWxJIYI7JIMS8/edit\">here</a>, though I\u2019m not sure how clear they\u2019ll be without context.</p>\n<p>Without going too much into detail (I\u2019ll leave that for the write-up), here are two important points:</p>\n<p>First, assumevalid is not actually a prerequisite (though it does make for an easier first PoC). Perhaps that was my fault for emphasizing it too much - you weren\u2019t the only one who got that impression. When processing the output you can add all the UTXO set data into the hash instead of just the outpoint. On the input side you\u2019d then have to re-download the UTXOs that are being spent in each block (essentially the undo data, though we should encode it a bit more efficiently\u2026 maybe 10% more data) in order to remove it again. This allows you to do full validation without assumevalid (a few more steps are actually needed, but you\u2019ll see the details in the draft).</p>\n<p>Second, MuHash is not strictly required. We can use a regular hash function like sha256 and do modular arithmetic, provided we add a salt to prevent birthday attacks. So it\u2019d be <code>hash(utxo_data_A||salt) + hash(utxo_data_B||salt) - hash(utxo_data_C||salt) - hash(utxo_data_D||salt) == 0</code> (thus proving <code>(A==C &amp;&amp; B==D) || (A==D &amp;&amp; B==C)</code>). This should be faster than MuHash.</p>\n<p>And one point of lesser importance, but it\u2019s simple to implement so why not: you can encode the bit hints as the number of 0\u2019s before each 1. So 00010000011001 would be encoded as 3,5,0,2. There is more you can do, but this should already save a ton of space.</p>\n<p>Very exciting!</p>",
  "post_number": 2,
  "post_type": 1,
  "updated_at": "2025-04-02T19:38:57.396Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 4,
  "reads": 15,
  "readers_count": 14,
  "score": 18.0,
  "yours": false,
  "topic_id": 1562,
  "topic_slug": "ibd-booster-speeding-up-ibd-with-pre-generated-hints-poc",
  "topic_title": "IBD Booster -- Speeding up IBD with pre-generated hints (PoC)",
  "topic_html_title": "IBD Booster &ndash; Speeding up IBD with pre-generated hints (PoC)",
  "category_id": 8,
  "display_username": "Ruben Somsen",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": "",
  "bookmarked": false,
  "raw": "Nice work! Really great to see such a large speedup already on the initial benchmark, especially considering this is without parallel block validation. Btw I now call this \"SwiftSync\" and I've been working on a full write-up. I'll send you the unpublished draft, but I already published an initial overview [here](https://gist.github.com/RubenSomsen/82ccd0f913057e05353b437457f68a11?permalink_comment_id=5510301#gistcomment-5510301) (along with the coredev session notes). I also gave a presentation on it at the recent Amsterdam bitdevs. Slides are [here](https://docs.google.com/presentation/d/1sqZIW3tBubaZRpTHJzgkiW1Vln-aDvrWxJIYI7JIMS8/edit), though I'm not sure how clear they'll be without context.\n\nWithout going too much into detail (I'll leave that for the write-up), here are two important points:\n\nFirst, assumevalid is not actually a prerequisite (though it does make for an easier first PoC). Perhaps that was my fault for emphasizing it too much - you weren't the only one who got that impression. When processing the output you can add all the UTXO set data into the hash instead of just the outpoint. On the input side you'd then have to re-download the UTXOs that are being spent in each block (essentially the undo data, though we should encode it a bit more efficiently... maybe 10% more data) in order to remove it again. This allows you to do full validation without assumevalid (a few more steps are actually needed, but you'll see the details in the draft).\n\nSecond, MuHash is not strictly required. We can use a regular hash function like sha256 and do modular arithmetic, provided we add a salt to prevent birthday attacks. So it'd be `hash(utxo_data_A||salt) + hash(utxo_data_B||salt) - hash(utxo_data_C||salt) - hash(utxo_data_D||salt) == 0` (thus proving `(A==C && B==D) || (A==D && B==C)`). This should be faster than MuHash.\n\nAnd one point of lesser importance, but it's simple to implement so why not: you can encode the bit hints as the number of 0's before each 1. So 00010000011001 would be encoded as 3,5,0,2. There is more you can do, but this should already save a ton of space.\n\nVery exciting!",
  "actions_summary": [],
  "moderator": true,
  "admin": true,
  "staff": true,
  "user_id": 2,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}