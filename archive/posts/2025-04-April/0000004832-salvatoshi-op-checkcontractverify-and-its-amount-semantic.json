{
  "id": 4832,
  "name": "salvatoshi",
  "username": "salvatoshi",
  "avatar_template": "/user_avatar/delvingbitcoin.org/salvatoshi/{size}/72_2.png",
  "created_at": "2025-04-19T15:56:27.954Z",
  "cooked": "<aside class=\"quote no-group quote-modified\" data-username=\"AntoineP\" data-post=\"10\" data-topic=\"1527\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/antoinep/48/483_2.png\" class=\"avatar\"> AntoineP:</div>\n<blockquote>\n<p>I think this is the wrong direction to take. There are a few reasons:\n<br>[ \u2026 ]</p>\n</blockquote>\n</aside>\n<p>I don\u2019t find these arguments particularly convincing. Input validation parallelization is already an approach that can be argued to have caused a certain amount of additional code complexity. Therefore, if (?) it can be proven (with benchmarks) that it doesn\u2019t bring any substantial benefit - then that could be an argument for its removal.\nToday, the counter-example to this no-benefits claim is the fact that parallel input validation (poorly) mitigates the damage of quadratic hashing - which I look forward to see mitigated more properly with your work on the Great Consensus Cleanup.\nSimplifying the interpreter code would benefit any present and future cross-input logic - not just CCV.</p>\n<p>In any case, I will not pursue this approach further at this time, as it widens the scope of the change too much.</p>\n<aside class=\"quote no-group\" data-username=\"AntoineP\" data-post=\"10\" data-topic=\"1527\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/antoinep/48/483_2.png\" class=\"avatar\"> AntoineP:</div>\n<blockquote>\n<p>If your transaction doesn\u2019t have a signature, malleability already goes out the window.</p>\n</blockquote>\n</aside>\n<p>You\u2019re right, it doesn\u2019t make a difference. I was thinking of cases where CCV makes sense without signatures (for example it seems to make sense for the <em>recover</em> transaction of vaults, which can be implemented so that jut knowledge of the spending path is enough to execute it. It seems to me that the little malleability possible is not an issue - but then it wouldn\u2019t be an issue even with your annex approach.</p>\n<aside class=\"quote no-group\" data-username=\"AntoineP\" data-post=\"10\" data-topic=\"1527\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/antoinep/48/483_2.png\" class=\"avatar\"> AntoineP:</div>\n<blockquote>\n<p>Why \u201cwould\u201d? I <a href=\"https://github.com/bitcoin/bitcoin/compare/v29.0...darosior:2504_hack_poc_annex_amounts\" rel=\"noopener nofollow ugc\">demonstrated it</a> already, and it\u2019s <em>much</em> simpler.</p>\n</blockquote>\n</aside>\n<p>You demonstrated the amount logic based on the annex, but there\u2019s still a non-trivial amount of code that is missing to make it work with a covenant opcode, and that\u2019s required for a fair comparison. An opcode adopting this system will have to:</p>\n<ul>\n<li>parse the parameters relevant to the amount constraints</li>\n<li>make sure that these constraints are indeed present in the annex</li>\n</ul>\n<p>This will require adding the annex constraints in a place that is accessible during the opcode execution (perhaps in <code>ScriptExecutionData</code>), with some due care as they should be stored in a format that can be queried efficiently like a hash table in order to avoid introducing <em>quadratic annexing</em>\u2026</p>\n<p>I\u2019m convinced that your approach is <em>somewhat</em> simpler than the deferred checks, but it\u2019s definitely more complicated/redundant than the current implementation based on a mutex from the current PR. (for comparison the current amount logic is entirely contained in <a href=\"https://github.com/bitcoin/bitcoin/blob/77c8c9ebb8082e8285d0c5d3b302c319fe659ae5/src/script/interpreter.h#L246-L301\" rel=\"noopener nofollow ugc\">interpreter.h#L246-L301</a> plus <a href=\"https://github.com/bitcoin/bitcoin/blob/77c8c9ebb8082e8285d0c5d3b302c319fe659ae5/src/script/interpreter.cpp#L1896-L1943\" rel=\"noopener nofollow ugc\">interpreter.cpp#L1896-L1943</a>).</p>\n<hr>\n<p>Taking a step back, my general impression is that for even for something like <a href=\"https://github.com/bitcoin/bitcoin/pull/29491\" rel=\"noopener nofollow ugc\">batch validation</a> (that is already useful today), one of:</p>\n<ul>\n<li>synchronization with mutexes</li>\n<li>a mechanism like deferred checks</li>\n<li>removal of parallel input validation</li>\n</ul>\n<p>will be necessary. Whatever solution is deemed best, it will be re-usable for CCV without sacrificing the desirable semantic (and avoiding redundant bytes).</p>",
  "post_number": 11,
  "post_type": 1,
  "posts_count": 13,
  "updated_at": "2025-04-19T15:56:27.954Z",
  "reply_count": 0,
  "reply_to_post_number": 10,
  "quote_count": 1,
  "incoming_link_count": 1,
  "reads": 24,
  "readers_count": 23,
  "score": 9.8,
  "yours": false,
  "topic_id": 1527,
  "topic_slug": "op-checkcontractverify-and-its-amount-semantic",
  "topic_title": "OP_CHECKCONTRACTVERIFY and its amount semantic",
  "topic_html_title": "OP_CHECKCONTRACTVERIFY and its amount semantic",
  "category_id": 7,
  "display_username": "salvatoshi",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"AntoineP, post:10, topic:1527\"]\nI think this is the wrong direction to take. There are a few reasons:\n<br>[ ... ]\n[/quote]\n\nI don't find these arguments particularly convincing. Input validation parallelization is already an approach that can be argued to have caused a certain amount of additional code complexity. Therefore, if (?) it can be proven (with benchmarks) that it doesn't bring any substantial benefit - then that could be an argument for its removal.\nToday, the counter-example to this no-benefits claim is the fact that parallel input validation (poorly) mitigates the damage of quadratic hashing - which I look forward to see mitigated more properly with your work on the Great Consensus Cleanup.\nSimplifying the interpreter code would benefit any present and future cross-input logic - not just CCV.\n\nIn any case, I will not pursue this approach further at this time, as it widens the scope of the change too much.\n\n[quote=\"AntoineP, post:10, topic:1527\"]\nIf your transaction doesn\u2019t have a signature, malleability already goes out the window.\n[/quote]\n\nYou're right, it doesn't make a difference. I was thinking of cases where CCV makes sense without signatures (for example it seems to make sense for the *recover* transaction of vaults, which can be implemented so that jut knowledge of the spending path is enough to execute it. It seems to me that the little malleability possible is not an issue - but then it wouldn't be an issue even with your annex approach.\n\n[quote=\"AntoineP, post:10, topic:1527\"]\nWhy \u201cwould\u201d? I [demonstrated it](https://github.com/bitcoin/bitcoin/compare/v29.0...darosior:2504_hack_poc_annex_amounts) already, and it\u2019s *much* simpler.\n[/quote]\n\nYou demonstrated the amount logic based on the annex, but there's still a non-trivial amount of code that is missing to make it work with a covenant opcode, and that's required for a fair comparison. An opcode adopting this system will have to:\n- parse the parameters relevant to the amount constraints\n- make sure that these constraints are indeed present in the annex\n\nThis will require adding the annex constraints in a place that is accessible during the opcode execution (perhaps in `ScriptExecutionData`), with some due care as they should be stored in a format that can be queried efficiently like a hash table in order to avoid introducing *quadratic annexing*...\n\nI'm convinced that your approach is _somewhat_ simpler than the deferred checks, but it's definitely more complicated/redundant than the current implementation based on a mutex from the current PR. (for comparison the current amount logic is entirely contained in [interpreter.h#L246-L301](https://github.com/bitcoin/bitcoin/blob/77c8c9ebb8082e8285d0c5d3b302c319fe659ae5/src/script/interpreter.h#L246-L301) plus [interpreter.cpp#L1896-L1943](https://github.com/bitcoin/bitcoin/blob/77c8c9ebb8082e8285d0c5d3b302c319fe659ae5/src/script/interpreter.cpp#L1896-L1943)).\n\n---\n\nTaking a step back, my general impression is that for even for something like [batch validation](https://github.com/bitcoin/bitcoin/pull/29491) (that is already useful today), one of:\n\n  - synchronization with mutexes\n  - a mechanism like deferred checks\n  - removal of parallel input validation\n\nwill be necessary. Whatever solution is deemed best, it will be re-usable for CCV without sacrificing the desirable semantic (and avoiding redundant bytes).",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 81,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "I don\u2019t find these arguments particularly convincing. Input validation parallelization is already an approach that can be argued to have caused a certain amount of additional code complexity. Therefore, if (?) it can be proven (with benchmarks) that it doesn\u2019t bring any substantial benefit - then t&hellip;",
  "truncated": true,
  "post_url": "/t/op-checkcontractverify-and-its-amount-semantic/1527/11",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}