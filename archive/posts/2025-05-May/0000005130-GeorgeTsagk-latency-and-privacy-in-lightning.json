{
  "id": 5130,
  "name": "George Tsagkarelis",
  "username": "GeorgeTsagk",
  "avatar_template": "/user_avatar/delvingbitcoin.org/georgetsagk/{size}/162_2.png",
  "created_at": "2025-05-27T13:31:37.554Z",
  "cooked": "<p>Thanks for the write-up!</p>\n<h3><a name=\"p-5130-attributable-failures-1\" class=\"anchor\" href=\"#p-5130-attributable-failures-1\"></a>Attributable Failures</h3>\n<p>I think changing the attr failure encoding to enforce hold_time related attributes isn\u2019t that absolute, routing nodes could manipulate the \u201cprotected\u201d encoding to signal lower delays, e.g if we used uint8 hold times then <code>10001000</code> could be some slang for <code>16ms</code>, and this could break a theoretical floor of <code>100ms</code>. The sender of the payment also has to opt-in to this custom value interpretation.</p>\n<p>We need to keep in mind that the reporting of the hold times as part of the attributable failures upgrade was just a placeholder that can prove useful in the future. It\u2019s not precise and certainly not reliable. Routing nodes can choose to lie or trim their hold times to make themselves look more attractive, and this inaccuracy would definitely be factored into the sender\u2019s pathfinding/scoring algorithm.</p>\n<p>Seems as if we rushed ahead to assume that hold times are going to be the primary attribute to score a node by? This is definitely not covered by attr failure spec and I\u2019m not sure if any discussion has started around how the values would be incorporated into pathfinding feedback.</p>\n<p>We could have senders interpret all values below a threshold as if they were the same, so <code>87ms / 42ms / 99ms</code> would all be considered as <code>100ms / 100ms / 100ms</code>. Routing nodes are free to race to the bottom, but for the majority of the network which defaults to the above behavior it wouldn\u2019t make a difference.</p>\n<h3><a name=\"p-5130-off-path-adversary-2\" class=\"anchor\" href=\"#p-5130-off-path-adversary-2\"></a>Off path adversary</h3>\n<p>Doing the LND-style commitment batching (maybe with greater &amp; randomized intervals?) is attractive, but would definitely contribute towards slower payment attempts.</p>\n<p>Since the cost of having timing related defenses is equally paid by payment senders, it\u2019s wiser to focus on the data/traffic obfuscation vector. Cover traffic sounds very promising, and can definitely help with muddying the waters for the adversary. This could also be an opt-in feature, controllable by the sender.</p>\n<p>A sender-controlled approach could be having a mock path which doesn\u2019t change the commitment tx and follows an onion route which only triggers a <code>mock_add_htlc</code> message. This way for every real payment there would be X \u201cmock payments\u201d travelling over a somewhat related route, solely for the purpose of misleading the network-level adversary. A node receiving a <code>mock_add_htlc</code> knows that the only purpose of the message is to forward it to another peer.</p>\n<p>Another simple approach could be having empty <code>mock_add_htlc</code> messages (no onion layers of any kind) with a <code>TTL</code> field, that nodes along the real payment path optimistically transmit (random receiver and delay included). A node receiving the mock message forwards to another random peer if TTL&gt;0, decreasing the TTL by 1. The longest possible route here could also be a <code>mock_add_htlc</code> chain triggered by the last hop before the receiver.</p>\n<p>All mock/obfuscation related messages should of course have their own processing budget and not interfere with channel related messages that are of higher priority.</p>\n<h3><a name=\"p-5130-on-path-adversary-3\" class=\"anchor\" href=\"#p-5130-on-path-adversary-3\"></a>On path adversary</h3>\n<p>I don\u2019t have much to add here, the sender/receiver controlled delays seem to be a very nice angle to tackle the issue.</p>",
  "post_number": 6,
  "post_type": 1,
  "posts_count": 40,
  "updated_at": "2025-05-27T13:31:37.554Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 2,
  "reads": 36,
  "readers_count": 35,
  "score": 32.2,
  "yours": false,
  "topic_id": 1723,
  "topic_slug": "latency-and-privacy-in-lightning",
  "topic_title": "Latency and Privacy in Lightning",
  "topic_html_title": "Latency and Privacy in Lightning",
  "category_id": 7,
  "display_username": "George Tsagkarelis",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Thanks for the write-up!\n\n### Attributable Failures\n\nI think changing the attr failure encoding to enforce hold_time related attributes isn't that absolute, routing nodes could manipulate the \"protected\" encoding to signal lower delays, e.g if we used uint8 hold times then `10001000` could be some slang for `16ms`, and this could break a theoretical floor of `100ms`. The sender of the payment also has to opt-in to this custom value interpretation.\n\nWe need to keep in mind that the reporting of the hold times as part of the attributable failures upgrade was just a placeholder that can prove useful in the future. It's not precise and certainly not reliable. Routing nodes can choose to lie or trim their hold times to make themselves look more attractive, and this inaccuracy would definitely be factored into the sender's pathfinding/scoring algorithm.\n\nSeems as if we rushed ahead to assume that hold times are going to be the primary attribute to score a node by? This is definitely not covered by attr failure spec and I'm not sure if any discussion has started around how the values would be incorporated into pathfinding feedback.\n\nWe could have senders interpret all values below a threshold as if they were the same, so `87ms / 42ms / 99ms` would all be considered as `100ms / 100ms / 100ms`. Routing nodes are free to race to the bottom, but for the majority of the network which defaults to the above behavior it wouldn't make a difference.\n\n### Off path adversary\n\nDoing the LND-style commitment batching (maybe with greater & randomized intervals?) is attractive, but would definitely contribute towards slower payment attempts.\n\nSince the cost of having timing related defenses is equally paid by payment senders, it's wiser to focus on the data/traffic obfuscation vector. Cover traffic sounds very promising, and can definitely help with muddying the waters for the adversary. This could also be an opt-in feature, controllable by the sender.\n\nA sender-controlled approach could be having a mock path which doesn't change the commitment tx and follows an onion route which only triggers a `mock_add_htlc` message. This way for every real payment there would be X \"mock payments\" travelling over a somewhat related route, solely for the purpose of misleading the network-level adversary. A node receiving a `mock_add_htlc` knows that the only purpose of the message is to forward it to another peer.\n\nAnother simple approach could be having empty `mock_add_htlc` messages (no onion layers of any kind) with a `TTL` field, that nodes along the real payment path optimistically transmit (random receiver and delay included). A node receiving the mock message forwards to another random peer if TTL>0, decreasing the TTL by 1. The longest possible route here could also be a `mock_add_htlc` chain triggered by the last hop before the receiver.\n\nAll mock/obfuscation related messages should of course have their own processing budget and not interfere with channel related messages that are of higher priority.\n\n### On path adversary\n\nI don't have much to add here, the sender/receiver controlled delays seem to be a very nice angle to tackle the issue.",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 144,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "Thanks for the write-up! \n<a name=\"p-5130-attributable-failures-1\" class=\"anchor\" href=\"#p-5130-attributable-failures-1\"></a>Attributable Failures\nI think changing the attr failure encoding to enforce hold_time related attributes isn\u2019t that absolute, routing nodes could manipulate the \u201cprotected\u201d encoding to signal lower delays, e.g if we used uint8 hold times then 10001000 could be some slang fo&hellip;",
  "truncated": true,
  "post_url": "/t/latency-and-privacy-in-lightning/1723/6",
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}