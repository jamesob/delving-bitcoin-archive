{
  "id": 5065,
  "name": "David Gumberg",
  "username": "davidgumberg",
  "avatar_template": "/user_avatar/delvingbitcoin.org/davidgumberg/{size}/378_2.png",
  "created_at": "2025-05-21T00:47:41.040Z",
  "cooked": "<p><a href=\"https://github.com/0xB10C/bitcoin/commits/2025-03-prefill-compactblocks/\" rel=\"noopener nofollow ugc\">0xB10C/2025-03-prefill-compactblocks</a> is very interesting,</p>\n<blockquote>\n<p>since the positive effect on the network is only measurable with a wide(r) deployment of the prefilling patch, it\u2019s probably worthwhile to do some Warnet simulations on this and test the improvement under different scenarios.</p>\n</blockquote>\n<p>I think one low effort way to perform a limited test of this patch on mainnet is to run a second node which only listens to <code>CMPCTBLOCK</code> announcements from manually-connected peers, and is manually connected to a <a href=\"https://github.com/0xB10C/bitcoin/commits/2025-03-prefill-compactblocks/\" rel=\"noopener nofollow ugc\">0xB10C/2025-03-prefill-compactblocks</a> node. I\u2019ve created a branch to try this: <a href=\"https://github.com/davidgumberg/bitcoin/tree/5-20-25-cmpct-manual-only\" rel=\"noopener nofollow ugc\">davidgumberg/5-20-25-cmpct-manual-only</a>, I\u2019ll try to run an experiment soon with two nodes.</p>\n<hr>\n<blockquote>\n<p>My assumption would be that if we prefill:</p>\n<ul>\n<li>transactions we had to request</li>\n<li>transactions we took from our extra pool</li>\n<li>prefilled transactions we didn\u2019t have in our mempool (i.e. prefilled txns that were announced to use and ended up being useful)</li>\n</ul>\n</blockquote>\n<p>I think the privacy concerns raised in <a href=\"https://github.com/bitcoin/bitcoin/pull/27086\" rel=\"noopener nofollow ugc\">bitcoin/bitcoin#27086</a>, are relevant here, how can a node avoid:</p>\n<ol>\n<li>Providing a unique fingerprint by revealing its exact mempool policy in CMPCTBLOCK announcements.</li>\n<li>Revealing all of the non-standard transactions that belong to it by failing to include them in it\u2019s prefill.</li>\n</ol>\n<p><code>2.</code> is more severe, and may be part of a class of problems (mempool\u2019s special treatment of it\u2019s own transactions) that is susceptible to a general fix outside of the scope of compact block prefill. Even if it\u2019s impossible or infeasible to close all leaks of what\u2019s in your mempool, it would be good to solve this.</p>\n<p>One way of fixing this might be to add another instantation of the mempool data structure (<a href=\"https://github.com/bitcoin/bitcoin/blob/ee5409d5705b2cb955c12e3ba07e051164b378d4/src/txmempool.h#L303\" rel=\"noopener nofollow ugc\"><code>CTxMempool</code></a>), maybe called <code>m_user_pool</code>. Most of the code could go unchanged except for where it is desirable to give special treatment to user transactions, and these cases could be handled explicitly.</p>\n<p>To solve <code>1.</code>, I wonder if there is a reasonably performant way to shift the prefills in the direction of prefilled transactions the node <em>wouldn\u2019t</em> have included according to default mempool policy. This is not just for privacy, as I imagine this is the ideal set of transactions to include, strict mempools prefilling too much, and loose mempools prefilling too little.<sup class=\"footnote-ref\"><a href=\"#footnote-5065-1\" id=\"footnote-ref-5065-1\">[1]</a></sup> If this would be too expensive to compute on CMPCTBLOCK receipt, maybe a variation of <code>m_user_pool</code> is possible, where a node maintains another <code>CTxMempool</code> instance for all the transactions which default mempool policy would have excluded, but user supplied arguments have permitted. Or maybe the extra state is too expensive/complicated, and instead just performing an extra standardness check with the default policy on tx receipt and setting a flag on the tx (or keeping a map of flagged tx\u2019es) is enough.</p>\n<p>Maybe all of this is too complicated to implement proportional to its value here, but these could also be steps toward solving mempool fingerprinting more generally.<sup class=\"footnote-ref\"><a href=\"#footnote-5065-2\" id=\"footnote-ref-5065-2\">[2]</a></sup></p>\n<hr>\n<blockquote>\n<p>the number of TCP packets sent over could increase if we\u2019re making the CMPCTBLOCK message larger with prefilledtxns.</p>\n</blockquote>\n<p>I am not very knowledgeable about TCP, but as I understand <a href=\"https://datatracker.ietf.org/doc/html/rfc5681\" rel=\"noopener nofollow ugc\">RFC 5681</a>, the issue is not a message growing to a size where it has to be split across multiple packets/segments, but a message that grows too big to fit in the receiver-advertised message window (rwnd) and the RFC 5681 (or other congestion control algorithm) specified congestion window. (cwnd). The smallest of these two (cwnd and rwnd) is the largest amount of data that can be transmitted in a single TCP round trip, it should be possible to get the relevant metrics for this from the <code>tcp_info</code> structure on *nix systems<sup class=\"footnote-ref\"><a href=\"#footnote-5065-3\" id=\"footnote-ref-5065-3\">[3]</a></sup> doing something like:</p>\n<pre data-code-wrap=\"c\"><code class=\"lang-c\">struct tcp_info info;\nsocklen_t info_len = sizeof(info);\ngetsockopt(sockfd, IPPROTO_TCP, TCP_INFO, &amp;info, &amp;info_len)\n\n// congestion send window (# of segments) * mss (max segment size)\nuint32_t cwnd_bytes = info.tcpi_snd_cwnd * info.tcpi_snd_mss;\n// our peer's advertised receive window in bytes\nuint32_t peer_rwnd_bytes = info.tcpi_snd_wnd;\n// get the smaller one\nuint32_t max_bytes_per_round_trip = cwnd_bytes &lt; peer_rwnd_bytes ? cwnd_bytes : peer_rwnd_bytes;\n</code></pre>\n<p>And the announcer could pack the prefill until it hits this limit. I am not sure how likely it is that that constraining messages to this size would deter a second round trip from taking place, but it seems like a reasonable starting point.</p>\n<hr class=\"footnotes-sep\">\n\n<ol class=\"footnotes-list\">\n<li id=\"footnote-5065-1\" class=\"footnote-item\"><p>For better or for worse, such an approach would disadvantage nodes with stricter-than-default mempools in compact block reconstruction. <a href=\"#footnote-ref-5065-1\" class=\"footnote-backref\">\u21a9\ufe0e</a></p>\n</li>\n<li id=\"footnote-5065-2\" class=\"footnote-item\"><p>But maybe no general solution to mempool fingerprinting is possible, and nodes with non-default mempools shouldn\u2019t have any expectation that they can\u2019t be fingerprinted. <a href=\"#footnote-ref-5065-2\" class=\"footnote-backref\">\u21a9\ufe0e</a></p>\n</li>\n<li id=\"footnote-5065-3\" class=\"footnote-item\"><p><a href=\"https://github.com/torvalds/linux/blob/b36ddb9210e6812eb1c86ad46b66cc46aa193487/include/uapi/linux/tcp.h#L261\" rel=\"noopener nofollow ugc\">Linux</a>, <a href=\"https://developer.apple.com/documentation/kernel/tcp_info/3944476-tcpi_snd_cwnd\" rel=\"noopener nofollow ugc\">Mac</a>, <a href=\"https://github.com/freebsd/freebsd-src/blob/3d2957336c7ddaa0a29cf60cfd458c07df1f5be9/sys/netinet/tcp.h#L421\" rel=\"noopener nofollow ugc\">FreeBSD</a> It seems something similar on Windows is possible with <a href=\"https://learn.microsoft.com/en-us/windows/win32/winsock/sio-tcp-info\" rel=\"noopener nofollow ugc\"><code>SIO_TCP_INFO</code></a> <a href=\"#footnote-ref-5065-3\" class=\"footnote-backref\">\u21a9\ufe0e</a></p>\n</li>\n</ol>",
  "post_number": 29,
  "post_type": 1,
  "posts_count": 42,
  "updated_at": "2025-05-21T06:35:09.509Z",
  "reply_count": 2,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 23,
  "reads": 54,
  "readers_count": 53,
  "score": 135.8,
  "yours": false,
  "topic_id": 1052,
  "topic_slug": "stats-on-compact-block-reconstructions",
  "topic_title": "Stats on compact block reconstructions",
  "topic_html_title": "Stats on compact block reconstructions",
  "category_id": 7,
  "display_username": "David Gumberg",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 4,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[0xB10C/2025-03-prefill-compactblocks](https://github.com/0xB10C/bitcoin/commits/2025-03-prefill-compactblocks/) is very interesting, \n\n> since the positive effect on the network is only measurable with a wide(r) deployment of the prefilling patch, it\u2019s probably worthwhile to do some Warnet simulations on this and test the improvement under different scenarios.\n\nI think one low effort way to perform a limited test of this patch on mainnet is to run a second node which only listens to `CMPCTBLOCK` announcements from manually-connected peers, and is manually connected to a [0xB10C/2025-03-prefill-compactblocks](https://github.com/0xB10C/bitcoin/commits/2025-03-prefill-compactblocks/) node. I've created a branch to try this: [davidgumberg/5-20-25-cmpct-manual-only](https://github.com/davidgumberg/bitcoin/tree/5-20-25-cmpct-manual-only), I'll try to run an experiment soon with two nodes.\n\n--------\n\n> My assumption would be that if we prefill:\n> - transactions we had to request\n> - transactions we took from our extra pool\n> - prefilled transactions we didn\u2019t have in our mempool (i.e. prefilled txns that were announced to use and ended up being useful)\n\nI think the privacy concerns raised in [bitcoin/bitcoin#27086](https://github.com/bitcoin/bitcoin/pull/27086), are relevant here, how can a node avoid:\n1. Providing a unique fingerprint by revealing its exact mempool policy in CMPCTBLOCK announcements.\n2. Revealing all of the non-standard transactions that belong to it by failing to include them in it's prefill.\n\n`2.` is more severe, and may be part of a class of problems (mempool's special treatment of it's own transactions) that is susceptible to a general fix outside of the scope of compact block prefill. Even if it's impossible or infeasible to close all leaks of what's in your mempool, it would be good to solve this.\n\nOne way of fixing this might be to add another instantation of the mempool data structure ([`CTxMempool`](https://github.com/bitcoin/bitcoin/blob/ee5409d5705b2cb955c12e3ba07e051164b378d4/src/txmempool.h#L303)), maybe called `m_user_pool`. Most of the code could go unchanged except for where it is desirable to give special treatment to user transactions, and these cases could be handled explicitly.\n\nTo solve `1.`, I wonder if there is a reasonably performant way to shift the prefills in the direction of prefilled transactions the node *wouldn't* have included according to default mempool policy. This is not just for privacy, as I imagine this is the ideal set of transactions to include, strict mempools prefilling too much, and loose mempools prefilling too little.[^1] If this would be too expensive to compute on CMPCTBLOCK receipt, maybe a variation of `m_user_pool` is possible, where a node maintains another `CTxMempool` instance for all the transactions which default mempool policy would have excluded, but user supplied arguments have permitted. Or maybe the extra state is too expensive/complicated, and instead just performing an extra standardness check with the default policy on tx receipt and setting a flag on the tx (or keeping a map of flagged tx'es) is enough.\n\nMaybe all of this is too complicated to implement proportional to its value here, but these could also be steps toward solving mempool fingerprinting more generally.[^2]\n\n--------\n\n>the number of TCP packets sent over could increase if we\u2019re making the CMPCTBLOCK message larger with prefilledtxns.\n\nI am not very knowledgeable about TCP, but as I understand [RFC 5681](https://datatracker.ietf.org/doc/html/rfc5681), the issue is not a message growing to a size where it has to be split across multiple packets/segments, but a message that grows too big to fit in the receiver-advertised message window (rwnd) and the RFC 5681 (or other congestion control algorithm) specified congestion window. (cwnd). The smallest of these two (cwnd and rwnd) is the largest amount of data that can be transmitted in a single TCP round trip, it should be possible to get the relevant metrics for this from the `tcp_info` structure on *nix systems[^3] doing something like:\n\n```c\nstruct tcp_info info;\nsocklen_t info_len = sizeof(info);\ngetsockopt(sockfd, IPPROTO_TCP, TCP_INFO, &info, &info_len)\n\n// congestion send window (# of segments) * mss (max segment size)\nuint32_t cwnd_bytes = info.tcpi_snd_cwnd * info.tcpi_snd_mss;\n// our peer's advertised receive window in bytes\nuint32_t peer_rwnd_bytes = info.tcpi_snd_wnd;\n// get the smaller one\nuint32_t max_bytes_per_round_trip = cwnd_bytes < peer_rwnd_bytes ? cwnd_bytes : peer_rwnd_bytes;\n```\n\nAnd the announcer could pack the prefill until it hits this limit. I am not sure how likely it is that that constraining messages to this size would deter a second round trip from taking place, but it seems like a reasonable starting point.\n\n[^1]: For better or for worse, such an approach would disadvantage nodes with stricter-than-default mempools in compact block reconstruction.\n[^2]: But maybe no general solution to mempool fingerprinting is possible, and nodes with non-default mempools shouldn't have any expectation that they can't be fingerprinted. \n[^3]: [Linux](https://github.com/torvalds/linux/blob/b36ddb9210e6812eb1c86ad46b66cc46aa193487/include/uapi/linux/tcp.h#L261), [Mac](https://developer.apple.com/documentation/kernel/tcp_info/3944476-tcpi_snd_cwnd), [FreeBSD](https://github.com/freebsd/freebsd-src/blob/3d2957336c7ddaa0a29cf60cfd458c07df1f5be9/sys/netinet/tcp.h#L421) It seems something similar on Windows is possible with [`SIO_TCP_INFO`](https://learn.microsoft.com/en-us/windows/win32/winsock/sio-tcp-info)",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 315,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "<a href=\"https://github.com/0xB10C/bitcoin/commits/2025-03-prefill-compactblocks/\" rel=\"noopener nofollow ugc\">0xB10C/2025-03-prefill-compactblocks</a> is very interesting, \n\nsince the positive effect on the network is only measurable with a wide(r) deployment of the prefilling patch, it\u2019s probably worthwhile to do some Warnet simulations on this and test the improvement under different scenarios. \n\nI think one &hellip;",
  "truncated": true,
  "post_url": "/t/stats-on-compact-block-reconstructions/1052/29",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}