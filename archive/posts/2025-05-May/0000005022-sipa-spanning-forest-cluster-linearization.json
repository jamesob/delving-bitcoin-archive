{
  "id": 5022,
  "name": "Pieter Wuille",
  "username": "sipa",
  "avatar_template": "/user_avatar/delvingbitcoin.org/sipa/{size}/1100_2.png",
  "created_at": "2025-05-17T13:08:05.308Z",
  "cooked": "<p>I have made a few changes to the merge and split selection works:</p>\n<ul>\n<li>When deciding which dependency between two to-be-merged chunks to activate, pick a uniformly random one. It turns out this can be done in <span class=\"math\">\\mathcal{O}(n)</span> time anyway, without needing to maintain randomly-sorted lists of dependencies per transaction. The previous approach picked a randomized (though not uniformly random) dependency, but always from the first transaction in the cluster that had any. This change alone seems to dramatically improve worst-case performance in synthetic clusters that are very dense (a factor 1.5x in some settings), but it also reduces attackers\u2019 ability to reliably trigger bad decisions even further.</li>\n<li>Keep track, per chunk, how many consecutive split attempts have failed on it (because the top part that was split off contains a dependency on the bottom part). Whenever that number is 1 below a multiple of 3, a uniformly random dependency within the chunk (among those with positive <span class=\"math\">q</span>) rather than the one with highest <span class=\"math\">q</span> is split. Benchmarks show that max-<span class=\"math\">q</span> is generally better on all types of graphs I can construct, but it does raise a small concern that by being more deterministic, it might be the case that adverserially-constructed clusters could reliably cause it make bad choices. I have not found any way of doing that, especially when merging is already done randomly, but out of an abundance of caution, this introduces an even more random step occasionally. By only triggering every 3rd attempt, its performance impact is minimal on realistic clusters, for which splits generally just don\u2019t fail.</li>\n</ul>\n<p>I have updated the benchmarks in the <a href=\"https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303/73\">other thread</a> to reflect this.</p>\n<p>With these changes, I\u2019m quite confident that SFL is still the way to go.</p>",
  "post_number": 8,
  "post_type": 1,
  "posts_count": 9,
  "updated_at": "2025-05-17T13:13:41.211Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 1,
  "reads": 22,
  "readers_count": 21,
  "score": 9.4,
  "yours": false,
  "topic_id": 1419,
  "topic_slug": "spanning-forest-cluster-linearization",
  "topic_title": "Spanning-forest cluster linearization",
  "topic_html_title": "Spanning-forest cluster linearization",
  "category_id": 8,
  "display_username": "Pieter Wuille",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "I have made a few changes to the merge and split selection works:\n* When deciding which dependency between two to-be-merged chunks to activate, pick a uniformly random one. It turns out this can be done in $\\mathcal{O}(n)$ time anyway, without needing to maintain randomly-sorted lists of dependencies per transaction. The previous approach picked a randomized (though not uniformly random) dependency, but always from the first transaction in the cluster that had any. This change alone seems to dramatically improve worst-case performance in synthetic clusters that are very dense (a factor 1.5x in some settings), but it also reduces attackers' ability to reliably trigger bad decisions even further.\n* Keep track, per chunk, how many consecutive split attempts have failed on it (because the top part that was split off contains a dependency on the bottom part). Whenever that number is 1 below a multiple of 3, a uniformly random dependency within the chunk (among those with positive $q$) rather than the one with highest $q$ is split. Benchmarks show that max-$q$ is generally better on all types of graphs I can construct, but it does raise a small concern that by being more deterministic, it might be the case that adverserially-constructed clusters could reliably cause it make bad choices. I have not found any way of doing that, especially when merging is already done randomly, but out of an abundance of caution, this introduces an even more random step occasionally. By only triggering every 3rd attempt, its performance impact is minimal on realistic clusters, for which splits generally just don't fail.\n\nI have updated the benchmarks in the [other thread](https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303/73) to reflect this.\n\nWith these changes, I'm quite confident that SFL is still the way to go.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 96,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "I have made a few changes to the merge and split selection works: \n\nWhen deciding which dependency between two to-be-merged chunks to activate, pick a uniformly random one. It turns out this can be done in \\mathcal{O}(n) time anyway, without needing to maintain randomly-sorted lists of dependencies &hellip;",
  "truncated": true,
  "post_url": "/t/spanning-forest-cluster-linearization/1419/8",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}