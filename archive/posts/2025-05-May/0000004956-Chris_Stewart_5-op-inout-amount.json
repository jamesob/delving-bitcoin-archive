{
  "id": 4956,
  "name": "Chris Stewart",
  "username": "Chris_Stewart_5",
  "avatar_template": "/user_avatar/delvingbitcoin.org/chris_stewart_5/{size}/296_2.png",
  "created_at": "2025-05-07T17:11:26.502Z",
  "cooked": "<h1><a name=\"p-4956-case-study-op_checkcontractverify-1\" class=\"anchor\" href=\"#p-4956-case-study-op_checkcontractverify-1\"></a>Case study: OP_CHECKCONTRACTVERIFY</h1>\n<p>This case study explores how Script opcodes can be used to implement <strong>amount locks</strong>\u2014restrictions that ensure the value of inputs and outputs in a transaction meets certain conditions. The goal is to evaluate the required features and developer ergonomics for opcodes that push input and output amounts onto the stack. Rather than starting from scratch, we build on existing opcode proposals and retrofit them to support amount locks directly in Script.</p>\n<p>This requires two proposals I am working on:</p>\n<ol>\n<li><a href=\"https://github.com/Christewart/bips/blob/79257ba5d7a632fa828208f266fd4f5540ffba7f/bip-XXXX.mediawiki\" rel=\"noopener nofollow ugc\">64-bit arithmetic in Script</a></li>\n<li><a href=\"https://delvingbitcoin.org/t/op-inout-amount/549/3\"><code>OP_IN_AMOUNT</code> &amp; <code>OP_OUT_AMOUNT</code></a></li>\n</ol>\n<p><strong>Note:</strong> This study does not attempt to implement <em>destination locks</em>\u2014restrictions on where funds may be sent. That logic is preserved from the original proposal being examined.</p>\n<p><a href=\"https://github.com/Christewart/bitcoin/tree/ccv-core-op-in-out-amount\" rel=\"noopener nofollow ugc\">Here</a> is a link to the repository that implements everything discussed below. A good place to start reading is the functional test: <a href=\"https://github.com/Christewart/bitcoin/blob/c83ed810a889e4e69ba8c417ddf4c85c1723f9e5/test/functional/feature_checkcontractverify.py\" rel=\"noopener nofollow ugc\"><code>feature_checkcontractverify.py</code></a>.</p>\n<h2><a name=\"p-4956-op_checkcontractverify-2\" class=\"anchor\" href=\"#p-4956-op_checkcontractverify-2\"></a>OP_CHECKCONTRACTVERIFY</h2>\n<p><a href=\"https://github.com/Merkleize/bips/blob/2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3/bip-ccv.mediawiki\" rel=\"noopener nofollow ugc\">OP_CHECKCONTRACTVERIFY</a> is an opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the script, allowing introspection to the committed data. Moreover, a script can constrain the internal public key and taptree of one or more outputs, and possibly the committed data.</p>\n<p>This case study is interested in the <a href=\"https://github.com/Merkleize/bips/blob/2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3/bip-ccv.mediawiki#user-content-Output_amounts\" rel=\"noopener nofollow ugc\">amount locks</a> of the <code>OP_CHECKCONTRACTVERIFY</code> proposal. Similar to the <a href=\"https://github.com/bitcoin/bips/blob/3365fb7a7e5e25b95b94d65808e32a02aa684aaa/bip-0345.mediawiki\" rel=\"noopener nofollow ugc\">BIP345</a> <a href=\"https://delvingbitcoin.org/t/op-inout-amount/549/4\">case study</a>, we are going to replace the current amount locks implemented via <a href=\"https://github.com/Merkleize/bips/blob/2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3/bip-ccv.mediawiki#output-amounts\" rel=\"noopener nofollow ugc\">modes</a> in the <a href=\"https://github.com/bitcoin/bitcoin/blob/1fca2689866761ee4cd6629c0f3a0deb0fac72ae/src/script/interpreter.cpp#L1908\" rel=\"noopener nofollow ugc\"><code>CheckContract()</code></a> function in the OP_CCV proposal with the opcodes <code>OP_IN_AMOUNT</code> and <code>OP_OUT_AMOUNT</code>.</p>\n<h2><a name=\"p-4956-op_ccv-witness-stack-3\" class=\"anchor\" href=\"#p-4956-op_ccv-witness-stack-3\"></a>OP_CCV Witness Stack</h2>\n<p>Here is what the stack looks like when evaluating <code>OP_CCV</code></p>\n<pre><code class=\"lang-auto\">`&lt;mode&gt;` # is a minimally encoded integer, according to one of the values defined below.\n`&lt;taptree&gt;` # is the Merkle root of the taproot tree, or a minimally encoded `-1`, or the empty buffer.\n`&lt;pk&gt;` # is called the _naked key_, and it's a valid 32-byte x-only public key, or a minimally encoded `-1`, or the empty buffer.\n`&lt;index&gt;` # is a minimally encoded -1, or a minimally encoded non-negative integer.\n`&lt;data&gt;` # is a buffer of arbitrary length.\n</code></pre>\n<p>We are interested in two values on the stack for implementing amount locks - <code>index</code> and <code>mode</code>.</p>\n<h3><a name=\"p-4956-modes-4\" class=\"anchor\" href=\"#p-4956-modes-4\"></a>Modes</h3>\n<p>There are 4 modes defined in the <code>OP_CHECKCONTRACTVERIFY</code> BIP. Unfortuantely the OP_CCV opcode currently has context specific meanings for the <code>index</code> value on the stack depending on the <code>mode</code> below. This will not work with implement amount locks in Script, so this work changes the meaning of <code>index</code> to be the <code>output_index</code> we are spending to.</p>\n<p>We add a new value called <a href=\"https://github.com/Christewart/bitcoin/blob/c83ed810a889e4e69ba8c417ddf4c85c1723f9e5/test/functional/feature_checkcontractverify.py#L232\" rel=\"noopener nofollow ugc\"><code>input_indices</code></a> that reference all of the funding outputs we are validating.</p>\n<h4><a name=\"p-4956-ccv_mode_check_input-5\" class=\"anchor\" href=\"#p-4956-ccv_mode_check_input-5\"></a>CCV_MODE_CHECK_INPUT</h4>\n<p>The <code>CCV_MODE_CHECK_INPUT</code> checks an input\u2019s script; no amount check. This means we do not need to implement an amount lock in Script.</p>\n<h4><a name=\"p-4956-ccv_mode_check_output_ignore_amount-6\" class=\"anchor\" href=\"#p-4956-ccv_mode_check_output_ignore_amount-6\"></a>CCV_MODE_CHECK_OUTPUT_IGNORE_AMOUNT</h4>\n<p>The <code>CCV_MODE_CHECK_OUTPUT_IGNORE_AMOUNT</code> checks an output\u2019s script, but ignores the amount. This means we do not need to implement an amount lock in the Script.</p>\n<h4><a name=\"p-4956-ccv_mode_check_output-7\" class=\"anchor\" href=\"#p-4956-ccv_mode_check_output-7\"></a>CCV_MODE_CHECK_OUTPUT</h4>\n<p>The <code>CCV_MODE_CHECK_OUTPUT</code> checks an output\u2019s script; preserve the (possibly residual) amount.</p>\n<p>Here is what the amount lock for this mode looks like when implemented in Script with <code>OP_IN_AMOUNT</code> and <code>OP_OUT_AMOUNT</code>. You can view the python implementation with working test cases <a href=\"https://github.com/Christewart/bitcoin/blob/c83ed810a889e4e69ba8c417ddf4c85c1723f9e5/test/functional/feature_checkcontractverify.py#L271\" rel=\"noopener nofollow ugc\">here</a>.</p>\n<pre><code class=\"lang-auto\">OP_3, # output_indices position on stack\nOP_PICK, # move output_indices to stack top\nOP_DUP, #duplicate output_indices\n\n# shift table for index since we have no OP_LSHIFT\nOP_0,\nOP_EQUAL,\nOP_IF,\n  OP_DROP, # drop duplicated index\n  OP_1,\nOP_ELSE,\n  OP_0,\n  OP_VERIFY,\nOP_ENDIF,\n# end shift table\n\nOP_OUT_AMOUNT, # push output_amount onto stack\nOP_5, # input indices position on stack\nOP_ROLL, # move input_indices to stack top\nOP_IN_AMOUNT, # push input amount onto stack\nOP_EQUALVERIFY, # make sure input and output amounts are equal\nOP_CHECKCONTRACTVERIFY,\nOP_TRUE\n</code></pre>\n<h4><a name=\"p-4956-ccv_mode_check_output_deduct_amount-8\" class=\"anchor\" href=\"#p-4956-ccv_mode_check_output_deduct_amount-8\"></a>CCV_MODE_CHECK_OUTPUT_DEDUCT_AMOUNT</h4>\n<p>The <code>CCV_MODE_CHECK_OUTPUT_DEDUCT_AMOUNT</code> mode checks an output\u2019s script and deducts the output amount from the input\u2019s residual amount.</p>\n<p>Here is what the amount lock for this mode looks like when implemented in Script with <code>OP_IN_AMOUNT</code> and <code>OP_OUT_AMOUNT</code>. You can view the python implementation with working test cases <a href=\"https://github.com/Christewart/bitcoin/blob/c83ed810a889e4e69ba8c417ddf4c85c1723f9e5/test/functional/feature_checkcontractverify.py#L351\" rel=\"noopener nofollow ugc\">here</a>.</p>\n<pre><code class=\"lang-auto\">\n# 1. Push full amount from input_indices\n# 2. Push first output index value\n# 3. Subract first output index value from input_indices amount\n# 4. Push second output index value\n# 5. Check (input_value - first_output_value) - second_output_value = 0\n\nOP_3, # input_indices on stack\nOP_ROLL, # move input_indices to stack top\nOP_IN_AMOUNT, # push full input amount onto the stack\nOP_4, # first output index on stack\nOP_PICK, # move it to stack top\n\n# shift table for index since we have no OP_LSHIFT\nOP_0,\nOP_EQUAL,\nOP_IF,\n  OP_1,\nOP_ELSE,\n  OP_0,\n  OP_VERIFY,\nOP_ENDIF,\n# end shift table\n\nOP_OUT_AMOUNT, # push first_output_amount onto stack\nOP_SUB, # input_amount - first_output_amount\nOP_TOALTSTACK, # move input_amount - first_output_amount to alt stack for now to check later\n\nCCV_MODE_CHECK_OUTPUT_DEDUCT_AMOUNT,\nOP_CHECKCONTRACTVERIFY,\n\n0, # no data tweaking (hardcoded in author's OP_CCV test case)\n1, # index (hardcoded in author's OP_CCV test case)\n0, # NUMS pubkey (hardcoded in author's OP_CCV test case)\n0, # no taptweak (hardcoded in author's OP_CCV test case)\n\n# check output, all remaining amount must go to this output\nOP_2,\nOP_PICK,\n\n# shift table for index since we have no OP_LSHIFT\nOP_1,\nOP_EQUAL,\nOP_IF,\n  OP_2,\nOP_ELSE,\n  OP_0,\n  OP_VERIFY,\nOP_ENDIF,\n# end shift table\n\nOP_OUT_AMOUNT, # push second_output_value onto stack\nOP_FROMALTSTACK, # move input_amount - first_output_amount back from alt stack\nOP_SUB, # (input_amount - first_output_amount) - second_output_value\nOP_0,\nOP_EQUALVERIFY, # (input_amount - first_output_amount) - second_output_value = 0\nCCV_MODE_CHECK_OUTPUT,\nOP_CHECKCONTRACTVERIFY,\nOP_TRUE\n</code></pre>\n<h3><a name=\"p-4956-one-big-beautiful-script-9\" class=\"anchor\" href=\"#p-4956-one-big-beautiful-script-9\"></a>One Big Beautiful Script</h3>\n<p>The <code>mode</code> for OP_CCV could be given as input to this Script and the mode could be matched with <code>OP_IF</code> <code>OP_ELSE</code> <code>OP_ENDIF</code>. The body of each conditional would be the different Script\u2019s written above. This could give the spending transaction more control over how the Script is evaluated.</p>\n<p>I\u2019m not sure if it could make sense to add <code>mode</code> to the witness stack in certain cases - or have it computed during Script execution. If there is a use case where this makes sense, having \u201cone big beautiful Script\u201d where all of the amount lock\u2019s conditionals are included in the Script could be very useful.</p>\n<h2><a name=\"p-4956-lessons-learned-10\" class=\"anchor\" href=\"#p-4956-lessons-learned-10\"></a>Lessons learned</h2>\n<h3><a name=\"p-4956-extensibility-11\" class=\"anchor\" href=\"#p-4956-extensibility-11\"></a>Extensibility</h3>\n<p>In the case of OP_CCV, amount locks implemented with <code>OP_IN_AMOUNT</code> and <code>OP_OUT_AMOUNT</code> greatly enhance the extensibility of the proposal. Rather than having to soft fork in a new <code>mode</code> every time there is a new feature we want to introduce, Script programmers can just implement the logic themselves. This makes the <code>OP_CCV</code> proposal much more flexible.</p>\n<h3><a name=\"p-4956-separation-of-concerns-12\" class=\"anchor\" href=\"#p-4956-separation-of-concerns-12\"></a>Separation of concerns</h3>\n<p>I think it is very useful to think of \u201cdestination locks\u201d and \u201camount locks\u201d separately. You need both restrictions to implement any covenant proposal. Trying to build them both in the same proposal can lead to sub-optimal design choices.</p>\n<p>For Instance, in this proposal it seems like OP_CCV is very close to <a href=\"https://gnusha.org/pi/bitcoindev/20210909064138.GA22496@erisian.com.au/\" rel=\"noopener nofollow ugc\"><code>OP_TAPLEAFUPDATEVERIFY</code></a> if it were to add support for adding/remove tap leafs from the taptree.</p>\n<p>The merkle root hash for the taptree is already on the stack for OP_CCV evaluation as its needed for verifying the piece of data is included in the internal key. It seems like it isn\u2019t too far of a stretch to adding a parameter to add a new leaf to the tap tree or removing a leaf.</p>\n<h3><a name=\"p-4956-separating-op_inout_amount-into-two-opcodes-op_in_amount-op_out_amount-13\" class=\"anchor\" href=\"#p-4956-separating-op_inout_amount-into-two-opcodes-op_in_amount-op_out_amount-13\"></a>Separating OP_INOUT_AMOUNT into two opcodes: OP_IN_AMOUNT, OP_OUT_AMOUNT</h3>\n<p>This did reduce some stack manipulation. Namely, I didn\u2019t have to use <code>OP_SWAP</code> as much to make sure stack arguments were in the correct place to be consumed by the single opcode <code>OP_INOUT_AMOUNT</code>.</p>\n<p>Unfortunately <code>OP_PICK</code> and <code>OP_ROLL</code> usage is still necessary to make sure stack arguments could be moved to the correct places to be used by the Script implementing the amount locks.</p>\n<h3><a name=\"p-4956-op_lshiftop_rshift-14\" class=\"anchor\" href=\"#p-4956-op_lshiftop_rshift-14\"></a><code>OP_LSHIFT</code>/<code>OP_RSHIFT</code></h3>\n<p>As expressed on the BIP345 case study, this case study reaffirms the need for <code>OP_LSHIFT</code>/<code>OP_RSHIFT</code> for a proposal like <code>OP_IN_AMOUNT</code>/<code>OP_OUT_AMOUNT</code> to be viable in its current form - specifically consuming bitvectors that correspond to input/output indices as an argument.</p>",
  "post_number": 5,
  "post_type": 1,
  "posts_count": 5,
  "updated_at": "2025-05-07T17:16:31.067Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 35,
  "reads": 8,
  "readers_count": 7,
  "score": 176.6,
  "yours": false,
  "topic_id": 549,
  "topic_slug": "op-inout-amount",
  "topic_title": "Op_inout_amount",
  "topic_html_title": "Op_inout_amount",
  "category_id": 7,
  "display_username": "Chris Stewart",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "# Case study: OP_CHECKCONTRACTVERIFY\n\nThis case study explores how Script opcodes can be used to implement **amount locks**\u2014restrictions that ensure the value of inputs and outputs in a transaction meets certain conditions. The goal is to evaluate the required features and developer ergonomics for opcodes that push input and output amounts onto the stack. Rather than starting from scratch, we build on existing opcode proposals and retrofit them to support amount locks directly in Script.\n\nThis requires two proposals I am working on:\n\n1. [64-bit arithmetic in Script](https://github.com/Christewart/bips/blob/79257ba5d7a632fa828208f266fd4f5540ffba7f/bip-XXXX.mediawiki)  \n2. [`OP_IN_AMOUNT` & `OP_OUT_AMOUNT`](https://delvingbitcoin.org/t/op-inout-amount/549/3?u=chris_stewart_5)\n\n**Note:** This study does not attempt to implement _destination locks_\u2014restrictions on where funds may be sent. That logic is preserved from the original proposal being examined.\n\n[Here](https://github.com/Christewart/bitcoin/tree/ccv-core-op-in-out-amount) is a link to the repository that implements everything discussed below. A good place to start reading is the functional test: [`feature_checkcontractverify.py`](https://github.com/Christewart/bitcoin/blob/c83ed810a889e4e69ba8c417ddf4c85c1723f9e5/test/functional/feature_checkcontractverify.py).\n\n\n## OP_CHECKCONTRACTVERIFY\n\n[OP_CHECKCONTRACTVERIFY](https://github.com/Merkleize/bips/blob/2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3/bip-ccv.mediawiki) is an opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the script, allowing introspection to the committed data. Moreover, a script can constrain the internal public key and taptree of one or more outputs, and possibly the committed data.\n\nThis case study is interested in the [amount locks](https://github.com/Merkleize/bips/blob/2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3/bip-ccv.mediawiki#user-content-Output_amounts) of the `OP_CHECKCONTRACTVERIFY` proposal. Similar to the [BIP345](https://github.com/bitcoin/bips/blob/3365fb7a7e5e25b95b94d65808e32a02aa684aaa/bip-0345.mediawiki) [case study](https://delvingbitcoin.org/t/op-inout-amount/549/4?u=chris_stewart_5), we are going to replace the current amount locks implemented via [modes](https://github.com/Merkleize/bips/blob/2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3/bip-ccv.mediawiki#output-amounts) in the [`CheckContract()`](https://github.com/bitcoin/bitcoin/blob/1fca2689866761ee4cd6629c0f3a0deb0fac72ae/src/script/interpreter.cpp#L1908) function in the OP_CCV proposal with the opcodes `OP_IN_AMOUNT` and `OP_OUT_AMOUNT`.\n\n\n## OP_CCV Witness Stack\n\nHere is what the stack looks like when evaluating `OP_CCV`\n```\n`<mode>` # is a minimally encoded integer, according to one of the values defined below.\n`<taptree>` # is the Merkle root of the taproot tree, or a minimally encoded `-1`, or the empty buffer.\n`<pk>` # is called the _naked key_, and it's a valid 32-byte x-only public key, or a minimally encoded `-1`, or the empty buffer.\n`<index>` # is a minimally encoded -1, or a minimally encoded non-negative integer.\n`<data>` # is a buffer of arbitrary length.\n```\n\nWe are interested in two values on the stack for implementing amount locks - `index` and `mode`. \n\n### Modes\n\nThere are 4 modes defined in the `OP_CHECKCONTRACTVERIFY` BIP. Unfortuantely the OP_CCV opcode currently has context specific meanings for the `index` value on the stack depending on the `mode` below. This will not work with implement amount locks in Script, so this work changes the meaning of `index` to be the `output_index` we are spending to. \n\nWe add a new value called [`input_indices`](https://github.com/Christewart/bitcoin/blob/c83ed810a889e4e69ba8c417ddf4c85c1723f9e5/test/functional/feature_checkcontractverify.py#L232) that reference all of the funding outputs we are validating.\n\n#### CCV_MODE_CHECK_INPUT\n\nThe `CCV_MODE_CHECK_INPUT` checks an input's script; no amount check. This means we do not need to implement an amount lock in Script.\n\n#### CCV_MODE_CHECK_OUTPUT_IGNORE_AMOUNT\n\nThe `CCV_MODE_CHECK_OUTPUT_IGNORE_AMOUNT` checks an output's script, but ignores the amount. This means we do not need to implement an amount lock in the Script.\n\n#### CCV_MODE_CHECK_OUTPUT\n\nThe `CCV_MODE_CHECK_OUTPUT` checks an output's script; preserve the (possibly residual) amount. \n\nHere is what the amount lock for this mode looks like when implemented in Script with `OP_IN_AMOUNT` and `OP_OUT_AMOUNT`. You can view the python implementation with working test cases [here](https://github.com/Christewart/bitcoin/blob/c83ed810a889e4e69ba8c417ddf4c85c1723f9e5/test/functional/feature_checkcontractverify.py#L271).\n\n```\nOP_3, # output_indices position on stack\nOP_PICK, # move output_indices to stack top\nOP_DUP, #duplicate output_indices\n\n# shift table for index since we have no OP_LSHIFT\nOP_0,\nOP_EQUAL,\nOP_IF,\n  OP_DROP, # drop duplicated index\n  OP_1,\nOP_ELSE,\n  OP_0,\n  OP_VERIFY,\nOP_ENDIF,\n# end shift table\n\nOP_OUT_AMOUNT, # push output_amount onto stack\nOP_5, # input indices position on stack\nOP_ROLL, # move input_indices to stack top\nOP_IN_AMOUNT, # push input amount onto stack\nOP_EQUALVERIFY, # make sure input and output amounts are equal\nOP_CHECKCONTRACTVERIFY,\nOP_TRUE\n```\n\n#### CCV_MODE_CHECK_OUTPUT_DEDUCT_AMOUNT\n\nThe `CCV_MODE_CHECK_OUTPUT_DEDUCT_AMOUNT` mode checks an output's script and deducts the output amount from the input's residual amount.\n\nHere is what the amount lock for this mode looks like when implemented in Script with `OP_IN_AMOUNT` and `OP_OUT_AMOUNT`. You can view the python implementation with working test cases [here](https://github.com/Christewart/bitcoin/blob/c83ed810a889e4e69ba8c417ddf4c85c1723f9e5/test/functional/feature_checkcontractverify.py#L351).\n\n```\n\n# 1. Push full amount from input_indices\n# 2. Push first output index value\n# 3. Subract first output index value from input_indices amount\n# 4. Push second output index value\n# 5. Check (input_value - first_output_value) - second_output_value = 0\n\nOP_3, # input_indices on stack\nOP_ROLL, # move input_indices to stack top\nOP_IN_AMOUNT, # push full input amount onto the stack\nOP_4, # first output index on stack\nOP_PICK, # move it to stack top\n\n# shift table for index since we have no OP_LSHIFT\nOP_0,\nOP_EQUAL,\nOP_IF,\n  OP_1,\nOP_ELSE,\n  OP_0,\n  OP_VERIFY,\nOP_ENDIF,\n# end shift table\n\nOP_OUT_AMOUNT, # push first_output_amount onto stack\nOP_SUB, # input_amount - first_output_amount\nOP_TOALTSTACK, # move input_amount - first_output_amount to alt stack for now to check later\n\nCCV_MODE_CHECK_OUTPUT_DEDUCT_AMOUNT,\nOP_CHECKCONTRACTVERIFY,\n\n0, # no data tweaking (hardcoded in author's OP_CCV test case)\n1, # index (hardcoded in author's OP_CCV test case)\n0, # NUMS pubkey (hardcoded in author's OP_CCV test case)\n0, # no taptweak (hardcoded in author's OP_CCV test case)\n\n# check output, all remaining amount must go to this output\nOP_2,\nOP_PICK,\n\n# shift table for index since we have no OP_LSHIFT\nOP_1,\nOP_EQUAL,\nOP_IF,\n  OP_2,\nOP_ELSE,\n  OP_0,\n  OP_VERIFY,\nOP_ENDIF,\n# end shift table\n\nOP_OUT_AMOUNT, # push second_output_value onto stack\nOP_FROMALTSTACK, # move input_amount - first_output_amount back from alt stack\nOP_SUB, # (input_amount - first_output_amount) - second_output_value\nOP_0,\nOP_EQUALVERIFY, # (input_amount - first_output_amount) - second_output_value = 0\nCCV_MODE_CHECK_OUTPUT,\nOP_CHECKCONTRACTVERIFY,\nOP_TRUE\n```\n\n### One Big Beautiful Script\n\nThe `mode` for OP_CCV could be given as input to this Script and the mode could be matched with `OP_IF` `OP_ELSE` `OP_ENDIF`. The body of each conditional would be the different Script's written above. This could give the spending transaction more control over how the Script is evaluated. \n\nI'm not sure if it could make sense to add `mode` to the witness stack in certain cases - or have it computed during Script execution. If there is a use case where this makes sense, having \"one big beautiful Script\" where all of the amount lock's conditionals are included in the Script could be very useful.\n\n## Lessons learned\n\n### Extensibility \n\nIn the case of OP_CCV, amount locks implemented with `OP_IN_AMOUNT` and `OP_OUT_AMOUNT` greatly enhance the extensibility of the proposal. Rather than having to soft fork in a new `mode` every time there is a new feature we want to introduce, Script programmers can just implement the logic themselves. This makes the `OP_CCV` proposal much more flexible.\n\n### Separation of concerns\n\nI think it is very useful to think of \"destination locks\" and \"amount locks\" separately. You need both restrictions to implement any covenant proposal. Trying to build them both in the same proposal can lead to sub-optimal design choices.\n\nFor Instance, in this proposal it seems like OP_CCV is very close to [`OP_TAPLEAFUPDATEVERIFY`](https://gnusha.org/pi/bitcoindev/20210909064138.GA22496@erisian.com.au/) if it were to add support for adding/remove tap leafs from the taptree. \n\nThe merkle root hash for the taptree is already on the stack for OP_CCV evaluation as its needed for verifying the piece of data is included in the internal key. It seems like it isn't too far of a stretch to adding a parameter to add a new leaf to the tap tree or removing a leaf.\n\n### Separating OP_INOUT_AMOUNT into two opcodes: OP_IN_AMOUNT, OP_OUT_AMOUNT\n\nThis did reduce some stack manipulation. Namely, I didn't have to use `OP_SWAP` as much to make sure stack arguments were in the correct place to be consumed by the single opcode `OP_INOUT_AMOUNT`. \n\nUnfortunately `OP_PICK` and `OP_ROLL` usage is still necessary to make sure stack arguments could be moved to the correct places to be used by the Script implementing the amount locks.\n\n### `OP_LSHIFT`/`OP_RSHIFT`\n\nAs expressed on the BIP345 case study, this case study reaffirms the need for `OP_LSHIFT`/`OP_RSHIFT` for a proposal like `OP_IN_AMOUNT`/`OP_OUT_AMOUNT` to be viable in its current form - specifically consuming bitvectors that correspond to input/output indices as an argument.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 193,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": "Github link was replaced with a permanent link",
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "<a name=\"p-4956-case-study-op_checkcontractverify-1\" class=\"anchor\" href=\"#p-4956-case-study-op_checkcontractverify-1\"></a>Case study: OP_CHECKCONTRACTVERIFY\nThis case study explores how Script opcodes can be used to implement amount locks\u2014restrictions that ensure the value of inputs and outputs in a transaction meets certain conditions. The goal is to evaluate the required features and developer ergonomics for opcodes &hellip;",
  "truncated": true,
  "post_url": "/t/op-inout-amount/549/5",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}