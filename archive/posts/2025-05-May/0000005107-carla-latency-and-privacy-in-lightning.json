{
  "id": 5107,
  "name": "Carla Kirk-Cohen",
  "username": "carla",
  "avatar_template": "/user_avatar/delvingbitcoin.org/carla/{size}/119_2.png",
  "created_at": "2025-05-23T17:44:47.800Z",
  "cooked": "<p>I was <em>ultimately</em> nerd sniped last LN spec meeting\u2019s discussion [0] of the privacy impact of surfacing granular HTLC hold times via attributable failures [1]. This post contains a recap of the discussion (as I understand it) and a summary of my sniping.</p>\n<p>Recap of meeting discussion:</p>\n<ul>\n<li>The current version of the spec allows forwarding nodes to specify the time they held the HTLC in ms.</li>\n<li>It\u2019s likely that sending nodes will use this value in the future to pick low latency routes.</li>\n<li>Adding a random forwarding delay ((2], [3]) improves payment privacy.</li>\n<li>Surfacing hold times may dis-incentive this privacy-preserving delay as nodes race to the bottom to be the fastest.</li>\n</ul>\n<p>The solution suggested in the meeting was to change the encoding to represent blocks time instead, so that the smallest encodable value still leaves time for processing and a random delay.\nThis can\u2019t be done by keeping ms encoding and enforcing some minimum, because nodes can always report smaller values; by changing the encoding, communicating a value under the smallest block of time becomes impractical [4].</p>\n<p>Some questions that came up in the meeting:</p>\n<ul>\n<li>What value should we set this minimum to?</li>\n<li>How should we manage the UX/privacy tradeoff of fast payments vs forwarding delays?</li>\n<li>What happens if we need to increase forwarding delays in future?</li>\n</ul>\n<h3><a name=\"p-5107-understanding-forwarding-delays-privacy-1\" class=\"anchor\" href=\"#p-5107-understanding-forwarding-delays-privacy-1\"></a>Understanding Forwarding Delays + Privacy</h3>\n<p>To understand how these forwarding delays impact payment privacy, I took a look at a few research papers on the subject - summarized below. Of course, any inaccuracies are my own, I\u2019d really recommend reading the papers to form your own opinion.</p>\n<p>We are concerned about two different types of attackers:</p>\n<ol>\n<li><strong>On path</strong>: attacker creates channels, routes payments and attempted to deanonymize them.</li>\n<li><strong>Off path</strong>: attacker controls an AS, and is able to monitor messages at a network level</li>\n</ol>\n<h4><a name=\"p-5107-on-path-adversary-2\" class=\"anchor\" href=\"#p-5107-on-path-adversary-2\"></a>On Path Adversary</h4>\n<p>As outlined in [5]:</p>\n<ul>\n<li>Attacker probes the network to get latency estimates for nodes.</li>\n<li>Attacker opens up low-fee and low-expiry channels to attract channels.</li>\n<li>Recipient identification:\n<ul>\n<li>Record the time between <code>update_add_htlc</code> and <code>update_fulfill_htlc</code></li>\n<li>Compare to latency estimates to calculate number of hops the HTLC took.</li>\n</ul>\n</li>\n<li>Sender identification:\n<ul>\n<li>Only works if the sender retries along the same path.</li>\n<li>Fail the first HTLC seen, and record time between <code>update_fail_htlc</code> and replacement <code>update_add_htlc</code>.</li>\n</ul>\n</li>\n<li>Use amount and CLTV of HTLC to reduce set of possible senders/receivers.</li>\n<li>Use latency estimates to identify possible paths based on recorded time.</li>\n</ul>\n<p>A <em>random</em> forwarding delay is helpful here because it interferes with the ability of the attacker to compare the time they\u2019ve recorded with their latency estimates. In lay-carla\u2019s terms (give or take some noise), the delay is successful if it equals at least the processing time of a single hop, because this means that the attacker will be off by one hop and fail to identify the sender/receiver.</p>\n<h4><a name=\"p-5107-off-path-adversary-3\" class=\"anchor\" href=\"#p-5107-off-path-adversary-3\"></a>Off Path Adversary</h4>\n<p>As outlined in [6]:</p>\n<ul>\n<li>Attacker ICMP pings nodes in the network to get latency estimate.</li>\n<li>Attacker controls an AS and passively monitors network traffic.</li>\n<li>The commitment dance for a channel can be identified by message size and direction.</li>\n<li>With knowledge of the LN graph, an adversary can construct \u201cpartial paths\u201d by tracing flow of <code>update_add_htlc</code> messages through the channels they observe.\n<ul>\n<li>This is timestamp based: if an incoming and outgoing <code>update_add_htlc</code> are processed within the estimated latency, they are assumed to be part of a partial path.</li>\n</ul>\n</li>\n<li>Set limits for the possible payment amounts:\n<ul>\n<li>Minimum: largest <code>htlc_minimum_msat</code> along the partial path (can\u2019t be smaller than the biggest minimum).</li>\n<li>Maximum: smallest <code>htlc_maximum_msat</code> or <code>capacity</code> along the partial path (can\u2019t be bigger than the smallest channel).</li>\n</ul>\n</li>\n<li>Perform a binary search to get a payment amount range:\n<ul>\n<li>Find the path from first to last node in the partial path for an amount.</li>\n<li>If the computed path differs from the partial path, the amount is discarded.</li>\n</ul>\n</li>\n<li>Remove channels that can\u2019t support the estimated payment amount.</li>\n<li>Identify sender and receiver:\n<ul>\n<li>Nodes that remain connected to the first/last hop in the partial path are candidate sender/receivers</li>\n<li>Check payment path between each possible pair for the payment amount.</li>\n<li>If the path uses the partial path, then the pair is a possible sender/receiver.</li>\n</ul>\n</li>\n</ul>\n<p>A forwarding delay is helpful here because it interferes with the ability of the attacker to construct partial paths. Notably, once these paths are constructed the attacker still has a large anonymity set to deal with, and the attack relies heavily on deterministic pathfinding at several stages to reduce this set.</p>\n<p>[7] also examines how a malicious AS can identify nodes roles in a route with the goal of selective censorship:</p>\n<ul>\n<li>Senders: <code>update_add_htlc</code> messages sent \u201cout of the blue\u201d indicate that the node is the original sender.</li>\n<li>Intermediaries: timing analysis is used to connect an incoming <code>revoke_and_ack</code> with an outgoing <code>update_add_htlc</code> to identify forwarding nodes.</li>\n<li>Recipient: sending a <code>update_fulfill_htlc</code> message after receiving a <code>revoke_and_ack</code> message identifies the recipient, independent of timing.</li>\n</ul>\n<p>Note that senders and receivers are identified based on the size of messages, without needing to rely on any timing information. Here, a forwarding delay isn\u2019t helping sender/receiver privacy at all - per the suggestions in the paper, it seems like message padding and possibly cover traffic are the most promising defenses.</p>\n<h3><a name=\"p-5107-incentives-4\" class=\"anchor\" href=\"#p-5107-incentives-4\"></a>Incentives</h3>\n<p>While reading through all of this, it stood out to me that we\u2019re relying on forwarding nodes to preserve the privacy of senders and receivers. This doesn\u2019t seem particularly incentive aligned. Attributable failures and hold times aside, a profit driven node is incentivized to clear out payments as fast as it can to make efficient use of its capital. This seems sub-optimal on both ends:</p>\n<ul>\n<li>Senders and receivers who care about privacy can\u2019t hold forwarding nodes accountable for adding a delay, because these values <em>must</em> be random to be effective. If you see that nobody delayed your payment, it may have just happened to get a very low delay on each hop.</li>\n<li>Forwarding nodes don\u2019t know how long a HTLC\u2019s payment route is, so they can\u2019t easily pick a good delay time that they\u2019re certain will help with privacy (unless they over-estimate, adding an additional hop\u2019s latency) [8].</li>\n</ul>\n<p>Is there something better that we can do?</p>\n<h4><a name=\"p-5107-on-path-adversary-5\" class=\"anchor\" href=\"#p-5107-on-path-adversary-5\"></a>On Path Adversary</h4>\n<p>In this attack, the attacker depends on the time between <code>update_add_htlc</code> and <code>update_fulfill_htlc</code> to make inferences about the number of hops between itself and the recipient to deanonymize the recipient. It doesn\u2019t matter where the delay happens, just that there is enough delay for it to be ambiguous to the attacker how many hops there are to the recipient. It seems reasonable that we could implement delays on the recipient, instead of with the forwarding nodes. This puts the decision in the hands of the party whose privacy is actually impacted. It also works reasonably well with other hold-time aware systems like jamming mitigations and latency-aware routing, because we have to accommodate the MPP case where the recipient can hold HTLCs anyway.</p>\n<p>For sender de-anonymization, the attacker needs to fail a payment and be on-path for the retry. This is more trivially addressable by adding a cool down between attempts and using more diverse retry paths. This is within the control of the sender, so it is nicely incentive aligned.</p>\n<h4><a name=\"p-5107-off-path-adversary-6\" class=\"anchor\" href=\"#p-5107-off-path-adversary-6\"></a>Off Path Adversary</h4>\n<p>While timing information is used in this attack, my impression from [6] was that predictable routing algorithms are what makes reducing the anonymity set feasible for the attacking node. This is again a level that we could provide the sender to toggle as they see fit rather than relying on forwarding nodes. Without the ability to prune the network, the anonymity set for this attack remains infeasibly large.</p>\n<p>This attack also gets significantly easier for larger payments, as the attacker can prune more channels (that wouldn\u2019t be able to facilitate the amount). So more aggressive payment splitting is another option for privacy conscious sending nodes that does not rely on forwarding nodes for protection.</p>\n<h3><a name=\"p-5107-what-to-do-for-attributable-failures-7\" class=\"anchor\" href=\"#p-5107-what-to-do-for-attributable-failures-7\"></a>What to do for attributable failures?</h3>\n<p>Practically in today\u2019s network, we don\u2019t have any privacy preserving forwarding delays deployed:</p>\n<ul>\n<li>LND (80-90% of public network): has a 50ms commitment ticker to batch updates, but it is not randomized so can trivially be accounted for in the attacks listed above [9].</li>\n<li>Eclair (major router): does not implement forward delays.</li>\n</ul>\n<p>So we do not currently have any defenses against the above listed attacks implemented. And we should fix that!</p>\n<p>My opinion is:</p>\n<p>If we truly believe that forwarding delays are the best mitigation:</p>\n<ul>\n<li>We should all implement and deploy them.</li>\n<li>We should change encoding in attributable failures hold times to enforce minimum value.</li>\n</ul>\n<p>If that\u2019s not the case (which I don\u2019t necessarily think it is):</p>\n<ul>\n<li>We should investigate and implement some of the suggestions listed above.</li>\n<li>It\u2019s fine to leave the attributable failures hold times encoded with millisecond granularity.</li>\n</ul>\n<h3><a name=\"p-5107-footnotes-8\" class=\"anchor\" href=\"#p-5107-footnotes-8\"></a>Footnotes</h3>\n<p>[0] <a href=\"https://github.com/lightning/bolts/issues/1258#issuecomment-2892255704\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">Lightning Specification Meeting 2025/05/19 \u00b7 Issue #1258 \u00b7 lightning/bolts \u00b7 GitHub</a></p>\n<p>[1] <a href=\"https://github.com/lightning/bolts/pull/1044\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">Attributable failures (feature 36/37) by joostjager \u00b7 Pull Request #1044 \u00b7 lightning/bolts \u00b7 GitHub</a></p>\n<p>[2] <a href=\"https://github.com/lightning/bolts/blob/011bf84d74d130c2972becca97c87f297b9d4a92/04-onion-routing.md?plain=1#L301\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">bolts/04-onion-routing.md at 011bf84d74d130c2972becca97c87f297b9d4a92 \u00b7 lightning/bolts \u00b7 GitHub</a></p>\n<p>[3] <a href=\"https://github.com/lightning/bolts/blob/011bf84d74d130c2972becca97c87f297b9d4a92/02-peer-protocol.md?plain=1#L2394\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">bolts/02-peer-protocol.md at 011bf84d74d130c2972becca97c87f297b9d4a92 \u00b7 lightning/bolts \u00b7 GitHub</a></p>\n<p>[4] Forwarding nodes could flip a high bit to indicate that they\u2019re using ms, but this would require sender cooperation and lead to devastating penalization if senders aren\u2019t modified (because it would lead to their hold time being interpreted as massive).</p>\n<p>[5] <a href=\"https://arxiv.org/pdf/2006.12143\" rel=\"noopener nofollow ugc\">https://arxiv.org/pdf/2006.12143</a></p>\n<p>[6] <a href=\"https://ieeexplore.ieee.org/document/10190502\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">Revelio: A Network-Level Privacy Attack in the Lightning Network | IEEE Conference Publication | IEEE Xplore</a></p>\n<p>[7] <a href=\"https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.AFT.2024.12\" rel=\"noopener nofollow ugc\">https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.AFT.2024.12</a></p>\n<p>[8] Yes, we may very well have an incredibly privacy conscious and altruistic routing layer. Even if that\u2019s the case (quite probably, since there isn\u2019t much money to be made with it), we shouldn\u2019t be relying on it to make privacy promises.</p>\n<p>[9] Heavily emphasized across all papers is that this delay needs to be random to be impactful.</p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 39,
  "updated_at": "2025-05-23T17:44:47.800Z",
  "reply_count": 1,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 88,
  "reads": 55,
  "readers_count": 54,
  "score": 471.0,
  "yours": false,
  "topic_id": 1723,
  "topic_slug": "latency-and-privacy-in-lightning",
  "topic_title": "Latency and Privacy in Lightning",
  "topic_html_title": "Latency and Privacy in Lightning",
  "category_id": 7,
  "display_username": "Carla Kirk-Cohen",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": "",
  "bookmarked": false,
  "raw": "I was *ultimately* nerd sniped last LN spec meeting's discussion [0] of the privacy impact of surfacing granular HTLC hold times via attributable failures [1]. This post contains a recap of the discussion (as I understand it) and a summary of my sniping.\n\nRecap of meeting discussion:\n- The current version of the spec allows forwarding nodes to specify the time they held the HTLC in ms.\n- It's likely that sending nodes will use this value in the future to pick low latency routes.\n- Adding a random forwarding delay ((2], [3]) improves payment privacy.\n- Surfacing hold times may dis-incentive this privacy-preserving delay as nodes race to the bottom to be the fastest.\n\nThe solution suggested in the meeting was to change the encoding to represent blocks time instead, so that the smallest encodable value still leaves time for processing and a random delay.\nThis can't be done by keeping ms encoding and enforcing some minimum, because nodes can always report smaller values; by changing the encoding, communicating a value under the smallest block of time becomes impractical [4].\n\nSome questions that came up in the meeting:\n- What value should we set this minimum to?\n- How should we manage the UX/privacy tradeoff of fast payments vs forwarding delays?\n- What happens if we need to increase forwarding delays in future? \n\n### Understanding Forwarding Delays + Privacy\n\nTo understand how these forwarding delays impact payment privacy, I took a look at a few research papers on the subject - summarized below. Of course, any inaccuracies are my own, I'd really recommend reading the papers to form your own opinion.\n\nWe are concerned about two different types of attackers:\n1. **On path**: attacker creates channels, routes payments and attempted to deanonymize them.\n2. **Off path**: attacker controls an AS, and is able to monitor messages at a network level\n\n#### On Path Adversary\n\nAs outlined in [5]:\n- Attacker probes the network to get latency estimates for nodes.\n- Attacker opens up low-fee and low-expiry channels to attract channels.\n- Recipient identification:\n  - Record the time between `update_add_htlc` and `update_fulfill_htlc` \n  - Compare to latency estimates to calculate number of hops the HTLC took.\n- Sender identification:\n  - Only works if the sender retries along the same path.\n  - Fail the first HTLC seen, and record time between `update_fail_htlc` and replacement `update_add_htlc`.\n- Use amount and CLTV of HTLC to reduce set of possible senders/receivers.\n- Use latency estimates to identify possible paths based on recorded time.\n\nA *random* forwarding delay is helpful here because it interferes with the ability of the attacker to compare the time they've recorded with their latency estimates. In lay-carla's terms (give or take some noise), the delay is successful if it equals at least the processing time of a single hop, because this means that the attacker will be off by one hop and fail to identify the sender/receiver.\n\n#### Off Path Adversary\n\nAs outlined in [6]:\n- Attacker ICMP pings nodes in the network to get latency estimate.\n- Attacker controls an AS and passively monitors network traffic.\n- The commitment dance for a channel can be identified by message size and direction.\n- With knowledge of the LN graph, an adversary can construct \"partial paths\" by tracing flow of `update_add_htlc` messages through the channels they observe.\n  - This is timestamp based: if an incoming and outgoing `update_add_htlc` are processed within the estimated latency, they are assumed to be part of a partial path.\n- Set limits for the possible payment amounts:\n  - Minimum: largest `htlc_minimum_msat` along the partial path (can't be smaller than the biggest minimum). \n  - Maximum: smallest `htlc_maximum_msat` or `capacity` along the partial path (can't be bigger than the smallest channel).\n- Perform a binary search to get a payment amount range:\n  - Find the path from first to last node in the partial path for an amount.\n  - If the computed path differs from the partial path, the amount is discarded.\n- Remove channels that can't support the estimated payment amount.\n- Identify sender and receiver:\n  - Nodes that remain connected to the first/last hop in the partial path are candidate sender/receivers\n  - Check payment path between each possible pair for the payment amount.\n  - If the path uses the partial path, then the pair is a possible sender/receiver.\n\nA forwarding delay is helpful here because it interferes with the ability of the attacker to construct partial paths. Notably, once these paths are constructed the attacker still has a large anonymity set to deal with, and the attack relies heavily on deterministic pathfinding at several stages to reduce this set.\n\n[7] also examines how a malicious AS can identify nodes roles in a route with the goal of selective censorship:\n- Senders: `update_add_htlc` messages sent \"out of the blue\" indicate that the node is the original sender.\n- Intermediaries: timing analysis is used to connect an incoming `revoke_and_ack` with an outgoing `update_add_htlc` to identify forwarding nodes.\n- Recipient: sending a `update_fulfill_htlc` message after receiving a `revoke_and_ack` message identifies the recipient, independent of timing.\n\nNote that senders and receivers are identified based on the size of messages, without needing to rely on any timing information. Here, a forwarding delay isn't helping sender/receiver privacy at all - per the suggestions in the paper, it seems like message padding and possibly cover traffic are the most promising defenses.\n\n### Incentives\n\nWhile reading through all of this, it stood out to me that we're relying on forwarding nodes to preserve the privacy of senders and receivers. This doesn't seem particularly incentive aligned. Attributable failures and hold times aside, a profit driven node is incentivized to clear out payments as fast as it can to make efficient use of its capital. This seems sub-optimal on both ends:\n- Senders and receivers who care about privacy can't hold forwarding nodes accountable for adding a delay, because these values *must* be random to be effective. If you see that nobody delayed your payment, it may have just happened to get a very low delay on each hop. \n- Forwarding nodes don't know how long a HTLC's payment route is, so they can't easily pick a good delay time that they're certain will help with privacy (unless they over-estimate, adding an additional hop's latency) [8].\n\nIs there something better that we can do?\n\n#### On Path Adversary\n\nIn this attack, the attacker depends on the time between `update_add_htlc` and `update_fulfill_htlc` to make inferences about the number of hops between itself and the recipient to deanonymize the recipient. It doesn't matter where the delay happens, just that there is enough delay for it to be ambiguous to the attacker how many hops there are to the recipient. It seems reasonable that we could implement delays on the recipient, instead of with the forwarding nodes. This puts the decision in the hands of the party whose privacy is actually impacted. It also works reasonably well with other hold-time aware systems like jamming mitigations and latency-aware routing, because we have to accommodate the MPP case where the recipient can hold HTLCs anyway.\n\nFor sender de-anonymization, the attacker needs to fail a payment and be on-path for the retry. This is more trivially addressable by adding a cool down between attempts and using more diverse retry paths. This is within the control of the sender, so it is nicely incentive aligned.\n\n#### Off Path Adversary\n\nWhile timing information is used in this attack, my impression from [6] was that predictable routing algorithms are what makes reducing the anonymity set feasible for the attacking node. This is again a level that we could provide the sender to toggle as they see fit rather than relying on forwarding nodes. Without the ability to prune the network, the anonymity set for this attack remains infeasibly large.\n\nThis attack also gets significantly easier for larger payments, as the attacker can prune more channels (that wouldn't be able to facilitate the amount). So more aggressive payment splitting is another option for privacy conscious sending nodes that does not rely on forwarding nodes for protection.\n\n### What to do for attributable failures?\n\nPractically in today's network, we don't have any privacy preserving forwarding delays deployed:\n- LND (80-90% of public network): has a 50ms commitment ticker to batch updates, but it is not randomized so can trivially be accounted for in the attacks listed above [9].\n- Eclair (major router): does not implement forward delays.\n\nSo we do not currently have any defenses against the above listed attacks implemented. And we should fix that!\n\nMy opinion is:\n\nIf we truly believe that forwarding delays are the best mitigation:\n- We should all implement and deploy them.\n- We should change encoding in attributable failures hold times to enforce minimum value.\n\nIf that's not the case (which I don't necessarily think it is):\n- We should investigate and implement some of the suggestions listed above.\n- It's fine to leave the attributable failures hold times encoded with millisecond granularity.\n\n### Footnotes\n[0] https://github.com/lightning/bolts/issues/1258#issuecomment-2892255704\n\n[1] https://github.com/lightning/bolts/pull/1044\n\n[2] https://github.com/lightning/bolts/blob/011bf84d74d130c2972becca97c87f297b9d4a92/04-onion-routing.md?plain=1#L301\n\n[3] https://github.com/lightning/bolts/blob/011bf84d74d130c2972becca97c87f297b9d4a92/02-peer-protocol.md?plain=1#L2394\n\n[4] Forwarding nodes could flip a high bit to indicate that they're using ms, but this would require sender cooperation and lead to devastating penalization if senders aren't modified (because it would lead to their hold time being interpreted as massive).\n\n[5] https://arxiv.org/pdf/2006.12143\n\n[6] https://ieeexplore.ieee.org/document/10190502\n\n[7] https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.AFT.2024.12\n\n[8] Yes, we may very well have an incredibly privacy conscious and altruistic routing layer. Even if that's the case (quite probably, since there isn't much money to be made with it), we shouldn't be relying on it to make privacy promises.\n\n[9] Heavily emphasized across all papers is that this delay needs to be random to be impactful.",
  "actions_summary": [
    {
      "id": 2,
      "count": 3
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 124,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "I was ultimately nerd sniped last LN spec meeting\u2019s discussion [0] of the privacy impact of surfacing granular HTLC hold times via attributable failures [1]. This post contains a recap of the discussion (as I understand it) and a summary of my sniping. \nRecap of meeting discussion: \n\nThe current ver&hellip;",
  "truncated": true,
  "post_url": "/t/latency-and-privacy-in-lightning/1723/1",
  "reactions": [
    {
      "id": "clap",
      "type": "emoji",
      "count": 2
    },
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 3,
  "current_user_used_main_reaction": false
}