{
  "id": 4913,
  "name": "Pieter Wuille",
  "username": "sipa",
  "avatar_template": "/user_avatar/delvingbitcoin.org/sipa/{size}/1100_2.png",
  "created_at": "2025-05-01T21:11:10.185Z",
  "cooked": "<h3><a name=\"p-4913-fairness-1\" class=\"anchor\" href=\"#p-4913-fairness-1\"></a>Fairness</h3>\n<p>There are a number of options for finding which split operation to perform:</p>\n<ol>\n<li>Among all active dependencies, pick the one with the highest-<span class=\"math\">q()</span>. This is what the post above describes.</li>\n<li>Round-robin over all chunks, until one is found with at least one positive-<span class=\"math\">q()</span> dependency. Pick the highest-<span class=\"math\">q()</span> active dependency within that chunk.</li>\n<li>Round-robin over all transactions, until one is found with at least one positive-<span class=\"math\">q()</span> dependency among its children. Pick the highest-<span class=\"math\">q()</span> dependency among them.</li>\n</ol>\n<p>(3) has arguably the best \u201cfairness\u201d, as it balances activity somewhat equally over all transactions, giving each in turn a chance to improve its feerate (by splitting off a worse child + subtree). That was the approach I used initially in the benchmark I linked to above, but I\u2019ve since changed the approach to (2), as it seems (3) does not actually guarantee that every step is an improvement (<a class=\"mention\" href=\"/u/ajtowns\">@ajtowns</a> found that the same state can be repeated), even though it seems extremely hard to hit this when randomness is added into the process. (2) still distributes work somewhat fairly, at least as soon as different potential parties\u2019 transactions have been split into separate chunks - and if they can\u2019t, then the chunk may well be optimal already and it doesn\u2019t matter. More complex cases may exist though, where the optimal chunks consists of combinations of multiple parties\u2019 transactions, in which case it\u2019s unclear to me what approach is better.</p>\n<p>Further, if (1) has the property that it always makes progress, then so does (2). Assume it doesn\u2019t, and a state exists for which (2) cycles. We know that any split that is not immediately followed by a self-merge strictly improves the area under the diagram, so afterwards no repetition of earlier states is possible anymore; thus, the cycle can only consist of splits + self-merges. If one removes from this cycling state all chunks but one splittable one (which must exist, as otherwise the algorithm has terminated), one obtains a state that cycles for (1), which is in contradiction with the assumption.</p>\n<p>Note that we don\u2019t know (yet) whether (1) or (2) actually always make progress, just that if (1) does, then so does (2).</p>\n<h3><a name=\"p-4913-randomization-2\" class=\"anchor\" href=\"#p-4913-randomization-2\"></a>Randomization</h3>\n<p>Even though it appears that nearly all real clusters (based on simulations using replay of 2023 P2P activity) can be linearized optimally by SFL in a very reasonable time, it\u2019s also clear that it\u2019s not hard to construct clusters that take longer, and I believe that it\u2019s possible to construct pathological examples where it takes a very long time.</p>\n<p>Because of that, I think the right approach is to having randomization in the linearization algorithm, so that no attacker can deterministically trigger problems across the network, like specific subsets of a cluster being badly linearized, causing things like say a simple CPFP not working. There are some downsides to non-determinism, like in extreme cases getting inconsistent relay behavior, but I think it\u2019s preferable to deterministic attacks, and given that we expect that pretty much all non-adversially-created clusters will be linearized optimally in negligible time with SFL, it feels like a non-issue.</p>\n<p>Here is a list of the types of randomness I have currently implemented in my prototype implementation (which the benchmarks are for):</p>\n<ul>\n<li>All transactions are given a random index value at startup. This index value is used for:\n<ul>\n<li>When performing a split, and there are multiple active dependencies within a chunk with the same <span class=\"math\">q()</span>, one with the lowest-index parent transaction is used.</li>\n<li>When performing a merge, and there are multiple inactive dependencies between the chunks being merged, one with the lowest-index child (when bubbling up) or lowest-index parent (when bubbling down) is used.</li>\n</ul>\n</li>\n<li>The dependencies (both active and inactive, and both parent and children) per transaction are kept in lists that are ordered randomly at startup. When a dependency is activated, it moves to the end of the active list. When a dependency is deactivated, it is placed in a random position in the inactive list. These lists are used to:\n<ul>\n<li>When performing a split, and there are multiple active dependencies within a chunk with the same <span class=\"math\">q()</span> and the same parent transaction, the first one from the list is used.</li>\n<li>When performing a merge, and there are multiple inactive dependencies between the two chunks with the same child (when bubbling up) or same parent (when bubbling down), the first one from the list is used.</li>\n</ul>\n</li>\n<li>There is a FIFO queue of chunks which should be considered for splitting. This queue is randomly shuffled initially.</li>\n<li>If no existing linearization is provided, a random one is constructed by shuffling the transactions randomly, and then sorting by number of ancestors.</li>\n</ul>",
  "post_number": 5,
  "post_type": 1,
  "posts_count": 5,
  "updated_at": "2025-05-01T21:11:10.185Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 7,
  "readers_count": 6,
  "score": 1.2,
  "yours": false,
  "topic_id": 1419,
  "topic_slug": "spanning-forest-cluster-linearization",
  "topic_title": "Spanning-forest cluster linearization",
  "topic_html_title": "Spanning-forest cluster linearization",
  "category_id": 8,
  "display_username": "Pieter Wuille",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "### Fairness\n\nThere are a number of options for finding which split operation to perform:\n1. Among all active dependencies, pick the one with the highest-$q()$. This is what the post above describes.\n2. Round-robin over all chunks, until one is found with at least one positive-$q()$ dependency. Pick the highest-$q()$ active dependency within that chunk.\n3. Round-robin over all transactions, until one is found with at least one positive-$q()$ dependency among its children. Pick the highest-$q()$ dependency among them.\n\n(3) has arguably the best \"fairness\", as it balances activity somewhat equally over all transactions, giving each in turn a chance to improve its feerate (by splitting off a worse child + subtree). That was the approach I used initially in the benchmark I linked to above, but I've since changed the approach to (2), as it seems (3) does not actually guarantee that every step is an improvement (@ajtowns found that the same state can be repeated), even though it seems extremely hard to hit this when randomness is added into the process. (2) still distributes work somewhat fairly, at least as soon as different potential parties' transactions have been split into separate chunks - and if they can't, then the chunk may well be optimal already and it doesn't matter. More complex cases may exist though, where the optimal chunks consists of combinations of multiple parties' transactions, in which case it's unclear to me what approach is better.\n\nFurther, if (1) has the property that it always makes progress, then so does (2). Assume it doesn't, and a state exists for which (2) cycles. We know that any split that is not immediately followed by a self-merge strictly improves the area under the diagram, so afterwards no repetition of earlier states is possible anymore; thus, the cycle can only consist of splits + self-merges. If one removes from this cycling state all chunks but one splittable one (which must exist, as otherwise the algorithm has terminated), one obtains a state that cycles for (1), which is in contradiction with the assumption.\n\nNote that we don't know (yet) whether (1) or (2) actually always make progress, just that if (1) does, then so does (2).\n\n### Randomization\n\nEven though it appears that nearly all real clusters (based on simulations using replay of 2023 P2P activity) can be linearized optimally by SFL in a very reasonable time, it's also clear that it's not hard to construct clusters that take longer, and I believe that it's possible to construct pathological examples where it takes a very long time.\n\nBecause of that, I think the right approach is to having randomization in the linearization algorithm, so that no attacker can deterministically trigger problems across the network, like specific subsets of a cluster being badly linearized, causing things like say a simple CPFP not working. There are some downsides to non-determinism, like in extreme cases getting inconsistent relay behavior, but I think it's preferable to deterministic attacks, and given that we expect that pretty much all non-adversially-created clusters will be linearized optimally in negligible time with SFL, it feels like a non-issue.\n\nHere is a list of the types of randomness I have currently implemented in my prototype implementation (which the benchmarks are for):\n* All transactions are given a random index value at startup. This index value is used for:\n  * When performing a split, and there are multiple active dependencies within a chunk with the same $q()$, one with the lowest-index parent transaction is used.\n  * When performing a merge, and there are multiple inactive dependencies between the chunks being merged, one with the lowest-index child (when bubbling up) or lowest-index parent (when bubbling down) is used.\n* The dependencies (both active and inactive, and both parent and children) per transaction are kept in lists that are ordered randomly at startup. When a dependency is activated, it moves to the end of the active list. When a dependency is deactivated, it is placed in a random position in the inactive list. These lists are used to:\n  * When performing a split, and there are multiple active dependencies within a chunk with the same $q()$ and the same parent transaction, the first one from the list is used.\n  * When performing a merge, and there are multiple inactive dependencies between the two chunks with the same child (when bubbling up) or same parent (when bubbling down), the first one from the list is used.\n* There is a FIFO queue of chunks which should be considered for splitting. This queue is randomly shuffled initially.\n* If no existing linearization is provided, a random one is constructed by shuffling the transactions randomly, and then sorting by number of ancestors.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 96,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "<a name=\"p-4913-fairness-1\" class=\"anchor\" href=\"#p-4913-fairness-1\"></a>Fairness\nThere are a number of options for finding which split operation to perform: \n\nAmong all active dependencies, pick the one with the highest-q(). This is what the post above describes.\nRound-robin over all chunks, until one is found with at least one positive-q() dependency. Pick the highest-q&hellip;",
  "truncated": true,
  "post_url": "/t/spanning-forest-cluster-linearization/1419/5",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}