{
  "id": 5167,
  "name": "Eugene",
  "username": "Crypt-iQ",
  "avatar_template": "/user_avatar/delvingbitcoin.org/crypt-iq/{size}/306_2.png",
  "created_at": "2025-05-30T13:48:55.474Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"t-bast\" data-post=\"12\" data-topic=\"1723\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/t-bast/48/98_2.png\" class=\"avatar\"> t-bast:</div>\n<blockquote>\n<p>Is this a default OS behavior? Or is it just a recommendation? I\u2019ll read the links you provided when I have some time, but would love a TL;DR for now</p>\n</blockquote>\n</aside>\n<p>I\u2019m syncing a bitcoind node on my macbook and I can see in Wireshark that it is both fragmenting and reassembling packets greater than 1500 bytes (specifically <code>headers</code> messages). You can run <code>ifconfig</code> or similar on your machine and it will tell you MTU. Packets larger than 1500 bytes can be transmitted, but I believe this requires every router to handle this. I believe the 1500 byte limitation is a legacy thing and may vary with OS but seems to be pretty consistent from what I\u2019ve seen. Hope I\u2019m not link spamming too much but this post gives some history into the 1500 byte limitation (<a href=\"https://blog.benjojo.co.uk/post/why-is-ethernet-mtu-1500\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">How 1500 bytes became the MTU of the internet</a>).</p>\n<p>RFC8900:</p>\n<ul>\n<li>This was written recently (in 2020) and describes all of the different issues with fragmentation and reassembly of IP packets.\n<ul>\n<li>Some senders use something called Path MTU Discovery where ICMP packets are sent back to the sender so they can update their MTU estimate for a path. Usage of ICMP is not great because there is no authentication, can be rate-limited, black-holed, etc and I believe this means that in adversarial cases or even during regular operation, the sender may have to retry the send.</li>\n<li>IPv6 has different fragmentation rules than IPv4 which seems to have some upsides but also may introduce some complications. It is less vulnerable to 3rd party IP reassembly attacks.</li>\n<li>It notes that RFC 4443 recommends strict rate limiting of ICMPv6 traffic which may come into play during congestion.</li>\n<li>Ultimately recommends that higher-layer protocols not rely on IP fragmentation as it\u2019s fragile.</li>\n</ul>\n</li>\n</ul>\n<p>RFC4963:</p>\n<ul>\n<li>This was written in 2007 and describes how IP reassembly works.\n<ul>\n<li>IPv4 uses a 16-bit ID field. The implementation \u201cassembling fragments judges fragments to belong to the same datagram if they have the same source, destination, protocol, and Identifier\u201d. In the RFC, it gives an example time that the packet can be alive as 30 seconds. I\u2019m not sure whether this is a TCP Maximum Segment Lifetime (MSL) value (depends on OS, defaults to 30 seconds in Linux) or an IP-related timeout. This has implications on a senders data rate as <em>technically</em> only 65,535 1500-byte packets are valid in a 30-second window or whatever the time limit is.</li>\n<li>IPv4 receivers store fragments in a reassembly buffer until all fragments are received or a reassembly timeout is reached. Configuring the reassembly timeout to be less has issues for slow senders but is better for fast senders. The opposite is also true when increasing the reassembly timeout.</li>\n<li>The RFC describes a situation that can occur either maliciously or under high data-rates called \u201cmis-association\u201d. This is where overlapping, unrelated IP packets are spliced together and then passed to the higher layer. Typically this will get caught by the TCP or UDP checksum, however it\u2019s only a 16-bit checksum and can occasionally be bypassed. Because of this, the RFC ultimately recommends the application layer to implement cryptographic integrity checks (which we do thankfully in both Bitcoin and Lightning).</li>\n<li>Over UDP with 10TB of \u201crandom\u201d data being sent, there were 8,847,668 UDP checksum errors and 121 corruptions due to mis-associated fragments (i.e. the UDP checksum was bypassed) and passed to the higher-layer.</li>\n<li>From what I can tell (I have yet to test this), just because we have integrity checks in both Bitcoin and Lightning doesn\u2019t preclude an attacker from messing with our reassembly and causing delays even if they are not an AS and are just guessing two people are connected. The LN graph is public also which is a bit concerning.</li>\n</ul>\n</li>\n</ul>\n<aside class=\"quote no-group\" data-username=\"t-bast\" data-post=\"12\" data-topic=\"1723\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/t-bast/48/98_2.png\" class=\"avatar\"> t-bast:</div>\n<blockquote>\n<p>I have no idea where to find actual data of what happens on the internet nowadays. I was thinking that we could do A/B testing on mainnet nodes: pad all packets to 65kB for a few days, then remove padding for a few days, and repeat, while measuring latency.</p>\n</blockquote>\n</aside>\n<p>Data is pretty hard to come by. I think testing on mainnet and observing traffic is probably your best bet. I think fragmentation can be pretty costly in the presence of errors since retransmission and reassembly has to occur again. But again I don\u2019t have hard data for this. It would be very interesting to see what other applications like Tor or something do when trying to send or receive large amounts of data at once.</p>",
  "post_number": 13,
  "post_type": 1,
  "posts_count": 40,
  "updated_at": "2025-05-30T15:05:54.281Z",
  "reply_count": 1,
  "reply_to_post_number": 12,
  "quote_count": 1,
  "incoming_link_count": 22,
  "reads": 37,
  "readers_count": 36,
  "score": 152.4,
  "yours": false,
  "topic_id": 1723,
  "topic_slug": "latency-and-privacy-in-lightning",
  "topic_title": "Latency and Privacy in Lightning",
  "topic_html_title": "Latency and Privacy in Lightning",
  "category_id": 7,
  "display_username": "Eugene",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 3,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"t-bast, post:12, topic:1723\"]\nIs this a default OS behavior? Or is it just a recommendation? I\u2019ll read the links you provided when I have some time, but would love a TL;DR for now\n[/quote]\n\nI'm syncing a bitcoind node on my macbook and I can see in Wireshark that it is both fragmenting and reassembling packets greater than 1500 bytes (specifically `headers` messages). You can run `ifconfig` or similar on your machine and it will tell you MTU. Packets larger than 1500 bytes can be transmitted, but I believe this requires every router to handle this. I believe the 1500 byte limitation is a legacy thing and may vary with OS but seems to be pretty consistent from what I've seen. Hope I'm not link spamming too much but this post gives some history into the 1500 byte limitation (https://blog.benjojo.co.uk/post/why-is-ethernet-mtu-1500).\n\nRFC8900:\n- This was written recently (in 2020) and describes all of the different issues with fragmentation and reassembly of IP packets.\n  - Some senders use something called Path MTU Discovery where ICMP packets are sent back to the sender so they can update their MTU estimate for a path. Usage of ICMP is not great because there is no authentication, can be rate-limited, black-holed, etc and I believe this means that in adversarial cases or even during regular operation, the sender may have to retry the send.\n  - IPv6 has different fragmentation rules than IPv4 which seems to have some upsides but also may introduce some complications. It is less vulnerable to 3rd party IP reassembly attacks.\n  - It notes that RFC 4443 recommends strict rate limiting of ICMPv6 traffic which may come into play during congestion.\n  - Ultimately recommends that higher-layer protocols not rely on IP fragmentation as it's fragile.\n\nRFC4963:\n- This was written in 2007 and describes how IP reassembly works.\n  - IPv4 uses a 16-bit ID field. The implementation \"assembling fragments judges fragments to belong to the same datagram if they have the same source, destination, protocol, and Identifier\". In the RFC, it gives an example time that the packet can be alive as 30 seconds. I'm not sure whether this is a TCP Maximum Segment Lifetime (MSL) value (depends on OS, defaults to 30 seconds in Linux) or an IP-related timeout. This has implications on a senders data rate as _technically_ only 65,535 1500-byte packets are valid in a 30-second window or whatever the time limit is.\n  - IPv4 receivers store fragments in a reassembly buffer until all fragments are received or a reassembly timeout is reached. Configuring the reassembly timeout to be less has issues for slow senders but is better for fast senders. The opposite is also true when increasing the reassembly timeout.\n  - The RFC describes a situation that can occur either maliciously or under high data-rates called \"mis-association\". This is where overlapping, unrelated IP packets are spliced together and then passed to the higher layer. Typically this will get caught by the TCP or UDP checksum, however it's only a 16-bit checksum and can occasionally be bypassed. Because of this, the RFC ultimately recommends the application layer to implement cryptographic integrity checks (which we do thankfully in both Bitcoin and Lightning).\n  - Over UDP with 10TB of \"random\" data being sent, there were 8,847,668 UDP checksum errors and 121 corruptions due to mis-associated fragments (i.e. the UDP checksum was bypassed) and passed to the higher-layer.\n  - From what I can tell (I have yet to test this), just because we have integrity checks in both Bitcoin and Lightning doesn't preclude an attacker from messing with our reassembly and causing delays even if they are not an AS and are just guessing two people are connected. The LN graph is public also which is a bit concerning.\n\n[quote=\"t-bast, post:12, topic:1723\"]\nI have no idea where to find actual data of what happens on the internet nowadays. I was thinking that we could do A/B testing on mainnet nodes: pad all packets to 65kB for a few days, then remove padding for a few days, and repeat, while measuring latency.\n[/quote]\n\nData is pretty hard to come by. I think testing on mainnet and observing traffic is probably your best bet. I think fragmentation can be pretty costly in the presence of errors since retransmission and reassembly has to occur again. But again I don't have hard data for this. It would be very interesting to see what other applications like Tor or something do when trying to send or receive large amounts of data at once.",
  "actions_summary": [
    {
      "id": 2,
      "count": 2
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 253,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "I\u2019m syncing a bitcoind node on my macbook and I can see in Wireshark that it is both fragmenting and reassembling packets greater than 1500 bytes (specifically headers messages). You can run ifconfig or similar on your machine and it will tell you MTU. Packets larger than 1500 bytes can be transmit&hellip;",
  "truncated": true,
  "post_url": "/t/latency-and-privacy-in-lightning/1723/13",
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    },
    {
      "id": "heart",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 2,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}