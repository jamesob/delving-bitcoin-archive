{
  "id": 5078,
  "name": "szarka",
  "username": "szarka",
  "avatar_template": "/letter_avatar_proxy/v4/letter/s/34f0e0/{size}.png",
  "created_at": "2025-05-21T22:21:46.376Z",
  "cooked": "<h1><a name=\"p-5078-vextratxnforcompact-considered-useful-1\" class=\"anchor\" href=\"#p-5078-vextratxnforcompact-considered-useful-1\"></a>vExtraTxnForCompact Considered Useful</h1>\n<h2><a name=\"p-5078-tldr-2\" class=\"anchor\" href=\"#p-5078-tldr-2\"></a>tl;dr</h2>\n<p>The <code>bitcoin.conf</code> option <code>blockreconstructionextratxn</code> is underappreciated, especially in the context of heterogeneous node policies, and more noderunners should consider increasing it from its current default. On a node that applies restrictive spam-filtering policies, a substantial number of filtered transactions can be recovered from <code>vExtraTxnForCompact</code>, saving the need to request them from peers during compact block reconstruction.</p>\n<h2><a name=\"p-5078-motivation-3\" class=\"anchor\" href=\"#p-5078-motivation-3\"></a>Motivation</h2>\n<p>An underappreciated feature of <a href=\"https://github.com/bitcoin/bitcoin\" rel=\"noopener nofollow ugc\">Bitcoin Core</a> is <a href=\"https://github.com/bitcoin/bitcoin/pull/9499\" rel=\"noopener nofollow ugc\"><code>vExtraTxnForCompact</code></a>, which is a sort of purgatory where a hodgepodge of misfit transactions swirl around a ring buffer before being shuffled off into the void. Here, transactions replaced in the mempool, orphans, and transactions rejected for policy reasons await a last chance at redemption during compact block reconstruction. If they get mined, the node uses them to reconstruct the block instead of requesting them from its peers.</p>\n<p>Poor little vExtra doesn\u2019t get much respect, having been implemented opportunistically in a way that isn\u2019t especially robust. And, by default, only 100 transactions are buffered. Consequently, it seems, a lot of folks engaged in the recent brouhaha around <code>OP_RETURN</code> forgot about (or were never aware of) its very existence. If nodes filter moby datacarriers (and other spam), the thinking went, they won\u2019t have those transactions around to reconstruct blocks and will have to request them from their peers. But, in fact, those transactions may be present in vExtra.</p>\n<p>Even for nodes running with Core\u2019s defaults (i.e., <code>datacarriersize=83</code>) and a modest increase of <code>blockreconstructionextratxn</code> from its default of <code>100</code> to <code>1000</code>, as <a href=\"https://delvingbitcoin.org/t/stats-on-compact-block-reconstructions/1052/1\">0xB10C reported last year</a>, vExtra improves compact block reconstruction performance. But vExtra\u2019s potential is even greater for nodes that apply more restrictive policies. For nodes running Bitcoin Core, that might mean <code>datacarriersize=0</code> (for now, at least) and <code>permitbaremultisig=0</code>. For nodes running <a href=\"https://github.com/bitcoinknots/bitcoin\" rel=\"noopener nofollow ugc\">Bitcoin Knots</a>, which uses the same code to handle vExtra but allows more control over policy, there\u2019s potentially a much larger number of rejected transactions added to vExtra.</p>\n<p><a href=\"https://github.com/bitcoin/bitcoin/pull/32510\" rel=\"noopener nofollow ugc\">Sjors recently proposed</a> a (temporary?) change that would only put replaced transactions, not transactions rejected by policy, in vExtra. Despite his valid concern that vExtra isn\u2019t robust to attacks that could fill it with garbage, consuming memory while also making it useless, this seemed to me like a big step backward at a time when many are concerned about degredation of compact block reconstruction. But exactly how load-bearing has this modest little data structure become? I decided to try a simple experiment to get a better sense of how helpful vExtra can be in the face of heterogeneous node policies.</p>\n<h2><a name=\"p-5078-method-4\" class=\"anchor\" href=\"#p-5078-method-4\"></a>Method</h2>\n<p>My strategy was to run a filtering node and a non-filtering node side-by-side and compare how many transactions they requested during compact block reconstruction and how many they retrieved from vExtra, as follows:</p>\n<ul>\n<li>Both nodes running Knots (Satoshi:27.1.0/Knots:20240801) on identical hardware on a 1 gbps connection (with IPv4, IPv6, and Tor) in the same subnet.</li>\n<li>Both nodes with <code>maxmempool=1200</code>, starting at the same time (shortly before block 897568) with an empty mempool.</li>\n<li>Both nodes with <code>blockreconstructionextratxn=100000</code>. (This seemed like the largest value that would keep memory usage from growing too large in the presence of an attack, and it seemed unlikely that larger values would greatly increase performance.)</li>\n<li>Both nodes connected to a node with Core 29.0 and default settings plus one running Core 29.0 with <code>datacarriersize=400000</code> for good measure.</li>\n<li>The two nodes peered with each other using <code>whitelist=forcerelay,in,out</code>.</li>\n<li>The equivalent of current Core defaults (including <code>datacarriersize=83</code>) on the non-filtering node.</li>\n<li>The following aggressive policy on the filtering node:</li>\n</ul>\n<pre><code class=\"lang-auto\">acceptnonstddatacarrier=0  \nacceptnonstdtxn=0  \ndatacarrier=1  \ndatacarriercost=1  \ndatacarriersize=83  \npermitbaremultisig=0  \npermitbarepubkey=0  \nrejectparasites=1  \nrejecttokens=1  \n</code></pre>\n<p>I collected 145 blocks of data (blocks 897568 through 897712), during a period when the network was reasonably active (only one empty block, not due to lack of transactions) and there were a fair number of inscriptions (mostly small BRC-20 transactions) being mined.</p>\n<h2><a name=\"p-5078-results-5\" class=\"anchor\" href=\"#p-5078-results-5\"></a>Results</h2>\n<p>In total, the filtering node requested 4% of the transactions needed for compact block reconstruction, vs. 1% for the non-filtering node. So, as expected, the ~101,000 additional transactions the filtering node rejected due to its more-restrictive policies resulted in almost triple (16,598 vs. 6,115) the requests from peers.</p>\n<p>However, performance on the filtering node would have been far worse without vExtra! Of the 415,686 transactions in these blocks, the filtering node found 103,820 (25%) in vExtra vs. only 24,413 (6%) for the non-filtering node. Put another way, the filtering node recovered about 80% of the filtered transactions from vExtra at reconstruction time.</p>\n<h2><a name=\"p-5078-conclusions-6\" class=\"anchor\" href=\"#p-5078-conclusions-6\"></a>Conclusions</h2>\n<p>Despite valid concerns about its robustness, <code>vExtraTxnForCompact</code> is earning its keep in Bitcoin Core (and, by extension, Knots). Any node that isn\u2019t severely resource-constrained should consider increasing <code>blockreconstructionextratxn</code> from its default of <code>100</code>, and miners\u2014especially those filtering spam\u2014should probably consider a much higher value. (Only rejected transactions &lt;100kb are added to vExtra, so, despite being sized by the number of entries rather than by the amount of memory, its size is still limited.)</p>\n<p>Someone who is more skilled at C++ than I (or who has more time to trace individual transactions from blocks back to log file entries) might consider collecting more data about which types of rejected transactions (and other denizens of vExtra) eventually find their way into blocks, and should perhaps be prioritized. Even simply providing options to configure what does and does not get added to vExtra might be useful to noderunners with different needs.</p>\n<p>Given its potentially increasing importance, making vExtra less susceptible to attack and/or engineering a new approach that appropriately handles the different types of transactions currently added to vExtra seems like a worthy goal that would improve node performance.</p>\n<h2><a name=\"p-5078-supplementary-7\" class=\"anchor\" href=\"#p-5078-supplementary-7\"></a>Supplementary</h2>\n<p>See <a href=\"https://github.com/szarka/vextratest\" rel=\"noopener nofollow ugc\">Github</a> for per block details and supporting log excerpts. Corrections very welcome!</p>\n<hr>\n<p>\u2013 szarka (2025-05-21)</p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 6,
  "updated_at": "2025-05-21T22:21:46.376Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 83,
  "reads": 31,
  "readers_count": 30,
  "score": 416.2,
  "yours": false,
  "topic_id": 1716,
  "topic_slug": "vextratxnforcompact-considered-useful",
  "topic_title": "vExtraTxnForCompact Considered Useful",
  "topic_html_title": "vExtraTxnForCompact Considered Useful",
  "category_id": 7,
  "display_username": "szarka",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "\n# vExtraTxnForCompact Considered Useful\n\n## tl;dr\n\nThe `bitcoin.conf` option `blockreconstructionextratxn` is underappreciated, especially in the context of heterogeneous node policies, and more noderunners should consider increasing it from its current default. On a node that applies restrictive spam-filtering policies, a substantial number of filtered transactions can be recovered from `vExtraTxnForCompact`, saving the need to request them from peers during compact block reconstruction.\n\n## Motivation\n\nAn underappreciated feature of [Bitcoin Core](https://github.com/bitcoin/bitcoin) is [`vExtraTxnForCompact`](https://github.com/bitcoin/bitcoin/pull/9499), which is a sort of purgatory where a hodgepodge of misfit transactions swirl around a ring buffer before being shuffled off into the void. Here, transactions replaced in the mempool, orphans, and transactions rejected for policy reasons await a last chance at redemption during compact block reconstruction. If they get mined, the node uses them to reconstruct the block instead of requesting them from its peers.\n\nPoor little vExtra doesn't get much respect, having been implemented opportunistically in a way that isn't especially robust. And, by default, only 100 transactions are buffered. Consequently, it seems, a lot of folks engaged in the recent brouhaha around `OP_RETURN` forgot about (or were never aware of) its very existence. If nodes filter moby datacarriers (and other spam), the thinking went, they won't have those transactions around to reconstruct blocks and will have to request them from their peers. But, in fact, those transactions may be present in vExtra.\n\nEven for nodes running with Core's defaults (i.e., `datacarriersize=83`) and a modest increase of `blockreconstructionextratxn` from its default of `100` to `1000`, as [0xB10C reported last year](https://delvingbitcoin.org/t/stats-on-compact-block-reconstructions/1052/1), vExtra improves compact block reconstruction performance. But vExtra's potential is even greater for nodes that apply more restrictive policies. For nodes running Bitcoin Core, that might mean `datacarriersize=0` (for now, at least) and `permitbaremultisig=0`. For nodes running [Bitcoin Knots](https://github.com/bitcoinknots/bitcoin), which uses the same code to handle vExtra but allows more control over policy, there's potentially a much larger number of rejected transactions added to vExtra.\n\n[Sjors recently proposed](https://github.com/bitcoin/bitcoin/pull/32510) a (temporary?) change that would only put replaced transactions, not transactions rejected by policy, in vExtra. Despite his valid concern that vExtra isn't robust to attacks that could fill it with garbage, consuming memory while also making it useless, this seemed to me like a big step backward at a time when many are concerned about degredation of compact block reconstruction. But exactly how load-bearing has this modest little data structure become? I decided to try a simple experiment to get a better sense of how helpful vExtra can be in the face of heterogeneous node policies.\n\n## Method\n\nMy strategy was to run a filtering node and a non-filtering node side-by-side and compare how many transactions they requested during compact block reconstruction and how many they retrieved from vExtra, as follows:\n\n- Both nodes running Knots (Satoshi:27.1.0/Knots:20240801) on identical hardware on a 1 gbps connection (with IPv4, IPv6, and Tor) in the same subnet.\n- Both nodes with `maxmempool=1200`, starting at the same time (shortly before block 897568) with an empty mempool.\n- Both nodes with `blockreconstructionextratxn=100000`. (This seemed like the largest value that would keep memory usage from growing too large in the presence of an attack, and it seemed unlikely that larger values would greatly increase performance.)\n- Both nodes connected to a node with Core 29.0 and default settings plus one running Core 29.0 with `datacarriersize=400000` for good measure.\n- The two nodes peered with each other using `whitelist=forcerelay,in,out`.\n- The equivalent of current Core defaults (including `datacarriersize=83`) on the non-filtering node.\n- The following aggressive policy on the filtering node:  \n```\nacceptnonstddatacarrier=0  \nacceptnonstdtxn=0  \ndatacarrier=1  \ndatacarriercost=1  \ndatacarriersize=83  \npermitbaremultisig=0  \npermitbarepubkey=0  \nrejectparasites=1  \nrejecttokens=1  \n```\n\nI collected 145 blocks of data (blocks 897568 through 897712), during a period when the network was reasonably active (only one empty block, not due to lack of transactions) and there were a fair number of inscriptions (mostly small BRC-20 transactions) being mined.\n\n## Results\n\nIn total, the filtering node requested 4% of the transactions needed for compact block reconstruction, vs. 1% for the non-filtering node. So, as expected, the ~101,000 additional transactions the filtering node rejected due to its more-restrictive policies resulted in almost triple (16,598 vs. 6,115) the requests from peers. \n\nHowever, performance on the filtering node would have been far worse without vExtra! Of the 415,686 transactions in these blocks, the filtering node found 103,820 (25%) in vExtra vs. only 24,413 (6%) for the non-filtering node. Put another way, the filtering node recovered about 80% of the filtered transactions from vExtra at reconstruction time.\n\n## Conclusions\n\nDespite valid concerns about its robustness, `vExtraTxnForCompact` is earning its keep in Bitcoin Core (and, by extension, Knots). Any node that isn't severely resource-constrained should consider increasing `blockreconstructionextratxn` from its default of `100`, and miners---especially those filtering spam---should probably consider a much higher value. (Only rejected transactions <100kb are added to vExtra, so, despite being sized by the number of entries rather than by the amount of memory, its size is still limited.)\n\nSomeone who is more skilled at C++ than I (or who has more time to trace individual transactions from blocks back to log file entries) might consider collecting more data about which types of rejected transactions (and other denizens of vExtra) eventually find their way into blocks, and should perhaps be prioritized. Even simply providing options to configure what does and does not get added to vExtra might be useful to noderunners with different needs.\n\nGiven its potentially increasing importance, making vExtra less susceptible to attack and/or engineering a new approach that appropriately handles the different types of transactions currently added to vExtra seems like a worthy goal that would improve node performance.\n\n## Supplementary\n\nSee [Github](https://github.com/szarka/vextratest) for per block details and supporting log excerpts. Corrections very welcome!\n\n---\n\n-- szarka (2025-05-21)",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 798,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "<a name=\"p-5078-vextratxnforcompact-considered-useful-1\" class=\"anchor\" href=\"#p-5078-vextratxnforcompact-considered-useful-1\"></a>vExtraTxnForCompact Considered Useful\n<a name=\"p-5078-tldr-2\" class=\"anchor\" href=\"#p-5078-tldr-2\"></a>tl;dr\nThe bitcoin.conf option blockreconstructionextratxn is underappreciated, especially in the context of heterogeneous node policies, and more noderunners should consider increasing it from its current default. On a node that applies restrictive spam-filterin&hellip;",
  "truncated": true,
  "post_url": "/t/vextratxnforcompact-considered-useful/1716/1",
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}