{
  "id": 5005,
  "name": "Sjors Provoost",
  "username": "sjors",
  "avatar_template": "/user_avatar/delvingbitcoin.org/sjors/{size}/59_2.png",
  "created_at": "2025-05-14T12:09:47.239Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"salvatoshi\" data-post=\"1\" data-topic=\"1607\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/salvatoshi/48/72_2.png\" class=\"avatar\"> salvatoshi:</div>\n<blockquote>\n<p>Therefore, <em>secrecy</em> is reduced to <em>secrecy for anyone who doesn\u2019t already have the descriptor</em>.</p>\n</blockquote>\n</aside>\n<p>I like this approach. Conversely, if you lose one of the signer keys (and the software wallet that goes with it), having <em>any</em> of the other keys lets you recover this information. E.g. your house burns down along with one signing device, your Bitcoin Core node and its wallet, but you still have a signing device in a vault.</p>\n<aside class=\"quote no-group\" data-username=\"salvatoshi\" data-post=\"1\" data-topic=\"1607\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/salvatoshi/48/72_2.png\" class=\"avatar\"> salvatoshi:</div>\n<blockquote>\n<p>In order to decrypt the payload of a backup, the owner of a certain public key <span class=\"math\">p</span> computes <span class=\"math\">s = \\operatorname{sha256}(``\\textrm{BACKUP_INDIVIDUAL_SECRET}\" \\| p)</span>, and attempt the decryption of the payload with the key <span class=\"math\">c_i \\oplus s</span> for each of the provided <span class=\"math\">c_i</span>.</p>\n</blockquote>\n</aside>\n<p>Calling this <span class=\"math\">s</span> had me confused. But IIUC what you\u2019re actually doing here is to reconstruct your <span class=\"math\">s_i</span>, without knowing which <span class=\"math\">i</span> is you. You try it against each <span class=\"math\">c_i</span> to see if you found <span class=\"math\">s</span>. The way you know if that worked is if <span class=\"math\">s</span> decrypts something sane.</p>\n<p>You still need to figure out which xpub to use for <span class=\"math\">p</span>.</p>\n<p>The <a href=\"https://github.com/bitcoin/bips/blob/60ac0e8feccb07f891fd984e4ed76105d2898609/bip-0087.mediawiki\">BIP87</a> account level xpub seems like a good candidate to recommended for this, where you may have to try multiple accounts for decryption.</p>\n<p>Or you just add a (plain text) derivation hint to the backup.</p>\n<p>Another approach is to pick a standard derivation path for these backups, but then you lose the nice property of being able to derive the backup key from a descriptor:</p>\n<aside class=\"quote no-group\" data-username=\"salvatoshi\" data-post=\"8\" data-topic=\"1607\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/salvatoshi/48/72_2.png\" class=\"avatar\"> salvatoshi:</div>\n<blockquote>\n<p>Instead, the more trivial scheme above is a pure function <code>f(descriptor) -&gt; backup</code>, which I think is a big practical advantage.</p>\n</blockquote>\n</aside>\n<p>One such practical advantage:</p>\n<aside class=\"quote no-group\" data-username=\"kloaec\" data-post=\"9\" data-topic=\"1607\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/kloaec/48/1191_2.png\" class=\"avatar\"> kloaec:</div>\n<blockquote>\n<p>Over time, data storage decay. As we can\u2019t assume it will always be stored in a self healing manner, I would put such a self healing mechanism in the backup itself</p>\n</blockquote>\n</aside>\n<p>Backups can easily be verified against data corruption by any software that has the descriptor.</p>\n<p>If you want to go one level fancier, you can even use this backup format for cloud sync.</p>\n<aside class=\"quote no-group\" data-username=\"salvatoshi\" data-post=\"1\" data-topic=\"1607\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/salvatoshi/48/72_2.png\" class=\"avatar\"> salvatoshi:</div>\n<blockquote>\n<p>the payload <span class=\"math\">data</span> that is being backed up is left unspecified, but it will include (at least) the descriptor or the <a href=\"https://github.com/bitcoin/bips/blob/c5220f8c3b43821efa3841a6c5e90af9ce5519e8/bip-0388.mediawiki\">BIP388</a> wallet policy</p>\n</blockquote>\n</aside>\n<p>I would suggest a simple JSON blob with a <code>\"descriptor\"</code> field. That can arbitrarily be expanded to include whatever else people want to (occasionally) backup, such as <a href=\"https://github.com/bitcoin/bips/blob/60ac0e8feccb07f891fd984e4ed76105d2898609/bip-0329.mediawiki\">BIP329</a> labels.</p>\n<aside class=\"quote no-group\" data-username=\"josh\" data-post=\"3\" data-topic=\"1607\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/josh/48/95_2.png\" class=\"avatar\"> josh:</div>\n<blockquote>\n<p>If the encrypted descriptor is stored publicly or on a compromised server, an attacker who gains access to one secret gains knowledge of the existence of the multisig. This is not ideal if a user wants to protect themselves with a decoy single-sig wallet.</p>\n</blockquote>\n</aside>\n<p>But this is an essential property for recovery in my opinion, see above.</p>\n<aside class=\"quote no-group\" data-username=\"josh\" data-post=\"3\" data-topic=\"1607\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/josh/48/95_2.png\" class=\"avatar\"> josh:</div>\n<blockquote>\n<p>In a <span class=\"math\">k</span>-of-<span class=\"math\">n</span> multisig descriptor, the secret <span class=\"math\">s</span> is split into <span class=\"math\">n</span> shares using shamir secret sharing, where <span class=\"math\">k</span> shares are needed to recover. Each share is then encrypted with one xpub, so that <span class=\"math\">k</span> xpubs are needed to decrypt.</p>\n</blockquote>\n</aside>\n<p>This adds complexity to recovery, since the (miniscript) descriptor might define a completely different policy than the the information access control. You\u2019d also have to remember the threshold value.</p>\n<p>In any case this scheme still reveals the <em>presence</em> of a more sophisticated wallet even if not its contents. It makes it unlikely an attacker falls for the decoy.</p>\n<p>Stenographic storage of the backup seems like a better way to deal with this issue.</p>",
  "post_number": 10,
  "post_type": 1,
  "posts_count": 31,
  "updated_at": "2025-05-14T12:18:33.194Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 4,
  "incoming_link_count": 3,
  "reads": 56,
  "readers_count": 55,
  "score": 26.2,
  "yours": false,
  "topic_id": 1607,
  "topic_slug": "a-simple-backup-scheme-for-wallet-accounts",
  "topic_title": "A simple backup scheme for wallet accounts",
  "topic_html_title": "A simple backup scheme for wallet accounts",
  "category_id": 8,
  "display_username": "Sjors Provoost",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"salvatoshi, post:1, topic:1607\"]\nTherefore, *secrecy* is reduced to *secrecy for anyone who doesn\u2019t already have the descriptor*.\n[/quote]\n\nI like this approach. Conversely, if you lose one of the signer keys (and the software wallet that goes with it), having _any_ of the other keys lets you recover this information. E.g. your house burns down along with one signing device, your Bitcoin Core node and its wallet, but you still have a signing device in a vault.\n\n[quote=\"salvatoshi, post:1, topic:1607\"]\nIn order to decrypt the payload of a backup, the owner of a certain public key $p$ computes $s = \\operatorname{sha256}(``\\textrm{BACKUP_INDIVIDUAL_SECRET}\" \\| p)$, and attempt the decryption of the payload with the key $c_i \\oplus s$ for each of the provided $c_i$.\n[/quote]\n\nCalling this $s$ had me confused. But IIUC what you're actually doing here is to reconstruct your $s_i$, without knowing which $i$ is you. You try it against each $c_i$ to see if you found $s$. The way you know if that worked is if $s$ decrypts something sane.\n\nYou still need to figure out which xpub to use for $p$.\n\nThe [BIP87](https://github.com/bitcoin/bips/blob/60ac0e8feccb07f891fd984e4ed76105d2898609/bip-0087.mediawiki) account level xpub seems like a good candidate to recommended for this, where you may have to try multiple accounts for decryption.\n\nOr you just add a (plain text) derivation hint to the backup.\n\nAnother approach is to pick a standard derivation path for these backups, but then you lose the nice property of being able to derive the backup key from a descriptor:\n\n[quote=\"salvatoshi, post:8, topic:1607\"]\nInstead, the more trivial scheme above is a pure function `f(descriptor) -> backup`, which I think is a big practical advantage.\n[/quote]\n\nOne such practical advantage:\n\n[quote=\"kloaec, post:9, topic:1607\"]\nOver time, data storage decay. As we can\u2019t assume it will always be stored in a self healing manner, I would put such a self healing mechanism in the backup itself\n[/quote]\n\nBackups can easily be verified against data corruption by any software that has the descriptor.\n\nIf you want to go one level fancier, you can even use this backup format for cloud sync.\n\n[quote=\"salvatoshi, post:1, topic:1607\"]\nthe payload $data$ that is being backed up is left unspecified, but it will include (at least) the descriptor or the [BIP388](https://github.com/bitcoin/bips/blob/c5220f8c3b43821efa3841a6c5e90af9ce5519e8/bip-0388.mediawiki) wallet policy\n[/quote]\n\nI would suggest a simple JSON blob with a `\"descriptor\"` field. That can arbitrarily be expanded to include whatever else people want to (occasionally) backup, such as [BIP329](https://github.com/bitcoin/bips/blob/60ac0e8feccb07f891fd984e4ed76105d2898609/bip-0329.mediawiki) labels.\n\n[quote=\"josh, post:3, topic:1607\"]\nIf the encrypted descriptor is stored publicly or on a compromised server, an attacker who gains access to one secret gains knowledge of the existence of the multisig. This is not ideal if a user wants to protect themselves with a decoy single-sig wallet.\n[/quote]\n\nBut this is an essential property for recovery in my opinion, see above.\n\n[quote=\"josh, post:3, topic:1607\"]\nIn a $k$-of-$n$ multisig descriptor, the secret $s$ is split into $n$ shares using shamir secret sharing, where $k$ shares are needed to recover. Each share is then encrypted with one xpub, so that $k$ xpubs are needed to decrypt.\n[/quote]\n\nThis adds complexity to recovery, since the (miniscript) descriptor might define a completely different policy than the the information access control. You'd also have to remember the threshold value.\n\nIn any case this scheme still reveals the _presence_ of a more sophisticated wallet even if not its contents. It makes it unlikely an attacker falls for the decoy.\n\nStenographic storage of the backup seems like a better way to deal with this issue.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 71,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": "Github link was replaced with a permanent link",
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "I like this approach. Conversely, if you lose one of the signer keys (and the software wallet that goes with it), having any of the other keys lets you recover this information. E.g. your house burns down along with one signing device, your Bitcoin Core node and its wallet, but you still have a sig&hellip;",
  "truncated": true,
  "post_url": "/t/a-simple-backup-scheme-for-wallet-accounts/1607/10",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}