{
  "id": 4964,
  "name": "Chris Stewart",
  "username": "Chris_Stewart_5",
  "avatar_template": "/user_avatar/delvingbitcoin.org/chris_stewart_5/{size}/296_2.png",
  "created_at": "2025-05-08T18:35:01.919Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"salvatoshi\" data-post=\"6\" data-topic=\"549\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/salvatoshi/48/72_2.png\" class=\"avatar\"> salvatoshi:</div>\n<blockquote>\n<p>It only works for cases where the structure of the transaction (that is, \u201cwhat inputs will be spent together\u201d) is known in advance and can be hardcoded in Script.</p>\n</blockquote>\n</aside>\n<p>Why? By \u201cit\u201d I assume you are referring to <code>OP_CCV</code>/<code>OP_VAULT</code>. Is there some security consideration I am missing?</p>\n<aside class=\"quote no-group\" data-username=\"salvatoshi\" data-post=\"6\" data-topic=\"549\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/salvatoshi/48/72_2.png\" class=\"avatar\"> salvatoshi:</div>\n<blockquote>\n<p>You might receive a number of transactions to a vault address, and then at spending time (<em>trigger</em> transaction) you\u2019ll want to select which of the vault UTXOs you want use as part of the withdrawal.</p>\n</blockquote>\n</aside>\n<p>This is tested in the <a href=\"https://delvingbitcoin.org/t/op-inout-amount/549/4\">BIP345</a> case study. I didn\u2019t have this issue you are talking about. Both <a href=\"https://github.com/Christewart/bitcoin/blob/4c6c2ecb59a132eeac43d5608a1a1c081940b0e0/test/functional/feature_vaults.py#L362\" rel=\"noopener nofollow ugc\"><code>test_batch_unvault</code></a>  and <a href=\"https://github.com/Christewart/bitcoin/blob/4c6c2ecb59a132eeac43d5608a1a1c081940b0e0/test/functional/feature_vaults.py#L251\" rel=\"noopener nofollow ugc\"><code>test_batch_recovery</code></a> test cases work with <code>OP_{IN,OUT}_AMOUNT</code>.</p>\n<aside class=\"quote no-group\" data-username=\"salvatoshi\" data-post=\"6\" data-topic=\"549\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/salvatoshi/48/72_2.png\" class=\"avatar\"> salvatoshi:</div>\n<blockquote>\n<p>The number and the position of those UTXOs can\u2019t be known in advance when their script is defined. In order to avoid having to hardcode these bitmaps, you\u2019d need some cross-input logic to somehow make sure that all those inputs are using compatible bitmaps</p>\n</blockquote>\n</aside>\n<p>Yes, that is why they should be provided on the witness stack at spending time rather than when the utxos are created. I modified your <a href=\"https://github.com/Christewart/bitcoin/blob/c83ed810a889e4e69ba8c417ddf4c85c1723f9e5/test/functional/feature_checkcontractverify.py#L232\" rel=\"noopener nofollow ugc\">OP_CCV test code</a> code to do just that.</p>\n<aside class=\"quote no-group\" data-username=\"salvatoshi\" data-post=\"6\" data-topic=\"549\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/salvatoshi/48/72_2.png\" class=\"avatar\"> salvatoshi:</div>\n<blockquote>\n<p>I believe this is in fact the most interesting part of the amount logic of <code>CCV</code> (inspired from <code>VAULT</code> rather than from the original applications of <code>CCV</code> to MATT and fraud proofs).</p>\n</blockquote>\n</aside>\n<p>Admittedly I am confused, as far as I can tell your test framework defines the index parameter for OP_CCV in the output script rather than placing it in the witness when the OP_CCV utxo is spent. Here is a link to the code I am looking at: <a href=\"https://github.com/Merkleize/bitcoin/blob/1fca2689866761ee4cd6629c0f3a0deb0fac72ae/test/functional/feature_checkcontractverify.py#L280\" rel=\"noopener nofollow ugc\">1</a> <a href=\"https://github.com/Merkleize/bitcoin/blob/1fca2689866761ee4cd6629c0f3a0deb0fac72ae/test/functional/feature_checkcontractverify.py#L303\" rel=\"noopener nofollow ugc\">2</a> <a href=\"https://github.com/Merkleize/bitcoin/blob/1fca2689866761ee4cd6629c0f3a0deb0fac72ae/test/functional/feature_checkcontractverify.py#L311\" rel=\"noopener nofollow ugc\">3</a> <a href=\"https://github.com/Merkleize/bitcoin/blob/1fca2689866761ee4cd6629c0f3a0deb0fac72ae/test/functional/feature_checkcontractverify.py#L258\" rel=\"noopener nofollow ugc\">4</a> <a href=\"https://github.com/Merkleize/bitcoin/blob/1fca2689866761ee4cd6629c0f3a0deb0fac72ae/test/functional/feature_checkcontractverify.py#L234\" rel=\"noopener nofollow ugc\">5</a>.</p>\n<p>I understand that both of our proposals are works in progress \u2013 is the the goal to remove the hard coded indices in favor of providing them on the witness stack in your OP_CCV test cases?</p>\n<aside class=\"quote no-group\" data-username=\"salvatoshi\" data-post=\"6\" data-topic=\"549\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/salvatoshi/48/72_2.png\" class=\"avatar\"> salvatoshi:</div>\n<blockquote>\n<p>Assuming that a clean solution to (1) is found, since all the related inputs that are being aggregated need to have a matching bitmap, the trivial implementation would require to report this same bitmap for all the inputs. This has <span class=\"math\">O(n^2)</span> cost both in terms of space occupation and computational cost. While <span class=\"math\">O(n^2)</span> bits and <span class=\"math\">O(n^2)</span> additions might not be a huge deal for many common use cases, it seems rather unsatisfactory to do in <span class=\"math\">O(n^2)</span> cost something that can be done optimally in <span class=\"math\">O(n)</span> cost.</p>\n</blockquote>\n</aside>\n<p>I think this is a fair critique and something I\u2019m going to look into.</p>\n<aside class=\"quote no-group\" data-username=\"salvatoshi\" data-post=\"6\" data-topic=\"549\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/salvatoshi/48/72_2.png\" class=\"avatar\"> salvatoshi:</div>\n<blockquote>\n<p>Without a real, embedded cross-input logic, the only way to achieve the optimal <span class=\"math\">O(n)</span> cost seems to be something like <a href=\"https://brqgoo.medium.com/emulating-op-vault-with-elements-opcodes-bdc7d8b0fe71\" rel=\"noopener nofollow ugc\">this demo from burak</a> <small>(TL;DR: one special input performs all the amount checks, while the other inputs merely check the presence of the special input)</small>, which is not exactly ergonomic.</p>\n</blockquote>\n</aside>\n<p>Thank you for sharing this, I wasn\u2019t aware of this work. I\u2019ll look into it. I\u2019m always interested in alternative designs for amount locks :-).</p>\n<aside class=\"quote no-group\" data-username=\"salvatoshi\" data-post=\"6\" data-topic=\"549\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/salvatoshi/48/72_2.png\" class=\"avatar\"> salvatoshi:</div>\n<blockquote>\n<p>More generally, any covenant opcode that constrains the destination seems to be pointless if the covenant opcode itself doesn\u2019t <em>also</em> enforce the <em>presence</em> of the amount logic,</p>\n</blockquote>\n</aside>\n<p>I think that is right. However I\u2019m not sure the inverse is true. I think amount locks may be useful without destination locks. <a href=\"https://delvingbitcoin.org/t/op-inout-amount/549/3#p-4521-coinjoin-use-case-3\">See my coinjoin example</a>. If privacy is your <span class=\"hashtag-raw\">#1</span> concern, you want to enforce at the Script level that your utxos follow a specific amount pattern \u2013 you can enforce the destinations with digital signatures as coinjoin protocols do today.</p>\n<p>I also think we can make more general purpose primitives to implement amount locks rather than baking them into a single covenant opcode. I like the design of OP_CCV for implementing destination locks from what I\u2019ve learned so far, but I\u2019m not a big fan of the amount lock side of things.</p>\n<aside class=\"quote no-group\" data-username=\"salvatoshi\" data-post=\"6\" data-topic=\"549\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/salvatoshi/48/72_2.png\" class=\"avatar\"> salvatoshi:</div>\n<blockquote>\n<p>I strongly believe that some amount of redundancy is unavoidable for any mechanism that extracts the amount logic out of the covenant opcode.</p>\n</blockquote>\n</aside>\n<p>I\u2019ll think about this more.</p>\n<p>Thank you for the thoughtful reply, you\u2019ve given me a lot to think about. <img src=\"https://delvingbitcoin.org/images/emoji/twitter/slightly_smiling_face.png?v=14\" title=\":slightly_smiling_face:\" class=\"emoji\" alt=\":slightly_smiling_face:\" loading=\"lazy\" width=\"20\" height=\"20\"></p>",
  "post_number": 7,
  "post_type": 1,
  "posts_count": 9,
  "updated_at": "2025-05-08T18:35:01.919Z",
  "reply_count": 1,
  "reply_to_post_number": 6,
  "quote_count": 1,
  "incoming_link_count": 3,
  "reads": 22,
  "readers_count": 21,
  "score": 24.4,
  "yours": false,
  "topic_id": 549,
  "topic_slug": "op-inout-amount",
  "topic_title": "Op_inout_amount",
  "topic_html_title": "Op_inout_amount",
  "category_id": 7,
  "display_username": "Chris Stewart",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"salvatoshi, post:6, topic:549\"]\nIt only works for cases where the structure of the transaction (that is, \u201cwhat inputs will be spent together\u201d) is known in advance and can be hardcoded in Script.\n[/quote]\n\nWhy? By \"it\" I assume you are referring to `OP_CCV`/`OP_VAULT`. Is there some security consideration I am missing?\n\n[quote=\"salvatoshi, post:6, topic:549\"]\nYou might receive a number of transactions to a vault address, and then at spending time (*trigger* transaction) you\u2019ll want to select which of the vault UTXOs you want use as part of the withdrawal.\n[/quote]\n\nThis is tested in the [BIP345](https://delvingbitcoin.org/t/op-inout-amount/549/4?u=chris_stewart_5) case study. I didn't have this issue you are talking about. Both [`test_batch_unvault`](https://github.com/Christewart/bitcoin/blob/4c6c2ecb59a132eeac43d5608a1a1c081940b0e0/test/functional/feature_vaults.py#L362)  and [`test_batch_recovery`](https://github.com/Christewart/bitcoin/blob/4c6c2ecb59a132eeac43d5608a1a1c081940b0e0/test/functional/feature_vaults.py#L251) test cases work with `OP_{IN,OUT}_AMOUNT`.\n\n[quote=\"salvatoshi, post:6, topic:549\"]\nThe number and the position of those UTXOs can\u2019t be known in advance when their script is defined. In order to avoid having to hardcode these bitmaps, you\u2019d need some cross-input logic to somehow make sure that all those inputs are using compatible bitmaps\n[/quote]\n\nYes, that is why they should be provided on the witness stack at spending time rather than when the utxos are created. I modified your [OP_CCV test code](https://github.com/Christewart/bitcoin/blob/c83ed810a889e4e69ba8c417ddf4c85c1723f9e5/test/functional/feature_checkcontractverify.py#L232) code to do just that.\n\n[quote=\"salvatoshi, post:6, topic:549\"]\nI believe this is in fact the most interesting part of the amount logic of `CCV` (inspired from `VAULT` rather than from the original applications of `CCV` to MATT and fraud proofs).\n[/quote]\n\nAdmittedly I am confused, as far as I can tell your test framework defines the index parameter for OP_CCV in the output script rather than placing it in the witness when the OP_CCV utxo is spent. Here is a link to the code I am looking at: [1](https://github.com/Merkleize/bitcoin/blob/1fca2689866761ee4cd6629c0f3a0deb0fac72ae/test/functional/feature_checkcontractverify.py#L280) [2](https://github.com/Merkleize/bitcoin/blob/1fca2689866761ee4cd6629c0f3a0deb0fac72ae/test/functional/feature_checkcontractverify.py#L303) [3](https://github.com/Merkleize/bitcoin/blob/1fca2689866761ee4cd6629c0f3a0deb0fac72ae/test/functional/feature_checkcontractverify.py#L311) [4](https://github.com/Merkleize/bitcoin/blob/1fca2689866761ee4cd6629c0f3a0deb0fac72ae/test/functional/feature_checkcontractverify.py#L258) [5](https://github.com/Merkleize/bitcoin/blob/1fca2689866761ee4cd6629c0f3a0deb0fac72ae/test/functional/feature_checkcontractverify.py#L234). \n\nI understand that both of our proposals are works in progress -- is the the goal to remove the hard coded indices in favor of providing them on the witness stack in your OP_CCV test cases?\n\n[quote=\"salvatoshi, post:6, topic:549\"]\nAssuming that a clean solution to (1) is found, since all the related inputs that are being aggregated need to have a matching bitmap, the trivial implementation would require to report this same bitmap for all the inputs. This has $O(n^2)$ cost both in terms of space occupation and computational cost. While $O(n^2)$ bits and $O(n^2)$ additions might not be a huge deal for many common use cases, it seems rather unsatisfactory to do in $O(n^2)$ cost something that can be done optimally in $O(n)$ cost.\n[/quote]\n\nI think this is a fair critique and something I'm going to look into.\n\n[quote=\"salvatoshi, post:6, topic:549\"]\nWithout a real, embedded cross-input logic, the only way to achieve the optimal $O(n)$ cost seems to be something like [this demo from burak](https://brqgoo.medium.com/emulating-op-vault-with-elements-opcodes-bdc7d8b0fe71) <small>(TL;DR: one special input performs all the amount checks, while the other inputs merely check the presence of the special input)</small>, which is not exactly ergonomic.\n[/quote]\n\nThank you for sharing this, I wasn't aware of this work. I'll look into it. I'm always interested in alternative designs for amount locks :-).\n\n[quote=\"salvatoshi, post:6, topic:549\"]\nMore generally, any covenant opcode that constrains the destination seems to be pointless if the covenant opcode itself doesn\u2019t *also* enforce the *presence* of the amount logic,\n[/quote]\n\nI think that is right. However I'm not sure the inverse is true. I think amount locks may be useful without destination locks. [See my coinjoin example](https://delvingbitcoin.org/t/op-inout-amount/549/3#p-4521-coinjoin-use-case-3). If privacy is your #1 concern, you want to enforce at the Script level that your utxos follow a specific amount pattern -- you can enforce the destinations with digital signatures as coinjoin protocols do today.\n\nI also think we can make more general purpose primitives to implement amount locks rather than baking them into a single covenant opcode. I like the design of OP_CCV for implementing destination locks from what I've learned so far, but I'm not a big fan of the amount lock side of things.\n\n[quote=\"salvatoshi, post:6, topic:549\"]\nI strongly believe that some amount of redundancy is unavoidable for any mechanism that extracts the amount logic out of the covenant opcode.\n[/quote]\n\nI'll think about this more.\n\nThank you for the thoughtful reply, you've given me a lot to think about. :slightly_smiling_face:",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 193,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "Why? By \u201cit\u201d I assume you are referring to OP_CCV/OP_VAULT. Is there some security consideration I am missing? \n\nThis is tested in the <a href=\"https://delvingbitcoin.org/t/op-inout-amount/549/4\">BIP345</a> case study. I didn\u2019t have this issue you are talking about. Both <a href=\"https://github.com/Christewart/bitcoin/blob/4c6c2ecb59a132eeac43d5608a1a1c081940b0e0/test/functional/feature_vaults.py#L362\" rel=\"noopener nofollow ugc\">test_batch_unvault</a>  and <a href=\"https://github.com/Christewart/bitcoin/blob/4c6c2ecb59a132eeac43d5608a1a1c081940b0e0/test/functional/feature_vaults.py#L251\" rel=\"noopener nofollow ugc\">test_batch_recovery</a> test cases work with OP_{IN,OUT}_AMOUNT. \n\nYes, &hellip;",
  "truncated": true,
  "post_url": "/t/op-inout-amount/549/7",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}