{
  "id": 4923,
  "name": "Chris Stewart",
  "username": "Chris_Stewart_5",
  "avatar_template": "/user_avatar/delvingbitcoin.org/chris_stewart_5/{size}/296_2.png",
  "created_at": "2025-05-02T17:32:43.907Z",
  "cooked": "<h1><a name=\"p-4923-case-study-op_vault-1\" class=\"anchor\" href=\"#p-4923-case-study-op_vault-1\"></a>Case study: OP_VAULT</h1>\n<p>This case study explores how Script opcodes can be used to implement <strong>amount locks</strong>\u2014restrictions that ensure the value of inputs and outputs in a transaction meets certain conditions. The goal is to evaluate the required features and developer ergonomics for opcodes that push input and output amounts onto the stack. Rather than starting from scratch, we build on existing opcode proposals and retrofit them to support amount locks directly in Script</p>\n<p>This requires 2 proposals I am working on</p>\n<ol>\n<li><a href=\"https://github.com/Christewart/bips/blob/79257ba5d7a632fa828208f266fd4f5540ffba7f/bip-XXXX.mediawiki\" rel=\"noopener nofollow ugc\">64-bit arithmetic in Script</a></li>\n<li><a href=\"https://delvingbitcoin.org/t/op-inout-amount/549/3\"><code>OP_INOUT_AMOUNT</code></a></li>\n</ol>\n<p><strong>Note:</strong> This study does not attempt to implement <em>destination locks</em>\u2014restrictions on where funds may be sent. That logic is preserved from the original proposal being examined.</p>\n<p><a href=\"https://github.com/Christewart/bitcoin/tree/2025-04-16-covtools-softfork-nochange\" rel=\"noopener nofollow ugc\">Here</a> is a link to the repository that implements everything talked about below - a good place to start reading is the functional test <a href=\"https://github.com/Christewart/bitcoin/blob/4c6c2ecb59a132eeac43d5608a1a1c081940b0e0/test/functional/feature_vaults.py\" rel=\"noopener nofollow ugc\"><code>feature_vaults.py</code></a></p>\n<h2><a name=\"p-4923-bip345-2\" class=\"anchor\" href=\"#p-4923-bip345-2\"></a>BIP345</h2>\n<p><a href=\"https://github.com/bitcoin/bips/blob/3365fb7a7e5e25b95b94d65808e32a02aa684aaa/bip-0345.mediawiki\" rel=\"noopener nofollow ugc\">BIP345</a> proposes a mechanism that enforces a delay before certain coins can be spent to arbitrary destinations\u2014unless they\u2019re redirected along a predefined \u201crecovery\u201d path. At any time before final withdrawal, the funds can be moved to this recovery path.</p>\n<p>The proposal introduces two opcodes\u2014<code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>\u2014that depend on enforcing <strong>two amount locks</strong>. In the original implementation, these were enforced using <a href=\"https://github.com/bitcoin/bips/blob/3365fb7a7e5e25b95b94d65808e32a02aa684aaa/bip-0345.mediawiki#cite_note-7\" rel=\"noopener nofollow ugc\">deferred checks</a>:</p>\n<ol>\n<li><code>trigger_vout_value</code> + <code>revault_vout_value?</code> = sum(<code>funding_vault_outputs</code>)</li>\n<li>sum(<code>vault_recover_outputs</code>) = <code>recov_vout_value</code></li>\n</ol>\n<blockquote>\n<p>Note: In (1), <code>revault_vout_value</code> is optional and may not be present in every case.</p>\n</blockquote>\n<p>This document explores how these amount locks can be enforced directly in Script using <code>OP_INOUT_AMOUNT</code>, eliminating the need for deferred checks for the amount lock portion of <code>OP_VAULT</code>/<code>OP_VAULT_RECOVER</code>.</p>\n<h2><a name=\"p-4923-op_vault-3\" class=\"anchor\" href=\"#p-4923-op_vault-3\"></a>OP_VAULT</h2>\n<p>Here is what the BIP345 stack looks like when evaluating <code>OP_VAULT</code></p>\n<pre><code class=\"lang-auto\">&lt;leaf-update-script-body&gt;\n&lt;push-count&gt;\n[ &lt;push-count&gt; leaf-update script data items ... ]\n&lt;trigger-vout-idx&gt;\n&lt;revault-vout-idx&gt;\n&lt;revault-amount&gt;\n</code></pre>\n<p>We are interested in <code>trigger-vout-idx</code>, <code>revault-vout-idx</code>, and <code>revault-amount</code>. The <code>OP_VAULT</code> opcode checks that the destination lock is satisfied, and the amount lock is satisfied via a combination of <a href=\"https://github.com/jamesob/bitcoin/blob/5e59c074703f0913db7ee004b99d086857d10ad6/src/script/interpreter.cpp#L2159\" rel=\"noopener nofollow ugc\">logic in the opcode implementation itself</a>, and a <a href=\"https://github.com/jamesob/bitcoin/blob/5e59c074703f0913db7ee004b99d086857d10ad6/src/validation.cpp#L1894\" rel=\"noopener nofollow ugc\">deferred check</a> that is run after all inputs are validated in the trigger transaction.</p>\n<h3><a name=\"p-4923-trigger-transactions-amount-lock-logic-in-script-4\" class=\"anchor\" href=\"#p-4923-trigger-transactions-amount-lock-logic-in-script-4\"></a>Trigger Transaction\u2019s Amount Lock Logic in Script</h3>\n<p>Here is what the witness stack looks like when you begin to evaluate in <code>OP_VAULT</code> output in a trigger transaction.</p>\n<pre><code class=\"lang-auto\">&lt;leaf-update-script-body&gt;\n&lt;push-count&gt;\n[ &lt;push-count&gt; leaf-update script data items ... ]\n&lt;trigger-vout-idx&gt;\n&lt;revault-vout-idx&gt;\n&lt;input_indices&gt; # a bitmap for compatible OP_VAULT outputs we are verifying in this transaction\n</code></pre>\n<p>The only new field is <code>input_indices</code> which corresponds to the compatible <code>OP_VAULT</code> outputs that are sending funds to the <code>trigger-vout-idx</code> and <code>revault-vout-idx</code>. This change removes <code>&lt;revault-amount&gt;</code> from the stack as it will be pushed onto the stack by <code>OP_INOUT_AMOUNT</code>. As a side note, I don\u2019t believe <code>revault-amount</code> is required in the original BIP345 proposal as the value can be checked via deferred checks.</p>\n<p>Here is what the corresponding <code>trigger_script</code> looks like to evaluate this stack</p>\n<pre><code class=\"lang-auto\">OP_6,            # Depth of input bitmap on stack\nOP_ROLL,         # Move input bitmap to stack top\nOP_6,            # Depth of revault vout index on stack\nOP_ROLL,         # Move revault vout index to top\nOP_6,            # Depth of trigger vout index on stack\nOP_PICK,         # Copy trigger vout index to top (keep original for OP_VAULT)\nOP_SWAP,         # Bring revault index to top\nOP_DUP,          # Copy revault index (for -1 check)\nOP_1NEGATE,\nOP_EQUAL,        # Check if revault index == -1\n\nOP_IF,           # Case: No revault output present\n  OP_DROP,       # Drop duplicated -1\n\n  # Convert trigger index into bitmap (simulate shift table since we have no OP_LSHIFT)\n  OP_DUP,\n  OP_0,\n  OP_EQUAL,\n  OP_IF,\n    OP_DROP,\n    OP_1,\n  OP_ELSE,\n    OP_DUP,\n    OP_1,\n    OP_EQUAL,\n    OP_IF,\n      OP_DROP,\n      OP_2,\n    OP_ELSE,\n      OP_0,\n      OP_VERIFY,\n    OP_ENDIF,\n  OP_ENDIF,\n\n  # Push amounts: op_vault_input_sum, trigger_vout_value\n  OP_INOUT_AMOUNT,\n  OP_EQUALVERIFY,  # Require: sum(inputs) == trigger output\nOP_ELSE,         # Case: Revault output exists\n  OP_DUP,\n  OP_0,\n  OP_GREATERTHAN,\n  OP_VERIFY,      # Require revault index &gt;= 0\n\n  # Convert revault index into bitmap (since we have no OP_LSHIFT)\n  OP_DUP,\n  OP_0,\n  OP_EQUAL,\n  OP_IF,\n    OP_DROP,\n    OP_1,\n  OP_ELSE,\n    OP_DUP,\n    OP_1,\n    OP_EQUAL,\n    OP_IF,\n      OP_DROP,\n      OP_2,\n    OP_ELSE,\n      OP_0,\n      OP_VERIFY,\n    OP_ENDIF,\n  OP_ENDIF,\n\n  OP_2,           # Depth of input bitmap\n  OP_ROLL,        # Bring input bitmap to top\n  OP_SWAP,        # Reorder: input bitmap, output bitmap\n  OP_INOUT_AMOUNT, # Push amounts: op_vault_input_sum, revault_output_value\n\n  # Prepare trigger output lookup\n  OP_2,\n  OP_ROLL,\n  OP_0,           # Dummy input bitmap\n  OP_SWAP,\n\n  # Convert trigger index into bitmap (since we have no OP_LSHIFT)\n  OP_DUP,\n  OP_0,\n  OP_EQUAL,\n  OP_IF,\n    OP_DROP,\n    OP_1,\n  OP_ELSE,\n    OP_DUP,\n    OP_1,\n    OP_EQUAL,\n    OP_IF,\n      OP_DROP,\n      OP_2,\n    OP_ELSE,\n      OP_0,\n      OP_VERIFY,\n    OP_ENDIF,\n  OP_ENDIF,\n\n  OP_INOUT_AMOUNT, # Push trigger output amount\n  OP_SWAP,\n  OP_DROP,         # Drop dummy input amount\n  OP_ADD,          # total_outputs = trigger + revault\n  OP_EQUALVERIFY,  # Require: sum(inputs) == total_outputs\nOP_ENDIF,\n\nOP_VAULT          # Final vault check\n</code></pre>\n<p>This Script checks this invariant using only Script</p>\n<blockquote>\n<ol>\n<li><code>trigger_vout_value</code> + <code>revault_vout_value?</code> = sum(<code>funding_vault_outputs</code>)</li>\n</ol>\n</blockquote>\n<p><a href=\"https://github.com/Christewart/bitcoin/blob/4c6c2ecb59a132eeac43d5608a1a1c081940b0e0/src/script/interpreter.cpp#L1427\" rel=\"noopener nofollow ugc\">Small modifications were made to the OP_VAULT implementation</a>. Namely the <code>OP_VAULT</code> opcode no longer consumes these stack arguments because the logic is implemented in Script</p>\n<ol>\n<li><code>revault_vout_idx</code></li>\n<li><code>revault_amount</code></li>\n</ol>\n<p><code>revault_amount</code> is removed all together, and <code>revault_vout_idx</code> is used by <code>OP_INOUT_AMOUNT</code> rather than <code>OP_VAULT</code>.</p>\n<h2><a name=\"p-4923-op_vault_recover-5\" class=\"anchor\" href=\"#p-4923-op_vault_recover-5\"></a>OP_VAULT_RECOVER</h2>\n<p><code>OP_VAULT_RECOVER</code> is an opcode that allows a user to recover a vaulted amount from a trigger transaction. This output can be spent at any time before the withdrawal transaction becomes confirmed on the bitcoin network.</p>\n<p>Here is what the witness stack looks like for <code>OP_VAULT_RECOVER</code> in BIP345.</p>\n<pre><code class=\"lang-auto\">&lt;recovery-sPK-hash&gt;\n&lt;recovery-vout-idx&gt;\n</code></pre>\n<p>We are interested in <code>recovery_vout_idx</code>. This index represents the output that the recovered funds are sent to in the recovery transaction.</p>\n<p>We need all inputs that spend an <code>OP_VAULT_RECOVER</code> to sum to the output value at the <code>recover_vout_idx</code>. The original implementation in BIP345 uses deferred checks to enforce this invariant - we are going to show how <code>OP_INOUT_AMOUNT</code> could be used to replace the deferred check.</p>\n<h3><a name=\"p-4923-recovery-transactions-amount-lock-logic-in-script-6\" class=\"anchor\" href=\"#p-4923-recovery-transactions-amount-lock-logic-in-script-6\"></a>Recovery Transaction\u2019s Amount Lock Logic in Script</h3>\n<p>This is what the <code>recovery_script</code> looks like to implement the amount lock on the recovery transaction.</p>\n<pre><code class=\"lang-auto\">OP_DUP,           # Duplicate recovery_output_idx for lookup\n\n# Simulate a left shift for recovery_output_idx using a lookup table since OP_LSHIFT isn't available\nOP_0,\nOP_EQUAL,\nOP_IF,\n  OP_1,\nOP_ELSE,\n  OP_DUP,\n  OP_1,\n  OP_EQUAL,\n  OP_IF,\n    OP_2,\n  OP_ELSE,\n    OP_DUP,\n    OP_2,\n    OP_EQUAL,\n    OP_IF,\n      OP_4,\n    OP_ELSE,\n      OP_DUP,\n      OP_3,\n      OP_EQUAL,\n      OP_IF,\n        OP_8,\n      OP_ELSE,\n        OP_DUP,\n        OP_5,\n        OP_EQUAL,\n        OP_IF,\n          CScriptNum(32),\n        OP_ELSE,\n          OP_DUP,\n          OP_1NEGATE,\n          OP_EQUAL,\n          OP_IF,\n            OP_1NEGATE,\n          OP_ELSE,\n            OP_0,\n            OP_VERIFY,\n          OP_ENDIF,\n        OP_ENDIF,\n      OP_ENDIF,\n    OP_ENDIF,\n  OP_ENDIF,\nOP_ENDIF,\n\nOP_2,             # Stack depth of trigger_input_indices\nOP_ROLL,          # Move input bitmap to stack top\nOP_SWAP,          # Reorder: input_bitmap, output_bitmap\nOP_INOUT_AMOUNT,  # Push input_sum and recovery_output_value\nOP_EQUALVERIFY,   # Ensure: sum(trigger_inputs) == recovery_output_value\n\nself.recovery_hash,\nOP_VAULT_RECOVER\n</code></pre>\n<p>If you are remove the shift table, the Script is relatively compact to enforce the recovery output\u2019s amount lock.</p>\n<h2><a name=\"p-4923-learnings-7\" class=\"anchor\" href=\"#p-4923-learnings-7\"></a>Learnings</h2>\n<ol>\n<li>Any index based opcodes require shift operators to be have nice developer ergonomics in Script. Most of the Script I\u2019ve written for BIP345\u2019s logic comes down to writing a table to figure out what the appropriate input/output indice we are checking.</li>\n<li>Segregating <code>OP_INOUT_AMOUNT</code> into 2 opcodes - <code>OP_IN_AMOUNT</code> and <code>OP_OUT_AMOUNT</code> would reduce the amount of stack manipulation that needs to be done with <code>OP_PICK</code>/<code>OP_ROLL</code>.</li>\n</ol>",
  "post_number": 4,
  "post_type": 1,
  "posts_count": 9,
  "updated_at": "2025-05-02T17:37:51.549Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 407,
  "reads": 37,
  "readers_count": 36,
  "score": 2047.4,
  "yours": false,
  "topic_id": 549,
  "topic_slug": "op-inout-amount",
  "topic_title": "Op_inout_amount",
  "topic_html_title": "Op_inout_amount",
  "category_id": 7,
  "display_username": "Chris Stewart",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "# Case study: OP_VAULT\n\n\nThis case study explores how Script opcodes can be used to implement **amount locks**\u2014restrictions that ensure the value of inputs and outputs in a transaction meets certain conditions. The goal is to evaluate the required features and developer ergonomics for opcodes that push input and output amounts onto the stack. Rather than starting from scratch, we build on existing opcode proposals and retrofit them to support amount locks directly in Script\n\nThis requires 2 proposals I am working on\n\n1. [64-bit arithmetic in Script](https://github.com/Christewart/bips/blob/79257ba5d7a632fa828208f266fd4f5540ffba7f/bip-XXXX.mediawiki)\n2. [`OP_INOUT_AMOUNT`](https://delvingbitcoin.org/t/op-inout-amount/549/3?u=chris_stewart_5)\n\n**Note:** This study does not attempt to implement _destination locks_\u2014restrictions on where funds may be sent. That logic is preserved from the original proposal being examined.\n\n[Here](https://github.com/Christewart/bitcoin/tree/2025-04-16-covtools-softfork-nochange) is a link to the repository that implements everything talked about below - a good place to start reading is the functional test [`feature_vaults.py`](https://github.com/Christewart/bitcoin/blob/4c6c2ecb59a132eeac43d5608a1a1c081940b0e0/test/functional/feature_vaults.py)\n\n## BIP345\n[BIP345](https://github.com/bitcoin/bips/blob/3365fb7a7e5e25b95b94d65808e32a02aa684aaa/bip-0345.mediawiki) proposes a mechanism that enforces a delay before certain coins can be spent to arbitrary destinations\u2014unless they're redirected along a predefined \"recovery\" path. At any time before final withdrawal, the funds can be moved to this recovery path.\n\nThe proposal introduces two opcodes\u2014`OP_VAULT` and `OP_VAULT_RECOVER`\u2014that depend on enforcing **two amount locks**. In the original implementation, these were enforced using [deferred checks](https://github.com/bitcoin/bips/blob/3365fb7a7e5e25b95b94d65808e32a02aa684aaa/bip-0345.mediawiki#cite_note-7):\n\n1. `trigger_vout_value` + `revault_vout_value?` = sum(`funding_vault_outputs`)  \n2. sum(`vault_recover_outputs`) = `recov_vout_value`\n\n> Note: In (1), `revault_vout_value` is optional and may not be present in every case.\n\nThis document explores how these amount locks can be enforced directly in Script using `OP_INOUT_AMOUNT`, eliminating the need for deferred checks for the amount lock portion of `OP_VAULT`/`OP_VAULT_RECOVER`.\n\n\n## OP_VAULT\n\nHere is what the BIP345 stack looks like when evaluating `OP_VAULT`\n```\n<leaf-update-script-body>\n<push-count>\n[ <push-count> leaf-update script data items ... ]\n<trigger-vout-idx>\n<revault-vout-idx>\n<revault-amount>\n```\n\nWe are interested in `trigger-vout-idx`, `revault-vout-idx`, and `revault-amount`. The `OP_VAULT` opcode checks that the destination lock is satisfied, and the amount lock is satisfied via a combination of [logic in the opcode implementation itself](https://github.com/jamesob/bitcoin/blob/5e59c074703f0913db7ee004b99d086857d10ad6/src/script/interpreter.cpp#L2159), and a [deferred check](https://github.com/jamesob/bitcoin/blob/5e59c074703f0913db7ee004b99d086857d10ad6/src/validation.cpp#L1894) that is run after all inputs are validated in the trigger transaction.\n\n### Trigger Transaction's Amount Lock Logic in Script\n\nHere is what the witness stack looks like when you begin to evaluate in `OP_VAULT` output in a trigger transaction.\n\n```\n<leaf-update-script-body>\n<push-count>\n[ <push-count> leaf-update script data items ... ]\n<trigger-vout-idx>\n<revault-vout-idx>\n<input_indices> # a bitmap for compatible OP_VAULT outputs we are verifying in this transaction\n```\n\nThe only new field is `input_indices` which corresponds to the compatible `OP_VAULT` outputs that are sending funds to the `trigger-vout-idx` and `revault-vout-idx`. This change removes `<revault-amount>` from the stack as it will be pushed onto the stack by `OP_INOUT_AMOUNT`. As a side note, I don't believe `revault-amount` is required in the original BIP345 proposal as the value can be checked via deferred checks.\n\nHere is what the corresponding `trigger_script` looks like to evaluate this stack\n\n```\nOP_6,            # Depth of input bitmap on stack\nOP_ROLL,         # Move input bitmap to stack top\nOP_6,            # Depth of revault vout index on stack\nOP_ROLL,         # Move revault vout index to top\nOP_6,            # Depth of trigger vout index on stack\nOP_PICK,         # Copy trigger vout index to top (keep original for OP_VAULT)\nOP_SWAP,         # Bring revault index to top\nOP_DUP,          # Copy revault index (for -1 check)\nOP_1NEGATE,\nOP_EQUAL,        # Check if revault index == -1\n\nOP_IF,           # Case: No revault output present\n  OP_DROP,       # Drop duplicated -1\n\n  # Convert trigger index into bitmap (simulate shift table since we have no OP_LSHIFT)\n  OP_DUP,\n  OP_0,\n  OP_EQUAL,\n  OP_IF,\n    OP_DROP,\n    OP_1,\n  OP_ELSE,\n    OP_DUP,\n    OP_1,\n    OP_EQUAL,\n    OP_IF,\n      OP_DROP,\n      OP_2,\n    OP_ELSE,\n      OP_0,\n      OP_VERIFY,\n    OP_ENDIF,\n  OP_ENDIF,\n\n  # Push amounts: op_vault_input_sum, trigger_vout_value\n  OP_INOUT_AMOUNT,\n  OP_EQUALVERIFY,  # Require: sum(inputs) == trigger output\nOP_ELSE,         # Case: Revault output exists\n  OP_DUP,\n  OP_0,\n  OP_GREATERTHAN,\n  OP_VERIFY,      # Require revault index >= 0\n\n  # Convert revault index into bitmap (since we have no OP_LSHIFT)\n  OP_DUP,\n  OP_0,\n  OP_EQUAL,\n  OP_IF,\n    OP_DROP,\n    OP_1,\n  OP_ELSE,\n    OP_DUP,\n    OP_1,\n    OP_EQUAL,\n    OP_IF,\n      OP_DROP,\n      OP_2,\n    OP_ELSE,\n      OP_0,\n      OP_VERIFY,\n    OP_ENDIF,\n  OP_ENDIF,\n\n  OP_2,           # Depth of input bitmap\n  OP_ROLL,        # Bring input bitmap to top\n  OP_SWAP,        # Reorder: input bitmap, output bitmap\n  OP_INOUT_AMOUNT, # Push amounts: op_vault_input_sum, revault_output_value\n\n  # Prepare trigger output lookup\n  OP_2,\n  OP_ROLL,\n  OP_0,           # Dummy input bitmap\n  OP_SWAP,\n\n  # Convert trigger index into bitmap (since we have no OP_LSHIFT)\n  OP_DUP,\n  OP_0,\n  OP_EQUAL,\n  OP_IF,\n    OP_DROP,\n    OP_1,\n  OP_ELSE,\n    OP_DUP,\n    OP_1,\n    OP_EQUAL,\n    OP_IF,\n      OP_DROP,\n      OP_2,\n    OP_ELSE,\n      OP_0,\n      OP_VERIFY,\n    OP_ENDIF,\n  OP_ENDIF,\n\n  OP_INOUT_AMOUNT, # Push trigger output amount\n  OP_SWAP,\n  OP_DROP,         # Drop dummy input amount\n  OP_ADD,          # total_outputs = trigger + revault\n  OP_EQUALVERIFY,  # Require: sum(inputs) == total_outputs\nOP_ENDIF,\n\nOP_VAULT          # Final vault check\n```\n\nThis Script checks this invariant using only Script\n\n>1. `trigger_vout_value` + `revault_vout_value?` = sum(`funding_vault_outputs`)\n\n[Small modifications were made to the OP_VAULT implementation](https://github.com/Christewart/bitcoin/blob/4c6c2ecb59a132eeac43d5608a1a1c081940b0e0/src/script/interpreter.cpp#L1427). Namely the `OP_VAULT` opcode no longer consumes these stack arguments because the logic is implemented in Script\n\n1. `revault_vout_idx`\n2. `revault_amount`\n\n`revault_amount` is removed all together, and `revault_vout_idx` is used by `OP_INOUT_AMOUNT` rather than `OP_VAULT`. \n\n## OP_VAULT_RECOVER\n\n`OP_VAULT_RECOVER` is an opcode that allows a user to recover a vaulted amount from a trigger transaction. This output can be spent at any time before the withdrawal transaction becomes confirmed on the bitcoin network.\n\nHere is what the witness stack looks like for `OP_VAULT_RECOVER` in BIP345.\n\n```\n<recovery-sPK-hash>\n<recovery-vout-idx>\n```\n\nWe are interested in `recovery_vout_idx`. This index represents the output that the recovered funds are sent to in the recovery transaction.\n\nWe need all inputs that spend an `OP_VAULT_RECOVER` to sum to the output value at the `recover_vout_idx`. The original implementation in BIP345 uses deferred checks to enforce this invariant - we are going to show how `OP_INOUT_AMOUNT` could be used to replace the deferred check.\n\n### Recovery Transaction's Amount Lock Logic in Script\n\nThis is what the `recovery_script` looks like to implement the amount lock on the recovery transaction. \n\n```\nOP_DUP,           # Duplicate recovery_output_idx for lookup\n\n# Simulate a left shift for recovery_output_idx using a lookup table since OP_LSHIFT isn't available\nOP_0,\nOP_EQUAL,\nOP_IF,\n  OP_1,\nOP_ELSE,\n  OP_DUP,\n  OP_1,\n  OP_EQUAL,\n  OP_IF,\n    OP_2,\n  OP_ELSE,\n    OP_DUP,\n    OP_2,\n    OP_EQUAL,\n    OP_IF,\n      OP_4,\n    OP_ELSE,\n      OP_DUP,\n      OP_3,\n      OP_EQUAL,\n      OP_IF,\n        OP_8,\n      OP_ELSE,\n        OP_DUP,\n        OP_5,\n        OP_EQUAL,\n        OP_IF,\n          CScriptNum(32),\n        OP_ELSE,\n          OP_DUP,\n          OP_1NEGATE,\n          OP_EQUAL,\n          OP_IF,\n            OP_1NEGATE,\n          OP_ELSE,\n            OP_0,\n            OP_VERIFY,\n          OP_ENDIF,\n        OP_ENDIF,\n      OP_ENDIF,\n    OP_ENDIF,\n  OP_ENDIF,\nOP_ENDIF,\n\nOP_2,             # Stack depth of trigger_input_indices\nOP_ROLL,          # Move input bitmap to stack top\nOP_SWAP,          # Reorder: input_bitmap, output_bitmap\nOP_INOUT_AMOUNT,  # Push input_sum and recovery_output_value\nOP_EQUALVERIFY,   # Ensure: sum(trigger_inputs) == recovery_output_value\n\nself.recovery_hash,\nOP_VAULT_RECOVER\n```\n\nIf you are remove the shift table, the Script is relatively compact to enforce the recovery output's amount lock.\n\n\n## Learnings\n\n1. Any index based opcodes require shift operators to be have nice developer ergonomics in Script. Most of the Script I've written for BIP345's logic comes down to writing a table to figure out what the appropriate input/output indice we are checking.\n2. Segregating `OP_INOUT_AMOUNT` into 2 opcodes - `OP_IN_AMOUNT` and `OP_OUT_AMOUNT` would reduce the amount of stack manipulation that needs to be done with `OP_PICK`/`OP_ROLL`.",
  "actions_summary": [
    {
      "id": 2,
      "count": 2
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 193,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": "Github link was replaced with a permanent link",
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "<a name=\"p-4923-case-study-op_vault-1\" class=\"anchor\" href=\"#p-4923-case-study-op_vault-1\"></a>Case study: OP_VAULT\nThis case study explores how Script opcodes can be used to implement amount locks\u2014restrictions that ensure the value of inputs and outputs in a transaction meets certain conditions. The goal is to evaluate the required features and developer ergonomics for opcodes that push inpu&hellip;",
  "truncated": true,
  "post_url": "/t/op-inout-amount/549/4",
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    },
    {
      "id": "heart",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 2,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}