{
  "id": 5108,
  "name": "Pieter Wuille",
  "username": "sipa",
  "avatar_template": "/user_avatar/delvingbitcoin.org/sipa/{size}/1100_2.png",
  "created_at": "2025-05-23T18:19:12.734Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"sipa\" data-post=\"3\" data-topic=\"1419\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/sipa/48/1100_2.png\" class=\"avatar\"> sipa:</div>\n<blockquote>\n<p>The result of this is that the chunks that come out may be contain multiple equal-feerate components that could be split in a topologically-valid manner, i.e., become separate equal-feerate chunks. It would be nice to find an algorithm that can efficiently find these, whether that\u2019s done as part of SFL, or as a separate post-processing step.</p>\n</blockquote>\n</aside>\n<p>Solved!</p>\n<p>The idea is that equal-feerate chunks can be split using the existing algorithm, by perturbing the transaction feerates slightly. If we pick an arbitrary transaction in a chunk, and:</p>\n<ul>\n<li>give it an infinitesimally <strong>higher</strong> feerate than it really has, then if a way to split the chunk exists such that this transaction is in the <strong>top</strong> part, it will be found using the normal split/merge algorithm</li>\n<li>give a transaction an infinitesimally <strong>smaller</strong> feerate than it really has, then if a way to split the chunk exists such that this transaction is in the bottom part, it will be found using the normal split/merge algorithm.</li>\n</ul>\n<p>If we try both the infinitesimally-higher and infinitesimally-smaller approaches for the same transaction, then if a split exists it must be found, as this transaction must appear in either the top or the bottom of the split.</p>\n<p>We do not actually need to modify the transaction feerates to implement this. Instead, for increased feerate we can look for <span class=\"math\">q=0</span> dependencies where the modified transaction is in the top part, as <span class=\"math\">q(a \\cup \\epsilon, b) = q(a,b) + q(\\epsilon,b) = q(\\epsilon,b) &gt; 0</span>, where <span class=\"math\">\\epsilon</span> is an imaginary transaction with very high feerate, but infinitesimal size. Similarly, for decreased feerate we can look for <span class=\"math\">q=0</span> dependencies with the modified transaction in the bottom. If the chunks are already optimal otherwise, the resulting split components cannot merge with any other chunk, so we only need to attempt self-merges, and do not need a full merge sequence.</p>\n<p>More concretely, given a chunk:</p>\n<ul>\n<li>Pick an arbitrary transaction <span class=\"math\">t</span> in it.</li>\n<li>Loop, trying to split the chunk with <span class=\"math\">t</span> in the top set:\n<ul>\n<li>Find an active dependency <span class=\"math\">d_1</span> in it with <span class=\"math\">q \\geq 0</span> (but note that <span class=\"math\">q &gt; 0</span> is not possible anymore if the normal optimization process has finished), and which has <span class=\"math\">t</span> in its <strong>top</strong> set. If no such dependency is found, stop.</li>\n<li>Deactivate <span class=\"math\">d_1</span>.</li>\n<li>Find an inactive dependency <span class=\"math\">d_2</span> whose child is in <span class=\"math\">d_1</span>'s top and whose parent is in <span class=\"math\">d_2</span>'s bottom. If none can be found, recurse into minimizing the created top and bottom chunk.</li>\n<li>Activate <span class=\"math\">d_2</span>.</li>\n</ul>\n</li>\n<li>Loop, trying to split the chunk with <span class=\"math\">t</span> in the bottom set:\n<ul>\n<li>Find an active dependency <span class=\"math\">d_1</span> in it with <span class=\"math\">q \\geq 0</span> (but note that <span class=\"math\">q &gt; 0</span> is not possible anymore if the normal optimization process has finished), and which has <span class=\"math\">t</span> in its <strong>bottom</strong> set. If no such dependency is found, stop.</li>\n<li>Deactivate <span class=\"math\">d_1</span>.</li>\n<li>Find an inactive dependency <span class=\"math\">d_2</span> whose child is in <span class=\"math\">d_1</span>'s top and whose parent is in <span class=\"math\">d_2</span>'s bottom. If none can be found, recurse into minimizing the created top and bottom chunk.</li>\n<li>Activate <span class=\"math\">d_2</span>.</li>\n</ul>\n</li>\n</ul>\n<p>I have implemented this in the <a href=\"https://github.com/bitcoin/bitcoin/pull/32545\">Bitcoin Core PR</a> for adding SFL.</p>\n<p>When running this on the replayed 2023 data, it appears that out of 24693846 clusters with 2 or more transactions, 136709 of them (0.55%) gain one or more chunks by running this chunk minimization procedure (at least for some random seeds), adding on average 1.58 chunks per affected cluster, or 0.0087 chunks per cluster over the whole dataset.</p>",
  "post_number": 9,
  "post_type": 1,
  "posts_count": 9,
  "updated_at": "2025-05-24T19:37:28.923Z",
  "reply_count": 0,
  "reply_to_post_number": 3,
  "quote_count": 1,
  "incoming_link_count": 2,
  "reads": 20,
  "readers_count": 19,
  "score": 14.0,
  "yours": false,
  "topic_id": 1419,
  "topic_slug": "spanning-forest-cluster-linearization",
  "topic_title": "Spanning-forest cluster linearization",
  "topic_html_title": "Spanning-forest cluster linearization",
  "category_id": 8,
  "display_username": "Pieter Wuille",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 7,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"sipa, post:3, topic:1419\"]\nThe result of this is that the chunks that come out may be contain multiple equal-feerate components that could be split in a topologically-valid manner, i.e., become separate equal-feerate chunks. It would be nice to find an algorithm that can efficiently find these, whether that\u2019s done as part of SFL, or as a separate post-processing step.\n[/quote]\n\nSolved!\n\nThe idea is that equal-feerate chunks can be split using the existing algorithm, by perturbing the transaction feerates slightly. If we pick an arbitrary transaction in a chunk, and:\n* give it an infinitesimally **higher** feerate than it really has, then if a way to split the chunk exists such that this transaction is in the **top** part, it will be found using the normal split/merge algorithm\n* give a transaction an infinitesimally **smaller** feerate than it really has, then if a way to split the chunk exists such that this transaction is in the bottom part, it will be found using the normal split/merge algorithm.\n\nIf we try both the infinitesimally-higher and infinitesimally-smaller approaches for the same transaction, then if a split exists it must be found, as this transaction must appear in either the top or the bottom of the split.\n\nWe do not actually need to modify the transaction feerates to implement this. Instead, for increased feerate we can look for $q=0$ dependencies where the modified transaction is in the top part, as $q(a \\cup \\epsilon, b) = q(a,b) + q(\\epsilon,b) = q(\\epsilon,b) > 0$, where $\\epsilon$ is an imaginary transaction with very high feerate, but infinitesimal size. Similarly, for decreased feerate we can look for $q=0$ dependencies with the modified transaction in the bottom. If the chunks are already optimal otherwise, the resulting split components cannot merge with any other chunk, so we only need to attempt self-merges, and do not need a full merge sequence.\n\nMore concretely, given a chunk:\n* Pick an arbitrary transaction $t$ in it.\n* Loop, trying to split the chunk with $t$ in the top set:\n  * Find an active dependency $d_1$ in it with $q \\geq 0$ (but note that $q > 0$ is not possible anymore if the normal optimization process has finished), and which has $t$ in its **top** set. If no such dependency is found, stop.\n  * Deactivate $d_1$.\n  * Find an inactive dependency $d_2$ whose child is in $d_1$'s top and whose parent is in $d_2$'s bottom. If none can be found, recurse into minimizing the created top and bottom chunk.\n  * Activate $d_2$.\n* Loop, trying to split the chunk with $t$ in the bottom set:\n  * Find an active dependency $d_1$ in it with $q \\geq 0$ (but note that $q > 0$ is not possible anymore if the normal optimization process has finished), and which has $t$ in its **bottom** set. If no such dependency is found, stop.\n  * Deactivate $d_1$.\n  * Find an inactive dependency $d_2$ whose child is in $d_1$'s top and whose parent is in $d_2$'s bottom. If none can be found, recurse into minimizing the created top and bottom chunk.\n  * Activate $d_2$.\n\nI have implemented this in the [Bitcoin Core PR](https://github.com/bitcoin/bitcoin/pull/32545) for adding SFL.\n\nWhen running this on the replayed 2023 data, it appears that out of 24693846 clusters with 2 or more transactions, 136709 of them (0.55%) gain one or more chunks by running this chunk minimization procedure (at least for some random seeds), adding on average 1.58 chunks per affected cluster, or 0.0087 chunks per cluster over the whole dataset.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 96,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "Solved! \nThe idea is that equal-feerate chunks can be split using the existing algorithm, by perturbing the transaction feerates slightly. If we pick an arbitrary transaction in a chunk, and: \n\ngive it an infinitesimally higher feerate than it really has, then if a way to split the chunk exists suc&hellip;",
  "truncated": true,
  "post_url": "/t/spanning-forest-cluster-linearization/1419/9",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}