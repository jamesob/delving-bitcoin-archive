{
  "id": 3969,
  "name": "Anthony Towns",
  "username": "ajtowns",
  "avatar_template": "/user_avatar/delvingbitcoin.org/ajtowns/{size}/417_2.png",
  "created_at": "2025-01-05T02:52:14.630Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"instagibbs\" data-post=\"1\" data-topic=\"1353\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/instagibbs/48/28_2.png\" class=\"avatar\"> instagibbs:</div>\n<blockquote>\n<p>With Chia\u2019s coinid, I think this gets pretty simple, but is still linear in update history:</p>\n</blockquote>\n</aside>\n<p>The Chia coinid also allows a mind-bending approach whose proof size is independent of update history (which is used in their NFT schemes), called a <a href=\"https://chialisp.com/singletons/\">singleton</a>.</p>\n<p>I believe the way it works is you identify a coin X as holding the singleton S provided by saying:</p>\n<ul>\n<li>parent_coin_id = A (extract from coin\u2019s coin id; ~40B)</li>\n<li>parent\u2019s puzzle = B (extract from parent_coin_id; ~40B)</li>\n<li>B = singleton_puzzle(singleton_id for S)  (same puzzle as self, so ~0B)</li>\n</ul>\n<p>Because the parent coin is already mined, you know the singleton_puzzle was satisfied, and the only way the singleton puzzle was satisfied is either recursively, or if the grantparent coin launched the singleton.</p>\n<p>(I might have some details wrong there, but I\u2019m pretty sure the gist is right)</p>",
  "post_number": 7,
  "post_type": 1,
  "posts_count": 17,
  "updated_at": "2025-01-05T02:52:14.630Z",
  "reply_count": 1,
  "reply_to_post_number": null,
  "quote_count": 1,
  "incoming_link_count": 41,
  "reads": 36,
  "readers_count": 35,
  "score": 232.2,
  "yours": false,
  "topic_id": 1353,
  "topic_slug": "contract-level-relative-timelocks-or-lets-talk-about-ancestry-proofs-and-singletons",
  "topic_title": "Contract-level Relative Timelocks (or, let's talk about ancestry proofs and singletons)",
  "topic_html_title": "Contract-level Relative Timelocks (or, let&rsquo;s talk about ancestry proofs and singletons)",
  "category_id": 7,
  "display_username": "Anthony Towns",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"instagibbs, post:1, topic:1353\"]\nWith Chia\u2019s coinid, I think this gets pretty simple, but is still linear in update history:\n[/quote]\n\nThe Chia coinid also allows a mind-bending approach whose proof size is independent of update history (which is used in their NFT schemes), called a [singleton](https://chialisp.com/singletons/).\n\nI believe the way it works is you identify a coin X as holding the singleton S provided by saying:\n\n   * parent_coin_id = A (extract from coin's coin id; ~40B)\n   * parent's puzzle = B (extract from parent_coin_id; ~40B)\n   * B = singleton_puzzle(singleton_id for S)  (same puzzle as self, so ~0B) \n\nBecause the parent coin is already mined, you know the singleton_puzzle was satisfied, and the only way the singleton puzzle was satisfied is either recursively, or if the grantparent coin launched the singleton.\n\n(I might have some details wrong there, but I'm pretty sure the gist is right)",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": true,
  "admin": true,
  "staff": true,
  "user_id": 3,
  "hidden": false,
  "trust_level": 4,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "The Chia coinid also allows a mind-bending approach whose proof size is independent of update history (which is used in their NFT schemes), called a <a href=\"https://chialisp.com/singletons/\">singleton</a>. \nI believe the way it works is you identify a coin X as holding the singleton S provided by saying: \n\nparent_coin_id = A (extract from coin&hellip;",
  "truncated": true,
  "post_url": "/t/contract-level-relative-timelocks-or-lets-talk-about-ancestry-proofs-and-singletons/1353/7",
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}