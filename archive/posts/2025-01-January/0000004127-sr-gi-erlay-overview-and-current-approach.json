{
  "id": 4127,
  "name": "Sergi Delgado",
  "username": "sr-gi",
  "avatar_template": "/user_avatar/delvingbitcoin.org/sr-gi/{size}/117_2.png",
  "created_at": "2025-01-31T20:20:15.919Z",
  "cooked": "<p>Earlier last year I started working on a second attempt to implement Erlay into Bitcoin Core, a process that started from convincing myself that the theoretical improvements were achievable in practice, followed by a research-oriented approach where multiple protocol choices need to be simulated and that will hopefully conclude with a well though implementation that satisfies the original goals.</p>\n<p>After several months of working alongside other Bitcoin Core developers (teaming up to create an Erlay working group), endless conversations, and hours of simulations (after implementing a <a href=\"https://delvingbitcoin.org/t/hyperion-a-discrete-time-network-event-simulator-for-bitcoin-core\">discrete time simulator for the matter</a>). I\u2019m happy to start reporting the current state of the project, especially for those of you who may be curious by not directly involved in it.</p>\n<p>This initial post will cover an overview of Erlay, alongside the current implementation approach, thought process, and some open questions.</p>\n<p>Future posts will contain some of the experiments we have been performing to answer those questions. Bear in mind Erlay is still in active development so some of the questions may still have no satisfactory answer.</p>\n<p>Any errors found within this write-up, or any of its follow-ups, are my own.</p>\n<h1><a name=\"p-4127-erlay-1\" class=\"anchor\" href=\"#p-4127-erlay-1\"></a>Erlay</h1>\n<h2><a name=\"p-4127-overview-2\" class=\"anchor\" href=\"#p-4127-overview-2\"></a>Overview</h2>\n<p>Erlay is an alternative method of announcing transactions between peers in the Bitcoin P2P network. Erlay\u2019s main goal is to reduce bandwidth utilization when propagating transaction data.</p>\n<p>The protocol builds on the assumption that a significant percentage of the data exchanged between peers when broadcasting transactions belongs to <strong>inventory</strong> (or <code>INV</code>) <strong>messages</strong> <sup class=\"footnote-ref\"><a href=\"#footnote-4127-1\" id=\"footnote-ref-4127-1\">[1]</a></sup>, which are used to announce the transaction hashes between peers. On receiving an <code>INV</code> message containing a collection of transactions, a well-behaved peer will respond with a message requesting all its missing transactions, this is known as a <strong>getdata message</strong> (or <code>GETDATA</code>).</p>\n<p>Erlay tries to solve this issue by using set reconciliation to work out the transaction differences between two nodes connected to each other instead of just announcing all transactions through all links. To do so, nodes keep a set of transactions to be reconciled (or <strong>reconciliation set</strong>) between each of their Erlay-enabled peers, and reconciliation is performed at regular intervals. Once it is time to reconcile, peers exchange <strong>sketches</strong> <sup class=\"footnote-ref\"><a href=\"#footnote-4127-2\" id=\"footnote-ref-4127-2\">[2]</a></sup> of their reconciliation sets, which can be used to optimally compute the symmetrical difference between their <strong>reconciliation sets</strong> and, therefore, identify which transactions need to be sent by each end of the connection.</p>\n<p>Therefore, Erlay aims to reduce traditional transaction relay (called <strong>fanout</strong> from now on) as much as possible but, maybe counterintuitively, not to completely replace it. For Erlay to be optimal, a small amount of <strong>fanout</strong> is still needed, given set reconciliation works best (sketches are smaller and sketch differences are cheaper to compute) when the differences between sets are small. This means that, even if all peers of a given node are Erlay enabled, some transactions will still be exchanged using <strong>fanout</strong><sup class=\"footnote-ref\"><a href=\"#footnote-4127-3\" id=\"footnote-ref-4127-3\">[3]</a></sup>. Moreover, fanout is more efficient, and considerably faster, than set reconciliation provided the receiving node <strong>does not know about</strong> the transaction being announced.</p>\n<h2><a name=\"p-4127-approach-3\" class=\"anchor\" href=\"#p-4127-approach-3\"></a>Approach</h2>\n<p>One of the first details to decide on, when implementing Erlay, is how small we want the network transaction <strong>fanout</strong> to be. That is, for each Erlay node, how many peers should it select to exchange transactions using fanout. This is a tradeoff between <strong>bandwidth efficiency</strong> and transaction <strong>propagation latency</strong>: the bigger the fanout, the more initial fast coverage of the network, but the less bandwidth savings. If the fanout rate is too low, we could incur drastically slower transaction propagation times, if it is too big, the bandwidth saving would be too small (maybe even not worth the additional code complexity of implementing Erlay). Furthermore, what kind of nodes are selected also matters: in Bitcoin Core, inbound connections are not trusted <sup class=\"footnote-ref\"><a href=\"#footnote-4127-4\" id=\"footnote-ref-4127-4\">[4]</a></sup>, and doing fanout only via inbounds could lead to the transaction propagation being controlled by adversarial peers. On top of that, most nodes do not even accept incoming connections due to their hosting settings. However, completely ignoring inbound connections for fanout would also be a mistake.</p>\n<p>This raises the question: <strong>How many peers do we fanout to, and how are they picked?</strong></p>\n<p>Our current approach is to pick a mix of both <strong>inbounds</strong> and <strong>outbound</strong> peers, as long as they are available (i.e. an unreachable node would only pick outbound). <a href=\"https://github.com/bitcoin/bitcoin/pull/30116\" rel=\"noopener nofollow ugc\">The current version of the PR</a> uses <strong>1 outbound and 10% of inbounds,</strong> based on <a href=\"https://github.com/naumenkogs/txrelaysim/issues/7#issuecomment-901869563\" rel=\"noopener nofollow ugc\">Gleb\u2019s simulations</a>.</p>\n<blockquote>\n<p><img src=\"https://delvingbitcoin.org/images/emoji/twitter/construction.png?v=12\" title=\":construction:\" class=\"emoji\" alt=\":construction:\" loading=\"lazy\" width=\"20\" height=\"20\"> We are currently working on extending this, given <strong>using a percentage of connections</strong> for this has the downside that it makes Erlay bandwidth usage still proportional to the number of connections a node maintains. A goal of Erlay is to allow for a higher number of connections per node without increasing the node\u2019s bandwidth requirements. Sort of a <strong>scale-free</strong> solution.</p>\n</blockquote>\n<blockquote>\n<p><img src=\"https://delvingbitcoin.org/images/emoji/twitter/test_tube.png?v=12\" title=\":test_tube:\" class=\"emoji\" alt=\":test_tube:\" loading=\"lazy\" width=\"20\" height=\"20\"> The goal would be finding values that do not necessarily scale with the number of connections. This needs to be simulated</p>\n</blockquote>\n<p>Another question that also relates to peer selection is: <strong>How do we decide what peers to fanout to / reconcile with?</strong></p>\n<p>This question has many parts, depending on the adopted solution. The first of them is: are peers selected for fanout/reconciliation on a connection level, or is the decision-making done at the transaction level (i.e. for every transaction, a subset of peers is selected for fanout/reconciliation)?</p>\n<p>For this first part of the question, we have decided to go with the latter approach:</p>\n<blockquote>\n<p><img src=\"https://delvingbitcoin.org/images/emoji/twitter/exclamation.png?v=12\" title=\":exclamation:\" class=\"emoji\" alt=\":exclamation:\" loading=\"lazy\" width=\"20\" height=\"20\"> <strong>Choose peers to fanout to on a transaction level</strong></p>\n</blockquote>\n<p>The rationale for this is to make the process more fair, otherwise, once a peer is selected for fanout, all transaction exchange would be done using fanout, even if the peer is Erlay-enabled. Also, choosing this on a connection level makes the process way more gameable: if a peer is not happy with our selection they can try to find ways to be \u201cpromoted\u201d to reconciliation, depending on how the decision is made (e.g. imagine a naive way of choosing such as flipping a coin per connection, a peer could try to reconnect until they are selected for reconciliation) or even find another peer that picks them for reconciliation.</p>\n<p>Given peers are chosen for fanout on a transaction level, the next natural question is: <strong>When do we pick peers for fanout?</strong></p>\n<p>We have two options here, either on the transaction relay schedule (when <strong>transactions are queued</strong> to be sent to peers over the next <strong>trickle</strong> <sup class=\"footnote-ref\"><a href=\"#footnote-4127-5\" id=\"footnote-ref-4127-5\">[5]</a></sup> or on the transaction relay itself (when the <code>INV</code> messages are being constructed and transactions are about to be sent out).</p>\n<h3><a name=\"p-4127-choosing-fanout-peers-at-relay-scheduling-time-4\" class=\"anchor\" href=\"#p-4127-choosing-fanout-peers-at-relay-scheduling-time-4\"></a>Choosing fanout peers at relay scheduling time</h3>\n<p>The main motivation for choosing peers at scheduling time is being able to more easily reason about transaction dependencies, that is, how to exchange a given transaction if some of their ancestors are already being scheduled for exchange. Being inconsistent on how dependent transactions are exchanged between peers can hurt <strong>orphan transaction</strong> rates.</p>\n<blockquote>\n<p><img src=\"https://delvingbitcoin.org/images/emoji/twitter/test_tube.png?v=12\" title=\":test_tube:\" class=\"emoji\" alt=\":test_tube:\" loading=\"lazy\" width=\"20\" height=\"20\"> <strong>This is the approach we are currently following</strong>. Simulation results will be posted on a separate post and linked here after.</p>\n</blockquote>\n<h3><a name=\"p-4127-choosing-fanout-peers-at-transaction-relay-time-5\" class=\"anchor\" href=\"#p-4127-choosing-fanout-peers-at-transaction-relay-time-5\"></a>Choosing fanout peers at transaction relay time</h3>\n<p>Choosing peers at relay time has a better effect on being effective when selecting peers for fanout. The main downside of <strong>deciding at scheduling time</strong> is that it <strong>is not reactive to what may happen between the selection and the actual relay</strong>, that is, a peer that is selected for fanout for a given transaction may announce it to us before our announcement timer goes off, meaning that we will skip that announcement to them when the time comes, effectively reducing the amount of peers we fanout that transaction to. However, <strong>deciding at relay time has the downside of not being reactive enough to things that happen during the fanout selection process</strong>, such as the previous ancestors example, but also if we have already selected enough peers to fanout to, but suddenly we cannot reconcile the given transaction with the remaining of our peers (e.g. the transaction has a collision with an existing one in their set <sup class=\"footnote-ref\"><a href=\"#footnote-4127-6\" id=\"footnote-ref-4127-6\">[6]</a></sup>, their reconciliation sets are full, \u2026) we would end up having a <strong>higher fanout rate</strong> than intended, and we would not be able to compensate with some of the peers that we have already decided for, given those messages would have already been sent.</p>\n<blockquote>\n<p><img src=\"https://delvingbitcoin.org/images/emoji/twitter/test_tube.png?v=12\" title=\":test_tube:\" class=\"emoji\" alt=\":test_tube:\" loading=\"lazy\" width=\"20\" height=\"20\"> <strong>This is a valid alternative approach</strong>. Simulation results will be posted on a separate post and linked here after.</p>\n</blockquote>\n<h3><a name=\"p-4127-making-transactions-available-for-fanoutreconciliation-6\" class=\"anchor\" href=\"#p-4127-making-transactions-available-for-fanoutreconciliation-6\"></a>Making transactions available for fanout/reconciliation</h3>\n<p>Independently of the method chosen to pick fanout peers, <strong>transactions must only be available after a given delay</strong> this helps prevent adversarial peers from knowing when a transaction enters our mempool, which can be used to learn who the transaction originator is. This behavior is not new, and it has been used for years. This process is known as <strong>trickle</strong> <sup class=\"footnote-ref\"><a href=\"#footnote-4127-5\" id=\"footnote-ref-4127-0\">[5:1]</a></sup>) and it is applied to every connection depending on their type.</p>\n<p>For Erlay connections, transactions <strong>are made available for reconciliation when the timer for the given peer trickles</strong>. Transactions flagged for reconciliation between intervals are delayed and won\u2019t be part of a sketch should a reconciliation be scheduled.</p>\n<p>The way we currently deal with this is by having two internal collections behind the reconciliation set interface, the <strong>ready set</strong>, and the <strong>delayed set</strong>. Transactions are added to the delayed set and readied on trickle (moved from one to the other). The set is seen as a single entity though, therefore the limits, collisions, deletions, \u2026 are performed by checking both internal collections. <strong>For reconciliation purposes, only transactions in the ready set are used.</strong></p>\n<p>An interesting implication of this is that transactions added to the reconciliation set at <code>t-1</code> are made available at time <code>t</code> <strong>strictly after fanout.</strong> The process of making the timer advance belongs to the networking <a href=\"https://github.com/bitcoin/bitcoin/blob/35000e34cf339e46d62b757c3723057724d23637/src/net_processing.cpp#L5676\" rel=\"noopener nofollow ugc\">thread that builds and sends out network messages</a> (more concretely, during the <code>INV</code> message building). Being this a sequential process, <strong>fanout data from <code>t-1</code> is always processed before reconciliation data</strong>, even if a reconciliation request happens right after trickling. This is especially interesting in situations <a href=\"https://www.notion.so/Erlay-1537b3fef97780038aa6fa2ea5aef421?pvs=21\" rel=\"noopener nofollow ugc\">where ancestors need to be considered</a>, since we should not end up in a situation where we produce orphans by splitting ancestors between fanout and reconciliation.</p>\n<p>Let\u2019s consider the following example:</p>\n<pre data-code-wrap=\"cmd\"><code class=\"lang-cmd\">                                    P1                   P2             \n                                                                        \n \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510                           Fanout: txA, txB     Fanout: txA    \n \u2502 txA  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                  Recon: \u2205             Recon: txB     \n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2502     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510     Processed: \u2205         Processed: \u2205   \n                 \u251c\u2500\u2500\u2500\u2500\u2500\u2524 txC  \u2502                                         \n \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2502     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518     P3                   P4             \n \u2502 txA  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                                      \n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518                           Fanout: \u2205            Fanout: txA    \n                                    Recon: txB           Recon: \u2205       \n                                    Processed: txA       Processed: txB \n                                                                        \n\ntxC is added at time t-1,and made available at time t\ntxA and txB were added at time t-n, for n &lt; 1\n</code></pre>\n<p>Given the outlaid setting where <code>txA</code> and <code>txB</code> have already been added to their respective sets at <code>t-n</code> (for <code>n&lt;1</code>), and <code>txC</code> is added at time <code>t-1</code>. How do we handle the following situations:</p>\n<ul>\n<li><code>P1</code>: if <code>txC</code> is picked for reconciliation, we can be sure that all ancestors will be announced before it. If it is picked for fanout, all the ancestor set will be announced at the same time.</li>\n<li><code>P2</code>: if <code>txC</code> is picked for reconciliation, we know that <code>txA</code> will be announced first, leaving <code>txB</code> and <code>txC</code> to be reconciled at a later time. If it is selected for fanout, <code>txB</code> <strong>would also need to be moved from reconciliation to fanout, otherwise</strong> <code>txC</code> <strong>could become an orphan.</strong> This can happen if fanout for <code>t</code> happens before reconciliation for <code>t-n</code>, since reconciliation needs to be actively requested.</li>\n<li><code>P3</code>: if <code>txC</code> is picked for reconciliation, <code>txB</code> and <code>txC</code> will be exchanged using the same method, so all good. If it is picked for fanout, <code>txB</code> would also need to be moved from reconciliation to fanout (for the same reasons pointed out in <code>P2</code>).</li>\n<li><code>P4</code>: if <code>txC</code> is picked for reconciliation, we are fine, given fanout for <code>txA</code> must happen before reconciliation for <code>txC</code>. If it is picked for fanout, it will be exchanged alongside <code>txA</code>, so all good.</li>\n</ul>\n<p>Notice there could be two additional cases, one analogous to <code>P2</code> with <code>txA</code> and <code>txB</code> swapped, and one with all dependencies in the reconciliation set. Both cases have the same implications as <code>P2</code>. In the first case the order doesn\u2019t really matter, whereas in the second, if <code>txC</code> is picked for fanout, all others would need to be moved, and if not, all the ancestor set can be easily reconciled. Cases where the two sets are empty (ancestors have already been processed) are uninteresting for this matter.</p>\n<p>Therefore, we only need to be careful about flagging dependent transactions for fanout if they have ancestors in the reconciliation set:</p>\n<blockquote>\n<p><img src=\"https://delvingbitcoin.org/images/emoji/twitter/exclamation.png?v=12\" title=\":exclamation:\" class=\"emoji\" alt=\":exclamation:\" loading=\"lazy\" width=\"20\" height=\"20\"> If a transaction that has ancestors in the reconciliation set of a given peer is flagged for fanout, it\u2019ll trigger moving all the ancestors from reconciliation to fanout. <strong>This is implemented in the current approach</strong></p>\n</blockquote>\n<h1><a name=\"p-4127-simulations-7\" class=\"anchor\" href=\"#p-4127-simulations-7\"></a>Simulations</h1>\n<p>Simulations will be presented in independent posts, but I\u2019ll be linking them here for reference and easy access.</p>\n<h1><a name=\"p-4127-acknowledgements-8\" class=\"anchor\" href=\"#p-4127-acknowledgements-8\"></a>Acknowledgements</h1>\n<p>Many of the results and ideas presented here originate from discussions with several people, both inside and outside the working group including: Gleb Naumenko (<a class=\"mention\" href=\"/u/naumenkogs\">@naumenkogs</a>), Pieter Wuille (<a class=\"mention\" href=\"/u/sipa\">@sipa</a>), Greg Maxwell, Mark Erhardt (<a class=\"mention\" href=\"/u/murch\">@murch</a>), Marco De Leon (<a class=\"mention\" href=\"/u/marcofleon\">@marcofleon</a>) and others.</p>\n<hr class=\"footnotes-sep\">\n\n<ol class=\"footnotes-list\">\n<li id=\"footnote-4127-1\" class=\"footnote-item\"><p>As presented in the <a href=\"https://arxiv.org/abs/1905.10518\" rel=\"noopener nofollow ugc\">Erlay paper</a>, most of these transaction announcements are redundant, given the transaction has already been announced to (or even received by) a given node. This is the main assumption Erlay builds on top of <a href=\"#footnote-ref-4127-1\" class=\"footnote-backref\">\u21a9\ufe0e</a></p>\n</li>\n<li id=\"footnote-4127-2\" class=\"footnote-item\"><p>What sketches are, and how are they computed is outside the scope of this document. They can be seen as black boxes with two properties: 1. Given two sketches, the symmetrical difference of the elements in the reconciliation sets can be computed. 2. Sketch size grows proportionally to the expected difference, instead of to the number of elements in it <a href=\"#footnote-ref-4127-2\" class=\"footnote-backref\">\u21a9\ufe0e</a></p>\n</li>\n<li id=\"footnote-4127-3\" class=\"footnote-item\"><p>Under what conditions these peers are picked is really implementation dependent, and one of the topics that will be discussed later in this document <a href=\"#footnote-ref-4127-3\" class=\"footnote-backref\">\u21a9\ufe0e</a></p>\n</li>\n<li id=\"footnote-4127-4\" class=\"footnote-item\"><p>No connection is really \u201ctrusted\u201d, but inbounds are seen as likely adversarial, given they are not selected by us in a hard-to-bias manner. A whole section could be written on this, but to keep it simple, <strong>inbounds = bad</strong> <a href=\"#footnote-ref-4127-4\" class=\"footnote-backref\">\u21a9\ufe0e</a></p>\n</li>\n<li id=\"footnote-4127-5\" class=\"footnote-item\"><p>Trickling happens on a timer that mimics a Poisson process. Inbound peers are on a shared timer with an expected value of <code>5s</code>, whereas outbound peers have their own timer with an expected value of <code>2s</code>. That means, on average, transactions are sent out to inbound/outbound peers every 5s/2s <a href=\"#footnote-ref-4127-5\" class=\"footnote-backref\">\u21a9\ufe0e</a> <a href=\"#footnote-ref-4127-5\" class=\"footnote-backref\">\u21a9\ufe0e</a></p>\n</li>\n<li id=\"footnote-4127-6\" class=\"footnote-item\"><p>Transactions added to a peer\u2019s <strong>reconciliation set</strong> are identified using <strong>a shorter id</strong> than transaction ids, meaning that the changes of an id collision are higher <a href=\"#footnote-ref-4127-6\" class=\"footnote-backref\">\u21a9\ufe0e</a></p>\n</li>\n</ol>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2025-01-31T20:36:05.358Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 4,
  "readers_count": 3,
  "score": 0.8,
  "yours": false,
  "topic_id": 1415,
  "topic_slug": "erlay-overview-and-current-approach",
  "topic_title": "Erlay: Overview and current approach",
  "topic_html_title": "Erlay: Overview and current approach",
  "category_id": 7,
  "display_username": "Sergi Delgado",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Earlier last year I started working on a second attempt to implement Erlay into Bitcoin Core, a process that started from convincing myself that the theoretical improvements were achievable in practice, followed by a research-oriented approach where multiple protocol choices need to be simulated and that will hopefully conclude with a well though implementation that satisfies the original goals.\n\nAfter several months of working alongside other Bitcoin Core developers (teaming up to create an Erlay working group), endless conversations, and hours of simulations (after implementing a [discrete time simulator for the matter](https://delvingbitcoin.org/t/hyperion-a-discrete-time-network-event-simulator-for-bitcoin-core)). I'm happy to start reporting the current state of the project, especially for those of you who may be curious by not directly involved in it.\n\nThis initial post will cover an overview of Erlay, alongside the current implementation approach, thought process, and some open questions.\n\nFuture posts will contain some of the experiments we have been performing to answer those questions. Bear in mind Erlay is still in active development so some of the questions may still have no satisfactory answer.\n\nAny errors found within this write-up, or any of its follow-ups, are my own.\n\n# Erlay\n\n## Overview \n\nErlay is an alternative method of announcing transactions between peers in the Bitcoin P2P network. Erlay's main goal is to reduce bandwidth utilization when propagating transaction data.\n\nThe protocol builds on the assumption that a significant percentage of the data exchanged between peers when broadcasting transactions belongs to **inventory** (or `INV`) **messages** [^1], which are used to announce the transaction hashes between peers. On receiving an `INV` message containing a collection of transactions, a well-behaved peer will respond with a message requesting all its missing transactions, this is known as a **getdata message** (or `GETDATA`).\n\nErlay tries to solve this issue by using set reconciliation to work out the transaction differences between two nodes connected to each other instead of just announcing all transactions through all links. To do so, nodes keep a set of transactions to be reconciled (or **reconciliation set**) between each of their Erlay-enabled peers, and reconciliation is performed at regular intervals. Once it is time to reconcile, peers exchange **sketches** [^2] of their reconciliation sets, which can be used to optimally compute the symmetrical difference between their **reconciliation sets** and, therefore, identify which transactions need to be sent by each end of the connection.\n\nTherefore, Erlay aims to reduce traditional transaction relay (called **fanout** from now on) as much as possible but, maybe counterintuitively, not to completely replace it. For Erlay to be optimal, a small amount of **fanout** is still needed, given set reconciliation works best (sketches are smaller and sketch differences are cheaper to compute) when the differences between sets are small. This means that, even if all peers of a given node are Erlay enabled, some transactions will still be exchanged using **fanout**[^3]. Moreover, fanout is more efficient, and considerably faster, than set reconciliation provided the receiving node **does not know about** the transaction being announced.\n\n## Approach\n\nOne of the first details to decide on, when implementing Erlay, is how small we want the network transaction **fanout** to be. That is, for each Erlay node, how many peers should it select to exchange transactions using fanout. This is a tradeoff between **bandwidth efficiency** and transaction **propagation latency**: the bigger the fanout, the more initial fast coverage of the network, but the less bandwidth savings. If the fanout rate is too low, we could incur drastically slower transaction propagation times, if it is too big, the bandwidth saving would be too small (maybe even not worth the additional code complexity of implementing Erlay). Furthermore, what kind of nodes are selected also matters: in Bitcoin Core, inbound connections are not trusted [^4], and doing fanout only via inbounds could lead to the transaction propagation being controlled by adversarial peers. On top of that, most nodes do not even accept incoming connections due to their hosting settings. However, completely ignoring inbound connections for fanout would also be a mistake.\n\nThis raises the question: **How many peers do we fanout to, and how are they picked?**\n\nOur current approach is to pick a mix of both **inbounds** and **outbound** peers, as long as they are available (i.e. an unreachable node would only pick outbound). [The current version of the PR](https://github.com/bitcoin/bitcoin/pull/30116) uses **1 outbound and 10% of inbounds,** based on [Gleb\u2019s simulations](https://github.com/naumenkogs/txrelaysim/issues/7#issuecomment-901869563).\n\n> :construction: We are currently working on extending this, given **using a percentage of connections** for this has the downside that it makes Erlay bandwidth usage still proportional to the number of connections a node maintains. A goal of Erlay is to allow for a higher number of connections per node without increasing the node\u2019s bandwidth requirements. Sort of a **scale-free** solution.\n\n> :test_tube: The goal would be finding values that do not necessarily scale with the number of connections. This needs to be simulated\n\nAnother question that also relates to peer selection is: **How do we decide what peers to fanout to / reconcile with?**\n\nThis question has many parts, depending on the adopted solution. The first of them is: are peers selected for fanout/reconciliation on a connection level, or is the decision-making done at the transaction level (i.e. for every transaction, a subset of peers is selected for fanout/reconciliation)?\n\nFor this first part of the question, we have decided to go with the latter approach: \n\n> :exclamation: **Choose peers to fanout to on a transaction level**\n\nThe rationale for this is to make the process more fair, otherwise, once a peer is selected for fanout, all transaction exchange would be done using fanout, even if the peer is Erlay-enabled. Also, choosing this on a connection level makes the process way more gameable: if a peer is not happy with our selection they can try to find ways to be \u201cpromoted\u201d to reconciliation, depending on how the decision is made (e.g. imagine a naive way of choosing such as flipping a coin per connection, a peer could try to reconnect until they are selected for reconciliation) or even find another peer that picks them for reconciliation.\n\nGiven peers are chosen for fanout on a transaction level, the next natural question is: **When do we pick peers for fanout?**\n\nWe have two options here, either on the transaction relay schedule (when **transactions are queued** to be sent to peers over the next **trickle** [^5] or on the transaction relay itself (when the `INV` messages are being constructed and transactions are about to be sent out).\n\n### Choosing fanout peers at relay scheduling time\n\nThe main motivation for choosing peers at scheduling time is being able to more easily reason about transaction dependencies, that is, how to exchange a given transaction if some of their ancestors are already being scheduled for exchange. Being inconsistent on how dependent transactions are exchanged between peers can hurt **orphan transaction** rates. \n\n> :test_tube: **This is the approach we are currently following**. Simulation results will be posted on a separate post and linked here after.\n\n### Choosing fanout peers at transaction relay time\n\nChoosing peers at relay time has a better effect on being effective when selecting peers for fanout. The main downside of **deciding at scheduling time** is that it **is not reactive to what may happen between the selection and the actual relay**, that is, a peer that is selected for fanout for a given transaction may announce it to us before our announcement timer goes off, meaning that we will skip that announcement to them when the time comes, effectively reducing the amount of peers we fanout that transaction to. However, **deciding at relay time has the downside of not being reactive enough to things that happen during the fanout selection process**, such as the previous ancestors example, but also if we have already selected enough peers to fanout to, but suddenly we cannot reconcile the given transaction with the remaining of our peers (e.g. the transaction has a collision with an existing one in their set [^6], their reconciliation sets are full, \u2026) we would end up having a **higher fanout rate** than intended, and we would not be able to compensate with some of the peers that we have already decided for, given those messages would have already been sent.\n\n> :test_tube: **This is a valid alternative approach**. Simulation results will be posted on a separate post and linked here after.\n\n### Making transactions available for fanout/reconciliation\n\nIndependently of the method chosen to pick fanout peers, **transactions must only be available after a given delay** this helps prevent adversarial peers from knowing when a transaction enters our mempool, which can be used to learn who the transaction originator is. This behavior is not new, and it has been used for years. This process is known as **trickle** [^5]) and it is applied to every connection depending on their type.\n\nFor Erlay connections, transactions **are made available for reconciliation when the timer for the given peer trickles**. Transactions flagged for reconciliation between intervals are delayed and won\u2019t be part of a sketch should a reconciliation be scheduled. \n\nThe way we currently deal with this is by having two internal collections behind the reconciliation set interface, the **ready set**, and the **delayed set**. Transactions are added to the delayed set and readied on trickle (moved from one to the other). The set is seen as a single entity though, therefore the limits, collisions, deletions, \u2026 are performed by checking both internal collections. **For reconciliation purposes, only transactions in the ready set are used.**\n\nAn interesting implication of this is that transactions added to the reconciliation set at `t-1` are made available at time `t` **strictly after fanout.** The process of making the timer advance belongs to the networking [thread that builds and sends out network messages](https://github.com/bitcoin/bitcoin/blob/35000e34cf339e46d62b757c3723057724d23637/src/net_processing.cpp#L5676) (more concretely, during the `INV` message building). Being this a sequential process, **fanout data from `t-1` is always processed before reconciliation data**, even if a reconciliation request happens right after trickling. This is especially interesting in situations [where ancestors need to be considered](https://www.notion.so/Erlay-1537b3fef97780038aa6fa2ea5aef421?pvs=21), since we should not end up in a situation where we produce orphans by splitting ancestors between fanout and reconciliation.\n\nLet\u2019s consider the following example:\n\n```cmd\n                                    P1                   P2             \n                                                                        \n \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510                           Fanout: txA, txB     Fanout: txA    \n \u2502 txA  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                  Recon: \u2205             Recon: txB     \n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2502     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510     Processed: \u2205         Processed: \u2205   \n                 \u251c\u2500\u2500\u2500\u2500\u2500\u2524 txC  \u2502                                         \n \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2502     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518     P3                   P4             \n \u2502 txA  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                                      \n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518                           Fanout: \u2205            Fanout: txA    \n                                    Recon: txB           Recon: \u2205       \n                                    Processed: txA       Processed: txB \n                                                                        \n\ntxC is added at time t-1,and made available at time t\ntxA and txB were added at time t-n, for n < 1\n```\n\nGiven the outlaid setting where `txA` and `txB` have already been added to their respective sets at `t-n` (for `n<1`), and `txC` is added at time `t-1`. How do we handle the following situations:\n\n- `P1`: if `txC` is picked for reconciliation, we can be sure that all ancestors will be announced before it. If it is picked for fanout, all the ancestor set will be announced at the same time.\n- `P2`: if `txC` is picked for reconciliation, we know that `txA` will be announced first, leaving `txB` and `txC` to be reconciled at a later time. If it is selected for fanout, `txB` **would also need to be moved from reconciliation to fanout, otherwise** `txC` **could become an orphan.** This can happen if fanout for `t` happens before reconciliation for `t-n`, since reconciliation needs to be actively requested.\n- `P3`: if `txC` is picked for reconciliation, `txB` and `txC` will be exchanged using the same method, so all good. If it is picked for fanout, `txB` would also need to be moved from reconciliation to fanout (for the same reasons pointed out in `P2`).\n- `P4`: if `txC` is picked for reconciliation, we are fine, given fanout for `txA` must happen before reconciliation for `txC`. If it is picked for fanout, it will be exchanged alongside `txA`, so all good.\n\nNotice there could be two additional cases, one analogous to `P2` with `txA` and `txB` swapped, and one with all dependencies in the reconciliation set. Both cases have the same implications as `P2`. In the first case the order doesn\u2019t really matter, whereas in the second, if `txC` is picked for fanout, all others would need to be moved, and if not, all the ancestor set can be easily reconciled. Cases where the two sets are empty (ancestors have already been processed) are uninteresting for this matter.\n\nTherefore, we only need to be careful about flagging dependent transactions for fanout if they have ancestors in the reconciliation set: \n\n> :exclamation: If a transaction that has ancestors in the reconciliation set of a given peer is flagged for fanout, it\u2019ll trigger moving all the ancestors from reconciliation to fanout. **This is implemented in the current approach** \n\n# Simulations\n\nSimulations will be presented in independent posts, but I'll be linking them here for reference and easy access. \n\n# Acknowledgements\n\nMany of the results and ideas presented here originate from discussions with several people, both inside and outside the working group including: Gleb Naumenko (@naumenkogs), Pieter Wuille (@sipa), Greg Maxwell, Mark Erhardt (@murch), Marco De Leon (@marcofleon) and others.\n\n [^1]: As presented in the [Erlay paper](https://arxiv.org/abs/1905.10518), most of these transaction announcements are redundant, given the transaction has already been announced to (or even received by) a given node. This is the main assumption Erlay builds on top of\n[^2]: What sketches are, and how are they computed is outside the scope of this document. They can be seen as black boxes with two properties: 1. Given two sketches, the symmetrical difference of the elements in the reconciliation sets can be computed. 2. Sketch size grows proportionally to the expected difference, instead of to the number of elements in it\n[^3]: Under what conditions these peers are picked is really implementation dependent, and one of the topics that will be discussed later in this document\n[^4]: No connection is really \u201ctrusted\u201d, but inbounds are seen as likely adversarial, given they are not selected by us in a hard-to-bias manner. A whole section could be written on this, but to keep it simple, **inbounds = bad**\n[^5]: Trickling happens on a timer that mimics a Poisson process. Inbound peers are on a shared timer with an expected value of `5s`, whereas outbound peers have their own timer with an expected value of `2s`. That means, on average, transactions are sent out to inbound/outbound peers every 5s/2s\n[^6]: Transactions added to a peer\u2019s **reconciliation set** are identified using **a shorter id** than transaction ids, meaning that the changes of an id collision are higher",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 122,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}