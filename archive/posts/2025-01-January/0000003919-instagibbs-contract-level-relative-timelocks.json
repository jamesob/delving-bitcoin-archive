{
  "id": 3919,
  "name": "Gregory Sanders",
  "username": "instagibbs",
  "avatar_template": "/user_avatar/delvingbitcoin.org/instagibbs/{size}/28_2.png",
  "created_at": "2025-01-02T15:00:14.885Z",
  "cooked": "<h1><a name=\"p-3919-contract-level-relative-timelock-clrt-utxo-for-eltoo-1\" class=\"anchor\" href=\"#p-3919-contract-level-relative-timelock-clrt-utxo-for-eltoo-1\"></a>Contract-level Relative Timelock (CLRT) UTXO for Eltoo</h1>\n<p>Eltoo constructs such as ln-symmetry suffer from an issue\nwhere every time an update transaction is confirmed on the\nblockchain, the relative timelock to settle the contract is reset. This causes\nfurther funds lockup, and further extends HTLC expiry in the LN\nuse-case, potentially reducing network utility.</p>\n<p>How can we have a \u201ccontract\u201d level relative timelock? Embedding state inside the continuously refreshed utxos seems intractable due to Bitcoin\u2019s requirement for monotonic validity of transactions. An adversary can simply \u201cunder-report\u201d the number of \u201celapsed\u201d blocks during the contract\u2019s lifetime.\nThe proposed solution here is to dedicate a specific utxo that doesn\u2019t move until\nthe the challenge period is over, and only allowing the contract state output and relative timelock output to be spent concurrently.</p>\n<h1><a name=\"p-3919-ln-symmetry-and-extension-2\" class=\"anchor\" href=\"#p-3919-ln-symmetry-and-extension-2\"></a>LN-symmetry and extension?</h1>\n<p>To recap, ln-symmetry has this series of transactions that must appear to settle the contract:</p>\n<p><code>funding-&gt;update-&gt;settle</code></p>\n<p>For this extension we change it to include a slightly\ndifferent update transaction we will call \u201ckickoff\u201d:</p>\n<p><code>funding-&gt;kickoff-&gt;update-&gt;settle</code></p>\n<p>Kickoff transactions have an additional CLRT output that\ncommits to a relative delay (ln-symmetry\u2019s <code>shared_delay</code>) for the eltoo challenge period\nbefore the settlement transaction can be confirmed.</p>\n<p>The output is dust-level and commits to being spent concurrently with an\neltoo state output. To do this, you need a recursive proof that links\nback to an update transcation\u2019s state output. In other words, the recursive\nproof needs to demonstrate that another input has an ancestry that includes\nthe kickoff transaction itself.</p>\n<p>Update transactions pre-commit to both the state output(s) and the CLRT\noutput to enforce that if the state output is spent, so is the CLRT output.</p>\n<p>This makes mutual spending of a state output and CLRT a requirement for settlement.</p>\n<h1><a name=\"p-3919-how-could-the-clrt-ancestry-proof-work-3\" class=\"anchor\" href=\"#p-3919-how-could-the-clrt-ancestry-proof-work-3\"></a>How could the CLRT ancestry proof work?</h1>\n<h1><a name=\"p-3919-make-the-problem-simpler-assume-txid-stability-4\" class=\"anchor\" href=\"#p-3919-make-the-problem-simpler-assume-txid-stability-4\"></a>Make the problem simpler: Assume TXID stability</h1>\n<p>If we accept the case where we are just doing \u201conchain\u201d eltoo with normal SIGHASH_DEFAULT,\nthis becomes a lot simpler due to txid stability of the eltoo chain. The CLRT output becomes\na connector output that is \u201cre-attached\u201d via consensus signatures of channel participants, and the script being a simple CSV of the <code>shared_delay</code>.</p>\n<p>Obviously, requiring O(n) state on-chain is sub-optimal, but I think it\u2019s important to have a correct construction for demonstration purposes.</p>\n<p>Another usage, at least on paper: <a href=\"https://delvingbitcoin.org/t/contract-level-relative-timelocks/1353\">Used for sequencing transactions in John Law\u2019s constructions of channels</a></p>\n<h1><a name=\"p-3919-without-txid-stability-5\" class=\"anchor\" href=\"#p-3919-without-txid-stability-5\"></a>Without TXID stability</h1>\n<p>Once we venture into \u201creal\u201d eltoo where we are re-attaching prevouts,\ntransaction id stability goes out the window and we cannot rely on\nregular signatures to authorize the connector output.</p>\n<p>High-level handwave solution:</p>\n<ol>\n<li>CLRT introspects \u201ccurrent\u201d input\u2019s prevout. This will be matched in ancestry proof next.</li>\n<li>Proof contains first submitted update transaction with matching kickoff prevout, computes\nits txid, checks that second confirmed update transaction in proof spends that utxo, etc, until\nproof connects with the settlement transaction itself in the state output being spent.\nThe proof checker MUST enforce the right outputs are being spent at each step: the state output\nof the eltoo contract, rather than say an anchor output.</li>\n</ol>\n<p>Problems:</p>\n<ol>\n<li>Requires some sort of consensus change to support proof construction, leaving this as exercise to reader.</li>\n<li>Kickoff transaction and additional utxo costs extra vbytes and adds lots of complexity.</li>\n<li>Proofs are vbytes-expensive and allow counterparty to penalize honest partner by doing additional updates.</li>\n<li>Crucially, the counter-party can make it consensus-invalid to actually spend the CLRT by inflating the proof\nbeyond consensus limits. Either need a mechanism for fixed number of updates and constant sized updates, or ZK magic to compress the proof to constant size?</li>\n</ol>\n<p>If we get OP_ZKP maybe it becomes practical with O(1) enforcement of transaction ancestry?</p>\n<p>Are there simpler solutions to this problem I\u2019m missing?</p>\n<h1><a name=\"p-3919-appendix-chia-version-6\" class=\"anchor\" href=\"#p-3919-appendix-chia-version-6\"></a>Appendix: Chia Version</h1>\n<p>h/t <a class=\"mention\" href=\"/u/ajtowns\">@ajtowns</a></p>\n<p>With Chia\u2019s coinid, I think this gets pretty simple, but is still linear in update history:</p>\n<p>reminder that <code>CoinID = SHA256(parent_coin_id || puzzle_hash || amount)</code></p>\n<p>Assuming the signature being used is functionally equivalent to <code>SIGHASH_ALL</code> and there is some sort of simplistic P2A like output for fees, that means there will be two types of outputs in each update: a contract output, and a static P2A-like puzzle we can filter for.</p>\n<p>For witness data you are given a series of 32WU <code>puzzle_hash</code>es, none of which can be the P2A-equivalent. You take CLRT\u2019s parent coin id, and repeatedly hash it with the static amount and series of puzzle hashes. At the end, the coinids should match expected.</p>\n<p>At 32WU per update, a standard relayable transaction could include a proof up to 12,500 levels, minus overhead.</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2025-01-02T19:35:31.228Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 28,
  "reads": 25,
  "readers_count": 24,
  "score": 160.0,
  "yours": false,
  "topic_id": 1353,
  "topic_slug": "contract-level-relative-timelocks",
  "topic_title": "Contract-level Relative Timelocks",
  "topic_html_title": "Contract-level Relative Timelocks",
  "category_id": 7,
  "display_username": "Gregory Sanders",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 4,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Contract-level Relative Timelock (CLRT) UTXO for Eltoo\n===\n\nEltoo constructs such as ln-symmetry suffer from an issue\nwhere every time an update transaction is confirmed on the\nblockchain, the relative timelock to settle the contract is reset. This causes\nfurther funds lockup, and further extends HTLC expiry in the LN\nuse-case, potentially reducing network utility.\n\nHow can we have a \"contract\" level relative timelock? Embedding state inside the continuously refreshed utxos seems intractable due to Bitcoin's requirement for monotonic validity of transactions. An adversary can simply \"under-report\" the number of \"elapsed\" blocks during the contract's lifetime.\nThe proposed solution here is to dedicate a specific utxo that doesn't move until\nthe the challenge period is over, and only allowing the contract state output and relative timelock output to be spent concurrently.\n\nLN-symmetry and extension?\n===\n\nTo recap, ln-symmetry has this series of transactions that must appear to settle the contract:\n\n`funding->update->settle`\n\nFor this extension we change it to include a slightly\ndifferent update transaction we will call \"kickoff\":\n\n`funding->kickoff->update->settle`\n\nKickoff transactions have an additional CLRT output that\ncommits to a relative delay (ln-symmetry's `shared_delay`) for the eltoo challenge period\nbefore the settlement transaction can be confirmed.\n\nThe output is dust-level and commits to being spent concurrently with an\neltoo state output. To do this, you need a recursive proof that links\nback to an update transcation's state output. In other words, the recursive\nproof needs to demonstrate that another input has an ancestry that includes\nthe kickoff transaction itself.\n\nUpdate transactions pre-commit to both the state output(s) and the CLRT\noutput to enforce that if the state output is spent, so is the CLRT output.\n\nThis makes mutual spending of a state output and CLRT a requirement for settlement.\n\nHow could the CLRT ancestry proof work?\n===\nMake the problem simpler: Assume TXID stability\n===\nIf we accept the case where we are just doing \"onchain\" eltoo with normal SIGHASH_DEFAULT,\nthis becomes a lot simpler due to txid stability of the eltoo chain. The CLRT output becomes\na connector output that is \"re-attached\" via consensus signatures of channel participants, and the script being a simple CSV of the `shared_delay`.\n\nObviously, requiring O(n) state on-chain is sub-optimal, but I think it's important to have a correct construction for demonstration purposes.\n\nAnother usage, at least on paper: [Used for sequencing transactions in John Law's constructions of channels](https://delvingbitcoin.org/t/contract-level-relative-timelocks/1353)\n\nWithout TXID stability\n===\nOnce we venture into \"real\" eltoo where we are re-attaching prevouts,\ntransaction id stability goes out the window and we cannot rely on\nregular signatures to authorize the connector output.\n\nHigh-level handwave solution:\n1) CLRT introspects \"current\" input's prevout. This will be matched in ancestry proof next.\n2) Proof contains first submitted update transaction with matching kickoff prevout, computes\nits txid, checks that second confirmed update transaction in proof spends that utxo, etc, until\nproof connects with the settlement transaction itself in the state output being spent.\nThe proof checker MUST enforce the right outputs are being spent at each step: the state output\nof the eltoo contract, rather than say an anchor output.\n\nProblems:\n1) Requires some sort of consensus change to support proof construction, leaving this as exercise to reader.\n2) Kickoff transaction and additional utxo costs extra vbytes and adds lots of complexity.\n3) Proofs are vbytes-expensive and allow counterparty to penalize honest partner by doing additional updates.\n4) Crucially, the counter-party can make it consensus-invalid to actually spend the CLRT by inflating the proof\nbeyond consensus limits. Either need a mechanism for fixed number of updates and constant sized updates, or ZK magic to compress the proof to constant size?\n\nIf we get OP_ZKP maybe it becomes practical with O(1) enforcement of transaction ancestry?\n\nAre there simpler solutions to this problem I'm missing?\n\nAppendix: Chia Version\n===\nh/t @ajtowns\n\nWith Chia's coinid, I think this gets pretty simple, but is still linear in update history:\n\nreminder that `CoinID = SHA256(parent_coin_id || puzzle_hash || amount)`\n\nAssuming the signature being used is functionally equivalent to `SIGHASH_ALL` and there is some sort of simplistic P2A like output for fees, that means there will be two types of outputs in each update: a contract output, and a static P2A-like puzzle we can filter for.\n\nFor witness data you are given a series of 32WU `puzzle_hash`es, none of which can be the P2A-equivalent. You take CLRT's parent coin id, and repeatedly hash it with the static amount and series of puzzle hashes. At the end, the coinids should match expected.\n\nAt 32WU per update, a standard relayable transaction could include a proof up to 12,500 levels, minus overhead.",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 31,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "eyes",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}