{
  "id": 4107,
  "name": "Alex",
  "username": "olkurbatov",
  "avatar_template": "/user_avatar/delvingbitcoin.org/olkurbatov/{size}/299_2.png",
  "created_at": "2025-01-29T11:17:08.789Z",
  "cooked": "<p>We propose a method of emulation of OP_RAND opcode on Bitcoin through a trustless interactive game between transaction counterparties. The game result is probabilistic and doesn\u2019t allow any party to cheat and increase their chance to win on any protocol step. The protocol can be organized in a way unrecognizable to any external party and doesn\u2019t require some specific scripts or Bitcoin protocol updates. We will show how the protocol works on the simple <strong>Thimbles Game</strong> and provide some initial thoughts about approaches and applications that can use the mentioned approach.</p>\n<h1><a name=\"p-4107-intro-1\" class=\"anchor\" href=\"#p-4107-intro-1\"></a>Intro</h1>\n<p>Bitcoin script doesn\u2019t directly allow putting randomness and constructing the spending flow based on that. So, realizing the flow \u201c<em>Alice and Bob put for 5 BTC each, and Bob takes everything if the coin comes up tails</em>\u201d wasn\u2019t possible upon the following assumptions:</p>\n<ol>\n<li>The transaction can\u2019t derive or take randomness from somewhere at the moment of confirmation</li>\n<li>Bitcoin Script can\u2019t inspect the block, past or future transactions</li>\n<li>Each party can receive the same stack\u2019s state after each opcode processing</li>\n<li>We can\u2019t control the ECDSA or Schnorr signature determinism</li>\n<li>Bitcoin doesn\u2019t support OP_RAND opcode =)</li>\n</ol>\n<p>All the limitations mentioned led to the situation where we couldn\u2019t find trustless solutions that allow scrambling randomness and use it for a trustless protocol operating with bitcoins. We propose a way to organize it via a 2-party interactive protocol and show how these properties can be applied in the example of a thimbles game that takes bids in BTC.</p>\n<h1><a name=\"p-4107-preliminaries-2\" class=\"anchor\" href=\"#p-4107-preliminaries-2\"></a>Preliminaries</h1>\n<p><span class=\"math\">\\mathbb{G}</span> a cyclic group of prime order <span class=\"math\">p</span> written additively, <span class=\"math\">G \\in \\mathbb{G}</span> is the group generator. <span class=\"math\">a \\in \\mathbb{F}_p</span> is a scalar value and <span class=\"math\">A \\in \\mathbb{G}</span> is a group element. <span class=\"math\">\\mathsf{hash}_p(m) \\rightarrow h\\in \\mathbb{F}_p</span> is the cryptographic hash function that takes as an input an arbitrary message <span class=\"math\">m</span> and returns the field element <span class=\"math\">h</span>. <span class=\"math\">\\mathsf{hash}_{160}(P) \\rightarrow \\mathsf{addr}\\in \\mathcal{A}</span> is the function of hashing the public key with sha-256 and ripemd160 functions and receiving a valid bitcoin address as an output.</p>\n<p>We define the relation for the proof <span class=\"math\">\\pi</span> as <span class=\"math\">\\mathcal{R} = \\{(w;x) \\in \\mathcal{W} \\times \\mathcal{X}: \\phi_1(w,x), \\phi_2(w,x) , \\dots, \\phi_m(w,x)\\}</span>, where <span class=\"math\">w</span> is a witness data, <span class=\"math\">x</span> is a public data and <span class=\"math\">\\phi_1(w,x), \\phi_2(w,x) , \\dots, \\phi_m(w,x)</span> the set of relations must be proven simultaneously.</p>\n<p>We define a bitcoin transaction as <span class=\"math\">\\mathsf{TX}\\{(\\mathsf{id, i, proof})^{(n)};(\\mathsf{a BTC, cond})^{(m)}\\}</span> with <span class=\"math\">n</span> inputs and <span class=\"math\">m</span> outputs, where <span class=\"math\">\\mathsf{id}</span> is the hash of the previous transaction, <span class=\"math\">i</span> - output\u2019s index, <span class=\"math\">\\mathsf{proof}</span> - the list of data which is needed to transaction spending, <span class=\"math\">a</span> - the number of coins in the output, <span class=\"math\">\\mathsf{cond}</span> - scriptPubKey conditions. For example, the P2PKH method requires <span class=\"math\">\\mathsf{proof} \\leftarrow \\langle  \\mathsf{PK}, \\sigma\\rangle</span> and <span class=\"math\">\\mathsf{cond}\\leftarrow \\langle</span> OP_DUP, OP_HASH160, <span class=\"math\">\\mathsf{addr},</span> OP_EQUALVERIFY, OP_CHECKSIG <span class=\"math\">\\rangle</span>. We are going to simplify the condition notation above to <span class=\"math\">\\mathsf{addr}</span> when referring to the P2PKH approach.</p>\n<h1><a name=\"p-4107-ec-point-covenant-3\" class=\"anchor\" href=\"#p-4107-ec-point-covenant-3\"></a>EC Point covenant</h1>\n<p>First of all, let\u2019s see how we can implement the transaction with two counterparties and the following conditions: \u201cIt\u2019s possible to spend the second transaction output only in the case the first is spent\u201d. Traditionally, it could be organized using a hash lock contract, but 1 \u2013 it\u2019s recognizable; 2 \u2013 it won\u2019t help us to implement the final game.</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/2X/e/ea9d150a03031d37d52f617f4841e13c4cfcba31.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/ea9d150a03031d37d52f617f4841e13c4cfcba31\" title=\"Screenshot 2025-01-29 at 13.04.56\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/2X/e/ea9d150a03031d37d52f617f4841e13c4cfcba31_2_517x337.png\" alt=\"Screenshot 2025-01-29 at 13.04.56\" data-base62-sha1=\"xtuh3wWgAUMYyy8vQqsTCkS7Y6B\" width=\"517\" height=\"337\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/2X/e/ea9d150a03031d37d52f617f4841e13c4cfcba31_2_517x337.png, https://delvingbitcoin.org/uploads/default/optimized/2X/e/ea9d150a03031d37d52f617f4841e13c4cfcba31_2_775x505.png 1.5x, https://delvingbitcoin.org/uploads/default/original/2X/e/ea9d150a03031d37d52f617f4841e13c4cfcba31.png 2x\" data-dominant-color=\"F6F6F7\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">Screenshot 2025-01-29 at 13.04.56</span><span class=\"informations\">1032\u00d7674 66 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>If Alice wants to spend her output, she needs to create a transaction and reveal a public key <span class=\"math\">P_a</span> and the signature value.</p>\n<div class=\"math\">\n\\mathsf{TX}_2\\{(\\mathsf{TX_1, 1, \\color{red}{\\langle P_a, \\sigma_{P_a}}(\\mathsf{TX_2})\\rangle});(\\mathsf{1 BTC, \\color{red}{addr_{a'}}})\\}\n</div>\n<p>After the transaction is published, Bob can extract <span class=\"math\">P_a</span> and recover the <span class=\"math\">\\mathsf{hash}_p(P_a)</span> value. Then the secret key for the second output is calculated as <span class=\"math\">sk = \\mathsf{hash}_p(P_a) + sk_b</span> (only Bob controls <span class=\"math\">sk_b</span>), and Bob can construct the signature related to <span class=\"math\">P_b+C</span> public key and corresponding address.</p>\n<div class=\"math\">\n\\mathsf{TX}_3\\{(\\mathsf{TX_1, 2, \\color{blue}{\\langle P_b + C, \\sigma_{P_b + C}}(\\mathsf{TX_3})\\rangle});(\\mathsf{1 BTC, \\color{blue}{addr_{b'}}})\\}\n</div>\n<p>So, we have built the first part needed for emulating the randomness and our thimbles game. We need to note that in the previous example, if Alice doesn\u2019t spend her output and doesn\u2019t publish <span class=\"math\">P_a</span> anywhere, Bob can\u2019t recover the key and spend his output as well. If we need to provide an ability to spend these outputs after some time (if the game hasn\u2019t started), we can do it similarly to the payment channel construction \u2014 lock coins to the multisignature and create a tx that can spend them after a defined period.</p>\n<h1><a name=\"p-4107-op_rand-emulation-protocol-4\" class=\"anchor\" href=\"#p-4107-op_rand-emulation-protocol-4\"></a>OP_RAND emulation protocol</h1>\n<p>We propose to emulate the OP_RAND opcode with an interactive protocol between parties involved in the transaction. Introducing the Challenger <span class=\"math\">\\mathcal{C}</span> and Accepter <span class=\"math\">\\mathcal{A}</span> roles we can define the OP_RAND emulation protocol as follows:</p>\n<ol>\n<li><span class=\"math\">\\mathcal{C}</span> and <span class=\"math\">\\mathcal{A}</span> have their cryptographic keypairs <span class=\"math\">\\langle sk_{\\mathcal{C}}, P_{\\mathcal{C}}\\rangle</span> and <span class=\"math\">\\langle sk_{\\mathcal{A}}, P_{\\mathcal{A}}\\rangle</span>. Only <span class=\"math\">P_{\\mathcal{C}}</span> value is public</li>\n<li><span class=\"math\">\\mathcal{C}</span> generates the set of random values <span class=\"math\">a_1, a_2,\\dots, a_n</span> and creates a first rank commitments for them as <span class=\"math\">A_i = a_iG, i\\in[1, n]</span></li>\n<li><span class=\"math\">\\mathcal{C}</span> selects one commitment <span class=\"math\">A_x</span>, assembles it with own public key as <span class=\"math\">R_{\\mathcal{C}} = P_{\\mathcal{C}}+A_x</span> and publishes only the hash value of the result <span class=\"math\">\\mathsf{hash}(R_{\\mathcal{C}})</span></li>\n<li><span class=\"math\">\\mathcal{C}</span> creates second rank commitments as <span class=\"math\">h_i = \\mathsf{hash}(A_i), i \\in[1,n]</span> and third rank commitments as <span class=\"math\">H_i = h_iG, i \\in[1,n]</span></li>\n<li><span class=\"math\">\\mathcal{C}</span> creates a proof <span class=\"math\">\\pi_a</span> that all third rank commitments were derived correctly, and one of the first rank commitments is used for assembling with <span class=\"math\">P_{\\mathcal{C}}</span></li>\n<li><span class=\"math\">\\mathcal{C}</span> proposes the set of third rank commitments to the <span class=\"math\">\\mathcal{A}</span> and provides <span class=\"math\">\\pi_a</span></li>\n<li><span class=\"math\">\\mathcal{A}</span> verifies the proof <span class=\"math\">\\pi_a</span> and selects one of the third-rank commitments <span class=\"math\">H_y</span> to assemble it with <span class=\"math\">P_{\\mathcal{A}}</span>. The result <span class=\"math\">R_{\\mathcal{A}}=P_{\\mathcal{A}}+H_y</span> is hashed <span class=\"math\">\\mathsf{hash}(R_{\\mathcal{A}})</span> and published</li>\n<li><span class=\"math\">\\mathcal{A}</span> creates a proof <span class=\"math\">\\pi_r</span> that one of the third rank commitments was used for assembling with <span class=\"math\">P_{\\mathcal{A}}</span> and sends it to <span class=\"math\">\\mathcal{C}</span>. Additionally the proof covers the knowledge of the discrete log of <span class=\"math\">P_{\\mathcal{A}}</span></li>\n<li><span class=\"math\">\\mathcal{C}</span> verifies the proof <span class=\"math\">\\pi_r</span> and if it\u2019s valid publishes the <span class=\"math\">R_{\\mathcal{C}}</span></li>\n<li><span class=\"math\">\\mathcal{A}</span> calculates <span class=\"math\">A_x = R_{\\mathcal{C}}-P_{\\mathcal{C}}</span></li>\n<li>If <span class=\"math\">\\mathsf{hash}(A_x)\\cdot G = H_y</span>, <span class=\"math\">\\mathcal{A}</span> won. Otherwise lost</li>\n</ol>\n<h1><a name=\"p-4107-an-example-of-thimbles-game-5\" class=\"anchor\" href=\"#p-4107-an-example-of-thimbles-game-5\"></a>An example of Thimbles Game</h1>\n<p>Finally, we can show how the interactive protocol we introduced allows the organization of a trustless thimbles game between two counterparties. So, having Alice and Bob, the game could be described as follows:</p>\n<ol>\n<li>Alice and Bob lock their coins.</li>\n<li>Alice generates two values and selects one of them (don\u2019t reveal the selected value to Bob). In other words, Alice chooses a thimble with a ball under it.</li>\n<li>Bob selects the thimble: takes value from proposed by Alice (and also doesn\u2019t reveal it).</li>\n<li>Alice reveals the value she selected initially.</li>\n<li>If Bob selected the same value \u2014 he can take all deposited coins. If not, Alice can spend coins after locktime.</li>\n</ol>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/2X/1/1a9861d911b02624ba23290a182f47a3af46698c.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/1a9861d911b02624ba23290a182f47a3af46698c\" title=\"Screenshot 2025-01-29 at 13.10.11\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/2X/1/1a9861d911b02624ba23290a182f47a3af46698c_2_432x500.png\" alt=\"Screenshot 2025-01-29 at 13.10.11\" data-base62-sha1=\"3NgThqa9NglFAQsE2fDHOeicY6E\" width=\"432\" height=\"500\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/2X/1/1a9861d911b02624ba23290a182f47a3af46698c_2_432x500.png, https://delvingbitcoin.org/uploads/default/optimized/2X/1/1a9861d911b02624ba23290a182f47a3af46698c_2_648x750.png 1.5x, https://delvingbitcoin.org/uploads/default/optimized/2X/1/1a9861d911b02624ba23290a182f47a3af46698c_2_864x1000.png 2x\" data-dominant-color=\"F7F7F7\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">Screenshot 2025-01-29 at 13.10.11</span><span class=\"informations\">1032\u00d71192 115 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>So Bob doesn\u2019t know which value was selected by Alice, Alice doesn\u2019t know what Bob selected. And we can go to the final stage when Alice takes her coins. For that Alice spends the first output, so publishes <span class=\"math\">P_a + A_1</span> value. Bob knows <span class=\"math\">P_a</span> so he can easily receive <span class=\"math\">A_1</span> value and corresponding <span class=\"math\">h_1 = \\mathsf{hash}_p(A_1)</span>.</p>\n<p>If the secret key <span class=\"math\">h_1 + sk_b</span> satisfies the address <span class=\"math\">\\mathsf{addr}_b</span>, Bob can take 10 BTC , locked on the second output. If not \u2014 Alice can spend them after the timelock.</p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 11,
  "updated_at": "2025-01-29T11:17:08.789Z",
  "reply_count": 1,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 189,
  "reads": 70,
  "readers_count": 69,
  "score": 989.0,
  "yours": false,
  "topic_id": 1409,
  "topic_slug": "emulating-op-rand",
  "topic_title": "Emulating OP_RAND",
  "topic_html_title": "Emulating OP_RAND",
  "category_id": 7,
  "display_username": "Alex",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "We propose a method of emulation of OP_RAND opcode on Bitcoin through a trustless interactive game between transaction counterparties. The game result is probabilistic and doesn't allow any party to cheat and increase their chance to win on any protocol step. The protocol can be organized in a way unrecognizable to any external party and doesn't require some specific scripts or Bitcoin protocol updates. We will show how the protocol works on the simple **Thimbles Game** and provide some initial thoughts about approaches and applications that can use the mentioned approach. \n\n# Intro\nBitcoin script doesn't directly allow putting randomness and constructing the spending flow based on that. So, realizing the flow \"*Alice and Bob put for 5 BTC each, and Bob takes everything if the coin comes up tails*\" wasn't possible upon the following assumptions:\n1. The transaction can't derive or take randomness from somewhere at the moment of confirmation\n2. Bitcoin Script can't inspect the block, past or future transactions\n3. Each party can receive the same stack's state after each opcode processing\n4. We can't control the ECDSA or Schnorr signature determinism\n5. Bitcoin doesn't support OP_RAND opcode =)\n\nAll the limitations mentioned led to the situation where we couldn't find trustless solutions that allow scrambling randomness and use it for a trustless protocol operating with bitcoins. We propose a way to organize it via a 2-party interactive protocol and show how these properties can be applied in the example of a thimbles game that takes bids in BTC.\n\n# Preliminaries\n$\\mathbb{G}$ a cyclic group of prime order $p$ written additively, $G \\in \\mathbb{G}$ is the group generator. $a \\in \\mathbb{F}_p$ is a scalar value and $A \\in \\mathbb{G}$ is a group element. $\\mathsf{hash}_p(m) \\rightarrow h\\in \\mathbb{F}_p$ is the cryptographic hash function that takes as an input an arbitrary message $m$ and returns the field element $h$. $\\mathsf{hash}_{160}(P) \\rightarrow \\mathsf{addr}\\in \\mathcal{A}$ is the function of hashing the public key with sha-256 and ripemd160 functions and receiving a valid bitcoin address as an output.\n\nWe define the relation for the proof $\\pi$ as $\\mathcal{R} = \\{(w;x) \\in \\mathcal{W} \\times \\mathcal{X}: \\phi_1(w,x), \\phi_2(w,x) , \\dots, \\phi_m(w,x)\\}$, where $w$ is a witness data, $x$ is a public data and $\\phi_1(w,x), \\phi_2(w,x) , \\dots, \\phi_m(w,x)$ the set of relations must be proven simultaneously.\n\nWe define a bitcoin transaction as $\\mathsf{TX}\\{(\\mathsf{id, i, proof})^{(n)};(\\mathsf{a BTC, cond})^{(m)}\\}$ with $n$ inputs and $m$ outputs, where $\\mathsf{id}$ is the hash of the previous transaction, $i$ - output's index, $\\mathsf{proof}$ - the list of data which is needed to transaction spending, $a$ - the number of coins in the output, $\\mathsf{cond}$ - scriptPubKey conditions. For example, the P2PKH method requires $\\mathsf{proof} \\leftarrow \\langle  \\mathsf{PK}, \\sigma\\rangle$ and $\\mathsf{cond}\\leftarrow \\langle$ OP_DUP, OP_HASH160, $\\mathsf{addr},$ OP_EQUALVERIFY, OP_CHECKSIG $\\rangle$. We are going to simplify the condition notation above to $\\mathsf{addr}$ when referring to the P2PKH approach.\n\n# EC Point covenant\nFirst of all, let's see how we can implement the transaction with two counterparties and the following conditions: \"It's possible to spend the second transaction output only in the case the first is spent\". Traditionally, it could be organized using a hash lock contract, but 1 -- it's recognizable; 2 -- it won't help us to implement the final game.\n\n![Screenshot 2025-01-29 at 13.04.56|690x450, 75%](upload://xtuh3wWgAUMYyy8vQqsTCkS7Y6B.png)\n\nIf Alice wants to spend her output, she needs to create a transaction and reveal a public key $P_a$ and the signature value.\n$$\n    \\mathsf{TX}_2\\{(\\mathsf{TX_1, 1, \\color{red}{\\langle P_a, \\sigma_{P_a}}(\\mathsf{TX_2})\\rangle});(\\mathsf{1 BTC, \\color{red}{addr_{a'}}})\\}\n$$\n\nAfter the transaction is published, Bob can extract $P_a$ and recover the $\\mathsf{hash}_p(P_a)$ value. Then the secret key for the second output is calculated as $sk = \\mathsf{hash}_p(P_a) + sk_b$ (only Bob controls $sk_b$), and Bob can construct the signature related to $P_b+C$ public key and corresponding address.\n$$\n    \\mathsf{TX}_3\\{(\\mathsf{TX_1, 2, \\color{blue}{\\langle P_b + C, \\sigma_{P_b + C}}(\\mathsf{TX_3})\\rangle});(\\mathsf{1 BTC, \\color{blue}{addr_{b'}}})\\}\n$$\n\nSo, we have built the first part needed for emulating the randomness and our thimbles game. We need to note that in the previous example, if Alice doesn't spend her output and doesn't publish $P_a$ anywhere, Bob can't recover the key and spend his output as well. If we need to provide an ability to spend these outputs after some time (if the game hasn't started), we can do it similarly to the payment channel construction --- lock coins to the multisignature and create a tx that can spend them after a defined period.\n\n# OP_RAND emulation protocol\nWe propose to emulate the OP_RAND opcode with an interactive protocol between parties involved in the transaction. Introducing the Challenger $\\mathcal{C}$ and Accepter $\\mathcal{A}$ roles we can define the OP_RAND emulation protocol as follows:\n\n1. $\\mathcal{C}$ and $\\mathcal{A}$ have their cryptographic keypairs $\\langle sk_{\\mathcal{C}}, P_{\\mathcal{C}}\\rangle$ and $\\langle sk_{\\mathcal{A}}, P_{\\mathcal{A}}\\rangle$. Only $P_{\\mathcal{C}}$ value is public\n2. $\\mathcal{C}$ generates the set of random values $a_1, a_2,\\dots, a_n$ and creates a first rank commitments for them as $A_i = a_iG, i\\in[1, n]$\n3. $\\mathcal{C}$ selects one commitment $A_x$, assembles it with own public key as $R_{\\mathcal{C}} = P_{\\mathcal{C}}+A_x$ and publishes only the hash value of the result $\\mathsf{hash}(R_{\\mathcal{C}})$\n4. $\\mathcal{C}$ creates second rank commitments as $h_i = \\mathsf{hash}(A_i), i \\in[1,n]$ and third rank commitments as $H_i = h_iG, i \\in[1,n]$\n5. $\\mathcal{C}$ creates a proof $\\pi_a$ that all third rank commitments were derived correctly, and one of the first rank commitments is used for assembling with $P_{\\mathcal{C}}$\n6. $\\mathcal{C}$ proposes the set of third rank commitments to the $\\mathcal{A}$ and provides $\\pi_a$\n7. $\\mathcal{A}$ verifies the proof $\\pi_a$ and selects one of the third-rank commitments $H_y$ to assemble it with $P_{\\mathcal{A}}$. The result $R_{\\mathcal{A}}=P_{\\mathcal{A}}+H_y$ is hashed $\\mathsf{hash}(R_{\\mathcal{A}})$ and published\n8. $\\mathcal{A}$ creates a proof $\\pi_r$ that one of the third rank commitments was used for assembling with $P_{\\mathcal{A}}$ and sends it to $\\mathcal{C}$. Additionally the proof covers the knowledge of the discrete log of $P_{\\mathcal{A}}$\n9. $\\mathcal{C}$ verifies the proof $\\pi_r$ and if it's valid publishes the $R_{\\mathcal{C}}$\n10. $\\mathcal{A}$ calculates $A_x = R_{\\mathcal{C}}-P_{\\mathcal{C}}$\n11. If $\\mathsf{hash}(A_x)\\cdot G = H_y$, $\\mathcal{A}$ won. Otherwise lost \n\n# An example of Thimbles Game\nFinally, we can show how the interactive protocol we introduced allows the organization of a trustless thimbles game between two counterparties. So, having Alice and Bob, the game could be described as follows:\n1. Alice and Bob lock their coins.\n2. Alice generates two values and selects one of them (don't reveal the selected value to Bob). In other words, Alice chooses a thimble with a ball under it.\n3. Bob selects the thimble: takes value from proposed by Alice (and also doesn't reveal it).\n4. Alice reveals the value she selected initially.\n5. If Bob selected the same value --- he can take all deposited coins. If not, Alice can spend coins after locktime.\n\n![Screenshot 2025-01-29 at 13.10.11|432x500](upload://3NgThqa9NglFAQsE2fDHOeicY6E.png)\n\nSo Bob doesn't know which value was selected by Alice, Alice doesn't know what Bob selected. And we can go to the final stage when Alice takes her coins. For that Alice spends the first output, so publishes $P_a + A_1$ value. Bob knows $P_a$ so he can easily receive $A_1$ value and corresponding $h_1 = \\mathsf{hash}_p(A_1)$. \n\nIf the secret key $h_1 + sk_b$ satisfies the address $\\mathsf{addr}_b$, Bob can take 10 BTC , locked on the second output. If not --- Alice can spend them after the timelock.",
  "actions_summary": [
    {
      "id": 2,
      "count": 2
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 246,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "We propose a method of emulation of OP_RAND opcode on Bitcoin through a trustless interactive game between transaction counterparties. The game result is probabilistic and doesn\u2019t allow any party to cheat and increase their chance to win on any protocol step. The protocol can be organized in a way u&hellip;",
  "truncated": true,
  "post_url": "/t/emulating-op-rand/1409/1",
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 2
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 2,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}