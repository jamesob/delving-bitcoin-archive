{
  "id": 3979,
  "name": "",
  "username": "rijndael",
  "avatar_template": "/letter_avatar_proxy/v4/letter/r/8797f3/{size}.png",
  "created_at": "2025-01-06T14:40:49.671Z",
  "cooked": "<p>to share some learnings in this area:</p>\n<p>the schnorr trick with CAT lets you get an inputs scriptpubkey, prevout, and index onto the stack. You can also get the outputs onto the stack. if you enforce that \u201cthis\u201d input\u2019s scriptpubkey matched an output scriptpubkey, then you can enforce that the spend is always happening back to the same taproot address. You can use this to build state machines where different states for your contract are different tapleafs that enforce the validity of a state transition (if you want all the gory details on this technique including the schnorr math, I gave a talk at Bitcoin++ that walks through it: <a href=\"https://t.co/tQJQoWepcK\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">https://youtu.be/U5qcL0hI30k?t=13016</a>)</p>\n<p>A technique I had played with in an <a href=\"https://github.com/taproot-wizards/purrfect_vault?tab=readme-ov-file#complete-withdrawal\" rel=\"noopener nofollow ugc\">early vault prototype was to pass state from TX_n to TX_n+1</a> by:</p>\n<ul>\n<li>putting a little state commitment in an output of TX_n</li>\n<li>in TX_n+1, reconstruct the (as <a class=\"mention\" href=\"/u/ajtowns\">@ajtowns</a> pointed out above) witness-stripped transaction on the stack, asserting the state commitment in the output from TX_n (either an OP_RETURN or a normal output if you\u2019re committing to a SPK)</li>\n<li>HASH256 the transaction on the stack to get the TXID, assert that it matches the prevout of the input</li>\n<li>you now have previously-committed state on the stack!</li>\n</ul>\n<p>the popular name for this technique now is the \u201cstate caboose\u201d (you pull it along). there are lots of cool things you can do with that (like committing to a withdrawal destination in a vault) but as <a class=\"mention\" href=\"/u/salvatoshi\">@salvatoshi</a> pointed out, one really cool thing is you can do a constant-sized inductive proof of contract validity. Here\u2019s how it works:</p>\n<p>Suppose you have a contract that is instantiated in TX FOO. let the TXID FOO be the contact instance ID. To spend a UTXO encumbered by FOO along, you have some set of validity rules for each step (for example, signature checks, amount validation logic, timelocks, whatever). Additionally, there is a \u201ccontract history\u201d check that you do. There are two cases you have to check for contract history (implemented as different tapleafs):</p>\n<ul>\n<li>the parent TXID is FOO</li>\n<li>the parent transaction spent from the contract scriptpubkey to the contract scriptpubkey</li>\n</ul>\n<p>if you have those two checks, then you always know that a UTXO in the contract is valid, because it came from either a valid state, or from the instance genesis. In the inductive case (coming from a valid state), you need to pass in a constant-ish amount of witness data (you can have different numbers of inputs and outputs, but its a bounded amount, so you in practice you write a script for the worst case), which means that you can actually use this in Script. The spender may need to do some extra work and state management, but the amount of data that hits the blockchain is bounded to a relatively small size.</p>\n<p>An extension on this that we\u2019ve done some experimenting with is that you can delegate your contract validity rules to another script. Here\u2019s the short version:</p>\n<ul>\n<li>in tx_n you make a commitment that says \u201cin the next transaction, I want my UTXO to obey the rules of this other contract (scriptpubkey)\u201d. This commitment is made in the state caboose described earlier</li>\n<li>in tx_n+1, you do your normal contract history check (the inductive bit above) and then you check if the input at index 0 (or whatever) is the scriptpubkey of the contract you delegated to. if not, fail</li>\n<li>now your contract instance UTXO has to follow the rules of that other contract! this is super useful as either an upgrade/extension mechanism</li>\n</ul>\n<p>we\u2019ve been experimenting with this stuff assuming only OP_CAT, but other opcodes make things a lot cleaner or open up other interesting avenues. for example, CCV or some TAPTWEAK makes state carrying cleaner and removes some technical limitations on the size of transactions in these contracts. CSFS lets us more easily do authenticated delegation (you can delegate to an approved contract) which you can do with just CAT using some funky signing over the state caboose but its a lot easier to do with CSFS. more-specialized introspection opcodes would make the whole thing easier to reason about and would have smaller scripts.</p>",
  "post_number": 11,
  "post_type": 1,
  "posts_count": 17,
  "updated_at": "2025-01-06T14:40:49.671Z",
  "reply_count": 0,
  "reply_to_post_number": 8,
  "quote_count": 0,
  "incoming_link_count": 82,
  "reads": 35,
  "readers_count": 34,
  "score": 417.0,
  "yours": false,
  "topic_id": 1353,
  "topic_slug": "contract-level-relative-timelocks-or-lets-talk-about-ancestry-proofs-and-singletons",
  "topic_title": "Contract-level Relative Timelocks (or, let's talk about ancestry proofs and singletons)",
  "topic_html_title": "Contract-level Relative Timelocks (or, let&rsquo;s talk about ancestry proofs and singletons)",
  "category_id": 7,
  "display_username": "",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "reply_to_user": {
    "id": 81,
    "username": "salvatoshi",
    "name": "salvatoshi",
    "avatar_template": "/user_avatar/delvingbitcoin.org/salvatoshi/{size}/72_2.png"
  },
  "bookmarked": false,
  "raw": "to share some learnings in this area: \n\nthe schnorr trick with CAT lets you get an inputs scriptpubkey, prevout, and index onto the stack. You can also get the outputs onto the stack. if you enforce that \"this\" input's scriptpubkey matched an output scriptpubkey, then you can enforce that the spend is always happening back to the same taproot address. You can use this to build state machines where different states for your contract are different tapleafs that enforce the validity of a state transition (if you want all the gory details on this technique including the schnorr math, I gave a talk at Bitcoin++ that walks through it: https://t.co/tQJQoWepcK)\n\nA technique I had played with in an [early vault prototype was to pass state from TX_n to TX_n+1](https://github.com/taproot-wizards/purrfect_vault?tab=readme-ov-file#complete-withdrawal) by:\n\n- putting a little state commitment in an output of TX_n\n- in TX_n+1, reconstruct the (as @ajtowns pointed out above) witness-stripped transaction on the stack, asserting the state commitment in the output from TX_n (either an OP_RETURN or a normal output if you're committing to a SPK)\n- HASH256 the transaction on the stack to get the TXID, assert that it matches the prevout of the input\n- you now have previously-committed state on the stack! \n\nthe popular name for this technique now is the \"state caboose\" (you pull it along). there are lots of cool things you can do with that (like committing to a withdrawal destination in a vault) but as @salvatoshi pointed out, one really cool thing is you can do a constant-sized inductive proof of contract validity. Here's how it works:\n\nSuppose you have a contract that is instantiated in TX FOO. let the TXID FOO be the contact instance ID. To spend a UTXO encumbered by FOO along, you have some set of validity rules for each step (for example, signature checks, amount validation logic, timelocks, whatever). Additionally, there is a \"contract history\" check that you do. There are two cases you have to check for contract history (implemented as different tapleafs):\n\n- the parent TXID is FOO\n- the parent transaction spent from the contract scriptpubkey to the contract scriptpubkey\n\nif you have those two checks, then you always know that a UTXO in the contract is valid, because it came from either a valid state, or from the instance genesis. In the inductive case (coming from a valid state), you need to pass in a constant-ish amount of witness data (you can have different numbers of inputs and outputs, but its a bounded amount, so you in practice you write a script for the worst case), which means that you can actually use this in Script. The spender may need to do some extra work and state management, but the amount of data that hits the blockchain is bounded to a relatively small size.\n\nAn extension on this that we've done some experimenting with is that you can delegate your contract validity rules to another script. Here's the short version:\n\n- in tx_n you make a commitment that says \"in the next transaction, I want my UTXO to obey the rules of this other contract (scriptpubkey)\". This commitment is made in the state caboose described earlier\n- in tx_n+1, you do your normal contract history check (the inductive bit above) and then you check if the input at index 0 (or whatever) is the scriptpubkey of the contract you delegated to. if not, fail\n- now your contract instance UTXO has to follow the rules of that other contract! this is super useful as either an upgrade/extension mechanism\n\nwe've been experimenting with this stuff assuming only OP_CAT, but other opcodes make things a lot cleaner or open up other interesting avenues. for example, CCV or some TAPTWEAK makes state carrying cleaner and removes some technical limitations on the size of transactions in these contracts. CSFS lets us more easily do authenticated delegation (you can delegate to an approved contract) which you can do with just CAT using some funky signing over the state caboose but its a lot easier to do with CSFS. more-specialized introspection opcodes would make the whole thing easier to reason about and would have smaller scripts.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 288,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "to share some learnings in this area: \nthe schnorr trick with CAT lets you get an inputs scriptpubkey, prevout, and index onto the stack. You can also get the outputs onto the stack. if you enforce that \u201cthis\u201d input\u2019s scriptpubkey matched an output scriptpubkey, then you can enforce that the spend i&hellip;",
  "truncated": true,
  "post_url": "/t/contract-level-relative-timelocks-or-lets-talk-about-ancestry-proofs-and-singletons/1353/11",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}