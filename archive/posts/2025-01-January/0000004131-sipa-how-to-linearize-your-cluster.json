{
  "id": 4131,
  "name": "Pieter Wuille",
  "username": "sipa",
  "avatar_template": "/user_avatar/delvingbitcoin.org/sipa/{size}/102_2.png",
  "created_at": "2025-01-31T20:58:53.179Z",
  "cooked": "<aside class=\"quote no-group quote-modified\" data-username=\"stefanwouldgo\" data-post=\"11\" data-topic=\"303\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/stefanwouldgo/48/664_2.png\" class=\"avatar\"> stefanwouldgo:</div>\n<blockquote>\n<p>The publication can be found at <a href=\"https://www.wellesu.com/10.1137/0218003\" class=\"inline-onebox\">A Fast Parametric Maximum Flow Algorithm and Applications | 10.1137/0218003-Sci_hub</a>. Yes, n is the number of nodes and m the number of edges, so that is cubic in the worst case.</p>\n</blockquote>\n</aside>\n<p>Thank you!</p>\n<p>Ok, here is my understanding so far. This paper, and two other papers it cites, introduce the concept of the \u201cmaximum-ratio closure problem\u201d, which is what we\u2019ve been calling \u201cmaximum-feerate topologically-valid subset finding\u201d.</p>\n<p>To explain it, we first need a simpler problem, the \u201cmaximum-weight closure problem\u201d, which, if applied to our setting, is effectively this:</p>\n<ul>\n<li>Input: a transaction graph with dependencies, fees, sizes, where fees can be positive or negative.</li>\n<li>Output: the maximum-<strong>fee</strong> topologically-valid subset (not feerate), which may be empty. This is trivial if all fees are positive (the entire graph is always maximal then), but nontrivial when negative fees are present.</li>\n<li>Algorithm:\n<ul>\n<li>Assign capacity <span class=\"math\">\\infty</span> to each dependency between transactions.</li>\n<li>Add two special nodes to the graph (in addition to the transactions), <span class=\"math\">s</span> (source) and <span class=\"math\">t</span> (sink).</li>\n<li>Add an edge from <span class=\"math\">s</span> to each transaction, with capacity equal to the transaction\u2019s fee.</li>\n<li>Add an adge from each transaction, with capacity <span class=\"math\">0</span>.</li>\n<li>Run a <a href=\"https://en.wikipedia.org/wiki/Minimum_cut\">minimum cut</a> algorithm between <span class=\"math\">s</span> and <span class=\"math\">t</span>. The side of the cut that includes <span class=\"math\">s</span> consists of the highest-fee topologically-valid subset.</li>\n</ul>\n</li>\n</ul>\n<p>Given this, one can define a slightly more complex problem:</p>\n<ul>\n<li>Input: a transaction graph with dependencies, fees, sizes, and a feerate <span class=\"math\">\\lambda</span>.</li>\n<li>Output: a non-empty topologically-valid subset with feerate <span class=\"math\">\\geq \\lambda</span> if one exists, or <span class=\"math\">\\varnothing</span> otherwise.</li>\n<li>Algorithm:\n<ul>\n<li>Subtract <span class=\"math\">\\lambda</span> from the feerates of all transactions, leaving their sizes unchanged (i.e., transform <span class=\"math\">(\\operatorname{fee},\\operatorname{size}) \\rightarrow (\\operatorname{fee} - \\lambda \\operatorname{size}, \\operatorname{size})</span>).</li>\n<li>Run the maximum-weight closure algorithm above, and return its result. The empty set has fee <span class=\"math\">0</span>, so if any topologically-valid subset with higher fee exists, one will be returned, and since <span class=\"math\">\\lambda</span> was subtracted from all feerates, the result necessarily has higher feerate than <span class=\"math\">\\lambda</span> in this case.</li>\n</ul>\n</li>\n</ul>\n<p>Finally, we can define the maximum-ratio closure problem, which is asking what the highest <span class=\"math\">\\lambda</span> is for which the previous problem has a non-empty set as answer (and what that set is). Three different papers use three different approaches:</p>\n<ul>\n<li><strong>Bisection search</strong>:\n<ul>\n<li>Paper: E. L. Lawler, \u201cSequencing jobs to minimize total weighted completion time subject to precedence constraints\u201d, 1978</li>\n<li>Approach: use a lower and upper bound on the maximum <span class=\"math\">\\lambda</span>, and use bisection search to find the highest for which a set exists.</li>\n<li>Complexity: <span class=\"math\">\\mathcal{O}(knm \\log(n^2/m))</span>, where <span class=\"math\">k</span> is the number of bits in the sizes/fees involved.</li>\n</ul>\n</li>\n<li><strong>FP algorithm</strong>:\n<ul>\n<li>Paper: J.C. Picard and M. Queyranne, \u201cSelected applications of minimum cuts in networks\u201d, 1982.</li>\n<li>Approach: maintain a single best solution, with associated feerate <span class=\"math\">\\lambda</span>. Run the previous algorithm with that <span class=\"math\">\\lambda</span> as input, and if it returns a non-empty solution, update lambda to be that set\u2019s feerate, and start over.</li>\n<li>Complexity: <span class=\"math\">\\mathcal{O}(n^2 m \\log(n^2/m))</span>, due to the fact that apparently no more than <span class=\"math\">\\mathcal{O}(n)</span> iterations are necessary.</li>\n</ul>\n</li>\n<li><strong>Parametric min-cut</strong>:\n<ul>\n<li>Paper: Giorgio Gallo, Michael D. Grigoriadis, and Robert E. Tarjan, \u201cA Fast Parametric Maximum Flow Algorithm And Applications\u201d, 1989.</li>\n<li>Approach: make the graph itself parametrized by <span class=\"math\">\\lambda</span>, and then solve the whole thing generically to find the maximum <span class=\"math\">\\lambda</span>, rather than needing multiple improvement steps. I don\u2019t quite get this yet.</li>\n<li>Complexity: <span class=\"math\">\\mathcal{O}(nm \\log(n^2/m))</span>.</li>\n</ul>\n</li>\n</ul>\n<p>Depending on whether the number of dependencies is linear or quadratic in the number of transactions, this last approach is <span class=\"math\">\\mathcal{O}(n^2 \\log{n})</span> or <span class=\"math\">\\mathcal{O}(n^3)</span> in the number of transactions. That is however just for a single topologically-valid subset, and for a full linearization we need to potentially run it <span class=\"math\">n</span> times, meaning an overall <span class=\"math\">\\mathcal{O}(n^3 \\log{n})</span> or <span class=\"math\">\\mathcal{O}(n^4)</span>. If it were somehow possible to reuse information from one subset-finding to the next this may be avoided, but that\u2019s not yet clear to me. Also, state of the art on minimum-cut algorithms has improved since 1989, so it\u2019s possible that even better is possible now.</p>",
  "post_number": 12,
  "post_type": 1,
  "updated_at": "2025-01-31T21:10:38.510Z",
  "reply_count": 0,
  "reply_to_post_number": 11,
  "quote_count": 1,
  "incoming_link_count": 0,
  "reads": 8,
  "readers_count": 7,
  "score": 1.4,
  "yours": false,
  "topic_id": 303,
  "topic_slug": "how-to-linearize-your-cluster",
  "topic_title": "How to linearize your cluster",
  "topic_html_title": "How to linearize your cluster",
  "category_id": 8,
  "display_username": "Pieter Wuille",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 3,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"stefanwouldgo, post:11, topic:303\"]\nThe publication can be found at https://www.wellesu.com/10.1137/0218003. Yes, n is the number of nodes and m the number of edges, so that is cubic in the worst case.\n[/quote]\n\nThank you!\n\nOk, here is my understanding so far. This paper, and two other papers it cites, introduce the concept of the \"maximum-ratio closure problem\", which is what we've been calling \"maximum-feerate topologically-valid subset finding\".\n\nTo explain it, we first need a simpler problem, the \"maximum-weight closure problem\", which, if applied to our setting, is effectively this:\n* Input: a transaction graph with dependencies, fees, sizes, where fees can be positive or negative.\n* Output: the maximum-**fee** topologically-valid subset (not feerate), which may be empty. This is trivial if all fees are positive (the entire graph is always maximal then), but nontrivial when negative fees are present.\n* Algorithm:\n  * Assign capacity $\\infty$ to each dependency between transactions.\n  * Add two special nodes to the graph (in addition to the transactions), $s$ (source) and $t$ (sink).\n  * Add an edge from $s$ to each transaction, with capacity equal to the transaction's fee.\n  * Add an adge from each transaction, with capacity $0$.\n  * Run a [minimum cut](https://en.wikipedia.org/wiki/Minimum_cut) algorithm between $s$ and $t$. The side of the cut that includes $s$ consists of the highest-fee topologically-valid subset.\n\nGiven this, one can define a slightly more complex problem:\n* Input: a transaction graph with dependencies, fees, sizes, and a feerate $\\lambda$.\n* Output: a non-empty topologically-valid subset with feerate $\\geq \\lambda$ if one exists, or $\\varnothing$ otherwise.\n* Algorithm:\n  * Subtract $\\lambda$ from the feerates of all transactions, leaving their sizes unchanged (i.e., transform $(\\operatorname{fee},\\operatorname{size}) \\rightarrow (\\operatorname{fee} - \\lambda \\operatorname{size}, \\operatorname{size})$).\n  * Run the maximum-weight closure algorithm above, and return its result. The empty set has fee $0$, so if any topologically-valid subset with higher fee exists, one will be returned, and since $\\lambda$ was subtracted from all feerates, the result necessarily has higher feerate than $\\lambda$ in this case.\n\nFinally, we can define the maximum-ratio closure problem, which is asking what the highest $\\lambda$ is for which the previous problem has a non-empty set as answer (and what that set is). Three different papers use three different approaches:\n* **Bisection search**:\n  * Paper: E. L. Lawler, \"Sequencing jobs to minimize total weighted completion time subject to precedence constraints\", 1978\n  * Approach: use a lower and upper bound on the maximum $\\lambda$, and use bisection search to find the highest for which a set exists.\n  * Complexity: $\\mathcal{O}(knm \\log(n^2/m))$, where $k$ is the number of bits in the sizes/fees involved.\n* **FP algorithm**:\n  * Paper: J.C. Picard and M. Queyranne, \"Selected applications of minimum cuts in networks\", 1982.\n  * Approach: maintain a single best solution, with associated feerate $\\lambda$. Run the previous algorithm with that $\\lambda$ as input, and if it returns a non-empty solution, update lambda to be that set's feerate, and start over.\n  * Complexity: $\\mathcal{O}(n^2 m \\log(n^2/m))$, due to the fact that apparently no more than $\\mathcal{O}(n)$ iterations are necessary.\n* **Parametric min-cut**:\n  * Paper: Giorgio Gallo, Michael D. Grigoriadis, and Robert E. Tarjan, \"A Fast Parametric Maximum Flow Algorithm And Applications\", 1989.\n  * Approach: make the graph itself parametrized by $\\lambda$, and then solve the whole thing generically to find the maximum $\\lambda$, rather than needing multiple improvement steps. I don't quite get this yet.\n  * Complexity: $\\mathcal{O}(nm \\log(n^2/m))$.\n\nDepending on whether the number of dependencies is linear or quadratic in the number of transactions, this last approach is $\\mathcal{O}(n^2 \\log{n})$ or $\\mathcal{O}(n^3)$ in the number of transactions. That is however just for a single topologically-valid subset, and for a full linearization we need to potentially run it $n$ times, meaning an overall $\\mathcal{O}(n^3 \\log{n})$ or $\\mathcal{O}(n^4)$. If it were somehow possible to reuse information from one subset-finding to the next this may be avoided, but that's not yet clear to me. Also, state of the art on minimum-cut algorithms has improved since 1989, so it's possible that even better is possible now.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 96,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}