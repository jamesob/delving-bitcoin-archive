{
  "id": 4112,
  "name": "Matt Morehouse",
  "username": "morehouse",
  "avatar_template": "/letter_avatar_proxy/v4/letter/m/df705f/{size}.png",
  "created_at": "2025-01-29T17:57:38.291Z",
  "cooked": "<p><em>The following disclosure is copied verbatim from a <a href=\"https://morehouse.github.io/lightning/ldk-duplicate-htlc-force-close-griefing/\" rel=\"noopener nofollow ugc\">blog post</a> on <a href=\"http://morehouse.github.io\" rel=\"noopener nofollow ugc\">morehouse.github.io</a>, reproduced here to facilitate discussion.</em></p>\n<p>LDK 0.1 and below are vulnerable to a griefing attack that causes all of the victim\u2019s channels to be force closed.\nUpdate to <a href=\"https://github.com/lightningdevkit/rust-lightning/releases/tag/v0.1.1\" rel=\"noopener nofollow ugc\">LDK 0.1.1</a> to protect your channels.</p>\n<h1><a name=\"p-4112-background-1\" class=\"anchor\" href=\"#p-4112-background-1\"></a>Background</h1>\n<p>Whenever a new payment is routed through a lightning channel, or whenever an existing payment is settled on the channel, the parties in that channel need to update their commitment transactions to match the new set of active HTLCs.\nDuring the course of these regular commitment updates, there is always a brief moment where one of the parties holds two valid commitment transactions.\nNormally that party immediately revokes the older commitment transaction after it receives a signature for the new one, bringing their number of valid commitment transactions back down to one.\nBut for that brief moment, the other party in the channel must be able to handle the case where <em>either</em> of the valid commitments confirms on chain.</p>\n<p>For this reason, LDK contains logic to detect when there\u2019s a difference between the counterparty\u2019s confirmed commitment transaction and the set of currently outstanding HTLCs.\nAny HTLCs missing from the confirmed commitment transaction are considered unrecoverable and are immediately failed backward on the upstream channel, while all other HTLCs  are left active until the resolution of the downstream HTLC on chain.</p>\n<p>Because the same payment hash and amount can be used for multiple HTLCs (e.g., <a href=\"https://github.com/lightning/bolts/blob/e92a7fae44bef8271d07377e95cee82e00acff62/04-onion-routing.md#basic-multi-part-payments\" rel=\"noopener nofollow ugc\">multi-part payments</a>), some extra data is stored to match HTLCs on commitment transactions against the set of outstanding HTLCs.\nLDK calls this extra data the \u201cHTLC source\u201d data, and LDK maintains this data for both of the counterparty\u2019s valid commitment transactions.</p>\n<h1><a name=\"p-4112-the-duplicate-htlc-failback-bug-2\" class=\"anchor\" href=\"#p-4112-the-duplicate-htlc-failback-bug-2\"></a>The Duplicate HTLC Failback Bug</h1>\n<p>Once a counterparty commitment transaction has been revoked, however, LDK forgets the HTLC source data for that commitment transaction to save memory.\nAs a result, if a revoked commitment transaction later confirms, LDK must attempt to match commitment transaction HTLCs up to outstanding HTLCs using only payment hashes and amounts.\nLDK\u2019s <a href=\"https://github.com/lightningdevkit/rust-lightning/blob/020be440b6d2dfea41820a137c7b26f43b289290/lightning/src/chain/channelmonitor.rs#L2624-L2684\" rel=\"noopener nofollow ugc\">logic</a> to do this matching works as follows:</p>\n<pre data-code-wrap=\"python\"><code class=\"lang-python\">for htlc, htlc_source in outstanding_htlcs:\n  if !confirmed_commitment_tx.is_revoked() &amp;&amp;\n      confirmed_commitment_tx.contains_source(htlc_source):\n    continue\n  if confirmed_commitment_tx.is_revoked() &amp;&amp;\n      confirmed_commitment_tx.contains_htlc(htlc.payment_hash, htlc.amount):\n    continue\n\n  failback_upstream_htlc(htlc_source)\n</code></pre>\n<p>Note that this logic short-circuits whenever an outstanding HTLC matches the payment hash and amount of an HTLC on the revoked commitment transaction.\nThus if there are multiple outstanding HTLCs with the same payment hash and amount, a single HTLC on the revoked commitment transaction can prevent all of the duplicate outstanding HTLCs from being failed back immediately.</p>\n<p>Those duplicate HTLCs remain outstanding until corresponding downstream HTLCs are resolved on chain.\nExcept, in this case there\u2019s only one downstream HTLC to resolve on chain, and its resolution only <a href=\"https://github.com/lightningdevkit/rust-lightning/blob/020be440b6d2dfea41820a137c7b26f43b289290/lightning/src/chain/channelmonitor.rs#L4460-L4468\" rel=\"noopener nofollow ugc\">triggers</a> <em>one</em> of the duplicate HTLCs to be failed upstream.\n<strong>All the other duplicate HTLCs are left outstanding indefinitely</strong>.</p>\n<h1><a name=\"p-4112-force-close-griefing-3\" class=\"anchor\" href=\"#p-4112-force-close-griefing-3\"></a>Force Close Griefing</h1>\n<p>Consider the following topology, where <code>B</code> is the victim and the <code>A_[1..N]</code> nodes are all the nodes that <code>B</code> has channels with.\n<code>M_1</code> and <code>M_2</code> are controlled by the attacker.</p>\n<pre><code class=\"lang-auto\">     -- A_1 --\n    /         \\\nM_1 --  ...  -- B -- M_2\n    \\         /\n     -- A_N --\n</code></pre>\n<p>The attacker routes <code>N</code> HTLCs from <code>M_1</code> to <code>M_2</code> using the same payment hash and amount for each, with each payment going through a different <code>A</code> node.\n<code>M_2</code> then confirms a revoked commitment that contains only one of the <code>N</code> HTLCs.\nDue to the duplicate HTLC failback bug, only one of the routed HTLCs gets failed backwards, while the remaining <code>N-1</code> HTLCs get stuck.</p>\n<p>Finally, after upstream HTLCs expire, all the <code>A</code> nodes with stuck HTLCs force close their channels with <code>B</code> to reclaim the stuck HTLCs.</p>\n<h2><a name=\"p-4112-attack-cost-4\" class=\"anchor\" href=\"#p-4112-attack-cost-4\"></a>Attack Cost</h2>\n<p>The attacker must broadcast a revoked commitment transaction, thereby forfeiting their channel balance.\nBut the size of the channel can be minimal, and the attacker can spend their balance down to the 1% reserve before executing the attack.\nAs a result, the cost of the attack can be negligible compared to the damage caused.</p>\n<h1><a name=\"p-4112-the-fix-5\" class=\"anchor\" href=\"#p-4112-the-fix-5\"></a>The Fix</h1>\n<p>Starting in v0.1.1, LDK <a href=\"https://github.com/lightningdevkit/rust-lightning/pull/3556\" rel=\"noopener nofollow ugc\">preemptively fails back</a> HTLCs when their deadlines approach if the downstream channel has been force closed or is in the process of force closing.\nWhile the main purpose of this behavior is to prevent cascading force closures when mempool fee rates spike, it also has a nice side effect of ensuring that duplicate HTLCs always get failed back eventually after a revoked commitment transaction confirms.\nAs a result, the duplicate HTLCs are never stuck long enough that the upstream nodes need to force close to reclaim them.</p>\n<h1><a name=\"p-4112-discovery-6\" class=\"anchor\" href=\"#p-4112-discovery-6\"></a>Discovery</h1>\n<p>This vulnerability was discovered during an audit of LDK\u2019s chain module.</p>\n<h2><a name=\"p-4112-timeline-7\" class=\"anchor\" href=\"#p-4112-timeline-7\"></a>Timeline</h2>\n<ul>\n<li><strong>2024-12-07:</strong> Vulnerability reported to the LDK security mailing list.</li>\n<li><strong>2025-01-27:</strong> Fix <a href=\"https://github.com/lightningdevkit/rust-lightning/pull/3556\" rel=\"noopener nofollow ugc\">merged</a>.</li>\n<li><strong>2025-01-28:</strong> LDK 0.1.1 released containing the fix, with public disclosure in <a href=\"https://github.com/lightningdevkit/rust-lightning/releases/tag/v0.1.1\" rel=\"noopener nofollow ugc\">release notes</a>.</li>\n<li><strong>2025-01-29:</strong> Detailed description of vulnerability published.</li>\n</ul>\n<h1><a name=\"p-4112-prevention-8\" class=\"anchor\" href=\"#p-4112-prevention-8\"></a>Prevention</h1>\n<p>Prior to the <a href=\"https://github.com/lightningdevkit/rust-lightning/commit/70ae45fea030ed1d2064918c7b023aa142387bc8\" rel=\"noopener nofollow ugc\">introduction</a> of the duplicate HTLC failback bug in 2022, LDK would immediately fail back <em>all</em> outstanding HTLCs once a revoked commitment reached 6 confirmations.\nThis was the safe and conservative thing to do \u2013 HTLC source information was missing, so proper matching of HTLCs could not be done.\nAnd since all outputs on the revoked commitment and HTLC transactions could be claimed via revocation key, there was no concern about losing funds if the downstream counterparty confirmed an HTLC claim before LDK could.</p>\n<h2><a name=\"p-4112-better-documentation-9\" class=\"anchor\" href=\"#p-4112-better-documentation-9\"></a>Better Documentation</h2>\n<p>Considering that LDK previously had a <a href=\"https://github.com/lightningdevkit/rust-lightning/commit/70ae45fea030ed1d2064918c7b023aa142387bc8#diff-b30410f22a759d5e664e05938af7ef2edd244c8a7872e7ada376055ff130088bL7296-L7314\" rel=\"noopener nofollow ugc\">test</a> explicitly checking for the original (conservative) failback behavior, it does appear that the original behavior was understood and intentional.\nUnfortunately the original author did not document the <em>reason</em> for the original behavior anywhere in the code or test.</p>\n<p>A single comment in the code would likely have been enough to prevent later contributors from introducing the buggy behavior:</p>\n<pre data-code-wrap=\"c\"><code class=\"lang-c\">// We fail back *all* outstanding HTLCs when a revoked commitment\n// confirms because we don't have HTLC source information for revoked\n// commitments, and attempting to match up HTLCs based on payment hashes\n// and amounts is inherently unreliable.\n//\n// Failing back all HTLCs after a 6 block delay is safe in this case\n// since we can use the revocation key to reliably claim all funds in the\n// downstream channel and therefore won't lose funds overall.\n</code></pre>\n<h1><a name=\"p-4112-takeaways-10\" class=\"anchor\" href=\"#p-4112-takeaways-10\"></a>Takeaways</h1>\n<ul>\n<li>Code documentation matters for preventing bugs.</li>\n<li>Update to LDK 0.1.1 for the vulnerability fix.</li>\n</ul>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2025-01-29T18:02:41.349Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 7,
  "readers_count": 6,
  "score": 1.4,
  "yours": false,
  "topic_id": 1410,
  "topic_slug": "disclosure-ldk-duplicate-htlc-force-close-griefing",
  "topic_title": "Disclosure: LDK Duplicate HTLC Force Close Griefing",
  "topic_html_title": "Disclosure: LDK Duplicate HTLC Force Close Griefing",
  "category_id": 8,
  "display_username": "Matt Morehouse",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "*The following disclosure is copied verbatim from a [blog post](https://morehouse.github.io/lightning/ldk-duplicate-htlc-force-close-griefing/) on [morehouse.github.io](http://morehouse.github.io), reproduced here to facilitate discussion.*\n\n\nLDK 0.1 and below are vulnerable to a griefing attack that causes all of the victim's channels to be force closed.\nUpdate to [LDK 0.1.1](https://github.com/lightningdevkit/rust-lightning/releases/tag/v0.1.1) to protect your channels.\n\n# Background\n\nWhenever a new payment is routed through a lightning channel, or whenever an existing payment is settled on the channel, the parties in that channel need to update their commitment transactions to match the new set of active HTLCs.\nDuring the course of these regular commitment updates, there is always a brief moment where one of the parties holds two valid commitment transactions.\nNormally that party immediately revokes the older commitment transaction after it receives a signature for the new one, bringing their number of valid commitment transactions back down to one.\nBut for that brief moment, the other party in the channel must be able to handle the case where *either* of the valid commitments confirms on chain.\n\nFor this reason, LDK contains logic to detect when there's a difference between the counterparty's confirmed commitment transaction and the set of currently outstanding HTLCs.\nAny HTLCs missing from the confirmed commitment transaction are considered unrecoverable and are immediately failed backward on the upstream channel, while all other HTLCs  are left active until the resolution of the downstream HTLC on chain.\n\nBecause the same payment hash and amount can be used for multiple HTLCs (e.g., [multi-part payments](https://github.com/lightning/bolts/blob/e92a7fae44bef8271d07377e95cee82e00acff62/04-onion-routing.md#basic-multi-part-payments)), some extra data is stored to match HTLCs on commitment transactions against the set of outstanding HTLCs.\nLDK calls this extra data the \"HTLC source\" data, and LDK maintains this data for both of the counterparty's valid commitment transactions.\n\n# The Duplicate HTLC Failback Bug\n\nOnce a counterparty commitment transaction has been revoked, however, LDK forgets the HTLC source data for that commitment transaction to save memory.\nAs a result, if a revoked commitment transaction later confirms, LDK must attempt to match commitment transaction HTLCs up to outstanding HTLCs using only payment hashes and amounts.\nLDK's [logic](https://github.com/lightningdevkit/rust-lightning/blob/020be440b6d2dfea41820a137c7b26f43b289290/lightning/src/chain/channelmonitor.rs#L2624-L2684) to do this matching works as follows:\n\n```python\nfor htlc, htlc_source in outstanding_htlcs:\n  if !confirmed_commitment_tx.is_revoked() &&\n      confirmed_commitment_tx.contains_source(htlc_source):\n    continue\n  if confirmed_commitment_tx.is_revoked() &&\n      confirmed_commitment_tx.contains_htlc(htlc.payment_hash, htlc.amount):\n    continue\n\n  failback_upstream_htlc(htlc_source)\n```\n\nNote that this logic short-circuits whenever an outstanding HTLC matches the payment hash and amount of an HTLC on the revoked commitment transaction.\nThus if there are multiple outstanding HTLCs with the same payment hash and amount, a single HTLC on the revoked commitment transaction can prevent all of the duplicate outstanding HTLCs from being failed back immediately.\n\nThose duplicate HTLCs remain outstanding until corresponding downstream HTLCs are resolved on chain.\nExcept, in this case there's only one downstream HTLC to resolve on chain, and its resolution only [triggers](https://github.com/lightningdevkit/rust-lightning/blob/020be440b6d2dfea41820a137c7b26f43b289290/lightning/src/chain/channelmonitor.rs#L4460-L4468) *one* of the duplicate HTLCs to be failed upstream.\n**All the other duplicate HTLCs are left outstanding indefinitely**.\n\n# Force Close Griefing\n\nConsider the following topology, where `B` is the victim and the `A_[1..N]` nodes are all the nodes that `B` has channels with.\n`M_1` and `M_2` are controlled by the attacker.\n\n```\n     -- A_1 --\n    /         \\\nM_1 --  ...  -- B -- M_2\n    \\         /\n     -- A_N --\n```\n\nThe attacker routes `N` HTLCs from `M_1` to `M_2` using the same payment hash and amount for each, with each payment going through a different `A` node.\n`M_2` then confirms a revoked commitment that contains only one of the `N` HTLCs.\nDue to the duplicate HTLC failback bug, only one of the routed HTLCs gets failed backwards, while the remaining `N-1` HTLCs get stuck.\n\nFinally, after upstream HTLCs expire, all the `A` nodes with stuck HTLCs force close their channels with `B` to reclaim the stuck HTLCs.\n\n## Attack Cost\n\nThe attacker must broadcast a revoked commitment transaction, thereby forfeiting their channel balance.\nBut the size of the channel can be minimal, and the attacker can spend their balance down to the 1% reserve before executing the attack.\nAs a result, the cost of the attack can be negligible compared to the damage caused.\n\n# The Fix\n\nStarting in v0.1.1, LDK [preemptively fails back](https://github.com/lightningdevkit/rust-lightning/pull/3556) HTLCs when their deadlines approach if the downstream channel has been force closed or is in the process of force closing.\nWhile the main purpose of this behavior is to prevent cascading force closures when mempool fee rates spike, it also has a nice side effect of ensuring that duplicate HTLCs always get failed back eventually after a revoked commitment transaction confirms.\nAs a result, the duplicate HTLCs are never stuck long enough that the upstream nodes need to force close to reclaim them.\n\n# Discovery\n\nThis vulnerability was discovered during an audit of LDK's chain module.\n\n## Timeline\n\n- **2024-12-07:** Vulnerability reported to the LDK security mailing list.\n- **2025-01-27:** Fix [merged](https://github.com/lightningdevkit/rust-lightning/pull/3556).\n- **2025-01-28:** LDK 0.1.1 released containing the fix, with public disclosure in [release notes](https://github.com/lightningdevkit/rust-lightning/releases/tag/v0.1.1).\n- **2025-01-29:** Detailed description of vulnerability published.\n\n# Prevention\n\nPrior to the [introduction](https://github.com/lightningdevkit/rust-lightning/commit/70ae45fea030ed1d2064918c7b023aa142387bc8) of the duplicate HTLC failback bug in 2022, LDK would immediately fail back *all* outstanding HTLCs once a revoked commitment reached 6 confirmations.\nThis was the safe and conservative thing to do -- HTLC source information was missing, so proper matching of HTLCs could not be done.\nAnd since all outputs on the revoked commitment and HTLC transactions could be claimed via revocation key, there was no concern about losing funds if the downstream counterparty confirmed an HTLC claim before LDK could.\n\n## Better Documentation\n\nConsidering that LDK previously had a [test](https://github.com/lightningdevkit/rust-lightning/commit/70ae45fea030ed1d2064918c7b023aa142387bc8#diff-b30410f22a759d5e664e05938af7ef2edd244c8a7872e7ada376055ff130088bL7296-L7314) explicitly checking for the original (conservative) failback behavior, it does appear that the original behavior was understood and intentional.\nUnfortunately the original author did not document the *reason* for the original behavior anywhere in the code or test.\n\nA single comment in the code would likely have been enough to prevent later contributors from introducing the buggy behavior:\n\n```c\n// We fail back *all* outstanding HTLCs when a revoked commitment\n// confirms because we don't have HTLC source information for revoked\n// commitments, and attempting to match up HTLCs based on payment hashes\n// and amounts is inherently unreliable.\n//\n// Failing back all HTLCs after a 6 block delay is safe in this case\n// since we can use the revocation key to reliably claim all funds in the\n// downstream channel and therefore won't lose funds overall.\n```\n\n# Takeaways\n\n- Code documentation matters for preventing bugs.\n- Update to LDK 0.1.1 for the vulnerability fix.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 47,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": "Github link was replaced with a permanent link",
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}