{
  "id": 3966,
  "name": "",
  "username": "ademan",
  "avatar_template": "/user_avatar/delvingbitcoin.org/ademan/{size}/337_2.png",
  "created_at": "2025-01-04T22:35:51.202Z",
  "cooked": "<h1><a name=\"p-3966-introduction-1\" class=\"anchor\" href=\"#p-3966-introduction-1\"></a>Introduction</h1>\n<p>Eltoo schemes have desirable properties such as simplicity, constant storage requirements, and compatibility with multi-party channels.\nHowever, naive eltoo is vulnerable to an attack where a dishonest party submits old update transactions in an attempt to delay settlement of the channel state until HTLCs have expired.</p>\n<p>This proposes a multi-party eltoo scheme that both allows penalizing dishonest behavior, and provides a bounded settlement time.\nBy giving parties only one chance to update the channel state on-chain, this scheme drastically reduces the ability of malicious parties to prevent honest settlement of the channel.</p>\n<p>This proposal depends on a way to make signed vector commitments, and check vector committed items against a spending transaction.\nI call this construct \"multi-transaction-signature\"s.\nThis proposal also depends on \u201cfloating transactions\u201d (as used in other eltoo schemes).\nTherefore, we will assume the LNHANCE soft fork, consisting of <code>OP_INTERNALKEY</code> (IK), <code>OP_CHECKTEMPLATEVERIFY</code> (CTV), <code>OP_CHECKSIGFROMSTACK</code> (CSFS), and <code>OP_PAIRCOMMIT</code> (PC).\nIn LNHANCE CTV+CSFS enables the \u201cfloating transactions\u201d construct, and CTV+CSFS+PC enable this \u201cmulti-transaction-signature\u201d construct.\nI believe this scheme could be adapted to ANYPREVOUT(APO)+CSFS+PC however I\u2019m admittedly less familiar with APO than I ought to be.</p>\n<h1><a name=\"p-3966-prior-art-2\" class=\"anchor\" href=\"#p-3966-prior-art-2\"></a>Prior Art</h1>\n<p>This is likely completely non-novel, but unfortunately I\u2019m unfamiliar with most of the literature.\nMy apologies to anyone whose work I almost certainly overlooked.</p>\n<h1><a name=\"p-3966-acknowledgements-3\" class=\"anchor\" href=\"#p-3966-acknowledgements-3\"></a>Acknowledgements</h1>\n<ul>\n<li>Moonsettler for review, tentative approval, and driving the current LNHANCE efforts and propsing an opcode (<code>OP_PAIRCOMMIT</code>) that enables this without all of the aspects of CAT that scare me.</li>\n<li>ReardenCode for review, comments, and being open to discussion on xitter which encouraged me greatly in getting back into Bitcoin dev.</li>\n<li>Everyone else who read this mess of a draft and offered comments or encouragement (or not-so-encouragement, you know who you are! lol)</li>\n<li>The all of the Bitcoin giants out there, I\u2019m not standing on your shoulders but I\u2019m probably stepping on your feet.</li>\n</ul>\n<h1><a name=\"p-3966-description-4\" class=\"anchor\" href=\"#p-3966-description-4\"></a>Description</h1>\n<p>This scheme bounds the number of times an update transaction can be submitted for a multi-party channel by limiting each party to submitting a single update.\nState updates occur similar to Decker, Russell, and Osuntokun eltoo by using <code>CHECKLOCKTIMEVERIFY</code>(CLTV) and an incrementing absolute timelock to ensure that update transactions can only be spent by either the appropriate settlement transaction or a newer update transaction.\nTo remove parties\u2019 ability to update more than once, every state update consists of a large set of update transactions arranged into generations.\nEvery generation allows a party to submit an update, but removes that party from the set of parties eligible to submit an update in the future.\nEach unique update transaction has a unique set of parties that are still eligible to submit updates.\nEach generation <code>1 &lt;= K &lt; N</code> has one transaction for every possible subset of length <code>N - K</code> of parties still eligible to submit updates.\nThese update transactions are divided into generations <code>1 &lt; K &lt; N</code> of <code>N choose K</code> transactions each.\nGeneration 1 prohibits 1 party from updating any further and has <code>N choose 1</code> transactions in it.\nGeneration 2 prohibits 2 parties from updating any further and has <code>N choose 2</code> transactions in it.\nGeneration N-1 prohibits all but 1 party from updating.\nThe total number of all of these update transactions is ~<code>2^N - 1 + N</code> which obviously grows very quickly.\nAfter an update transaction is accepted either because the last party submitted their update transaction, or by a timelock expiring, a settlement transaction splitting up the channel balance can be submitted as in other eltoo schemes.\nThis settlement transaction can optionally penalize misbehaving parties by dividing their channel balance among the honest parties.</p>\n<p>This scheme as described so far, achieves both of the stated goals, bounding settlement time and optionally enabling punishment.\nIt does, however, require sharing <code>2^N</code> signatures <em>per party</em>.</p>\n<p>Using <code>OP_PAIRCOMMIT</code> we can instead sign a commitment which authorizes many transactions, requiring only a merkle proof proving that a given CTV template has been signed, which indicates a valid state transition.\nThis compression from <code>2^N</code> signatures to one per party enormously reduces network communications required, and also makes it feasible to use musig to produce a single signature instead.\nHowever, for the sake of reduced interactivity, this proposal will use one signature per party.</p>\n<p>Outputs on each update transaction are Segwit v1, and have <code>P=N-K</code> tap leaves, one for every party still eligible to update.</p>\n<p>The witness includes a merkle proof that the transaction has been signed for, as well as signatures on that merkle root from all parties (even ones no longer eligible to update), <em>except</em> for the updating party.\nThe updating party provides a regular <code>SIGHASH_ALL</code> signature which is checked with <code>CHECKSIGVERIFY</code>.\nThis ensures other parties cannot submit an update transaction on behalf of a different party.\nEach tapscript follows a fixed path in the merkle tree, which binds it to transition to a specific transaction.\nIf parties could submit an arbitrary inclusion proof in their transaction, they could for instance fraudulently submit one that removes a different party from the eligible-to-update set.</p>\n<p>To illustrate, here is what a generation 0 tap script (from the commitment TX) might look like for A to update.\nBecause party A is updating, the spending transaction must match the CTV template <code>TX_BCD_TEMPLATE</code> whose output is identical to this transaction, but without a tap leaf for A to submit another update.\nThis removes party A\u2019s ability to update further.\nIn addition to this one, generation 0 would have equivalent tap leaves with scripts corresponding to each of the other parties in the channel.</p>\n<pre><code class=\"lang-auto\">witness: &lt;DSIG&gt; &lt;CSIG&gt; &lt;BSIG&gt; &lt;GEN2_MERKLE_ROOT&gt; &lt;ABD_ABC&gt; &lt;TX_ACD_TEMPLATE&gt; &lt;TX_BCD_TEMPLATE&gt; &lt;sig(A)&gt;\ntapscript:\n&lt;S+1&gt; CHECKLOCKTIMEVERIFY DROP # &lt;DSIG&gt; &lt;CSIG&gt; &lt;BSIG&gt; &lt;GEN2_MERKLE_ROOT&gt; &lt;ABD_ABC&gt; &lt;TX_ACD_TEMPLATE&gt; &lt;TX_BCD_TEMPLATE&gt; &lt;sig(A)&gt;\n&lt;A&gt;                            # &lt;DSIG&gt; &lt;CSIG&gt; &lt;BSIG&gt; &lt;GEN2_MERKLE_ROOT&gt; &lt;ABD_ABC&gt; &lt;TX_ACD_TEMPLATE&gt; &lt;TX_BCD_TEMPLATE&gt; &lt;sig(A)&gt; &lt;A&gt;\nCHECKSIGVERIFY                 # &lt;DSIG&gt; &lt;CSIG&gt; &lt;BSIG&gt; &lt;GEN2_MERKLE_ROOT&gt; &lt;ABD_ABC&gt; &lt;TX_ACD_TEMPLATE&gt; &lt;TX_BCD_TEMPLATE&gt;\nCHECKTEMPLATEVERIFY            # &lt;DSIG&gt; &lt;CSIG&gt; &lt;BSIG&gt; &lt;GEN2_MERKLE_ROOT&gt; &lt;ABD_ABC&gt; &lt;TX_ACD_TEMPLATE&gt; &lt;TX_BCD_TEMPLATE&gt;\nSWAP                           # &lt;DSIG&gt; &lt;CSIG&gt; &lt;BSIG&gt; &lt;GEN2_MERKLE_ROOT&gt; &lt;ABD_ABC&gt; &lt;TX_BCD_TEMPLATE&gt; &lt;TX_ACD_TEMPLATE&gt;\nPAIRCOMMIT                     # &lt;DSIG&gt; &lt;CSIG&gt; &lt;BSIG&gt; &lt;GEN2_MERKLE_ROOT&gt; &lt;ABD_ABC&gt; &lt;BCD_ACD&gt;\nSWAP                           # &lt;DSIG&gt; &lt;CSIG&gt; &lt;BSIG&gt; &lt;GEN2_MERKLE_ROOT&gt; &lt;BCD_ACD&gt; &lt;ABD_ABC&gt;\nPAIRCOMMIT                     # &lt;DSIG&gt; &lt;CSIG&gt; &lt;BSIG&gt; &lt;GEN2_MERKLE_ROOT&gt; &lt;GEN1_ROOT&gt;\nSWAP                           # &lt;DSIG&gt; &lt;CSIG&gt; &lt;BSIG&gt; &lt;GEN1_ROOT&gt; &lt;GEN2_MERKLE_ROOT&gt;\nPAIRCOMMIT                     # &lt;DSIG&gt; &lt;CSIG&gt; &lt;BSIG&gt; &lt;GEN1_MERKLE_ROOT&gt;\nTUCK                           # &lt;DSIG&gt; &lt;CSIG&gt; &lt;GEN1_MERKLE_ROOT&gt; &lt;BSIG&gt; &lt;GEN1_MERKLE_ROOT&gt;\n&lt;B&gt;                            # &lt;DSIG&gt; &lt;CSIG&gt; &lt;GEN1_MERKLE_ROOT&gt; &lt;BSIG&gt; &lt;GEN1_MERKLE_ROOT&gt; &lt;B&gt;\nCHECKSIGFROMSTACK              # &lt;DSIG&gt; &lt;CSIG&gt; &lt;GEN1_MERKLE_ROOT&gt; &lt;1|0&gt;\nVERIFY                         # &lt;DSIG&gt; &lt;CSIG&gt; &lt;GEN1_MERKLE_ROOT&gt;\nTUCK                           # &lt;DSIG&gt; &lt;GEN1_MERKLE_ROOT&gt; &lt;CSIG&gt; &lt;GEN1_MERKLE_ROOT&gt;\n&lt;C&gt;                            # &lt;DSIG&gt; &lt;GEN1_MERKLE_ROOT&gt; &lt;CSIG&gt; &lt;GEN1_MERKLE_ROOT&gt; &lt;C&gt;\nCHECKSIGFROMSTACK              # &lt;DSIG&gt; &lt;GEN1_MERKLE_ROOT&gt; &lt;1|0&gt;\nVERIFY                         # &lt;DSIG&gt; &lt;GEN1_MERKLE_ROOT&gt;\n&lt;D&gt;                            # &lt;DSIG&gt; &lt;GEN1_MERKLE_ROOT&gt; &lt;D&gt;\nCHECKSIGFROMSTACK              # &lt;1|0&gt;\n</code></pre>\n<p>The templates are arranged into a proof tree structured like this:</p>\n<pre><code class=\"lang-auto\">                                                       GEN1_MERKLE_ROOT\n                           GEN1_ROOT                                          GEN2_MERKLE_ROOT\n            BCD_ACD                         ABD_ABC                     GEN2_ROOT             GEN3_MERKLE_ROOT\nTX_BCD_TEMPLATE TX_ACD_TEMPLATE TX_ABD_TEMPLATE TX_ABC_TEMPLATE             |\n                                                                            |\n                                                   /---------------------------------------------------------\\\n                                              AB_AC_AD_BC                                                 BD_CD_DUMMY\n                                   AB_AC                         AD_BC                         BD_CD                    DUMMY\n                       TX_AB_TEMPLATE TX_AC_TEMPLATE TX_AD_TEMPLATE TX_BC_TEMPLATE TX_BD_TEMPLATE TX_CD_TEMPLATE\n\n</code></pre>\n<p>Every party signs the merkle root <code>GEN1_MERKLE_ROOT</code>, and that set of N signatures is sufficient for a state update.</p>\n<p>The presence of SWAP or NOP opcodes commits to the path in the merkle tree, and prevents invalid state transitions.</p>\n<p>Party B\u2019s script would instead have the sequence <code>NOP PAIRCOMMIT SWAP PAIRCOMMIT SWAP PAIRCOMMIT</code> since the <code>TX_ACD_TEMPLATE</code> which excludes B from further updates, is at index 1.\nParty C\u2019s script would have the sequence <code>SWAP PAIRCOMMIT NOP PAIRCOMMIT SWAP PAIRCOMMIT</code> since it is at index 2.\nYou can see how the index of the desired template in the ordered list of transaction templates corresponds to the SWAP and NOP opcodes as a little-endian representation of bits, with SWAP representing a 0 and a NOP representing a 1.\nLater generations are encoded in the lower branches of the tree.\nNOPs could be eliminated making some scripts shorter than others.\nI think this would have pretty negligible effects on incentives, but it\u2019s also simpler for me to think about with them in.</p>\n<h1><a name=\"p-3966-without-paircommit-5\" class=\"anchor\" href=\"#p-3966-without-paircommit-5\"></a>Without PAIRCOMMIT</h1>\n<p>This scheme works without PAIRCOMMIT but requires every party to share a signature for every valid state transition.\n~<code>2^N</code> signatures, per party, need to be shared to make this scheme work without PAIRCOMMIT.</p>\n<p>Transitions must be individually authorized, otherwise a blanket signature authorizing a transition to state S would permit any update transaction in <code>R&lt;S</code> to transition into any update transaction in state <code>S</code>.\nConsider a case where parties A,B, and C are eligible to update.\nWith blanket signatures from B, and C to state S, A could sign a transaction that transitions to a state where A and B are able to update, thereby stealing C\u2019s update opportunity and preserving their own.\nThis is why each valid state transition must be authorized individually.</p>\n<h1><a name=\"p-3966-practicality-6\" class=\"anchor\" href=\"#p-3966-practicality-6\"></a>Practicality</h1>\n<p>Each party is required to recompute the entire multi-transaction-signature commitment every channel state update, and this involves computing ~2^N transactions and building a merkle tree committing to all of them.\nThis means that there are ~<code>(N - 1) * 2^(N + 1) - 1</code> SHA256 operations required for a penalty scheme. (Take this math with a grain of salt, I haven\u2019t proved it out)\nA non-penalty scheme is around twice as fast because there is only one settlement transaction for all updates in a state, rather than one settlement transaction for every update in a state, this takes the complexity to ~<code>(N - 1) * 2^N - 1</code>.\nFor a penalty scheme this results in ~18431 SHA256 `operations for N=10 parties.\nThe amount of memory required should be logarithmic or better over N so memory should not be a limiting factor.\nWith a very plausible single core performance of ~1MHash/s on my aging mid-range desktop computer, that means calculating the commitment merkle root will optimistically take ~18ms.\nState recomputation can be significantly parallelized, so with 12 threads that\u2019s a best case scenario of 1.5ms.\nThis is all very optimistic and assumes the other computations in state recalculation take negligible time.\nThe practical limit for this scheme is probably in the 10-20 party range because the exponential growth more than doubles for every party added.\nUsing these very optimistic assumptions, 17 parties, a penalty scheme would take ~743ms to recalculate.\nI unfortunately don\u2019t know how many parties other schemes consider practical, but this scheme is fairly limited due to the exponential size of the number of potential update transactions that need to be computed.</p>\n<h1><a name=\"p-3966-conclusion-7\" class=\"anchor\" href=\"#p-3966-conclusion-7\"></a>Conclusion</h1>\n<p>I present a multi-party eltoo scheme with desirable functional properties but exponential computational complexity using one known technique and one likely known technique.\nWhat I\u2019m calling a \u201cmulti-transaction-signature\u201d permits a single signature to commit to multiple possible transactions representing state transitions.\nI suspect it\u2019s a trivial variant of vector commitments too uninteresting to have a name.\nThis scheme combines these \"multi-transaction-signature\"s with existing eltoo \u201cfloating transactions\u201d to enable a communication-efficient multiparty eltoo channel with or without penalty, and with bounded settlement time.\nParties are given one chance to update the on-chain state, and may (optionally) be penalized for publishing old state, which should make attacks economically unattractive.\nThe amount of computation required of parties is exponential on the number of parties N, however I believe that N~=10 is practical in this scheme, and also nearing the practical limit of multi-party channels anyway, due to the liveness requirements of participants, and network latency.\nI present this scheme mostly to solicit feedback, is this interesting enough to deserve a better writeup? this is obviously very incompletel.\nIs it interesting enough to warrant an implementation?\nMaybe it is only rehashing previous work, if please direct me to it so I can familiarize myself.\nMaybe, (my hope) is it inspires one of you wizards to invent a better or related scheme.</p>\n<h1><a name=\"p-3966-further-work-8\" class=\"anchor\" href=\"#p-3966-further-work-8\"></a>Further Work</h1>\n<ul>\n<li>Can this be safely integrated with a watchtower?</li>\n<li>Truncating the number of generations at some number <code>M &lt; N</code> could potentially drastically reduce the number of transactions to calculate and hash, as long as there are less malicious users than M it should remain secure.</li>\n<li>Can this scheme be adapted to tolerate offline users?\nEach generation of update transaction already partitions the parties into two sets, it <em>might</em> be possible to use something like this to split and merge a multi party pool if parties also sign for a set of merge transactions?\n<em>Maybe?</em>. It\u2019s worth exploring but there\u2019s a lot of pitfalls, there might not be a (good) way to do it.</li>\n<li>Since state update communications are reduced to a single signature per party, is it practical to use musig instead, to reduce the witness size of uncooperative closes?\nThat would require two rounds of communication, however it could still be practical.</li>\n<li>Is this interesting enough to implement? Maybe just to benchmark state update performance to gauge practical limits.</li>\n</ul>\n<p>Copied from here: <a href=\"https://gist.github.com/Ademan/4a14614fa850511d63a5b2a9b5104cb7\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">Multiparty Eltoo with bounded settlement and optional penalties \u00b7 GitHub</a></p>\n<p>I\u2019ve started on a proof of concept implementation here, it is <em>really</em> rough and I\u2019m only sharing it so other people can get benchmark numbers on their machines, there\u2019s probably many bugs: <a href=\"https://github.com/Ademan/multi-party-eltoo-with-bounded-settlement\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">GitHub - Ademan/multi-party-eltoo-with-bounded-settlement</a></p>\n<p>As could be expected from an exponentially growing complexity, this protocol maxes out fairly quickly, I\u2019m using a 20ms cutoff per an anonymous suggestion, however I think 10-12 parties should be pretty possible on similar hardware. Everything about the current version is very naive and could be improved, probably not enough to hit 16 parties though.</p>\n<p>On my 16 thread Ryzen 7 5700U (mobile processor) here\u2019s a graph of time taken to recalculate state vs number of parties. It <em>is</em> already using multiple cores via rayon, but only in one place and in a very naive way.</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/1X/ffc4476a064760f7446588759c203f7115598b7b.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/ffc4476a064760f7446588759c203f7115598b7b\" title=\"2025-01-04-154303_1064x616_scrot\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/1X/ffc4476a064760f7446588759c203f7115598b7b_2_690x399.png\" alt=\"2025-01-04-154303_1064x616_scrot\" data-base62-sha1=\"AuChp0IrpWLzhmzw0B5D9i2fBft\" width=\"690\" height=\"399\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/1X/ffc4476a064760f7446588759c203f7115598b7b_2_690x399.png, https://delvingbitcoin.org/uploads/default/optimized/1X/ffc4476a064760f7446588759c203f7115598b7b_2_1035x598.png 1.5x, https://delvingbitcoin.org/uploads/default/original/1X/ffc4476a064760f7446588759c203f7115598b7b.png 2x\" data-dominant-color=\"FCFCFC\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">2025-01-04-154303_1064x616_scrot</span><span class=\"informations\">1064\u00d7616 19.9 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>Aside from general comments I\u2019d like to know how many parties we\u2019re really shooting for in a multi-party channel. Is this a dead end, or somewhat interesting?</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2025-01-05T02:37:11.084Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 63,
  "reads": 12,
  "readers_count": 11,
  "score": 327.2,
  "yours": false,
  "topic_id": 1364,
  "topic_slug": "multi-party-eltoo-with-bounded-settlement",
  "topic_title": "Multi-Party Eltoo with bounded settlement",
  "topic_html_title": "Multi-Party Eltoo with bounded settlement",
  "category_id": 7,
  "display_username": "",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "# Introduction\n\nEltoo schemes have desirable properties such as simplicity, constant storage requirements, and compatibility with multi-party channels.\nHowever, naive eltoo is vulnerable to an attack where a dishonest party submits old update transactions in an attempt to delay settlement of the channel state until HTLCs have expired.\n\nThis proposes a multi-party eltoo scheme that both allows penalizing dishonest behavior, and provides a bounded settlement time.\nBy giving parties only one chance to update the channel state on-chain, this scheme drastically reduces the ability of malicious parties to prevent honest settlement of the channel.\n\nThis proposal depends on a way to make signed vector commitments, and check vector committed items against a spending transaction.\nI call this construct \"multi-transaction-signature\"s.\nThis proposal also depends on \"floating transactions\" (as used in other eltoo schemes).\nTherefore, we will assume the LNHANCE soft fork, consisting of `OP_INTERNALKEY` (IK), `OP_CHECKTEMPLATEVERIFY` (CTV), `OP_CHECKSIGFROMSTACK` (CSFS), and `OP_PAIRCOMMIT` (PC).\nIn LNHANCE CTV+CSFS enables the \"floating transactions\" construct, and CTV+CSFS+PC enable this \"multi-transaction-signature\" construct.\nI believe this scheme could be adapted to ANYPREVOUT(APO)+CSFS+PC however I'm admittedly less familiar with APO than I ought to be.\n\n# Prior Art\n\nThis is likely completely non-novel, but unfortunately I'm unfamiliar with most of the literature.\nMy apologies to anyone whose work I almost certainly overlooked.\n\n# Acknowledgements\n\n* Moonsettler for review, tentative approval, and driving the current LNHANCE efforts and propsing an opcode (`OP_PAIRCOMMIT`) that enables this without all of the aspects of CAT that scare me.\n* ReardenCode for review, comments, and being open to discussion on xitter which encouraged me greatly in getting back into Bitcoin dev.\n* Everyone else who read this mess of a draft and offered comments or encouragement (or not-so-encouragement, you know who you are! lol)\n* The all of the Bitcoin giants out there, I'm not standing on your shoulders but I'm probably stepping on your feet.\n\n# Description\n\nThis scheme bounds the number of times an update transaction can be submitted for a multi-party channel by limiting each party to submitting a single update.\nState updates occur similar to Decker, Russell, and Osuntokun eltoo by using `CHECKLOCKTIMEVERIFY`(CLTV) and an incrementing absolute timelock to ensure that update transactions can only be spent by either the appropriate settlement transaction or a newer update transaction.\nTo remove parties' ability to update more than once, every state update consists of a large set of update transactions arranged into generations.\nEvery generation allows a party to submit an update, but removes that party from the set of parties eligible to submit an update in the future.\nEach unique update transaction has a unique set of parties that are still eligible to submit updates.\nEach generation `1 <= K < N` has one transaction for every possible subset of length `N - K` of parties still eligible to submit updates.\nThese update transactions are divided into generations `1 < K < N` of `N choose K` transactions each.\nGeneration 1 prohibits 1 party from updating any further and has `N choose 1` transactions in it.\nGeneration 2 prohibits 2 parties from updating any further and has `N choose 2` transactions in it.\nGeneration N-1 prohibits all but 1 party from updating.\nThe total number of all of these update transactions is ~`2^N - 1 + N` which obviously grows very quickly.\nAfter an update transaction is accepted either because the last party submitted their update transaction, or by a timelock expiring, a settlement transaction splitting up the channel balance can be submitted as in other eltoo schemes.\nThis settlement transaction can optionally penalize misbehaving parties by dividing their channel balance among the honest parties.\n\nThis scheme as described so far, achieves both of the stated goals, bounding settlement time and optionally enabling punishment.\nIt does, however, require sharing `2^N` signatures *per party*.\n\nUsing `OP_PAIRCOMMIT` we can instead sign a commitment which authorizes many transactions, requiring only a merkle proof proving that a given CTV template has been signed, which indicates a valid state transition.\nThis compression from `2^N` signatures to one per party enormously reduces network communications required, and also makes it feasible to use musig to produce a single signature instead.\nHowever, for the sake of reduced interactivity, this proposal will use one signature per party.\n\nOutputs on each update transaction are Segwit v1, and have `P=N-K` tap leaves, one for every party still eligible to update.\n\nThe witness includes a merkle proof that the transaction has been signed for, as well as signatures on that merkle root from all parties (even ones no longer eligible to update), *except* for the updating party.\nThe updating party provides a regular `SIGHASH_ALL` signature which is checked with `CHECKSIGVERIFY`.\nThis ensures other parties cannot submit an update transaction on behalf of a different party.\nEach tapscript follows a fixed path in the merkle tree, which binds it to transition to a specific transaction.\nIf parties could submit an arbitrary inclusion proof in their transaction, they could for instance fraudulently submit one that removes a different party from the eligible-to-update set.\n\nTo illustrate, here is what a generation 0 tap script (from the commitment TX) might look like for A to update.\nBecause party A is updating, the spending transaction must match the CTV template `TX_BCD_TEMPLATE` whose output is identical to this transaction, but without a tap leaf for A to submit another update.\nThis removes party A's ability to update further.\nIn addition to this one, generation 0 would have equivalent tap leaves with scripts corresponding to each of the other parties in the channel.\n\n```\nwitness: <DSIG> <CSIG> <BSIG> <GEN2_MERKLE_ROOT> <ABD_ABC> <TX_ACD_TEMPLATE> <TX_BCD_TEMPLATE> <sig(A)>\ntapscript:\n<S+1> CHECKLOCKTIMEVERIFY DROP # <DSIG> <CSIG> <BSIG> <GEN2_MERKLE_ROOT> <ABD_ABC> <TX_ACD_TEMPLATE> <TX_BCD_TEMPLATE> <sig(A)>\n<A>                            # <DSIG> <CSIG> <BSIG> <GEN2_MERKLE_ROOT> <ABD_ABC> <TX_ACD_TEMPLATE> <TX_BCD_TEMPLATE> <sig(A)> <A>\nCHECKSIGVERIFY                 # <DSIG> <CSIG> <BSIG> <GEN2_MERKLE_ROOT> <ABD_ABC> <TX_ACD_TEMPLATE> <TX_BCD_TEMPLATE>\nCHECKTEMPLATEVERIFY            # <DSIG> <CSIG> <BSIG> <GEN2_MERKLE_ROOT> <ABD_ABC> <TX_ACD_TEMPLATE> <TX_BCD_TEMPLATE>\nSWAP                           # <DSIG> <CSIG> <BSIG> <GEN2_MERKLE_ROOT> <ABD_ABC> <TX_BCD_TEMPLATE> <TX_ACD_TEMPLATE>\nPAIRCOMMIT                     # <DSIG> <CSIG> <BSIG> <GEN2_MERKLE_ROOT> <ABD_ABC> <BCD_ACD>\nSWAP                           # <DSIG> <CSIG> <BSIG> <GEN2_MERKLE_ROOT> <BCD_ACD> <ABD_ABC>\nPAIRCOMMIT                     # <DSIG> <CSIG> <BSIG> <GEN2_MERKLE_ROOT> <GEN1_ROOT>\nSWAP                           # <DSIG> <CSIG> <BSIG> <GEN1_ROOT> <GEN2_MERKLE_ROOT>\nPAIRCOMMIT                     # <DSIG> <CSIG> <BSIG> <GEN1_MERKLE_ROOT>\nTUCK                           # <DSIG> <CSIG> <GEN1_MERKLE_ROOT> <BSIG> <GEN1_MERKLE_ROOT>\n<B>                            # <DSIG> <CSIG> <GEN1_MERKLE_ROOT> <BSIG> <GEN1_MERKLE_ROOT> <B>\nCHECKSIGFROMSTACK              # <DSIG> <CSIG> <GEN1_MERKLE_ROOT> <1|0>\nVERIFY                         # <DSIG> <CSIG> <GEN1_MERKLE_ROOT>\nTUCK                           # <DSIG> <GEN1_MERKLE_ROOT> <CSIG> <GEN1_MERKLE_ROOT>\n<C>                            # <DSIG> <GEN1_MERKLE_ROOT> <CSIG> <GEN1_MERKLE_ROOT> <C>\nCHECKSIGFROMSTACK              # <DSIG> <GEN1_MERKLE_ROOT> <1|0>\nVERIFY                         # <DSIG> <GEN1_MERKLE_ROOT>\n<D>                            # <DSIG> <GEN1_MERKLE_ROOT> <D>\nCHECKSIGFROMSTACK              # <1|0>\n```\n\nThe templates are arranged into a proof tree structured like this:\n\n```\n                                                       GEN1_MERKLE_ROOT\n                           GEN1_ROOT                                          GEN2_MERKLE_ROOT\n            BCD_ACD                         ABD_ABC                     GEN2_ROOT             GEN3_MERKLE_ROOT\nTX_BCD_TEMPLATE TX_ACD_TEMPLATE TX_ABD_TEMPLATE TX_ABC_TEMPLATE             |\n                                                                            |\n                                                   /---------------------------------------------------------\\\n                                              AB_AC_AD_BC                                                 BD_CD_DUMMY\n                                   AB_AC                         AD_BC                         BD_CD                    DUMMY\n                       TX_AB_TEMPLATE TX_AC_TEMPLATE TX_AD_TEMPLATE TX_BC_TEMPLATE TX_BD_TEMPLATE TX_CD_TEMPLATE\n\n```\n\nEvery party signs the merkle root `GEN1_MERKLE_ROOT`, and that set of N signatures is sufficient for a state update.\n\nThe presence of SWAP or NOP opcodes commits to the path in the merkle tree, and prevents invalid state transitions.\n\nParty B's script would instead have the sequence `NOP PAIRCOMMIT SWAP PAIRCOMMIT SWAP PAIRCOMMIT` since the `TX_ACD_TEMPLATE` which excludes B from further updates, is at index 1.\nParty C's script would have the sequence `SWAP PAIRCOMMIT NOP PAIRCOMMIT SWAP PAIRCOMMIT` since it is at index 2.\nYou can see how the index of the desired template in the ordered list of transaction templates corresponds to the SWAP and NOP opcodes as a little-endian representation of bits, with SWAP representing a 0 and a NOP representing a 1.\nLater generations are encoded in the lower branches of the tree.\nNOPs could be eliminated making some scripts shorter than others.\nI think this would have pretty negligible effects on incentives, but it's also simpler for me to think about with them in.\n\n# Without PAIRCOMMIT\n\nThis scheme works without PAIRCOMMIT but requires every party to share a signature for every valid state transition.\n~`2^N` signatures, per party, need to be shared to make this scheme work without PAIRCOMMIT.\n\nTransitions must be individually authorized, otherwise a blanket signature authorizing a transition to state S would permit any update transaction in `R<S` to transition into any update transaction in state `S`.\nConsider a case where parties A,B, and C are eligible to update.\nWith blanket signatures from B, and C to state S, A could sign a transaction that transitions to a state where A and B are able to update, thereby stealing C's update opportunity and preserving their own.\nThis is why each valid state transition must be authorized individually.\n\n# Practicality\n\nEach party is required to recompute the entire multi-transaction-signature commitment every channel state update, and this involves computing ~2^N transactions and building a merkle tree committing to all of them.\nThis means that there are ~`(N - 1) * 2^(N + 1) - 1` SHA256 operations required for a penalty scheme. (Take this math with a grain of salt, I haven't proved it out)\nA non-penalty scheme is around twice as fast because there is only one settlement transaction for all updates in a state, rather than one settlement transaction for every update in a state, this takes the complexity to ~`(N - 1) * 2^N - 1`.\nFor a penalty scheme this results in ~18431 SHA256 `operations for N=10 parties.\nThe amount of memory required should be logarithmic or better over N so memory should not be a limiting factor.\nWith a very plausible single core performance of ~1MHash/s on my aging mid-range desktop computer, that means calculating the commitment merkle root will optimistically take ~18ms.\nState recomputation can be significantly parallelized, so with 12 threads that's a best case scenario of 1.5ms.\nThis is all very optimistic and assumes the other computations in state recalculation take negligible time.\nThe practical limit for this scheme is probably in the 10-20 party range because the exponential growth more than doubles for every party added.\nUsing these very optimistic assumptions, 17 parties, a penalty scheme would take ~743ms to recalculate.\nI unfortunately don't know how many parties other schemes consider practical, but this scheme is fairly limited due to the exponential size of the number of potential update transactions that need to be computed.\n\n# Conclusion\n\nI present a multi-party eltoo scheme with desirable functional properties but exponential computational complexity using one known technique and one likely known technique.\nWhat I'm calling a \"multi-transaction-signature\" permits a single signature to commit to multiple possible transactions representing state transitions.\nI suspect it's a trivial variant of vector commitments too uninteresting to have a name.\nThis scheme combines these \"multi-transaction-signature\"s with existing eltoo \"floating transactions\" to enable a communication-efficient multiparty eltoo channel with or without penalty, and with bounded settlement time.\nParties are given one chance to update the on-chain state, and may (optionally) be penalized for publishing old state, which should make attacks economically unattractive.\nThe amount of computation required of parties is exponential on the number of parties N, however I believe that N~=10 is practical in this scheme, and also nearing the practical limit of multi-party channels anyway, due to the liveness requirements of participants, and network latency.\nI present this scheme mostly to solicit feedback, is this interesting enough to deserve a better writeup? this is obviously very incompletel.\nIs it interesting enough to warrant an implementation?\nMaybe it is only rehashing previous work, if please direct me to it so I can familiarize myself.\nMaybe, (my hope) is it inspires one of you wizards to invent a better or related scheme.\n\n# Further Work\n\n- Can this be safely integrated with a watchtower?\n- Truncating the number of generations at some number `M < N` could potentially drastically reduce the number of transactions to calculate and hash, as long as there are less malicious users than M it should remain secure.\n- Can this scheme be adapted to tolerate offline users?\n  Each generation of update transaction already partitions the parties into two sets, it *might* be possible to use something like this to split and merge a multi party pool if parties also sign for a set of merge transactions?\n  *Maybe?*. It's worth exploring but there's a lot of pitfalls, there might not be a (good) way to do it.\n- Since state update communications are reduced to a single signature per party, is it practical to use musig instead, to reduce the witness size of uncooperative closes?\n  That would require two rounds of communication, however it could still be practical.\n- Is this interesting enough to implement? Maybe just to benchmark state update performance to gauge practical limits.\n\nCopied from here: https://gist.github.com/Ademan/4a14614fa850511d63a5b2a9b5104cb7\n\nI've started on a proof of concept implementation here, it is *really* rough and I'm only sharing it so other people can get benchmark numbers on their machines, there's probably many bugs: https://github.com/Ademan/multi-party-eltoo-with-bounded-settlement\n\nAs could be expected from an exponentially growing complexity, this protocol maxes out fairly quickly, I'm using a 20ms cutoff per an anonymous suggestion, however I think 10-12 parties should be pretty possible on similar hardware. Everything about the current version is very naive and could be improved, probably not enough to hit 16 parties though.\n\nOn my 16 thread Ryzen 7 5700U (mobile processor) here's a graph of time taken to recalculate state vs number of parties. It *is* already using multiple cores via rayon, but only in one place and in a very naive way.\n\n![2025-01-04-154303_1064x616_scrot|690x399](upload://AuChp0IrpWLzhmzw0B5D9i2fBft.png)\n\nAside from general comments I'd like to know how many parties we're really shooting for in a multi-party channel. Is this a dead end, or somewhat interesting?",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 276,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "rocket",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}