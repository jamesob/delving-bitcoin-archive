{
  "id": 3959,
  "name": "Anthony Towns",
  "username": "ajtowns",
  "avatar_template": "/user_avatar/delvingbitcoin.org/ajtowns/{size}/417_2.png",
  "created_at": "2025-01-04T08:10:18.927Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"mcelrath\" data-post=\"8\" data-topic=\"1331\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/mcelrath/48/521_2.png\" class=\"avatar\"> mcelrath:</div>\n<blockquote>\n<p>As far as not punishing latency, the algorithm will pay miners proportional to their work as long as their latency isn\u2019t excessive. At high latencies the miner is likely to create Bitcoin orphans and reduce the profit of the pool.</p>\n</blockquote>\n</aside>\n<p>I think it would be interesting to analyse this both as a difficulty adjustment for a standalone consensus system (as if bitcoin didn\u2019t exist), and as its intended purpose as a way of coordinating reward sharing for bitcoin mining. I think those scenarios are a bit different \u2013 for example some form of 50% attack on the former is probably catastrophic, but the same \u201c50% attack\u201d on the latter as long as its kept at the pool level, even when completely successful, can just be dealt with as \u201cokay you\u2019re not letting us in your pool, so we\u2019ll make our own pool\u201d and be completely fine.</p>\n<p>In particular, if you have 10% of bitcoin hashrate in a single data centre, and it all uses a single pool with 1ms latency, and meanwhile 70% of hashrate is distributed evenly around the world at 300ms latency on average, then just having two braidpools that run independently is likely fine for everyone concerned. But if the braid were the thing people were trying to come to consensus on diretly, then a chain/braid split isn\u2019t an acceptable outcome.</p>\n<aside class=\"quote no-group\" data-username=\"mcelrath\" data-post=\"8\" data-topic=\"1331\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/mcelrath/48/521_2.png\" class=\"avatar\"> mcelrath:</div>\n<blockquote>\n<p>Bitcoin\u2019s orphan rate is around 1%</p>\n</blockquote>\n</aside>\n<aside class=\"quote no-group\" data-username=\"zawy\" data-post=\"9\" data-topic=\"1331\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/zawy/48/750_2.png\" class=\"avatar\"> zawy:</div>\n<blockquote>\n<p>I think Bitcoin\u2019s orphan rate is about 0.04% to agree with the orphan estimate of e^(-latency/600).</p>\n</blockquote>\n</aside>\n<p>0.04% (one every 2500 blocks) seems roughly accurate based on <a href=\"https://fork.observer/\">fork.observer\u2019s reports</a>. I think the orphan rate due to network latency estimate is <span class=\"math\">1-e^{-a/600}</span> so at 0.04% that gives a latency of <span class=\"math\">a \\approx 240</span> milliseconds which seems plausible, presuming the only orphans we actually observe are due to latency.</p>\n<p>With the same latency applying to a global braidpool, but an expected block rate of 100 blocks per ten minutes (10% hashrate at 1/1000th of the difficulty), then the expected \u201corphan\u201d rate is about 4%. Conversely, if you target an expected \u201corphan\u201d rate of 44%, with 10% hashrate, that means beads are 14,500 times easier than blocks, rather than 1000 times easier?</p>\n<aside class=\"quote no-group\" data-username=\"zawy\" data-post=\"5\" data-topic=\"1331\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/zawy/48/750_2.png\" class=\"avatar\"> zawy:</div>\n<blockquote>\n<p>Here\u2019s the response of different algorithms to 2x increases in hashrate and latency.</p>\n</blockquote>\n</aside>\n<aside class=\"quote no-group\" data-username=\"zawy\" data-post=\"7\" data-topic=\"1331\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/zawy/48/750_2.png\" class=\"avatar\"> zawy:</div>\n<blockquote>\n<p>The DAA does a \u201clook-back\u201d of only 7 blocks to have a fast consensus.</p>\n</blockquote>\n</aside>\n<aside class=\"quote no-group\" data-username=\"mcelrath\" data-post=\"8\" data-topic=\"1331\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/mcelrath/48/521_2.png\" class=\"avatar\"> mcelrath:</div>\n<blockquote>\n<p>As far as not punishing latency, the algorithm will pay miners proportional to their work as long as their latency isn\u2019t excessive.</p>\n</blockquote>\n</aside>\n<p>I think/conjecture the look-back/latency constraints are probably critical for this approach\u2019s ability to come to consensus between subsets of hashrate with very different latency properties \u2013 the 200:1 latency ratio I suggested would (I think) make it difficult for the latest beads from the two groups to have sufficiently common ancestry that they get merged; whereas I\u2019d expect a 2:1 latency ratio to be more-or-less fine.</p>\n<p>If there\u2019s a latency ratio limit where good behaviour breaks down, I think that would be interesting to understand, even if the result is just \u201cwell, we automatically have two distinct braid pools in that case, which each pay their members out fairly from the bitcoin rewards for that pool\u2019s found blocks\u201d.</p>\n<aside class=\"quote no-group\" data-username=\"mcelrath\" data-post=\"8\" data-topic=\"1331\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/mcelrath/48/521_2.png\" class=\"avatar\"> mcelrath:</div>\n<blockquote>\n<p>The above idea is contrary to Zawy\u2019s suggestion to orphan high latency beads, I want to include them but not pay them.</p>\n</blockquote>\n</aside>\n<p>That sounds a bit exploitable to me (presuming including them means they contribute to the most-work comparison) \u2013 if you\u2019ve got a signfiicant portion of hashrate, just artificially declare delay everyone else\u2019s beads by X milliseconds, before you include them in your braid. Every now and then everyone else will have a run of bad luck and your tip will become the best tip, making their work not result in a payout. Perhaps the feasibility of this depends on the relationship between X and when payouts get finalised.</p>",
  "post_number": 15,
  "post_type": 1,
  "updated_at": "2025-01-04T08:10:18.927Z",
  "reply_count": 1,
  "reply_to_post_number": 8,
  "quote_count": 4,
  "incoming_link_count": 0,
  "reads": 7,
  "readers_count": 6,
  "score": 6.2,
  "yours": false,
  "topic_id": 1331,
  "topic_slug": "fastest-possible-pow-via-simple-dag",
  "topic_title": "Fastest-possible PoW via Simple DAG",
  "topic_html_title": "Fastest-possible PoW via Simple DAG",
  "category_id": 7,
  "display_username": "Anthony Towns",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"mcelrath, post:8, topic:1331\"]\nAs far as not punishing latency, the algorithm will pay miners proportional to their work as long as their latency isn\u2019t excessive. At high latencies the miner is likely to create Bitcoin orphans and reduce the profit of the pool.\n[/quote]\n\nI think it would be interesting to analyse this both as a difficulty adjustment for a standalone consensus system (as if bitcoin didn't exist), and as its intended purpose as a way of coordinating reward sharing for bitcoin mining. I think those scenarios are a bit different -- for example some form of 50% attack on the former is probably catastrophic, but the same \"50% attack\" on the latter as long as its kept at the pool level, even when completely successful, can just be dealt with as \"okay you're not letting us in your pool, so we'll make our own pool\" and be completely fine.\n\nIn particular, if you have 10% of bitcoin hashrate in a single data centre, and it all uses a single pool with 1ms latency, and meanwhile 70% of hashrate is distributed evenly around the world at 300ms latency on average, then just having two braidpools that run independently is likely fine for everyone concerned. But if the braid were the thing people were trying to come to consensus on diretly, then a chain/braid split isn't an acceptable outcome.\n\n[quote=\"mcelrath, post:8, topic:1331\"]\nBitcoin\u2019s orphan rate is around 1%\n[/quote]\n\n[quote=\"zawy, post:9, topic:1331\"]\nI think Bitcoin\u2019s orphan rate is about 0.04% to agree with the orphan estimate of e^(-latency/600).\n[/quote]\n\n0.04% (one every 2500 blocks) seems roughly accurate based on [fork.observer's reports](https://fork.observer/). I think the orphan rate due to network latency estimate is $1-e^{-a/600}$ so at 0.04% that gives a latency of $a \\approx 240$ milliseconds which seems plausible, presuming the only orphans we actually observe are due to latency.\n\nWith the same latency applying to a global braidpool, but an expected block rate of 100 blocks per ten minutes (10% hashrate at 1/1000th of the difficulty), then the expected \"orphan\" rate is about 4%. Conversely, if you target an expected \"orphan\" rate of 44%, with 10% hashrate, that means beads are 14,500 times easier than blocks, rather than 1000 times easier?\n\n[quote=\"zawy, post:5, topic:1331\"]\nHere\u2019s the response of different algorithms to 2x increases in hashrate and latency.\n[/quote]\n\n[quote=\"zawy, post:7, topic:1331\"]\nThe DAA does a \u201clook-back\u201d of only 7 blocks to have a fast consensus.\n[/quote]\n\n[quote=\"mcelrath, post:8, topic:1331\"]\nAs far as not punishing latency, the algorithm will pay miners proportional to their work as long as their latency isn\u2019t excessive.\n[/quote]\n\nI think/conjecture the look-back/latency constraints are probably critical for this approach's ability to come to consensus between subsets of hashrate with very different latency properties -- the 200:1 latency ratio I suggested would (I think) make it difficult for the latest beads from the two groups to have sufficiently common ancestry that they get merged; whereas I'd expect a 2:1 latency ratio to be more-or-less fine.\n\nIf there's a latency ratio limit where good behaviour breaks down, I think that would be interesting to understand, even if the result is just \"well, we automatically have two distinct braid pools in that case, which each pay their members out fairly from the bitcoin rewards for that pool's found blocks\".\n\n[quote=\"mcelrath, post:8, topic:1331\"]\nThe above idea is contrary to Zawy\u2019s suggestion to orphan high latency beads, I want to include them but not pay them.\n[/quote]\n\nThat sounds a bit exploitable to me (presuming including them means they contribute to the most-work comparison) -- if you've got a signfiicant portion of hashrate, just artificially declare delay everyone else's beads by X milliseconds, before you include them in your braid. Every now and then everyone else will have a run of bad luck and your tip will become the best tip, making their work not result in a payout. Perhaps the feasibility of this depends on the relationship between X and when payouts get finalised.",
  "actions_summary": [],
  "moderator": true,
  "admin": true,
  "staff": true,
  "user_id": 3,
  "hidden": false,
  "trust_level": 4,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}