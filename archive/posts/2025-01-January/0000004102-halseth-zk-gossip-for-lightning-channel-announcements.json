{
  "id": 4102,
  "name": "Johan T. Halseth",
  "username": "halseth",
  "avatar_template": "/user_avatar/delvingbitcoin.org/halseth/{size}/198_2.png",
  "created_at": "2025-01-28T13:04:49.946Z",
  "cooked": "<p>Hi, I would like to propose an extension to the taproot gossip proposal, that\nmakes it possible to avoid revealing the channel outpoint.</p>\n<p>It is based on Utreexo and zero-knowledge proofs, and is accompanied with a\nproof-of-concept Rust implementation.</p>\n<p>The proposal is created as an extension to the gossip v1.75 proposal for\ntaproot channel gossip and intended to be used as an optional feature for\nprivacy conscious users.</p>\n<h3><a name=\"p-4102-taproot-gossip-gossip-v175-1\" class=\"anchor\" href=\"#p-4102-taproot-gossip-gossip-v175-1\"></a>Taproot gossip (gossip v1.75)</h3>\n<p>See Elle\u2019s deep dive here: <a href=\"https://delvingbitcoin.org/t/updates-to-the-gossip-1-75-proposal-post-ln-summit-meeting/1202\">Updates to the Gossip 1.75 proposal post LN summit meeting</a>.</p>\n<p>Tl;dr: a new <code>channel_announcement_2</code> message that carries a Musig2 signature\nproving the two nodes control a certain UTXO.</p>\n<p>An example <code>channel_announcement_2</code>:</p>\n<pre data-code-wrap=\"json\"><code class=\"lang-json\">{\n  \"ChainHash\": \"000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f\",\n  \"ShortChannelID\": \"1000:100:0\",\n  \"Capacity\": 100000,\n  \"NodeID1\": \"0246175dd633eaa1c1684a9e15d218d247e421b009642f3e82e9f138ad9d645e03\",\n  \"NodeID2\": \"02b651f157c5cf7bfbf07d52855c21aca861d7e3b8711d84cb04149e0a67151e16\",\n  \"BitcoinKey1\": \"027fc1e3f6f5a67b804cb86d813adf94f89ea1de63f630607d4c31242d58306043\",\n  \"BitcoinKey2\": \"03fef5084b98aa37757acce81d25148cfdb9592142567c6265e39b082e73c4d54\",\n  \"MerkleRootHash\": null,\n  \"Signature\": {\n    \"bytes\": \"5c14ad15b614c9f91fd5c66b7bfe3f3552427c6d5e6d598f5838c5d219cdd0b89c72ad6a3effe5d995387563b80dfb1b59da599c936c705ad8dfd6da8288b89b\",\n    \"sigType\": 1\n  },\n}\n</code></pre>\n<h2><a name=\"p-4102-zk-gossip-2\" class=\"anchor\" href=\"#p-4102-zk-gossip-2\"></a>ZK-gossip</h2>\n<p>What we propose is an extension to the taproot gossip proposal, that makes it\npossible for the two channel parties to remove the link between the channel and\non-chain output.</p>\n<p>In order to still be able to protect the network from channel DOS attacks, we\nrequire the channel announcement message to include a ZK-proof that proves the\ninclusion of the channel in the UTXO set, and that it is controlled by the two\nnodes in the graph.</p>\n<p>In order to create the ZK proof with these properties, we start with the data\nalready contained in the regular taproot gossip channel announcment:</p>\n<ol>\n<li><code>node_id_1</code>, <code>node_id_2</code></li>\n<li><code>bitcoin_key_1</code>, <code>bitcoin_key_2</code></li>\n<li><code>merkle_root_hash</code></li>\n<li><code>signature</code></li>\n<li><code>capacity</code></li>\n</ol>\n<p>(we\u2019ll ignore the <code>merkle_root_hash</code> for now).</p>\n<p>In addition we assemble a Utreexo accumulator and a proof for the channel\noutput\u2019s inclusion in this accumulator.</p>\n<p>Using these pieces of data we create a ZK-proof that validates the following:</p>\n<ol>\n<li><code>bitcoin_keys = MuSig2.KeySort(bitcoin_key_1, bitcoin_key_2)</code></li>\n<li><code>P_agg_out = MuSig2.KeyAgg(bitcoin_keys)</code></li>\n<li>Check <code>capacity &lt;= vout.value</code></li>\n<li>Check <code>P_agg_out = vout.script_pubkey</code></li>\n<li>Verify that <code>vout</code> is in the UTXO set using the utreexo accumulator and proof.</li>\n<li><code>P_agg = MuSig2.KeyAgg(MuSig2.KeySort(node_id_1, node_id_2, bitcoin_key_1, bitcoin_key_2))</code></li>\n<li>Verify the signaure against <code>P_agg</code></li>\n<li><code>pk_hash = hash(bitcoin_keys[0] || bitcoin_keys[1])</code></li>\n</ol>\n<p>We then output (or make public) the two <code>node_ids</code>, the signed data, utreexo accumulator and <code>pk_hash</code>.</p>\n<p>Now we can output a proof (ZK-SNARK, groth16) of 256 bytes, and assemble a new\n<code>channel_announcement_zk</code> (since messages are TLV, this should really be\ncombined with the <code>channel_announcement_2</code> with appropriate fields set):</p>\n<pre data-code-wrap=\"json\"><code class=\"lang-json\">{\n  \"ChainHash\": \"000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f\",\n  \"Capacity\": 100000,\n  \"NodeID1\": \"0246175dd633eaa1c1684a9e15d218d247e421b009642f3e82e9f138ad9d645e03\",\n  \"NodeID2\": \"02b651f157c5cf7bfbf07d52855c21aca861d7e3b8711d84cb04149e0a67151e16\",\n  \"UtreexoRoot\": \"4b07311e3e774f0db3bcedee47c56fe30da326d9271d1a2558a5975ab4214478\",\n  \"ZKType\": \"9bce41211c9d71e1ed07a2a5244f95ab98b0ba3a6e95dda9c87ba071ff871418\",\n  \"ZKProof\": \"6508d8476086238076bb673005f9ef3bfe7f0c198a1d4f6fcee65e19478b422c512aefd004f8f476d0ef5939dc4339e3e19347a6ab60fe5714e9d3e3e77417499dbf18da68dfd942d79c8bf4cf811f615334f4643befb267a189d8e6b05509760bfd7add9aa9ecbce38db277bf11b1b94e147b504e75be5405066421aad8e10b49d105a33241742bafe611b4025ffa35d066fc87e11df595030d18b962ad5917ef1f73c97d660c1e62c7e392d51821ec342b2faf763d2a9177d13471c8b2a829578fd401d76aa8ae5642937f48573e657a5af14fda5f7a39216dda05b183121913088d2d0e0c1902d1f656b5d769b95040a40ef5a9ffd87f550545b0a5bc2505\",\n  \"PKHash\": \"be7d602934c5ce95000ee989748f6c892ce16fb4276389ec15bc0764fbc4bea5\"\n}\n</code></pre>\n<p><code>ZKType</code> is the unique identifier for the verification program, and is often a\nunique hash of the binary representation of the verifier. This makes it easy to\nmove to a new proof type. <code>pk_hash</code> acts as a unique channel identifier.</p>\n<p>(note: the <code>pk_hash</code> is not unique if the two nodes reuse their public keys for\na new output. Maybe this can be used to move the channel to a bigger UTXO\nwithout closing it\u2026)</p>\n<h3><a name=\"p-4102-handling-received-channel_announcement_zk-3\" class=\"anchor\" href=\"#p-4102-handling-received-channel_announcement_zk-3\"></a>Handling received channel_announcement_zk</h3>\n<p>When a node receives a <code>channel_announcement_zk</code> message, it will first use\nthe <code>pk_hash</code> to check whether this is a channel already known to the node. The\n<code>pk_hash</code> is deterministic and unique per channel. It will then verify the\nproof if it has a type known to the node. Otherwise it will ignore it.</p>\n<p>Since we can no longer detect channels closing on-chain, we must require\nperiodic refreshes of announcememnts, proving the channel is still in the utxo\nset. It is an open problem what the requirement shoud be here, but I propose\nsetting this to around two weeks. With legacy channels we already have the\nproblem of not knowing whether a channel unspent on-chain is active, so some\nkind of liveness signal is needed regardless.</p>\n<h3><a name=\"p-4102-proof-of-concept-4\" class=\"anchor\" href=\"#p-4102-proof-of-concept-4\"></a>Proof-of-concept</h3>\n<p>I\u2019ve preperad a branch with accompanying code and documents walking through the\nprocess of creating a proof from the original channel announcment: <a href=\"https://github.com/halseth/output-zero/blob/15cfb6adcef11379c5601831a864e15fe09910dc/docs/musig2.md\" rel=\"noopener nofollow ugc\">Musig2\nexample</a>.</p>\n<p>It is based on RiscZero, a versatile framework for creating proofs of execution\nfor RISC-V binaries. This means that is easy to add more contrainsts to the\nverification of the UTXOs if useful.</p>\n<h3><a name=\"p-4102-more-details-5\" class=\"anchor\" href=\"#p-4102-more-details-5\"></a>More details</h3>\n<p>More details regarding proof types, pros and cons and the proof-of-concept can\nbe found here: <a href=\"https://github.com/halseth/output-zero/blob/15cfb6adcef11379c5601831a864e15fe09910dc/docs/ln_gossip.md\" rel=\"noopener nofollow ugc\">Privacy preserving Lightning\ngossip</a></p>\n<p>See this thread for more info on the OutputZero project (formerly <code>utxozkp</code>): <a href=\"https://delvingbitcoin.org/t/proving-utxo-set-inclusion-in-zero-knowledge/1142\" class=\"inline-onebox\">Proving UTXO set inclusion in zero-knowledge</a></p>\n<p>Feedback much appreciated!</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2025-01-28T13:10:04.280Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 4,
  "readers_count": 3,
  "score": 15.8,
  "yours": false,
  "topic_id": 1407,
  "topic_slug": "zk-gossip-for-lightning-channel-announcements",
  "topic_title": "ZK-gossip for lightning channel announcements",
  "topic_html_title": "ZK-gossip for lightning channel announcements",
  "category_id": 7,
  "display_username": "Johan T. Halseth",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Hi, I would like to propose an extension to the taproot gossip proposal, that\nmakes it possible to avoid revealing the channel outpoint.\n\nIt is based on Utreexo and zero-knowledge proofs, and is accompanied with a\nproof-of-concept Rust implementation.\n\nThe proposal is created as an extension to the gossip v1.75 proposal for\ntaproot channel gossip and intended to be used as an optional feature for\nprivacy conscious users.\n\n### Taproot gossip (gossip v1.75)\nSee Elle's deep dive here: [Updates to the Gossip 1.75 proposal post LN summit meeting](https://delvingbitcoin.org/t/updates-to-the-gossip-1-75-proposal-post-ln-summit-meeting/1202).\n\nTl;dr: a new `channel_announcement_2` message that carries a Musig2 signature\nproving the two nodes control a certain UTXO.\n\nAn example `channel_announcement_2`:\n```json\n{\n  \"ChainHash\": \"000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f\",\n  \"ShortChannelID\": \"1000:100:0\",\n  \"Capacity\": 100000,\n  \"NodeID1\": \"0246175dd633eaa1c1684a9e15d218d247e421b009642f3e82e9f138ad9d645e03\",\n  \"NodeID2\": \"02b651f157c5cf7bfbf07d52855c21aca861d7e3b8711d84cb04149e0a67151e16\",\n  \"BitcoinKey1\": \"027fc1e3f6f5a67b804cb86d813adf94f89ea1de63f630607d4c31242d58306043\",\n  \"BitcoinKey2\": \"03fef5084b98aa37757acce81d25148cfdb9592142567c6265e39b082e73c4d54\",\n  \"MerkleRootHash\": null,\n  \"Signature\": {\n    \"bytes\": \"5c14ad15b614c9f91fd5c66b7bfe3f3552427c6d5e6d598f5838c5d219cdd0b89c72ad6a3effe5d995387563b80dfb1b59da599c936c705ad8dfd6da8288b89b\",\n    \"sigType\": 1\n  },\n}\n```\n\n## ZK-gossip\nWhat we propose is an extension to the taproot gossip proposal, that makes it\npossible for the two channel parties to remove the link between the channel and\non-chain output.\n\nIn order to still be able to protect the network from channel DOS attacks, we\nrequire the channel announcement message to include a ZK-proof that proves the\ninclusion of the channel in the UTXO set, and that it is controlled by the two\nnodes in the graph.\n\nIn order to create the ZK proof with these properties, we start with the data\nalready contained in the regular taproot gossip channel announcment:\n\n1) `node_id_1`, `node_id_2`\n2) `bitcoin_key_1`, `bitcoin_key_2`\n3) `merkle_root_hash`\n4) `signature`\n5) `capacity`\n\n(we'll ignore the `merkle_root_hash` for now).\n\nIn addition we assemble a Utreexo accumulator and a proof for the channel\noutput's inclusion in this accumulator.\n\nUsing these pieces of data we create a ZK-proof that validates the following:\n\n1) `bitcoin_keys = MuSig2.KeySort(bitcoin_key_1, bitcoin_key_2)`\n2) `P_agg_out = MuSig2.KeyAgg(bitcoin_keys)`\n3) Check `capacity <= vout.value`\n4) Check `P_agg_out = vout.script_pubkey`\n3) Verify that `vout` is in the UTXO set using the utreexo accumulator and proof.\n4) `P_agg = MuSig2.KeyAgg(MuSig2.KeySort(node_id_1, node_id_2, bitcoin_key_1, bitcoin_key_2))`\n5) Verify the signaure against `P_agg`\n6) `pk_hash = hash(bitcoin_keys[0] || bitcoin_keys[1])`\n\nWe then output (or make public) the two `node_ids`, the signed data, utreexo accumulator and `pk_hash`.\n\nNow we can output a proof (ZK-SNARK, groth16) of 256 bytes, and assemble a new\n`channel_announcement_zk` (since messages are TLV, this should really be\ncombined with the `channel_announcement_2` with appropriate fields set):\n\n```json\n{\n  \"ChainHash\": \"000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f\",\n  \"Capacity\": 100000,\n  \"NodeID1\": \"0246175dd633eaa1c1684a9e15d218d247e421b009642f3e82e9f138ad9d645e03\",\n  \"NodeID2\": \"02b651f157c5cf7bfbf07d52855c21aca861d7e3b8711d84cb04149e0a67151e16\",\n  \"UtreexoRoot\": \"4b07311e3e774f0db3bcedee47c56fe30da326d9271d1a2558a5975ab4214478\",\n  \"ZKType\": \"9bce41211c9d71e1ed07a2a5244f95ab98b0ba3a6e95dda9c87ba071ff871418\",\n  \"ZKProof\": \"6508d8476086238076bb673005f9ef3bfe7f0c198a1d4f6fcee65e19478b422c512aefd004f8f476d0ef5939dc4339e3e19347a6ab60fe5714e9d3e3e77417499dbf18da68dfd942d79c8bf4cf811f615334f4643befb267a189d8e6b05509760bfd7add9aa9ecbce38db277bf11b1b94e147b504e75be5405066421aad8e10b49d105a33241742bafe611b4025ffa35d066fc87e11df595030d18b962ad5917ef1f73c97d660c1e62c7e392d51821ec342b2faf763d2a9177d13471c8b2a829578fd401d76aa8ae5642937f48573e657a5af14fda5f7a39216dda05b183121913088d2d0e0c1902d1f656b5d769b95040a40ef5a9ffd87f550545b0a5bc2505\",\n  \"PKHash\": \"be7d602934c5ce95000ee989748f6c892ce16fb4276389ec15bc0764fbc4bea5\"\n}\n```\n\n`ZKType` is the unique identifier for the verification program, and is often a\nunique hash of the binary representation of the verifier. This makes it easy to\nmove to a new proof type. `pk_hash` acts as a unique channel identifier.\n\n(note: the `pk_hash` is not unique if the two nodes reuse their public keys for\na new output. Maybe this can be used to move the channel to a bigger UTXO\nwithout closing it...)\n\n### Handling received channel_announcement_zk\nWhen a node receives a `channel_announcement_zk` message, it will first use\nthe `pk_hash` to check whether this is a channel already known to the node. The\n`pk_hash` is deterministic and unique per channel. It will then verify the\nproof if it has a type known to the node. Otherwise it will ignore it.\n\nSince we can no longer detect channels closing on-chain, we must require\nperiodic refreshes of announcememnts, proving the channel is still in the utxo\nset. It is an open problem what the requirement shoud be here, but I propose\nsetting this to around two weeks. With legacy channels we already have the\nproblem of not knowing whether a channel unspent on-chain is active, so some\nkind of liveness signal is needed regardless.\n\n### Proof-of-concept\nI've preperad a branch with accompanying code and documents walking through the\nprocess of creating a proof from the original channel announcment: [Musig2\nexample](https://github.com/halseth/output-zero/blob/15cfb6adcef11379c5601831a864e15fe09910dc/docs/musig2.md).\n\nIt is based on RiscZero, a versatile framework for creating proofs of execution\nfor RISC-V binaries. This means that is easy to add more contrainsts to the\nverification of the UTXOs if useful.\n\n\n### More details\nMore details regarding proof types, pros and cons and the proof-of-concept can\nbe found here: [Privacy preserving Lightning\ngossip](https://github.com/halseth/output-zero/blob/15cfb6adcef11379c5601831a864e15fe09910dc/docs/ln_gossip.md)\n\nSee this thread for more info on the OutputZero project (formerly `utxozkp`): https://delvingbitcoin.org/t/proving-utxo-set-inclusion-in-zero-knowledge/1142 \n\n\nFeedback much appreciated!",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 163,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": "Github link was replaced with a permanent link",
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "eyes",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}