{
  "id": 4122,
  "name": "Bastien Teinturier",
  "username": "t-bast",
  "avatar_template": "/user_avatar/delvingbitcoin.org/t-bast/{size}/98_2.png",
  "created_at": "2025-01-31T15:47:17.512Z",
  "cooked": "<p>In this post, I\u2019d like to explore the various options available for the ephemeral anchor output used in future lightning commitment transactions that use <code>nVersion = 3</code>. We could go in a few different directions, and every option has a different set of trade-offs.</p>\n<p>Let\u2019s start with a brief summary of how this ephemeral anchor output will behave in the context of lightning channels.</p>\n<h2><a name=\"p-4122-ephemeral-anchor-in-lightning-commitment-transactions-1\" class=\"anchor\" href=\"#p-4122-ephemeral-anchor-in-lightning-commitment-transactions-1\"></a>Ephemeral anchor in lightning commitment transactions</h2>\n<p>When there are no pending dust HTLCs, the amount of the anchor will be <code>0 sat</code>.</p>\n<p>In order to spend it (to CPFP the commitment transaction), nodes will need to add additional inputs to pay fees.</p>\n<p>When HTLCs are pending that are below the <code>dust_limit</code> defined by the channel participants, the amount of those HTLCs will be:</p>\n<ul>\n<li>\n<p>subtracted from the sending node\u2019s main output</p>\n</li>\n<li>\n<p>added to the anchor output</p>\n</li>\n</ul>\n<p>Note that this means that the anchor output amount will contain funds that may come from both participants, depending on who sent dust HTLCs.</p>\n<p>This can result in the anchor output amount being large enough to pay the commitment fees on its own, depending on how many pending dust HTLCs nodes allow on the channel. This can be a good thing because it may allow CPFP on the commitment transaction without adding external wallet inputs. But the drawback is that if the anchor output amount is larger than the on-chain fees that need to be paid, there is a race between everyone who can spend that output to collect the remaining amount.</p>\n<p>For example, let\u2019s assume that the anchor output amount is <code>50 000 sat</code> but Alice only needs <code>20 000 sat</code> to pay enough on-chain fees for the commitment transaction to be confirmed. So Alice will create an <code>anchor-tx</code> that spends the anchor output and sends <code>30 000 sat</code> back to her address. But when Bob sees that transaction, he will most likely replace it with a different <code>anchor-tx</code> transaction that sends <code>25 000 sat</code> to his own address, and this will be a more interesting package for miners!</p>\n<h2><a name=\"p-4122-option-1-unkeyed-anchor-2\" class=\"anchor\" href=\"#p-4122-option-1-unkeyed-anchor-2\"></a>Option 1: unkeyed anchor</h2>\n<p>Ephemeral anchors can be used with the new <code>P2A</code> output type (<code>OP_1 4e73</code>) which can be spent by anyone.</p>\n<p>The benefits of this option are that:</p>\n<ul>\n<li>\n<p>it can easily be spent by both channel participants</p>\n</li>\n<li>\n<p>since anyone can spend it, nodes can even delegate paying the on-chain fees to someone else</p>\n</li>\n<li>\n<p>this is the most economical way to spend an anchor output (no witness data)</p>\n</li>\n</ul>\n<p>The main drawback of this option is that when the anchor output amount is larger than the on-chain fees required for confirmation, miners will always claim the whole amount: when they see the transaction spending the anchor output, they always have an incentive to replace it with one that sends the funds to themselves. This can lead to a non-negligible overpaying of on-chain fees. However, note that this is already what happens in today\u2019s lightning channels, since pending dust HTLCs are currently directly added to mining fees (they\u2019re subtracted from the sender\u2019s main output but not added to any output).</p>\n<p>I don\u2019t see other drawbacks to this solution: am I missing something?</p>\n<h2><a name=\"p-4122-option-2-single-participant-keyed-anchor-3\" class=\"anchor\" href=\"#p-4122-option-2-single-participant-keyed-anchor-3\"></a>Option 2: single-participant keyed anchor</h2>\n<p>In this variant, we use a keyed script (either <code>p2wpkh</code> or <code>p2tr</code>) for the ephemeral anchor, paying to the node\u2019s <code>local_funding_pubkey</code>. This means that channel participants can only spend the anchor output of <em>their</em> commitment transaction. While this cannot be done with v2 commitments because of pinning, this is actually fine for v3 commitments: if the remote commitment has been published but doesn\u2019t confirm, you can replace it with your local commitment using v3 package RBF (but then you\u2019ll need to wait for the <code>to_self_delay</code> to spend your channel balance).</p>\n<p>The benefits of this option are:</p>\n<ul>\n<li>\n<p>it isn\u2019t too costly to spend (no script path)</p>\n</li>\n<li>\n<p>miners cannot steal the on-chain fee over-payment</p>\n</li>\n<li>\n<p>your channel counterparty may steal the on-chain fee over-payment, but only by getting <em>their</em> commitment transaction confirmed, thus locking their funds until <code>to_self_delay</code></p>\n</li>\n</ul>\n<p>The drawbacks are that you cannot delegate paying the on-chain fees, and you may be forced to publish your local commitment if the remote commitment doesn\u2019t confirm, even though you weren\u2019t the node who decided to force-close.</p>\n<h2><a name=\"p-4122-option-3-shared-key-anchor-4\" class=\"anchor\" href=\"#p-4122-option-3-shared-key-anchor-4\"></a>Option 3: shared key anchor</h2>\n<p>In this variant, we still use a keyed script (either <code>p2wpkh</code> or <code>p2tr</code>) for the ephemeral anchor, but it pays to a public key created by the channel opener, who shares the private key with the other node when opening the channel.</p>\n<p>This option has the following benefits:</p>\n<ul>\n<li>\n<p>it can be spent by both channel participants</p>\n</li>\n<li>\n<p>participants can CPFP the remote commitment (which lets them spend their balance immediately)</p>\n</li>\n<li>\n<p>by revealing the private key (which shouldn\u2019t be used for anything else), it becomes possible to delegate paying the on-chain fees</p>\n</li>\n<li>\n<p>miners cannot steal the on-chain fee over-payment</p>\n</li>\n<li>\n<p>but anyone you share that private key with can steal the on-chain fee over-payment</p>\n</li>\n</ul>\n<p>This option is very similar to option 1, but fixes the fact that miners can steal the over-payment, at the cost of a larger witness.</p>\n<h2><a name=\"p-4122-option-4-dual-keyed-anchor-5\" class=\"anchor\" href=\"#p-4122-option-4-dual-keyed-anchor-5\"></a>Option 4: dual-keyed anchor</h2>\n<p>In this option, we use a taproot output for the ephemeral anchor where:</p>\n<ul>\n<li>\n<p>the key path uses the <code>local_funding_pubkey</code></p>\n</li>\n<li>\n<p>a script path is included that uses the <code>remote_funding_pubkey</code></p>\n</li>\n</ul>\n<p>The benefits of this option are:</p>\n<ul>\n<li>\n<p>it can be spent by both channel participants</p>\n</li>\n<li>\n<p>CPFP-ing the local commitment transaction is efficient (key-path spend)</p>\n</li>\n<li>\n<p>CPFP-ing the remote commitment transaction is less efficient (script-path spend) but you can spend your channel funds without a <code>to_self_delay</code></p>\n</li>\n<li>\n<p>the on-chain fee over-payment can only be stolen by your channel peers</p>\n</li>\n</ul>\n<p>The drawback is that you cannot delegate paying the on-chain fees.</p>\n<hr>\n<p>I haven\u2019t decided yet which option I like best: I think it mostly depends on how much we care about preventing on-chain fee over-payment.</p>\n<p>Since nodes can decide how much dust they allow in the commitment, it is somewhat easy to limit this exposure, so maybe we don\u2019t care about it at all?</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2025-01-31T15:49:30.771Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 10,
  "readers_count": 9,
  "score": 17.0,
  "yours": false,
  "topic_id": 1412,
  "topic_slug": "which-ephemeral-anchor-script-should-lightning-use",
  "topic_title": "Which ephemeral anchor script should lightning use?",
  "topic_html_title": "Which ephemeral anchor script should lightning use?",
  "category_id": 7,
  "display_username": "Bastien Teinturier",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "In this post, I'd like to explore the various options available for the ephemeral anchor output used in future lightning commitment transactions that use `nVersion = 3`. We could go in a few different directions, and every option has a different set of trade-offs.\n\nLet's start with a brief summary of how this ephemeral anchor output will behave in the context of lightning channels.\n\n## Ephemeral anchor in lightning commitment transactions\n\nWhen there are no pending dust HTLCs, the amount of the anchor will be `0 sat`.\n\nIn order to spend it (to CPFP the commitment transaction), nodes will need to add additional inputs to pay fees.\n\nWhen HTLCs are pending that are below the `dust_limit` defined by the channel participants, the amount of those HTLCs will be:\n\n- subtracted from the sending node's main output\n\n- added to the anchor output\n\nNote that this means that the anchor output amount will contain funds that may come from both participants, depending on who sent dust HTLCs.\n\nThis can result in the anchor output amount being large enough to pay the commitment fees on its own, depending on how many pending dust HTLCs nodes allow on the channel. This can be a good thing because it may allow CPFP on the commitment transaction without adding external wallet inputs. But the drawback is that if the anchor output amount is larger than the on-chain fees that need to be paid, there is a race between everyone who can spend that output to collect the remaining amount.\n\nFor example, let's assume that the anchor output amount is `50 000 sat` but Alice only needs `20 000 sat` to pay enough on-chain fees for the commitment transaction to be confirmed. So Alice will create an `anchor-tx` that spends the anchor output and sends `30 000 sat` back to her address. But when Bob sees that transaction, he will most likely replace it with a different `anchor-tx` transaction that sends `25 000 sat` to his own address, and this will be a more interesting package for miners!\n\n## Option 1: unkeyed anchor\n\nEphemeral anchors can be used with the new `P2A` output type (`OP_1 4e73`) which can be spent by anyone.\n\nThe benefits of this option are that:\n\n- it can easily be spent by both channel participants\n\n- since anyone can spend it, nodes can even delegate paying the on-chain fees to someone else\n\n- this is the most economical way to spend an anchor output (no witness data)\n\nThe main drawback of this option is that when the anchor output amount is larger than the on-chain fees required for confirmation, miners will always claim the whole amount: when they see the transaction spending the anchor output, they always have an incentive to replace it with one that sends the funds to themselves. This can lead to a non-negligible overpaying of on-chain fees. However, note that this is already what happens in today's lightning channels, since pending dust HTLCs are currently directly added to mining fees (they're subtracted from the sender's main output but not added to any output).\n\nI don't see other drawbacks to this solution: am I missing something?\n\n## Option 2: single-participant keyed anchor\n\nIn this variant, we use a keyed script (either `p2wpkh` or `p2tr`) for the ephemeral anchor, paying to the node's `local_funding_pubkey`. This means that channel participants can only spend the anchor output of *their* commitment transaction. While this cannot be done with v2 commitments because of pinning, this is actually fine for v3 commitments: if the remote commitment has been published but doesn't confirm, you can replace it with your local commitment using v3 package RBF (but then you'll need to wait for the `to_self_delay` to spend your channel balance).\n\nThe benefits of this option are:\n\n- it isn't too costly to spend (no script path)\n\n- miners cannot steal the on-chain fee over-payment\n\n- your channel counterparty may steal the on-chain fee over-payment, but only by getting *their* commitment transaction confirmed, thus locking their funds until `to_self_delay`\n\nThe drawbacks are that you cannot delegate paying the on-chain fees, and you may be forced to publish your local commitment if the remote commitment doesn't confirm, even though you weren't the node who decided to force-close.\n\n## Option 3: shared key anchor\n\nIn this variant, we still use a keyed script (either `p2wpkh` or `p2tr`) for the ephemeral anchor, but it pays to a public key created by the channel opener, who shares the private key with the other node when opening the channel.\n\nThis option has the following benefits:\n\n- it can be spent by both channel participants\n\n- participants can CPFP the remote commitment (which lets them spend their balance immediately)\n\n- by revealing the private key (which shouldn't be used for anything else), it becomes possible to delegate paying the on-chain fees\n\n- miners cannot steal the on-chain fee over-payment\n\n- but anyone you share that private key with can steal the on-chain fee over-payment\n\nThis option is very similar to option 1, but fixes the fact that miners can steal the over-payment, at the cost of a larger witness.\n\n## Option 4: dual-keyed anchor\n\nIn this option, we use a taproot output for the ephemeral anchor where:\n\n- the key path uses the `local_funding_pubkey`\n\n- a script path is included that uses the `remote_funding_pubkey`\n\nThe benefits of this option are:\n\n- it can be spent by both channel participants\n\n- CPFP-ing the local commitment transaction is efficient (key-path spend)\n\n- CPFP-ing the remote commitment transaction is less efficient (script-path spend) but you can spend your channel funds without a `to_self_delay`\n\n- the on-chain fee over-payment can only be stolen by your channel peers\n\nThe drawback is that you cannot delegate paying the on-chain fees.\n\n---\n\nI haven't decided yet which option I like best: I think it mostly depends on how much we care about preventing on-chain fee over-payment.\n\nSince nodes can decide how much dust they allow in the commitment, it is somewhat easy to limit this exposure, so maybe we don't care about it at all?",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 101,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}