{
  "id": 4411,
  "name": "Matt Morehouse",
  "username": "morehouse",
  "avatar_template": "/letter_avatar_proxy/v4/letter/m/df705f/{size}.png",
  "created_at": "2025-03-04T15:58:58.986Z",
  "cooked": "<p><em>The following disclosure is copied verbatim from a <a href=\"https://morehouse.github.io/lightning/lnd-excessive-failback-exploit/\" rel=\"noopener nofollow ugc\">blog post</a> on <a href=\"http://morehouse.github.io\" rel=\"noopener nofollow ugc\">morehouse.github.io</a>, reproduced here to facilitate discussion.</em></p>\n<p>LND 0.17.5 and below contain a bug in the on-chain resolution logic that can be exploited to steal funds.\nFor the attack to be practical the attacker must be able to force a restart of the victim node, perhaps via an unpatched DoS vector.\nUpdate to at least <a href=\"https://github.com/lightningnetwork/lnd/releases/tag/v0.18.0-beta\" rel=\"noopener nofollow ugc\">LND 0.18.0</a> to protect your node.</p>\n<h1><a name=\"p-4411-background-1\" class=\"anchor\" href=\"#p-4411-background-1\"></a>Background</h1>\n<p>Whenever a new payment is routed through a lightning channel, or whenever an existing payment is settled on the channel, the parties in that channel need to update their commitment transactions to match the new set of active HTLCs.\nDuring the course of these regular commitment updates, there is always a brief moment where one of the parties holds two valid commitment transactions.\nNormally that party immediately revokes the older commitment transaction after it receives a signature for the new one, bringing their number of valid commitment transactions back down to one.\nBut for that brief moment, the other party in the channel must be able to handle the case where <em>either</em> of the valid commitments confirms on chain.</p>\n<p>As part of this handling, nodes need to detect when any currently outstanding HTLCs are missing from the confirmed commitment transaction so that those HTLCs can be failed backward on the upstream channel.</p>\n<h1><a name=\"p-4411-the-excessive-failback-bug-2\" class=\"anchor\" href=\"#p-4411-the-excessive-failback-bug-2\"></a>The Excessive Failback Bug</h1>\n<p>Prior to v0.18.0, LND\u2019s <a href=\"https://github.com/lightningnetwork/lnd/blob/f4035ade05d0c44b441f2fe26af89584a76a55d6/contractcourt/channel_arbitrator.go#L2079-L2151\" rel=\"noopener nofollow ugc\">logic</a> to detect and fail back missing HTLCs works like this:</p>\n<pre data-code-wrap=\"go\"><code class=\"lang-go\">func failBackMissingHtlcs(confirmedCommit Commitment) {\n  currentCommit, pendingCommit := getValidCounterpartyCommitments()\n\n  var danglingHtlcs HtlcSet\n  if confirmedCommit == pendingCommit {\n    danglingHtlcs = currentCommit.Htlcs()\n  } else {\n    danglingHtlcs = pendingCommit.Htlcs()\n  }\n\n  confirmedHtlcs := confirmedCommit.Htlcs()\n  missingHtlcs := danglingHtlcs.SetDifference(confirmedHtlcs)\n  for _, htlc := range missingHtlcs {\n    failBackHtlc(htlc)\n  }\n}\n</code></pre>\n<p>LND compares the HTLCs present on the confirmed commitment transaction against the HTLCs present on the counterparty\u2019s <em>other</em> valid commitment (if there is one) and fails back any HTLCs that are missing from the confirmed commitment.\nThis logic is mostly correct, but it does the wrong thing in one particular scenario:</p>\n<ol>\n<li>LND forwards an HTLC <code>H</code> to the counterparty, signing commitment <code>C0</code> with <code>H</code> added as an output.  The previous commitment is revoked.</li>\n<li>The counterparty claims <code>H</code> by revealing the preimage to LND.</li>\n<li>LND forwards the preimage upstream to start the process of claiming the incoming HTLC.</li>\n<li>LND signs a new counterparty commitment <code>C1</code> with <code>H</code> removed and its value added to the counterparty\u2019s balance.</li>\n<li>The counterparty refuses to revoke <code>C0</code>.</li>\n<li>The counterparty broadcasts and confirms <code>C1</code>.</li>\n</ol>\n<p>In this case, LND compares the confirmed commitment <code>C1</code> against the other valid commitment <code>C0</code> and determines that <code>H</code> is missing from the confirmed commitment.\nAs a result, LND incorrectly determines that <code>H</code> needs to be failed back upstream, and executes the following <a href=\"https://github.com/lightningnetwork/lnd/blob/f4035ade05d0c44b441f2fe26af89584a76a55d6/htlcswitch/switch.go#L1822-L1872\" rel=\"noopener nofollow ugc\">logic</a>:</p>\n<pre data-code-wrap=\"go\"><code class=\"lang-go\">func failBackHtlc(htlc Htlc) {\n  markFailedInDatabase(htlc)\n  \n  incomingHtlc, ok := incomingHtlcMap[htlc]\n  if !ok {\n    log(\"Incoming HTLC has already been resolved\")\n    return\n  }\n  failHtlc(incomingHtlc)\n  delete(incomingHtlcMap, htlc)\n}\n</code></pre>\n<p>In this case, the preimage for the incoming HTLC was already sent upstream (step 3), so the corresponding entry in <code>incomingHtlcMap</code> has already been removed.\nThus LND catches the \u201cdouble resolution\u201d and returns from <code>failBackHtlc</code> without sending the incorrect failure message upstream.\nUnfortunately, LND only catches the double resolution <em>after</em> <code>H</code> is marked as failed in the database.\nAs a result, when LND next restarts it will reconstruct its state from the database and determine that <code>H</code> still needs to be failed back.\nIf the incoming HTLC hasn\u2019t been fully resolved with the upstream node, the reconstructed <code>incomingHtlcMap</code> <em>will</em> have an entry for <code>H</code> this time, and LND will incorrectly send a failure message upstream.</p>\n<p>At that point, the downstream node will have claimed <code>H</code> via preimage while the upstream node will have had the HTLC refunded to them, causing LND to lose the full value of <code>H</code>.</p>\n<h1><a name=\"p-4411-stealing-htlcs-3\" class=\"anchor\" href=\"#p-4411-stealing-htlcs-3\"></a>Stealing HTLCs</h1>\n<p>Consider the following topology, where <code>B</code> is the victim and <code>M0</code> and <code>M1</code> are controlled by the attacker.</p>\n<pre><code class=\"lang-auto\">M0 -- B -- M1\n</code></pre>\n<p>The attacker can steal funds as follows:</p>\n<ol>\n<li><code>M0</code> routes a large HTLC along the path <code>M0 -&gt; B -&gt; M1</code>.</li>\n<li><code>M0</code> goes offline.</li>\n<li><code>M1</code> claims the HTLC from <code>B</code> by revealing the preimage, receives a new commitment signature from <code>B</code>, and then refuses to revoke the previous commitment.</li>\n<li><code>B</code> attempts to claim the upstream HTLC from <code>M0</code> but can\u2019t because <code>M0</code> is offline.</li>\n<li><code>M1</code> force closes the <code>B-M1</code> channel using their new commitment, thus triggering the excessive failback bug.</li>\n<li>The attacker crashes <code>B</code> using an unpatched DoS vector.</li>\n<li><code>M0</code> comes back online.</li>\n<li><code>B</code> restarts, loads HTLC resolution data from the database, and incorrectly fails the HTLC with <code>M0</code>.</li>\n</ol>\n<p>At this point, the attacker has succeeded in stealing the HTLC from <code>B</code>.\n<code>M0</code> got the HTLC refunded, while <code>M1</code> got the value of the HTLC added to their balance on the confirmed commitment.</p>\n<h1><a name=\"p-4411-the-fix-4\" class=\"anchor\" href=\"#p-4411-the-fix-4\"></a>The Fix</h1>\n<p>The excessive failback bug was fixed by a <a href=\"https://github.com/lightningnetwork/lnd/commit/6f0c2b5bab68c156262c1e8e2286f9a6b36bbbd7#diff-a0b8064876b1b1d6085fa7ffdbfd38c81cb06c1ca3f34a08dbaacba203cda3ebR2142-R2155\" rel=\"noopener nofollow ugc\">small change</a> to prevent failback of HTLCs for which the preimage is already known.\nThe updated logic now explicitly checks for preimage availability before failing back each HTLC:</p>\n<pre data-code-wrap=\"go\"><code class=\"lang-go\">func failBackMissingHtlcs(confirmedCommit Commitment) {\n  currentCommit, pendingCommit := getValidCounterpartyCommitments()\n\n  var danglingHtlcs HtlcSet\n  if confirmedCommit == pendingCommit {\n    danglingHtlcs = currentCommit.Htlcs()\n  } else {\n    danglingHtlcs = pendingCommit.Htlcs()\n  }\n\n  confirmedHtlcs := confirmedCommit.Htlcs()\n  missingHtlcs := danglingHtlcs.SetDifference(confirmedHtlcs)\n  for _, htlc := range missingHtlcs {\n    if preimageIsKnown(htlc.PaymentHash()) {\n      continue  // Don't fail back HTLCs we can claim.\n    }\n    failBackHtlc(htlc)\n  }\n}\n</code></pre>\n<p>The <code>preimageIsKnown</code> check prevents <code>failBackHtlc</code> from being called when the preimage is known, so such HTLCs are never failed backward or marked as failed in the database.\nOn restart, the incorrect failback behavior no longer occurs.</p>\n<p>The patch was hidden in a <a href=\"https://github.com/lightningnetwork/lnd/pull/8667\" rel=\"noopener nofollow ugc\">massive rewrite</a> of LND\u2019s sweeper system and was released in LND 0.18.0.</p>\n<h1><a name=\"p-4411-discovery-5\" class=\"anchor\" href=\"#p-4411-discovery-5\"></a>Discovery</h1>\n<p>This vulnerability was discovered during an audit of LND\u2019s <code>contractcourt</code> package, which handles on-chain resolution of force closures.</p>\n<h2><a name=\"p-4411-timeline-6\" class=\"anchor\" href=\"#p-4411-timeline-6\"></a>Timeline</h2>\n<ul>\n<li><strong>2024-03-20:</strong> Vulnerability reported to the LND security mailing list.</li>\n<li><strong>2024-04-19:</strong> Fix <a href=\"https://github.com/lightningnetwork/lnd/commit/6f0c2b5bab68c156262c1e8e2286f9a6b36bbbd7#diff-a0b8064876b1b1d6085fa7ffdbfd38c81cb06c1ca3f34a08dbaacba203cda3ebR2142-R2155\" rel=\"noopener nofollow ugc\">merged</a>.</li>\n<li><strong>2024-05-30:</strong> LND 0.18.0 released containing the fix.</li>\n<li><strong>2025-02-17:</strong> <a href=\"https://github.com/gijswijs\" rel=\"noopener nofollow ugc\">Gijs</a> gives the OK to disclose publicly in March.</li>\n<li><strong>2025-03-04:</strong> Public disclosure.</li>\n</ul>\n<h1><a name=\"p-4411-prevention-7\" class=\"anchor\" href=\"#p-4411-prevention-7\"></a>Prevention</h1>\n<p>It appears all other lightning implementations have independently discovered and handled the corner case that LND mishandled:</p>\n<ul>\n<li>CLN <a href=\"https://github.com/ElementsProject/lightning/commit/6c96bcacd763cf5cd81226e3b161be161c3818ed#diff-d161f42609a169a38f366a0628bceefa6bed62eb9af20082c5ad08add899a2fbR863-R864\" rel=\"noopener nofollow ugc\">added</a> a preimage check to the failback logic in 2018.</li>\n<li>eclair <a href=\"https://github.com/ACINQ/eclair/commit/c7e47ba751dc1ed4a96bcb4b7e5fcd49d78cfb78#diff-97779917bce211cd035ebf8f9f265a7ecece4efcd1861c7bab05e0113dd86b06R1310-R1318\" rel=\"noopener nofollow ugc\">introduced</a> failback logic in 2023 that filtered upstream HTLCs by preimage availability.</li>\n<li>LDK <a href=\"https://github.com/lightningdevkit/rust-lightning/commit/0ad1f4c943bdc9037d0c43d1b74c745befa065f0#diff-fec072136ddc5ad6b84dd8e4d2368e9e793f994c8bcccf011508038a81eb408aR1988-R1990\" rel=\"noopener nofollow ugc\">added</a> a preimage check to the failback logic in 2023.</li>\n</ul>\n<p>Yet the BOLT specification has not been updated to describe this corner case.\nIn fact, by a strict interpretation the <a href=\"https://github.com/lightning/bolts/blob/ccfa38ed4f592c3711156bb4ded77f44ec01101d/05-onchain.md?plain=1#L407-L410\" rel=\"noopener nofollow ugc\">specification</a> actually requires the <em>incorrect</em> behavior that LND implemented:</p>\n<pre><code class=\"lang-auto\">## HTLC Output Handling: Remote Commitment, Local Offers\n\n### Requirements\n\nA local node:\n  - for any committed HTLC that does NOT have an output in this commitment transaction:\n    - once the commitment transaction has reached reasonable depth:\n      - MUST fail the corresponding incoming HTLC (if any).\n</code></pre>\n<p>It is quite unfortunate that all implementations had to independently discover and correct this bug.\nIf any single implementation had contributed a small patch to the specification after discovering the issue, it would have at least sparked some discussion about whether the other implementations had considered this corner case.\nAnd if CLN had recognized that the specification needed updating back in 2018, there\u2019s a good chance all other implementations would have handled this case correctly from the start.</p>\n<h1><a name=\"p-4411-takeaways-8\" class=\"anchor\" href=\"#p-4411-takeaways-8\"></a>Takeaways</h1>\n<ul>\n<li>Keeping specifications up-to-date can improve security for all implementations.</li>\n<li>Update to at least LND 0.18.0 to protect your funds.</li>\n</ul>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2025-03-04T15:58:58.986Z",
  "reply_count": 1,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 12,
  "reads": 26,
  "readers_count": 25,
  "score": 130.2,
  "yours": false,
  "topic_id": 1493,
  "topic_slug": "disclosure-lnd-excessive-failback-exploit",
  "topic_title": "Disclosure: LND Excessive Failback Exploit",
  "topic_html_title": "Disclosure: LND Excessive Failback Exploit",
  "category_id": 8,
  "display_username": "Matt Morehouse",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "*The following disclosure is copied verbatim from a [blog post](https://morehouse.github.io/lightning/lnd-excessive-failback-exploit/) on [morehouse.github.io](http://morehouse.github.io), reproduced here to facilitate discussion.*\n\n\nLND 0.17.5 and below contain a bug in the on-chain resolution logic that can be exploited to steal funds.\nFor the attack to be practical the attacker must be able to force a restart of the victim node, perhaps via an unpatched DoS vector.\nUpdate to at least [LND 0.18.0](https://github.com/lightningnetwork/lnd/releases/tag/v0.18.0-beta) to protect your node.\n\n# Background\n\nWhenever a new payment is routed through a lightning channel, or whenever an existing payment is settled on the channel, the parties in that channel need to update their commitment transactions to match the new set of active HTLCs.\nDuring the course of these regular commitment updates, there is always a brief moment where one of the parties holds two valid commitment transactions.\nNormally that party immediately revokes the older commitment transaction after it receives a signature for the new one, bringing their number of valid commitment transactions back down to one.\nBut for that brief moment, the other party in the channel must be able to handle the case where *either* of the valid commitments confirms on chain.\n\nAs part of this handling, nodes need to detect when any currently outstanding HTLCs are missing from the confirmed commitment transaction so that those HTLCs can be failed backward on the upstream channel.\n\n# The Excessive Failback Bug\n\nPrior to v0.18.0, LND's [logic](https://github.com/lightningnetwork/lnd/blob/f4035ade05d0c44b441f2fe26af89584a76a55d6/contractcourt/channel_arbitrator.go#L2079-L2151) to detect and fail back missing HTLCs works like this:\n\n```go\nfunc failBackMissingHtlcs(confirmedCommit Commitment) {\n  currentCommit, pendingCommit := getValidCounterpartyCommitments()\n\n  var danglingHtlcs HtlcSet\n  if confirmedCommit == pendingCommit {\n    danglingHtlcs = currentCommit.Htlcs()\n  } else {\n    danglingHtlcs = pendingCommit.Htlcs()\n  }\n\n  confirmedHtlcs := confirmedCommit.Htlcs()\n  missingHtlcs := danglingHtlcs.SetDifference(confirmedHtlcs)\n  for _, htlc := range missingHtlcs {\n    failBackHtlc(htlc)\n  }\n}\n```\n\nLND compares the HTLCs present on the confirmed commitment transaction against the HTLCs present on the counterparty's *other* valid commitment (if there is one) and fails back any HTLCs that are missing from the confirmed commitment.\nThis logic is mostly correct, but it does the wrong thing in one particular scenario:\n\n1. LND forwards an HTLC `H` to the counterparty, signing commitment `C0` with `H` added as an output.  The previous commitment is revoked.\n2. The counterparty claims `H` by revealing the preimage to LND.\n3. LND forwards the preimage upstream to start the process of claiming the incoming HTLC.\n4. LND signs a new counterparty commitment `C1` with `H` removed and its value added to the counterparty's balance.\n5. The counterparty refuses to revoke `C0`.\n6. The counterparty broadcasts and confirms `C1`.\n\nIn this case, LND compares the confirmed commitment `C1` against the other valid commitment `C0` and determines that `H` is missing from the confirmed commitment.\nAs a result, LND incorrectly determines that `H` needs to be failed back upstream, and executes the following [logic](https://github.com/lightningnetwork/lnd/blob/f4035ade05d0c44b441f2fe26af89584a76a55d6/htlcswitch/switch.go#L1822-L1872):\n\n```go\nfunc failBackHtlc(htlc Htlc) {\n  markFailedInDatabase(htlc)\n  \n  incomingHtlc, ok := incomingHtlcMap[htlc]\n  if !ok {\n    log(\"Incoming HTLC has already been resolved\")\n    return\n  }\n  failHtlc(incomingHtlc)\n  delete(incomingHtlcMap, htlc)\n}\n```\n\nIn this case, the preimage for the incoming HTLC was already sent upstream (step 3), so the corresponding entry in `incomingHtlcMap` has already been removed.\nThus LND catches the \"double resolution\" and returns from `failBackHtlc` without sending the incorrect failure message upstream.\nUnfortunately, LND only catches the double resolution *after* `H` is marked as failed in the database.\nAs a result, when LND next restarts it will reconstruct its state from the database and determine that `H` still needs to be failed back.\nIf the incoming HTLC hasn't been fully resolved with the upstream node, the reconstructed `incomingHtlcMap` *will* have an entry for `H` this time, and LND will incorrectly send a failure message upstream.\n\nAt that point, the downstream node will have claimed `H` via preimage while the upstream node will have had the HTLC refunded to them, causing LND to lose the full value of `H`.\n\n# Stealing HTLCs\n\nConsider the following topology, where `B` is the victim and `M0` and `M1` are controlled by the attacker.\n\n```\nM0 -- B -- M1\n```\n\nThe attacker can steal funds as follows:\n\n1. `M0` routes a large HTLC along the path `M0 -> B -> M1`.\n2. `M0` goes offline.\n3. `M1` claims the HTLC from `B` by revealing the preimage, receives a new commitment signature from `B`, and then refuses to revoke the previous commitment.\n4. `B` attempts to claim the upstream HTLC from `M0` but can't because `M0` is offline.\n5. `M1` force closes the `B-M1` channel using their new commitment, thus triggering the excessive failback bug.\n6. The attacker crashes `B` using an unpatched DoS vector.\n7. `M0` comes back online.\n8. `B` restarts, loads HTLC resolution data from the database, and incorrectly fails the HTLC with `M0`.\n\nAt this point, the attacker has succeeded in stealing the HTLC from `B`.\n`M0` got the HTLC refunded, while `M1` got the value of the HTLC added to their balance on the confirmed commitment.\n\n# The Fix\n\nThe excessive failback bug was fixed by a [small change](https://github.com/lightningnetwork/lnd/commit/6f0c2b5bab68c156262c1e8e2286f9a6b36bbbd7#diff-a0b8064876b1b1d6085fa7ffdbfd38c81cb06c1ca3f34a08dbaacba203cda3ebR2142-R2155) to prevent failback of HTLCs for which the preimage is already known.\nThe updated logic now explicitly checks for preimage availability before failing back each HTLC:\n\n```go\nfunc failBackMissingHtlcs(confirmedCommit Commitment) {\n  currentCommit, pendingCommit := getValidCounterpartyCommitments()\n\n  var danglingHtlcs HtlcSet\n  if confirmedCommit == pendingCommit {\n    danglingHtlcs = currentCommit.Htlcs()\n  } else {\n    danglingHtlcs = pendingCommit.Htlcs()\n  }\n\n  confirmedHtlcs := confirmedCommit.Htlcs()\n  missingHtlcs := danglingHtlcs.SetDifference(confirmedHtlcs)\n  for _, htlc := range missingHtlcs {\n    if preimageIsKnown(htlc.PaymentHash()) {\n      continue  // Don't fail back HTLCs we can claim.\n    }\n    failBackHtlc(htlc)\n  }\n}\n```\n\nThe `preimageIsKnown` check prevents `failBackHtlc` from being called when the preimage is known, so such HTLCs are never failed backward or marked as failed in the database.\nOn restart, the incorrect failback behavior no longer occurs.\n\nThe patch was hidden in a [massive rewrite](https://github.com/lightningnetwork/lnd/pull/8667) of LND's sweeper system and was released in LND 0.18.0.\n\n# Discovery\n\nThis vulnerability was discovered during an audit of LND's `contractcourt` package, which handles on-chain resolution of force closures.\n\n## Timeline\n\n- **2024-03-20:** Vulnerability reported to the LND security mailing list.\n- **2024-04-19:** Fix [merged](https://github.com/lightningnetwork/lnd/commit/6f0c2b5bab68c156262c1e8e2286f9a6b36bbbd7#diff-a0b8064876b1b1d6085fa7ffdbfd38c81cb06c1ca3f34a08dbaacba203cda3ebR2142-R2155).\n- **2024-05-30:** LND 0.18.0 released containing the fix.\n- **2025-02-17:** [Gijs](https://github.com/gijswijs) gives the OK to disclose publicly in March.\n- **2025-03-04:** Public disclosure.\n\n# Prevention\n\nIt appears all other lightning implementations have independently discovered and handled the corner case that LND mishandled:\n\n- CLN [added](https://github.com/ElementsProject/lightning/commit/6c96bcacd763cf5cd81226e3b161be161c3818ed#diff-d161f42609a169a38f366a0628bceefa6bed62eb9af20082c5ad08add899a2fbR863-R864) a preimage check to the failback logic in 2018.\n- eclair [introduced](https://github.com/ACINQ/eclair/commit/c7e47ba751dc1ed4a96bcb4b7e5fcd49d78cfb78#diff-97779917bce211cd035ebf8f9f265a7ecece4efcd1861c7bab05e0113dd86b06R1310-R1318) failback logic in 2023 that filtered upstream HTLCs by preimage availability.\n- LDK [added](https://github.com/lightningdevkit/rust-lightning/commit/0ad1f4c943bdc9037d0c43d1b74c745befa065f0#diff-fec072136ddc5ad6b84dd8e4d2368e9e793f994c8bcccf011508038a81eb408aR1988-R1990) a preimage check to the failback logic in 2023.\n\nYet the BOLT specification has not been updated to describe this corner case.\nIn fact, by a strict interpretation the [specification](https://github.com/lightning/bolts/blob/ccfa38ed4f592c3711156bb4ded77f44ec01101d/05-onchain.md?plain=1#L407-L410) actually requires the *incorrect* behavior that LND implemented:\n\n```\n## HTLC Output Handling: Remote Commitment, Local Offers\n\n### Requirements\n\nA local node:\n  - for any committed HTLC that does NOT have an output in this commitment transaction:\n    - once the commitment transaction has reached reasonable depth:\n      - MUST fail the corresponding incoming HTLC (if any).\n```\n\nIt is quite unfortunate that all implementations had to independently discover and correct this bug.\nIf any single implementation had contributed a small patch to the specification after discovering the issue, it would have at least sparked some discussion about whether the other implementations had considered this corner case.\nAnd if CLN had recognized that the specification needed updating back in 2018, there's a good chance all other implementations would have handled this case correctly from the start.\n\n# Takeaways\n\n- Keeping specifications up-to-date can improve security for all implementations.\n- Update to at least LND 0.18.0 to protect your funds.",
  "actions_summary": [
    {
      "id": 2,
      "count": 4
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 47,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "clap",
      "type": "emoji",
      "count": 2
    },
    {
      "id": "eyes",
      "type": "emoji",
      "count": 1
    },
    {
      "id": "rocket",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 4,
  "current_user_used_main_reaction": false
}