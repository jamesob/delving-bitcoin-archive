{
  "id": 4632,
  "name": "Pieter Wuille",
  "username": "sipa",
  "avatar_template": "/user_avatar/delvingbitcoin.org/sipa/{size}/1100_2.png",
  "created_at": "2025-03-26T12:41:53.669Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"stefanwouldgo\" data-post=\"61\" data-topic=\"303\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/stefanwouldgo/48/664_2.png\" class=\"avatar\"> stefanwouldgo:</div>\n<blockquote>\n<p>But this way or through normal propagation I will learn of the newly attached attacker transaction eventually. When I do, I do the calculation again and resubmit with a better linearization.</p>\n</blockquote>\n</aside>\n<p>No, not necessarily. If the attacker makes many different versions of the attached transaction, that all conflict with each other, and races them all to the network, then every network participant will eventually learn <em>one</em> of them, but not all, \u201cpartitioning\u201d the network into groups of nodes which have the same attacker transaction. And relay of other, honest, transactions across these partition boundaries will be harder if you require the sender to provide good linearization information, because it will be a requirement of linearization on a cluster the sender does not (exactly) have.</p>\n<hr>\n<p>In other news, I have a working GGT implementation with max-height active node selection strategy (so, <span class=\"math\">\\mathcal{O}(n^2 \\sqrt{m})</span>): <a href=\"https://github.com/sipa/bitcoin/commits/min_cut_linearization\" class=\"inline-onebox\">Commits \u00b7 sipa/bitcoin \u00b7 GitHub</a>. It passes all tests, so I\u2019m reasonably confident that it can actually optimally linearize from scratch. I\u2019ll post more detailed benchmarks later, but my benchmarks for up to 64 transactions run in 5-15 \u00b5s, and up to 60 \u00b5s for up to 99 transactions. These numbers are comparable to the spanning-forest linearizarion algorithm I posted about in the other thread. It\u2019s a bit slower (around 1.5x) than the numbers I had before adding the concurrent reverse execution, but maybe that\u2019s not a terrible price for gaining a factor <span class=\"math\">n</span> in the worst case.</p>\n<p>Counting how many iterations the algorithm actually performs, and extrapolating that to the worst case for 64 transactions predicts something in the \u201cfew ms\u201d range, which is amazing performance for a background optimizer, but probably not acceptable for doing at relay time itself.</p>",
  "post_number": 62,
  "post_type": 1,
  "updated_at": "2025-03-26T15:17:30.023Z",
  "reply_count": 0,
  "reply_to_post_number": 61,
  "quote_count": 1,
  "incoming_link_count": 0,
  "reads": 12,
  "readers_count": 11,
  "score": 17.4,
  "yours": false,
  "topic_id": 303,
  "topic_slug": "how-to-linearize-your-cluster",
  "topic_title": "How to linearize your cluster",
  "topic_html_title": "How to linearize your cluster",
  "category_id": 8,
  "display_username": "Pieter Wuille",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 4,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"stefanwouldgo, post:61, topic:303\"]\nBut this way or through normal propagation I will learn of the newly attached attacker transaction eventually. When I do, I do the calculation again and resubmit with a better linearization.\n[/quote]\n\nNo, not necessarily. If the attacker makes many different versions of the attached transaction, that all conflict with each other, and races them all to the network, then every network participant will eventually learn *one* of them, but not all, \"partitioning\" the network into groups of nodes which have the same attacker transaction. And relay of other, honest, transactions across these partition boundaries will be harder if you require the sender to provide good linearization information, because it will be a requirement of linearization on a cluster the sender does not (exactly) have.\n\n---\n\nIn other news, I have a working GGT implementation with max-height active node selection strategy (so, $\\mathcal{O}(n^2 \\sqrt{m})$): https://github.com/sipa/bitcoin/commits/min_cut_linearization. It passes all tests, so I'm reasonably confident that it can actually optimally linearize from scratch. I'll post more detailed benchmarks later, but my benchmarks for up to 64 transactions run in 5-15 \u00b5s, and up to 60 \u00b5s for up to 99 transactions. These numbers are comparable to the spanning-forest linearizarion algorithm I posted about in the other thread. It's a bit slower (around 1.5x) than the numbers I had before adding the concurrent reverse execution, but maybe that's not a terrible price for gaining a factor $n$ in the worst case.\n\nCounting how many iterations the algorithm actually performs, and extrapolating that to the worst case for 64 transactions predicts something in the \"few ms\" range, which is amazing performance for a background optimizer, but probably not acceptable for doing at relay time itself.",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 96,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "heart",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}