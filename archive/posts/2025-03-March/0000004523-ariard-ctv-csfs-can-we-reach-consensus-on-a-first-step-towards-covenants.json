{
  "id": 4523,
  "name": "Antoine Riard",
  "username": "ariard",
  "avatar_template": "/letter_avatar_proxy/v4/letter/a/c67d28/{size}.png",
  "created_at": "2025-03-13T20:15:10.382Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"ajtowns\" data-post=\"29\" data-topic=\"1509\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/ajtowns/48/417_2.png\" class=\"avatar\"> ajtowns:</div>\n<blockquote>\n<p>Greg used the term precisely and correctly \u2013 his post describes taking a general <a href=\"https://bitcointalk.org/index.php?topic=277389.0\">zero-knowledge proof</a> feature and using that to produce actual covenant constructions where a coin and all possible spends of that coin are permanently constrained in a particular way, creating a burn address that allows the burnt coins to be burnt again and again:</p>\n</blockquote>\n</aside>\n<p>Yes, I\u2019m familiar with the idea that you have a SNARK verifier as a replacement for the script interpreter, so you get as an input stack <code>&lt;input public data&gt;</code> <code>&lt;verification public key&gt;</code> <code>&lt;signature&gt;</code> <code>&lt;hash_masked_tx&gt;</code>, where you can assert properties on the spending tx (e.g is this output scriptpubkey size 32 bytes).</p>\n<p>By setting the verification rule that an output redeem script must be of the form <code>THIS_VALIDATION_KEY &amp;&amp; {whatever rules you want}</code>, in my understanding you\u2019re introducing recursivity of the verification rules.</p>\n<p>The recursivity can be bounded (i.e using the tx nVersion field as a counter) or unbounded, by generating a correct and custom <code>&lt;verification public key&gt;</code>.</p>\n<p>In my understanding, and here with in mind Roconnor\u2019s FC\u201917 paper and Jeremy\u2019s talk at Standford\u2019s 2017, the idea of constraining and recursively applying a set of rules on a UTXO and any of spent tx, is what probably mistakenly understood as a covenant nowadays. At the very least, I gave talks and used the term in that sense in my own writing on bitcoin covenants.</p>\n<p>I don\u2019t disagree that \u201ccovenant\u201d is an imprecise terminology. After re-checking the translation in my native tongue (i.e \u201cune convention legale\u201d), the term designates more wider legal constructions than what is understood as a \u201ccovenant\u201d in the English real estate law. Saying contracting primitives or Script opcodes sounds indeed better.</p>\n<aside class=\"quote no-group\" data-username=\"reardencode\" data-post=\"30\" data-topic=\"1509\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/reardencode/48/27_2.png\" class=\"avatar\"> reardencode:</div>\n<blockquote>\n<p>I\u2019ve made a comparison of many alternatives for developing eltoo. Briefly, APO+CTV+standardized_annex is the most efficient of known alternatives. Compared to this:</p>\n</blockquote>\n</aside>\n<p>So the original idea of Eltoo was to have a new sighash flag for the signature of state transaction, that makes them re-bindable on any previous state, removing the constraint to have to store revoked scripts / amounts, for each previous state, and opening the door to &gt;= 2 parties off-chain constructions.</p>\n<p>Efficiency-wise, yes I can see how you can have the chan constraint in an \u201canyprevout_flag\u201d tx template in the commitment_tx output, the per-state counter in the annex fields which could be saving the signature cost size, though I\u2019m not sure we\u2019re talking about the same data layout. And I believe you might need one more opcode to push the annex field on the stack.</p>\n<aside class=\"quote no-group\" data-username=\"stevenroose\" data-post=\"31\" data-topic=\"1509\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/stevenroose/48/1087_2.png\" class=\"avatar\"> stevenroose:</div>\n<blockquote>\n<p>I wasn\u2019t trying to point fingers at whomever was involved in the taproot deployment. More rather trying to indicate that the bar for the taproot soft fork was met on perceived technical merit only, while today it seems that practical usage is the only bar upheld.</p>\n</blockquote>\n</aside>\n<p>As I pointed out on the mailing list more powerful opcode primitives can open the door to <code>TxWithhold</code> risks, by allowing to introspect the status of another UTXO. E.g a basic tx-withhold contract would be someone promising to any miner that if target LN commitment tx is not confirmed until N, a native bitcoin bounty is paid. The N picked up can be the safety timelock of a LN commitment tx.</p>\n<p>At the very least CSFS, with CSFS you can have the <code>&lt;message&gt;</code> being the commitment transaction, for which you know the public key (e.g if you\u2019re a LN counterparty), but you don\u2019t know the <code>&lt;signature&gt;</code>.</p>\n<p>If you combine it with an UTXO set oracle (e.g <code>&lt;message=UTXO_123</code> signed), you\u2019ve already a rudimentary yet powerful tx-withhold contract. I don\u2019t believe CTV allows in any fashion to do more powerful malicious tx-withhold contract, though I believe if it can affect LN, it can certainly affect Ark too.</p>\n<p>If I\u2019m correct here, the lemma is that you certainly needs to have any LN chan UTXO be veiled with some kind of consensus-level semantics, \u201cthis outpoint cannot be referenced by the Script execution of another UTXO spend\u201d. That can be very touchy to implement in bitcoin Script interpreter\u2026</p>\n<aside class=\"quote no-group\" data-username=\"jamesob\" data-post=\"32\" data-topic=\"1509\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/jamesob/48/271_2.png\" class=\"avatar\"> jamesob:</div>\n<blockquote>\n<p>What the watchmen need is super simple. \u201cThese keys allow moving the coins to a special timelocked staging area, from which the original keys can still pull them back\u201d It\u2019s basically a one-step vault.</p>\n<p>In fact we literally implemented it in terms of unsigned transactions in an early version of liquid, but it was too difficult to keep them synced up and invalidated.</p>\n</blockquote>\n</aside>\n<p>Thanks, this is interesting to get Andrew\u2019s opinion here. While I disagree with him on the simplicity (lol) of translating \u201cthese keys allow moving the coins\u2026\u201d in a protocol and well-designed cryptographic API, I believe this is backing the point I was raising in my previous comment that you should get support for any opcode at the HW-level or within the secure enclave.</p>\n<p>Otherwise, how can you be sure that the \u201ccold keys\u201d are authorizing the spend to the correct hash of a transaction, if you do not re-verify the hash computation on the enclave ? This is the same problem that the Validating Lightning Signer has already today to verify <em>all</em> the state transition of the LN protocol to be secure in face of a \u201ccompromised\u201d main LN node.</p>\n<p>In my opinion, this as much the community of bitcoin protocol experts to convince than HW vendors of all kinds, that a said given opcode should be supported.</p>\n<p>\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014-</p>\n<p>Speaking for myself, I can be supportive of the most minimal opcode improvement that improves self-custody for the lambda bitcoin user, at condition it doesn\u2019t introduce tx-withholding risk or extend DoS surface area for full-nodes. If you go in the street to ask to 10 bitcoiners \u201cdo you wish to make the self-custody of your coins, <em>stronger</em> and <em>easier</em>\u201d, I genuinely believe the number of positive answer is going to be equal to 10. I don\u2019t expect the same level of positive answer for Ark, DLC or payment pool, I think it\u2019s just either early or far too complex to be understood by a lambda bitcoin user. In comparison coins self-custody has always been an\narea of focus of bitcoin development since people have started to develop lightweight wallets for their own usage in  ~2010 / 2011.</p>\n<p>Liquid, no opinion. I\u2019ve already met many Liquid devs in real-life but I\u2019ve never met a L-BTC user, which it doesn\u2019t mean Liquid users don\u2019t exist.</p>",
  "post_number": 36,
  "post_type": 1,
  "updated_at": "2025-03-13T20:15:10.382Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 4,
  "incoming_link_count": 0,
  "reads": 2,
  "readers_count": 1,
  "score": 0,
  "yours": false,
  "topic_id": 1509,
  "topic_slug": "ctv-csfs-can-we-reach-consensus-on-a-first-step-towards-covenants",
  "topic_title": "CTV+CSFS: Can we reach consensus on a first step towards covenants?",
  "topic_html_title": "CTV+CSFS: Can we reach consensus on a first step towards covenants?",
  "category_id": 7,
  "display_username": "Antoine Riard",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"ajtowns, post:29, topic:1509\"]\nGreg used the term precisely and correctly \u2013 his post describes taking a general [zero-knowledge proof](https://bitcointalk.org/index.php?topic=277389.0) feature and using that to produce actual covenant constructions where a coin and all possible spends of that coin are permanently constrained in a particular way, creating a burn address that allows the burnt coins to be burnt again and again:\n[/quote]\n\nYes, I'm familiar with the idea that you have a SNARK verifier as a replacement for the script interpreter, so you get as an input stack `<input public data>` `<verification public key>` `<signature>` `<hash_masked_tx>`, where you can assert properties on the spending tx (e.g is this output scriptpubkey size 32 bytes).\n\nBy setting the verification rule that an output redeem script must be of the form `THIS_VALIDATION_KEY && {whatever rules you want}`, in my understanding you're introducing recursivity of the verification rules.\n\nThe recursivity can be bounded (i.e using the tx nVersion field as a counter) or unbounded, by generating a correct and custom `<verification public key>`.\n\nIn my understanding, and here with in mind Roconnor's FC'17 paper and Jeremy's talk at Standford's 2017, the idea of constraining and recursively applying a set of rules on a UTXO and any of spent tx, is what probably mistakenly understood as a covenant nowadays. At the very least, I gave talks and used the term in that sense in my own writing on bitcoin covenants.\n\nI don't disagree that \"covenant\" is an imprecise terminology. After re-checking the translation in my native tongue (i.e \"une convention legale\"), the term designates more wider legal constructions than what is understood as a \"covenant\" in the English real estate law. Saying contracting primitives or Script opcodes sounds indeed better.\n\n[quote=\"reardencode, post:30, topic:1509\"]\nI\u2019ve made a comparison of many alternatives for developing eltoo. Briefly, APO+CTV+standardized_annex is the most efficient of known alternatives. Compared to this:\n[/quote]\n\nSo the original idea of Eltoo was to have a new sighash flag for the signature of state transaction, that makes them re-bindable on any previous state, removing the constraint to have to store revoked scripts / amounts, for each previous state, and opening the door to >= 2 parties off-chain constructions.\n\nEfficiency-wise, yes I can see how you can have the chan constraint in an \"anyprevout_flag\" tx template in the commitment_tx output, the per-state counter in the annex fields which could be saving the signature cost size, though I'm not sure we're talking about the same data layout. And I believe you might need one more opcode to push the annex field on the stack.\n\n[quote=\"stevenroose, post:31, topic:1509\"]\nI wasn\u2019t trying to point fingers at whomever was involved in the taproot deployment. More rather trying to indicate that the bar for the taproot soft fork was met on perceived technical merit only, while today it seems that practical usage is the only bar upheld.\n[/quote]\n\nAs I pointed out on the mailing list more powerful opcode primitives can open the door to `TxWithhold` risks, by allowing to introspect the status of another UTXO. E.g a basic tx-withhold contract would be someone promising to any miner that if target LN commitment tx is not confirmed until N, a native bitcoin bounty is paid. The N picked up can be the safety timelock of a LN commitment tx.\n\nAt the very least CSFS, with CSFS you can have the `<message>` being the commitment transaction, for which you know the public key (e.g if you're a LN counterparty), but you don't know the `<signature>`.\n\nIf you combine it with an UTXO set oracle (e.g `<message=UTXO_123` signed), you've already a rudimentary yet powerful tx-withhold contract. I don't believe CTV allows in any fashion to do more powerful malicious tx-withhold contract, though I believe if it can affect LN, it can certainly affect Ark too.\n\nIf I'm correct here, the lemma is that you certainly needs to have any LN chan UTXO be veiled with some kind of consensus-level semantics, \"this outpoint cannot be referenced by the Script execution of another UTXO spend\". That can be very touchy to implement in bitcoin Script interpreter\u2026\n\n[quote=\"jamesob, post:32, topic:1509\"]\nWhat the watchmen need is super simple. \u201cThese keys allow moving the coins to a special timelocked staging area, from which the original keys can still pull them back\u201d It\u2019s basically a one-step vault.\n\nIn fact we literally implemented it in terms of unsigned transactions in an early version of liquid, but it was too difficult to keep them synced up and invalidated.\n[/quote]\n\nThanks, this is interesting to get Andrew's opinion here. While I disagree with him on the simplicity (lol) of translating \"these keys allow moving the coins...\" in a protocol and well-designed cryptographic API, I believe this is backing the point I was raising in my previous comment that you should get support for any opcode at the HW-level or within the secure enclave.\n\nOtherwise, how can you be sure that the \"cold keys\" are authorizing the spend to the correct hash of a transaction, if you do not re-verify the hash computation on the enclave ? This is the same problem that the Validating Lightning Signer has already today to verify *all* the state transition of the LN protocol to be secure in face of a \"compromised\" main LN node.\n\nIn my opinion, this as much the community of bitcoin protocol experts to convince than HW vendors of all kinds, that a said given opcode should be supported.\n\n\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014-\n\nSpeaking for myself, I can be supportive of the most minimal opcode improvement that improves self-custody for the lambda bitcoin user, at condition it doesn't introduce tx-withholding risk or extend DoS surface area for full-nodes. If you go in the street to ask to 10 bitcoiners \"do you wish to make the self-custody of your coins, *stronger* and *easier*\", I genuinely believe the number of positive answer is going to be equal to 10. I don't expect the same level of positive answer for Ark, DLC or payment pool, I think it's just either early or far too complex to be understood by a lambda bitcoin user. In comparison coins self-custody has always been an\narea of focus of bitcoin development since people have started to develop lightweight wallets for their own usage in  ~2010 / 2011.\n\nLiquid, no opinion. I've already met many Liquid devs in real-life but I've never met a L-BTC user, which it doesn't mean Liquid users don't exist.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 5,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}