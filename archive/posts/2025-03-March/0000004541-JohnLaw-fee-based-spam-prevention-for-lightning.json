{
  "id": 4541,
  "name": null,
  "username": "JohnLaw",
  "avatar_template": "/letter_avatar_proxy/v4/letter/j/58956e/{size}.png",
  "created_at": "2025-03-14T23:53:46.823Z",
  "cooked": "<h1><a name=\"p-4541-tldr-1\" class=\"anchor\" href=\"#p-4541-tldr-1\"></a>TL;DR</h1>\n<ul>\n<li>Jager [1][2] and Teinturier [8][9] proposed Upfront Fees and Time-Dependent Reverse Hold Fees to prevent spam on the Lightning Network (LN).\n<ul>\n<li>Their protocols charged fees that paid for all significant routing costs.</li>\n<li>However, routers could steal fees from others.</li>\n</ul>\n</li>\n<li>This post extends their protocols by adding:\n<ul>\n<li>secrets that prove a payment reached a given routing node, and</li>\n<li>burn outputs (as proposed by Riard and Naumenko [6][7]) to prevent theft and encourage cooperation.</li>\n</ul>\n</li>\n<li>The resulting protocols charge fees for all significant routing costs and those fees cannot be stolen.\n<ul>\n<li>As a result, they should reduce spam and increase the efficiency of the LN.</li>\n</ul>\n</li>\n</ul>\n<h1><a name=\"p-4541-paper-2\" class=\"anchor\" href=\"#p-4541-paper-2\"></a>Paper</h1>\n<p>A more complete description (including figures, packet details, related work and security analysis) is given in a paper [5].</p>\n<h1><a name=\"p-4541-fee-types-3\" class=\"anchor\" href=\"#p-4541-fee-types-3\"></a>Fee Types</h1>\n<p>The protocols presented here collect 3 types of fees:</p>\n<ul>\n<li>an Upfront Fee paid by the sender to the downstream node in each channel which updates the channel state to include an HTLC for the sender\u2019s Lightning payment,</li>\n<li>a Hold Fee paid by any node that delays the payment to each upstream node that they delay, and</li>\n<li>a Success Fee paid by the sender to each node that helps deliver a successful Lightning payment.</li>\n</ul>\n<p>The Upfront Fee pays for:</p>\n<ul>\n<li>the computation and communication costs of routing the payment,</li>\n<li>the cost of allocating a Commitment transaction output (\u201cslot\u201d) to the payment,</li>\n<li>the cost of allocating channel funds to the payment for the seconds that can be required for a non-delayed payment,</li>\n<li>the risk of not fulfilling the HTLC with one\u2019s upstream partner despite one\u2019s downstream partner having fulfilled their HTLC,</li>\n<li>the risk of having to pay a Hold Fee (as described below), and</li>\n<li>the risk of burning funds (as described below).</li>\n</ul>\n<p>Before routing or receiving a Lightning payment, each node publishes its hold_grace_period_delta_msec parameter giving the minimum time they can take without having to pay for delaying a Lightning payment.\nIf a router or the destination delays a Lightning payment beyond its grace period, it pays a Hold Fee to each of the upstream nodes for:</p>\n<ul>\n<li>the cost of their capital held for the length of the delay, and</li>\n<li>the inconvenience imposed on the sender for the length of the delay.</li>\n</ul>\n<p>The Success Fee pays for the service of successfully completing a payment.\nAs a result, it motivates the routers and the destination to make the payment attempt succeed.</p>\n<h1><a name=\"p-4541-fee-collection-4\" class=\"anchor\" href=\"#p-4541-fee-collection-4\"></a>Fee Collection</h1>\n<p>As in the current Lightning protocol, the Success Fee is paid by increasing the size of each HTLC in order to include fees for the downstream node in the current channel and in all later channels.\nAs a result, any node that participates in a successful payment will be rewarded with a Success Fee.</p>\n<p>The collection of Upfront and Hold Fees relies on the addition of a burn output to the Lightning channel\u2019s transactions.\nThe burn output can be spent by anyone after a 20-year delay (so the burn output will be claimed by a miner 20 years in the future).\nBoth parties in a Lightning channel put some of their funds in the burn output, and when the payment\u2019s HTLC is resolved the protocol determines how the burn output\u2019s funds are divided between the channel partners.\nThe protocol allows both parties to calculate the same division of the burn output\u2019s funds, and the fact that those funds will be burned unless the parties agree on their division incentivizes cooperation.</p>\n<h1><a name=\"p-4541-calculating-upfront-fees-5\" class=\"anchor\" href=\"#p-4541-calculating-upfront-fees-5\"></a>Calculating Upfront Fees</h1>\n<p>This post presents two protocols for calculating Upfront Fees.\nIn both protocols, the upstream node in each channel stakes (by adding them to the burn output) Upfront Fee funds that are sufficient to pay Upfront Fees to all of the nodes that are downstream of it along the payment\u2019s path.\nThe staked Upfront Fees are then divided according to how far the payment is routed.</p>\n<p>Let n denote the number of payment hops, with node 0 being the sender and node n being the destination.\nFor 0 &lt; k &lt;= n, a payment \u201cstops\u201d at node k if node k is a downstream node in the last channel which updated its state to include an HTLC for the given payment.</p>\n<p>In both protocols the channel partners create a contract for transferring Upfront Fee funds to the downstream node if that node provides a required secret before the contract\u2019s expiry.\nAs a result, the contract for transferring Upfront funds is similar to an HTLC, but with multiple cases based on which secret is provided by the downstream node.\nThese different secrets correspond to different nodes at which the payment could stop.</p>\n<h2><a name=\"p-4541-preimage-per-stopping-node-6\" class=\"anchor\" href=\"#p-4541-preimage-per-stopping-node-6\"></a>Preimage Per Stopping Node</h2>\n<p>The first protocol uses secrets that are hash preimages, with a separate preimage per stopping node.</p>\n<p>The hop payload of the onion packet received by node i includes the secret X_i.</p>\n<p>The update_add_htlc packet sent to node i includes the list of pairs (Y_i, t_{i,i}), (Y_{i+1}, t_{i,i+1}) \u2026 (Y_n, t_{i,n}) where for each k, Y_k = hash(X_k).\nThe value t_{i,k} equals the sum of the Upfront Fees for nodes i through k, so t_{i,k} is the amount of Upfront Fees transferred (via the burn output) from node i-1 to node i for a payment that stops at node k.</p>\n<p>When node i-1 sends an update_add_htlc packet to node i, both nodes update the channel state to include the given HTLC.\nIn addition, node i-1 stakes t_{i,n} funds (which is the maximum possible transfer of Upfront Fees to node i) to the burn output, and both nodes contribute a fixed fraction of t_{i,n} funds (called \u201cmatching funds\u201d) to the burn output.</p>\n<p>When the payment stops at some node k, node k includes the secret X_k in the update_fulfill_htlc or update_fail_htlc packet that it sends to its upstream partner.\nEach node i, 0 &lt; i &lt; k, then includes this same secret X_k in the update_fulfill_htlc or update_fail_htlc packet that it sends to its upstream partner.</p>\n<p>Nodes i-1 and i then update their channel state to reflect the resolution of the HTLC and the division of the Upfront funds.\nSpecifically, nodes i-1 and i determine the value of k such that Y_k = hash(X_k), transfer t_{i,k} Upfront funds from the burn output to node i, refund the remaining staked Upfront funds to node i-1, and refund the matching funds to both nodes.</p>\n<p>This simple protocol allows each node to receive its correct Upfront Fee, but it reduces privacy because two routers can use the list of pairs in the update_add_htlc packet to determine they are routing the same payment.</p>\n<h2><a name=\"p-4541-discrete-logarithms-7\" class=\"anchor\" href=\"#p-4541-discrete-logarithms-7\"></a>Discrete Logarithms</h2>\n<p>The second protocol uses discrete logarithms of points (rather than hash preimages) in order to eliminate this loss of privacy.</p>\n<p>Let u_i denote the Upfront Fee paid to node i if the payment reaches node i.\nLet f_i denote the amount of Upfront Fees staked by node i-1 for potential transfer to node i.</p>\n<p>For each i, 0 &lt; i &lt;= n, node i-1 includes the Upfront stake amount f_i and a list of points P_{i,i}, P_{i,i+1} \u2026 P_{i,n} in the update_add_htlc packet that it sends to node i.</p>\n<p>Nodes i-1 and i create the following contract:</p>\n<ul>\n<li>node i-1 stakes f_i Upfront funds for potential transfer to node i, and</li>\n<li>if node i includes a discrete log p_{i,k} in the update_fulfill_htlc or update_fail_htlc packet it sends to node i-1, where:\n<ul>\n<li>p_{i,k}*G = P_{i,k} for some k &lt;= n,</li>\n<li>t_{i,k} is the value of the 32 most significant bits of p_{i,k}, and</li>\n<li>t_{i,k} &lt;= f_i,\nthen node i-1 will transfer t_{i,k} Upfront funds to node i.</li>\n</ul>\n</li>\n</ul>\n<p>The onion payload for node i provides two types of secret.</p>\n<p>First, it provides the discrete log p_{i,i} where p_{i,i}*G = P_{i,i} and the most significant 32 bits of p_{i,i} equal u_i.\nTherefore, p_{i,i} is the discrete log that node i gives node i-1 if the payment stops at node i.</p>\n<p>Second, if i &lt; n the onion payload provides delta values d_{i,k}, i &lt; k &lt;= n, which are the differences between the discrete log of P_{i,k} and the discrete log of P_{i+1,k} (where P_{i+1,k} is a point in the list of points in the update_add_htlc packet sent to node i+1).\nWhile the onion payload does not allow node i to determine the discrete log of P_{i,k}, it does allow node i to determine that P_{i,k} = P_{i+1,k} + d_{i,k}*G.\nTherefore, d_{i,k} is the difference between the discrete log of P_{i+1,k} and the discrete log of P_{i,k}, so if node i+1 gives node i the discrete log of P_{i+1,k}, node i will be able to calculate the discrete log of P_{i,k}.\nFurthermore, the most significant 32 bits of d_{i,k} are a lower bound on the difference between t_{i,k} (the Upfront transfer to node i from node i-1) and t_{i+1,k} (the Upfront transfer from node i to node i+1) [5].\nAs a result, node i can verify that it will receive a sufficiently large net Upfront transfer of t_{i,k} - t_{i+1,k} by examining the most significant 32 bits of each d_{i,k}.</p>\n<p>When the payment stops at some node k, node k includes the discrete log p_{k,k} in the update_fulfill_htlc or update_fail_htlc packet that it sends to its upstream partner.\nEach node i, 0 &lt; i &lt; k, then takes the discrete log p_{i+1,k} that it received from its downstream partner and determines k using the formula p_{i+1,k}*G = P_{i+1,k}.\nNext, each node i, 0 &lt; i &lt; k, calculates the discrete log p_{i,k} to include in the update_fulfill_htlc or update_fail_htlc packet that it sends to its upstream partner using the formula p_{i,k} = p_{i+1,k} + d_{i,k} [5].\nNodes i-1 and i then update their channel state to reflect the resolution of the HTLC and the division of the Upfront funds.\nSpecifically, nodes i-1 and i calculate t_{i,k} equals the 32 most significant bits of p_{i,k}, verify that t_{i,k} &lt;= f_i, transfer t_{i,k} Upfront funds from the burn output to node i, refund the remaining staked Upfront funds to node i-1, and refund the matching funds to both nodes.</p>\n<p>While the above protocol allows the nodes to calculate the correct division of Upfront Fees, including the delta values d_{i,k}, i &lt; k &lt;= n, in the onion payload would force the onion size to grow quadratically in n.\nInstead, the actual protocol uses hash functions to eliminate this quadratic growth.\nThe full details are given in the paper [5].</p>\n<h1><a name=\"p-4541-calculating-hold-fees-8\" class=\"anchor\" href=\"#p-4541-calculating-hold-fees-8\"></a>Calculating Hold Fees</h1>\n<p>Hold Fees are paid by nodes to all upstream nodes that are delayed beyond the payment\u2019s hold grace period.\nThe downstream node in each channel stakes the maximum Hold Fee it could transfer by putting those funds in the burn output.\nIn addition, both nodes add matching funds to the burn output that are a fixed fraction of the staked Hold Fee funds.\nIf the downstream node provides an update_fulfill_htlc or update_fail_htlc packet to its upstream partner after the payment\u2019s hold grace period expires, the downstream node makes a transfer of Hold Fee funds that is the product of the downstream node\u2019s hold_usat_per_hour value and the number of hours by which the payment was delayed, regardless of whether or not the downstream node was the cause of the delay.</p>\n<p>The update_add_htlc packet sent to each node i includes:</p>\n<ul>\n<li>the grace period expiry g_i and</li>\n<li>the stake amount h_i.</li>\n</ul>\n<p>When it receives an update_add_htlc packet, node i calculates h_i divided by the maximum delay possible at node i (which is the difference between the expiry of the HTLC offered to node i and the grace period expiry g_i) to obtain y_i (which is the rate at which node i transfers Hold Fee funds to its upstream partner).\nIf i &lt; n, node i also calculates y_{i+1} and verifies that y_{i+1} - y_i (which is the rate at which node i is paid a net Hold Fee for the cost of delaying its use of its capital) is sufficiently large.\nNode i also verifies that its hold grace period, g_i - g_{i+1}, is sufficiently long.</p>\n<p>The Hold funds that are staked in the burn output by node i have to be divided according to how quickly the HTLC offered to node i is resolved.\nIf that HTLC is resolved by g_i, then all of those funds are refunded to node i.\nHowever, if the HTLC is resolved after g_i, node i calculates the length of the delay, d_i, and transfers d_i * y_i Hold funds to its upstream partner and refunds the remaining staked Hold funds to itself.\nIn addition, the matching funds are returned to both nodes.\nThe full details are given in the paper [5].</p>\n<h1><a name=\"p-4541-risk-of-burning-funds-9\" class=\"anchor\" href=\"#p-4541-risk-of-burning-funds-9\"></a>Risk Of Burning Funds</h1>\n<p>There are four ways in which a party that follows the protocol can be forced to burn funds.</p>\n<p>First, one may have to put a Commitment transaction with a burn output on-chain in order to resolve an HTLC.\nFor example, this can happen when using the current Lightning protocol.\nHowever, this possibility can be eliminated by using a separate Payment transaction [5], a factory-optimized channel protocol [5][3], or the Off-chain Payment Resolution protocol [5][4].</p>\n<p>Second, if one\u2019s channel partner fails and cannot update the channel state for a very long time (e.g., months), one may have to close the channel unilaterally by putting their channel state transactions with a burn output on-chain.\nThe amount of time one is willing to wait is based on the likelihood of their partner becoming responsive versus the cost of the channel\u2019s capital, and is independent of the lengths of the HTLCs\u2019 expiries.</p>\n<p>Third, a dishonest channel partner can put channel state transactions with a burn output on-chain in order to grief their partner (while also griefing themselves).\nIn this case, the griefer loses (at least) their matching funds, which are set high enough to discourage most or all such griefing attacks.\nSpecifically, if each party devotes a fraction m of the amount staked for Upfront and Hold Fees as matching funds, the griefer must lose at least m/(1+m) as many funds as their partner loses.</p>\n<p>Fourth, if both parties are honest but they fail in such a way that they don\u2019t agree on the determination of Upfront and Hold Fees, they will be forced to burn those fees and their matching funds.\nFortunately, there are many techniques that reduce the likelihood of such failures, including:</p>\n<ul>\n<li>adding buffers for clock skew and maximum packet transmission times when determining when the downstream partner sent the payment\u2019s update_fulfill_htlc or update_fail_htlc packet,</li>\n<li>synchronizing the channel partners\u2019 clocks by exchanging frequent time stamp messages,</li>\n<li>maintaining a nonvolatile log of when all update_fulfill_htlc or update_fail_htlc packets are sent or received, and</li>\n<li>sending multiple encrypted copies of update_fulfill_htlc or update_fail_htlc packets via independent third-parties.</li>\n</ul>\n<p>If all of the multiple copies are sent but fail to reach the offerer, it is likely there was either a complete loss of communication by the offeree or a failure of the offerer.\nThese cases can be differentiated by looking at the nonvolatile logs for the nodes\u2019 other channels.\nFor example, if a node has 20 channels with different partners and stops receiving time-stamped messages from just one of those partners, they can conclude that the failure was likely caused by that partner.\nOn the other hand, if the node stops receiving messages on all 20 channels, the node can conclude that it\u2019s likely the cause of the failures (and as a result, it should agree with its partner\u2019s division of the burn output funds).</p>\n<p>Finally, a party can lose funds if they can be psychologically manipulated to allow their partner to steal from them.\nFor example, if Alice and Bob should each receive two thousand sats from the burn output, Bob could refuse to update the channel state unless he gets three thousand sats from the burn output (and Alice could agree in order to at least get the remaining one thousand sats).\nThis type of bullying attack can be prevented by ensuring that all channel updates are performed automatically, rather than under human control.</p>\n<h1><a name=\"p-4541-conclusions-10\" class=\"anchor\" href=\"#p-4541-conclusions-10\"></a>Conclusions</h1>\n<p>This post presents protocols for assigning and collecting fees for Lightning services.\nThese protocols force the parties to pay for all significant costs that they impose on others and the fees they charge cannot be stolen by self-interested parties.\nIt\u2019s hoped these protocols will be used to both reduce spam and improve the efficiency of the Lightning Network.</p>\n<h1><a name=\"p-4541-references-11\" class=\"anchor\" href=\"#p-4541-references-11\"></a>References</h1>\n<p>[1] Jager, \u201cHold fees: 402 Payment Required for Lightning itself\u201d, <a href=\"https://www.mail-archive.com/lightning-dev@lists.linuxfoundation.org/msg02080.html\" rel=\"noopener nofollow ugc\">https://www.mail-archive.com/lightning-dev@lists.linuxfoundation.org/msg02080.html</a></p>\n<p>[2] Jager, \u201cHold fee rates as DoS protection (channel spamming and jamming)\u201d, <a href=\"https://www.mail-archive.com/lightning-dev@lists.linuxfoundation.org/msg02212.html\" rel=\"noopener nofollow ugc\">https://www.mail-archive.com/lightning-dev@lists.linuxfoundation.org/msg02212.html</a></p>\n<p>[3] Law, \u201cFactory Optimized Protocols For Lightning\u201d, <a href=\"https://github.com/JohnLaw2/ln-factory-optimized\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">GitHub - JohnLaw2/ln-factory-optimized: Factory-optimized Lightning channels for Bitcoin</a></p>\n<p>[4] Law, \u201cA Fast, Scalable Protocol For Resolving Lightning Payments\u201d, <a href=\"https://github.com/JohnLaw2/ln-opr\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">GitHub - JohnLaw2/ln-opr: A fast, scalable protocol for resolving Lightning payments</a></p>\n<p>[5] Law, \u201cFee-Based Spam Prevention For Lightning\u201d, <a href=\"https://github.com/JohnLaw2/ln-spam-prevention\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">GitHub - JohnLaw2/ln-spam-prevention: Fee-based protocols for preventing spam on the Bitcoin Lightning Network</a></p>\n<p>[6] Riard, \u201cUnjamming lightning (new research paper)\u201d, <a href=\"https://www.mail-archive.com/lightning-dev@lists.linuxfoundation.org/msg02996.html\" rel=\"noopener nofollow ugc\">https://www.mail-archive.com/lightning-dev@lists.linuxfoundation.org/msg02996.html</a></p>\n<p>[7] Riard and Naumenko, \u201cLightning Jamming Book\u201d, <a href=\"https://jamming-dev.github.io/book/\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">About</a></p>\n<p>[8] Teinturier, \u201cRe: Hold fees: 402 Payment Required for Lightning itself\u201d, <a href=\"https://www.mail-archive.com/lightning-dev@lists.linuxfoundation.org/msg02106.html\" rel=\"noopener nofollow ugc\">https://www.mail-archive.com/lightning-dev@lists.linuxfoundation.org/msg02106.html</a></p>\n<p>[9] Teinturier, \u201cSpam Prevention\u201d, <a href=\"https://github.com/t-bast/lightning-docs/blob/398a1b78250f564f7c86a414810f7e87e5af23ba/spam-prevention.md\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">lightning-docs/spam-prevention.md at 398a1b78250f564f7c86a414810f7e87e5af23ba \u00b7 t-bast/lightning-docs \u00b7 GitHub</a></p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2025-03-14T23:58:49.861Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 1,
  "reads": 4,
  "readers_count": 3,
  "score": 5.6,
  "yours": false,
  "topic_id": 1524,
  "topic_slug": "fee-based-spam-prevention-for-lightning",
  "topic_title": "Fee-Based Spam Prevention For Lightning",
  "topic_html_title": "Fee-Based Spam Prevention For Lightning",
  "category_id": 7,
  "display_username": null,
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "TL;DR\n=====\n* Jager [1][2] and Teinturier [8][9] proposed Upfront Fees and Time-Dependent Reverse Hold Fees to prevent spam on the Lightning Network (LN).\n  - Their protocols charged fees that paid for all significant routing costs.\n  - However, routers could steal fees from others.\n* This post extends their protocols by adding:\n  - secrets that prove a payment reached a given routing node, and\n  - burn outputs (as proposed by Riard and Naumenko [6][7]) to prevent theft and encourage cooperation.\n* The resulting protocols charge fees for all significant routing costs and those fees cannot be stolen.\n  - As a result, they should reduce spam and increase the efficiency of the LN.\n\nPaper\n=====\nA more complete description (including figures, packet details, related work and security analysis) is given in a paper [5].\n\nFee Types\n=========\nThe protocols presented here collect 3 types of fees:\n  * an Upfront Fee paid by the sender to the downstream node in each channel which updates the channel state to include an HTLC for the sender's Lightning payment,\n  * a Hold Fee paid by any node that delays the payment to each upstream node that they delay, and\n  * a Success Fee paid by the sender to each node that helps deliver a successful Lightning payment.\n\nThe Upfront Fee pays for:\n  * the computation and communication costs of routing the payment,\n  * the cost of allocating a Commitment transaction output (\"slot\") to the payment,\n  * the cost of allocating channel funds to the payment for the seconds that can be required for a non-delayed payment,\n  * the risk of not fulfilling the HTLC with one's upstream partner despite one's downstream partner having fulfilled their HTLC,\n  * the risk of having to pay a Hold Fee (as described below), and\n  * the risk of burning funds (as described below).\n\nBefore routing or receiving a Lightning payment, each node publishes its hold_grace_period_delta_msec parameter giving the minimum time they can take without having to pay for delaying a Lightning payment.\nIf a router or the destination delays a Lightning payment beyond its grace period, it pays a Hold Fee to each of the upstream nodes for:\n  * the cost of their capital held for the length of the delay, and\n  * the inconvenience imposed on the sender for the length of the delay.\n\nThe Success Fee pays for the service of successfully completing a payment.\nAs a result, it motivates the routers and the destination to make the payment attempt succeed.\n\nFee Collection\n==============\nAs in the current Lightning protocol, the Success Fee is paid by increasing the size of each HTLC in order to include fees for the downstream node in the current channel and in all later channels.\nAs a result, any node that participates in a successful payment will be rewarded with a Success Fee.\n\nThe collection of Upfront and Hold Fees relies on the addition of a burn output to the Lightning channel's transactions.\nThe burn output can be spent by anyone after a 20-year delay (so the burn output will be claimed by a miner 20 years in the future).\nBoth parties in a Lightning channel put some of their funds in the burn output, and when the payment's HTLC is resolved the protocol determines how the burn output's funds are divided between the channel partners.\nThe protocol allows both parties to calculate the same division of the burn output's funds, and the fact that those funds will be burned unless the parties agree on their division incentivizes cooperation.\n\nCalculating Upfront Fees\n========================\nThis post presents two protocols for calculating Upfront Fees.\nIn both protocols, the upstream node in each channel stakes (by adding them to the burn output) Upfront Fee funds that are sufficient to pay Upfront Fees to all of the nodes that are downstream of it along the payment's path.\nThe staked Upfront Fees are then divided according to how far the payment is routed.\n\nLet n denote the number of payment hops, with node 0 being the sender and node n being the destination.\nFor 0 < k <= n, a payment \"stops\" at node k if node k is a downstream node in the last channel which updated its state to include an HTLC for the given payment.\n\nIn both protocols the channel partners create a contract for transferring Upfront Fee funds to the downstream node if that node provides a required secret before the contract's expiry.\nAs a result, the contract for transferring Upfront funds is similar to an HTLC, but with multiple cases based on which secret is provided by the downstream node.\nThese different secrets correspond to different nodes at which the payment could stop.\n\nPreimage Per Stopping Node\n--------------------------\nThe first protocol uses secrets that are hash preimages, with a separate preimage per stopping node.\n\nThe hop payload of the onion packet received by node i includes the secret X_i.\n\nThe update_add_htlc packet sent to node i includes the list of pairs (Y_i, t_{i,i}), (Y_{i+1}, t_{i,i+1}) ... (Y_n, t_{i,n}) where for each k, Y_k = hash(X_k).\nThe value t_{i,k} equals the sum of the Upfront Fees for nodes i through k, so t_{i,k} is the amount of Upfront Fees transferred (via the burn output) from node i-1 to node i for a payment that stops at node k.\n\nWhen node i-1 sends an update_add_htlc packet to node i, both nodes update the channel state to include the given HTLC.\nIn addition, node i-1 stakes t_{i,n} funds (which is the maximum possible transfer of Upfront Fees to node i) to the burn output, and both nodes contribute a fixed fraction of t_{i,n} funds (called \"matching funds\") to the burn output.\n\nWhen the payment stops at some node k, node k includes the secret X_k in the update_fulfill_htlc or update_fail_htlc packet that it sends to its upstream partner.\nEach node i, 0 < i < k, then includes this same secret X_k in the update_fulfill_htlc or update_fail_htlc packet that it sends to its upstream partner.\n\nNodes i-1 and i then update their channel state to reflect the resolution of the HTLC and the division of the Upfront funds.\nSpecifically, nodes i-1 and i determine the value of k such that Y_k = hash(X_k), transfer t_{i,k} Upfront funds from the burn output to node i, refund the remaining staked Upfront funds to node i-1, and refund the matching funds to both nodes.\n\nThis simple protocol allows each node to receive its correct Upfront Fee, but it reduces privacy because two routers can use the list of pairs in the update_add_htlc packet to determine they are routing the same payment.\n\nDiscrete Logarithms\n-------------------\nThe second protocol uses discrete logarithms of points (rather than hash preimages) in order to eliminate this loss of privacy.\n\nLet u_i denote the Upfront Fee paid to node i if the payment reaches node i.\nLet f_i denote the amount of Upfront Fees staked by node i-1 for potential transfer to node i.\n\nFor each i, 0 < i <= n, node i-1 includes the Upfront stake amount f_i and a list of points P_{i,i}, P_{i,i+1} ... P_{i,n} in the update_add_htlc packet that it sends to node i.\n\nNodes i-1 and i create the following contract:\n  * node i-1 stakes f_i Upfront funds for potential transfer to node i, and\n  * if node i includes a discrete log p_{i,k} in the update_fulfill_htlc or update_fail_htlc packet it sends to node i-1, where:\n    * p_{i,k}*G = P_{i,k} for some k <= n,\n    * t_{i,k} is the value of the 32 most significant bits of p_{i,k}, and\n    * t_{i,k} <= f_i,\nthen node i-1 will transfer t_{i,k} Upfront funds to node i.\n\nThe onion payload for node i provides two types of secret.\n\nFirst, it provides the discrete log p_{i,i} where p_{i,i}*G = P_{i,i} and the most significant 32 bits of p_{i,i} equal u_i.\nTherefore, p_{i,i} is the discrete log that node i gives node i-1 if the payment stops at node i.\n\nSecond, if i < n the onion payload provides delta values d_{i,k}, i < k <= n, which are the differences between the discrete log of P_{i,k} and the discrete log of P_{i+1,k} (where P_{i+1,k} is a point in the list of points in the update_add_htlc packet sent to node i+1).\nWhile the onion payload does not allow node i to determine the discrete log of P_{i,k}, it does allow node i to determine that P_{i,k} = P_{i+1,k} + d_{i,k}*G.\nTherefore, d_{i,k} is the difference between the discrete log of P_{i+1,k} and the discrete log of P_{i,k}, so if node i+1 gives node i the discrete log of P_{i+1,k}, node i will be able to calculate the discrete log of P_{i,k}.\nFurthermore, the most significant 32 bits of d_{i,k} are a lower bound on the difference between t_{i,k} (the Upfront transfer to node i from node i-1) and t_{i+1,k} (the Upfront transfer from node i to node i+1) [5].\nAs a result, node i can verify that it will receive a sufficiently large net Upfront transfer of t_{i,k} - t_{i+1,k} by examining the most significant 32 bits of each d_{i,k}.\n\nWhen the payment stops at some node k, node k includes the discrete log p_{k,k} in the update_fulfill_htlc or update_fail_htlc packet that it sends to its upstream partner.\nEach node i, 0 < i < k, then takes the discrete log p_{i+1,k} that it received from its downstream partner and determines k using the formula p_{i+1,k}*G = P_{i+1,k}.\nNext, each node i, 0 < i < k, calculates the discrete log p_{i,k} to include in the update_fulfill_htlc or update_fail_htlc packet that it sends to its upstream partner using the formula p_{i,k} = p_{i+1,k} + d_{i,k} [5].\nNodes i-1 and i then update their channel state to reflect the resolution of the HTLC and the division of the Upfront funds.\nSpecifically, nodes i-1 and i calculate t_{i,k} equals the 32 most significant bits of p_{i,k}, verify that t_{i,k} <= f_i, transfer t_{i,k} Upfront funds from the burn output to node i, refund the remaining staked Upfront funds to node i-1, and refund the matching funds to both nodes.\n\nWhile the above protocol allows the nodes to calculate the correct division of Upfront Fees, including the delta values d_{i,k}, i < k <= n, in the onion payload would force the onion size to grow quadratically in n.\nInstead, the actual protocol uses hash functions to eliminate this quadratic growth.\nThe full details are given in the paper [5].\n\nCalculating Hold Fees\n=====================\nHold Fees are paid by nodes to all upstream nodes that are delayed beyond the payment's hold grace period.\nThe downstream node in each channel stakes the maximum Hold Fee it could transfer by putting those funds in the burn output.\nIn addition, both nodes add matching funds to the burn output that are a fixed fraction of the staked Hold Fee funds.\nIf the downstream node provides an update_fulfill_htlc or update_fail_htlc packet to its upstream partner after the payment's hold grace period expires, the downstream node makes a transfer of Hold Fee funds that is the product of the downstream node's hold_usat_per_hour value and the number of hours by which the payment was delayed, regardless of whether or not the downstream node was the cause of the delay.\n\nThe update_add_htlc packet sent to each node i includes:\n  * the grace period expiry g_i and\n  * the stake amount h_i.\n  \nWhen it receives an update_add_htlc packet, node i calculates h_i divided by the maximum delay possible at node i (which is the difference between the expiry of the HTLC offered to node i and the grace period expiry g_i) to obtain y_i (which is the rate at which node i transfers Hold Fee funds to its upstream partner).\nIf i < n, node i also calculates y_{i+1} and verifies that y_{i+1} - y_i (which is the rate at which node i is paid a net Hold Fee for the cost of delaying its use of its capital) is sufficiently large.\nNode i also verifies that its hold grace period, g_i - g_{i+1}, is sufficiently long.\n\nThe Hold funds that are staked in the burn output by node i have to be divided according to how quickly the HTLC offered to node i is resolved.\nIf that HTLC is resolved by g_i, then all of those funds are refunded to node i.\nHowever, if the HTLC is resolved after g_i, node i calculates the length of the delay, d_i, and transfers d_i * y_i Hold funds to its upstream partner and refunds the remaining staked Hold funds to itself.\nIn addition, the matching funds are returned to both nodes.\nThe full details are given in the paper [5].\n\nRisk Of Burning Funds\n=====================\nThere are four ways in which a party that follows the protocol can be forced to burn funds.\n\nFirst, one may have to put a Commitment transaction with a burn output on-chain in order to resolve an HTLC.\nFor example, this can happen when using the current Lightning protocol.\nHowever, this possibility can be eliminated by using a separate Payment transaction [5], a factory-optimized channel protocol [5][3], or the Off-chain Payment Resolution protocol [5][4].\n\nSecond, if one's channel partner fails and cannot update the channel state for a very long time (e.g., months), one may have to close the channel unilaterally by putting their channel state transactions with a burn output on-chain.\nThe amount of time one is willing to wait is based on the likelihood of their partner becoming responsive versus the cost of the channel's capital, and is independent of the lengths of the HTLCs' expiries.\n\nThird, a dishonest channel partner can put channel state transactions with a burn output on-chain in order to grief their partner (while also griefing themselves).\nIn this case, the griefer loses (at least) their matching funds, which are set high enough to discourage most or all such griefing attacks.\nSpecifically, if each party devotes a fraction m of the amount staked for Upfront and Hold Fees as matching funds, the griefer must lose at least m/(1+m) as many funds as their partner loses.\n\nFourth, if both parties are honest but they fail in such a way that they don't agree on the determination of Upfront and Hold Fees, they will be forced to burn those fees and their matching funds.\nFortunately, there are many techniques that reduce the likelihood of such failures, including:\n  * adding buffers for clock skew and maximum packet transmission times when determining when the downstream partner sent the payment's update_fulfill_htlc or update_fail_htlc packet,\n  * synchronizing the channel partners' clocks by exchanging frequent time stamp messages,\n  * maintaining a nonvolatile log of when all update_fulfill_htlc or update_fail_htlc packets are sent or received, and\n  * sending multiple encrypted copies of update_fulfill_htlc or update_fail_htlc packets via independent third-parties.\n  \nIf all of the multiple copies are sent but fail to reach the offerer, it is likely there was either a complete loss of communication by the offeree or a failure of the offerer.\nThese cases can be differentiated by looking at the nonvolatile logs for the nodes' other channels.\nFor example, if a node has 20 channels with different partners and stops receiving time-stamped messages from just one of those partners, they can conclude that the failure was likely caused by that partner.\nOn the other hand, if the node stops receiving messages on all 20 channels, the node can conclude that it's likely the cause of the failures (and as a result, it should agree with its partner's division of the burn output funds).\n\nFinally, a party can lose funds if they can be psychologically manipulated to allow their partner to steal from them.\nFor example, if Alice and Bob should each receive two thousand sats from the burn output, Bob could refuse to update the channel state unless he gets three thousand sats from the burn output (and Alice could agree in order to at least get the remaining one thousand sats).\nThis type of bullying attack can be prevented by ensuring that all channel updates are performed automatically, rather than under human control.\n\nConclusions\n===========\nThis post presents protocols for assigning and collecting fees for Lightning services.\nThese protocols force the parties to pay for all significant costs that they impose on others and the fees they charge cannot be stolen by self-interested parties.\nIt's hoped these protocols will be used to both reduce spam and improve the efficiency of the Lightning Network.\n\nReferences\n==========\n\n[1] Jager, \"Hold fees: 402 Payment Required for Lightning itself\", https://www.mail-archive.com/lightning-dev@lists.linuxfoundation.org/msg02080.html\n\n[2] Jager, \"Hold fee rates as DoS protection (channel spamming and jamming)\", https://www.mail-archive.com/lightning-dev@lists.linuxfoundation.org/msg02212.html\n\n[3] Law, \"Factory Optimized Protocols For Lightning\", https://github.com/JohnLaw2/ln-factory-optimized\n\n[4] Law, \"A Fast, Scalable Protocol For Resolving Lightning Payments\", https://github.com/JohnLaw2/ln-opr\n\n[5] Law, \"Fee-Based Spam Prevention For Lightning\", https://github.com/JohnLaw2/ln-spam-prevention\n\n[6] Riard, \"Unjamming lightning (new research paper)\", https://www.mail-archive.com/lightning-dev@lists.linuxfoundation.org/msg02996.html\n\n[7] Riard and Naumenko, \"Lightning Jamming Book\", https://jamming-dev.github.io/book/\n\n[8] Teinturier, \"Re: Hold fees: 402 Payment Required for Lightning itself\", https://www.mail-archive.com/lightning-dev@lists.linuxfoundation.org/msg02106.html\n\n[9] Teinturier, \"Spam Prevention\", https://github.com/t-bast/lightning-docs/blob/398a1b78250f564f7c86a414810f7e87e5af23ba/spam-prevention.md",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 279,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": "Github link was replaced with a permanent link",
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}