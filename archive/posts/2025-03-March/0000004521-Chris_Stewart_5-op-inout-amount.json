{
  "id": 4521,
  "name": "Chris Stewart",
  "username": "Chris_Stewart_5",
  "avatar_template": "/user_avatar/delvingbitcoin.org/chris_stewart_5/{size}/296_2.png",
  "created_at": "2025-03-13T18:43:07.492Z",
  "cooked": "<p>Ok Johan, i finally took you up on this. Here is my attempt at implementing what I think you and <a href=\"https://gnusha.org/pi/bitcoindev/20210909065330.GB22496@erisian.com.au/\" rel=\"noopener nofollow ugc\">AJ Towns</a> were hinting at.</p>\n<blockquote>\n<p>Having it be possible to specify indexes would be very helpful in creating more sophisticated merges/splits of UTXOS. And I think the implementation complexity would not drastically increase?</p>\n</blockquote>\n<blockquote>\n<p>\u2026 or it could even accept a parameter letting you specify which input \u2026</p>\n</blockquote>\n<h2><a name=\"p-4521-background-1\" class=\"anchor\" href=\"#p-4521-background-1\"></a>Background</h2>\n<p>Elements has 2 opcodes called <a href=\"https://github.com/ElementsProject/elements/blob/df4e99dca3b9f4a49592b98fed3af8aeed6035ae/src/script/interpreter.cpp#L1875\" rel=\"noopener nofollow ugc\">OP_INSPECTINPUTVALUE</a> and <a href=\"https://github.com/ElementsProject/elements/blob/df4e99dca3b9f4a49592b98fed3af8aeed6035ae/src/script/interpreter.cpp#L1958\" rel=\"noopener nofollow ugc\">OP_INSPECTOUTPUTVALUE</a>. These opcodes are limited to pushing the value of the current input index and its corresponding output index onto the stack. I believe this means that there must be a one-to-one size relationship for inputs and outputs in element\u2019s transactions if either <code>OP_INSPECTINPUTVALUE</code> or <code>OP_INSPECTOUTPUTVALUE</code> is used. Also - IIUC - this creates a simple heuristic to correlate inputs and outputs in a transaction. If this is incorrect, please let me know.</p>\n<h2><a name=\"p-4521-design-2\" class=\"anchor\" href=\"#p-4521-design-2\"></a>Design</h2>\n<p>A design goal of mine for this iteration of <code>OP_INOUT_AMOUNT</code> is to allow for variable size input and output sets in a bitcoin transaction.</p>\n<p>I reworked <code>OP_INOUT_AMOUNT</code> to take 2 stack parameters. They are each interpreted as bitmaps. We sum the outputs and inputs at the set indices and push the result onto the stack.</p>\n<p>Lets assume our transaction has the format</p>\n<blockquote>\n<p>CTx(input_amounts=[1BTC,2BTC],output_amounts=[0.25BTC,0.5BTC,1BTC])</p>\n</blockquote>\n<p>and the current stack state before evaluating <code>OP_INOUT_AMOUNT</code> is</p>\n<pre><code class=\"lang-auto\">10100000 # output indices to push onto the stack\n11000000 # input indices to push onto the stack\n</code></pre>\n<p>This would mean the values at output indexes 0 and 2 (<code>0.25BTC</code> and <code>1BTC</code>) should be added together and pushed onto the stack.</p>\n<p>This also mean the values at input indices 0 and 1 (<code>1BTC</code> and <code>2BTC</code>) should be added together and pushed onto the stack.</p>\n<p>The resulting stack would be</p>\n<pre><code class=\"lang-auto\">1.25BTC # output value pushed onto the stack\n3BTC # input value pushed onto the stack\n</code></pre>\n<p>Here is the to see the <a href=\"https://github.com/Christewart/bitcoin/blob/df5ef7baf2493c59062991d872425cfdf39d181f/src/script/interpreter.cpp#L1283\" rel=\"noopener nofollow ugc\">implementation</a> and <a href=\"https://github.com/Christewart/bitcoin/blob/df5ef7baf2493c59062991d872425cfdf39d181f/test/functional/feature_inout_amount.py#L7\" rel=\"noopener nofollow ugc\">test cases</a>.</p>\n<h2><a name=\"p-4521-coinjoin-use-case-3\" class=\"anchor\" href=\"#p-4521-coinjoin-use-case-3\"></a>Coinjoin use case</h2>\n<p>Lets assume we want to specify that the first 5 outputs have uniform amounts of 1BTC in our transaction.</p>\n<p>The funding output with the <code>OP_INOUT_AMOUNT</code> Script contains <code>2.1BTC</code>. This means the counterparty must bring <code>3BTC</code> or more to the transaction to satisfy the witness script. This implies the counterparty can claim a <code>0.1BTC</code> fee for their services.  Here is what the Script looks like</p>\n<blockquote>\n<p>OP_0 OP_1 OP_INOUT_AMOUNT ONE_BTC OP_EQUALVERIFY OP_DROP\nOP_0 OP_2 OP_INOUT_AMOUNT ONE_BTC OP_EQUALVERIFY OP_DROP\nOP_0 OP_4 OP_INOUT_AMOUNT ONE_BTC OP_EQUALVERIFY OP_DROP\nOP_0 OP_8 OP_INOUT_AMOUNT ONE_BTC OP_EQUALVERIFY OP_DROP\nOP_0 OP_16 OP_INOUT_AMOUNT ONE_BTC OP_EQUALVERIFY OP_DROP\nOP_1</p>\n</blockquote>\n<p>You could put these scripts in a tapscript tree to allow for more fees for larger output sets - you could imagine having an alternative tapleaf that requires <code>0.5BTC</code> outputs and paying a larger fee ( <code>0.6BTC</code>in this toy example) compensate for the larger network fee for more outputs and a larger witness script.</p>\n<h2><a name=\"p-4521-design-questions-problems-that-i-see-4\" class=\"anchor\" href=\"#p-4521-design-questions-problems-that-i-see-4\"></a>Design questions / problems that I see</h2>\n<p>These are design issues I\u2019ve seen, I\u2019m posting them so I\u2019ve got them written down and out of my head. There are probably more issues that I haven\u2019t understood or realized yet, so please comment below if you see them. Perhaps someone cleverer than me can figure out a way to fix them, explain why they aren\u2019t a problem, or suggest why other blockchains such as Elements chose different designs to avoid these problems?</p>\n<h3><a name=\"p-4521-bitmaps-are-too-flexible-5\" class=\"anchor\" href=\"#p-4521-bitmaps-are-too-flexible-5\"></a>Bitmaps are too flexible?</h3>\n<p>Lets assume my use case is to make an <code>OP_INOUT_AMOUNT</code> Script that guarantees a max fee in a transaction. This means my Script needs to know about <em>all</em> input and output values in the transaction. If my Script is unaware of all values, it cannot accurately calculate the absolute fee. This is a similar to the attack that possible before <a href=\"https://github.com/bitcoin/bips/blob/050d422b2ac24d8221edab0ff0053e0f585409f7/bip-0341.mediawiki#cite_note-18\" rel=\"noopener nofollow ugc\">BIP341</a> adjusted its sighash algorithm to commit to all input values.</p>\n<p>One way to solve this is to require that the bitmap specifies sets <em>all</em> transaction inputs and outputs.</p>\n<p>However I believe this would exclude other use cases where you would only like to check a subset of inputs/outputs, like vaults or coinjoins.</p>\n<p>In a coinjoin transaction, you may want to exclude 1 output from being required to have a uniform value to send \u201cchange\u201d too. This is convenient as its unlikely that  <code>(sum(input_amounts) - network_fees) % COINJOIN_AMOUNT</code> is going to be a round number.</p>\n<p>To put it simply, is there a way we have both of these features depending on the context</p>\n<ol>\n<li>A guarantee we know about all inputs/outputs</li>\n<li>The flexibility to specify subsets of inputs and outputs</li>\n</ol>\n<p>I guess this can be solved with another opcode like <code>OP_PUSHINPUTSET_BITMAP</code> / <code>OP_PUSHOUTPUTSET_BITMAP</code>, but that introduces more complexity\u2026</p>\n<h3><a name=\"p-4521-ordering-of-stack-inputs-6\" class=\"anchor\" href=\"#p-4521-ordering-of-stack-inputs-6\"></a>Ordering of stack inputs</h3>\n<p><code>OP_INOUT_AMOUNT</code> as I\u2019ve designed it consumes 2 inputs. The stack top is a bitmap of output indices, the second item on the stack is a bitmap of input indices.</p>\n<p>If for some reason you would like to express a input value pattern, but allow the caller of the Script to express an output value pattern, this would not be possible. I can\u2019t think of a use case for this, but it does seem like a design issue. This probably means this opcode should be broken down into 2 opcodes, as done in elements?</p>\n<h3><a name=\"p-4521-malleability-7\" class=\"anchor\" href=\"#p-4521-malleability-7\"></a>Malleability</h3>\n<p>Lets assume my witness script looks like this</p>\n<blockquote>\n<p>OP_1 OP_INOUT_AMOUNT ONE_BTC OP_DUP OP_EQUALVERIFY OP_EQUAL</p>\n</blockquote>\n<p>This script checks that the output at index 0 is equal to <code>1BTC</code>. It also checks there exists at least 1 input that is equal to <code>1BTC</code>. The caller of this Script can specify the input index to check that its equal to exactly <code>1BTC</code>.</p>\n<p>If you have multiple inputs that have exactly <code>1BTC</code>, 3rd parties on the network could malleate the witness stack and still have the bitcoin transaction be valid.</p>",
  "post_number": 3,
  "post_type": 1,
  "updated_at": "2025-03-13T21:08:20.247Z",
  "reply_count": 0,
  "reply_to_post_number": 2,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 16,
  "readers_count": 15,
  "score": 3.2,
  "yours": false,
  "topic_id": 549,
  "topic_slug": "op-inout-amount",
  "topic_title": "Op_inout_amount",
  "topic_html_title": "Op_inout_amount",
  "category_id": 7,
  "display_username": "Chris Stewart",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 4,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "reply_to_user": {
    "username": "halseth",
    "name": "Johan T. Halseth",
    "avatar_template": "/user_avatar/delvingbitcoin.org/halseth/{size}/198_2.png"
  },
  "bookmarked": false,
  "raw": "Ok Johan, i finally took you up on this. Here is my attempt at implementing what I think you and [AJ Towns](https://gnusha.org/pi/bitcoindev/20210909065330.GB22496@erisian.com.au/) were hinting at.\n\n>Having it be possible to specify indexes would be very helpful in creating more sophisticated merges/splits of UTXOS. And I think the implementation complexity would not drastically increase?\n\n>... or it could even accept a parameter letting you specify which input ...\n\n## Background\n\nElements has 2 opcodes called [OP_INSPECTINPUTVALUE](https://github.com/ElementsProject/elements/blob/df4e99dca3b9f4a49592b98fed3af8aeed6035ae/src/script/interpreter.cpp#L1875) and [OP_INSPECTOUTPUTVALUE](https://github.com/ElementsProject/elements/blob/df4e99dca3b9f4a49592b98fed3af8aeed6035ae/src/script/interpreter.cpp#L1958). These opcodes are limited to pushing the value of the current input index and its corresponding output index onto the stack. I believe this means that there must be a one-to-one size relationship for inputs and outputs in element's transactions if either `OP_INSPECTINPUTVALUE` or `OP_INSPECTOUTPUTVALUE` is used. Also - IIUC - this creates a simple heuristic to correlate inputs and outputs in a transaction. If this is incorrect, please let me know. \n\n## Design\n\nA design goal of mine for this iteration of `OP_INOUT_AMOUNT` is to allow for variable size input and output sets in a bitcoin transaction.\n\nI reworked `OP_INOUT_AMOUNT` to take 2 stack parameters. They are each interpreted as bitmaps. We sum the outputs and inputs at the set indices and push the result onto the stack.\n\nLets assume our transaction has the format\n\n>CTx(input_amounts=[1BTC,2BTC],output_amounts=[0.25BTC,0.5BTC,1BTC])\n\nand the current stack state before evaluating `OP_INOUT_AMOUNT` is\n\n```\n10100000 # output indices to push onto the stack\n11000000 # input indices to push onto the stack\n```\n\nThis would mean the values at output indexes 0 and 2 (`0.25BTC` and `1BTC`) should be added together and pushed onto the stack.\n\nThis also mean the values at input indices 0 and 1 (`1BTC` and `2BTC`) should be added together and pushed onto the stack.\n\nThe resulting stack would be\n\n```\n1.25BTC # output value pushed onto the stack\n3BTC # input value pushed onto the stack\n```\n\nHere is the to see the [implementation](https://github.com/Christewart/bitcoin/blob/df5ef7baf2493c59062991d872425cfdf39d181f/src/script/interpreter.cpp#L1283) and [test cases](https://github.com/Christewart/bitcoin/blob/df5ef7baf2493c59062991d872425cfdf39d181f/test/functional/feature_inout_amount.py#L7).\n\n## Coinjoin use case\n\nLets assume we want to specify that the first 5 outputs have uniform amounts of 1BTC in our transaction.\n\nThe funding output with the `OP_INOUT_AMOUNT` Script contains `2.1BTC`. This means the counterparty must bring `3BTC` or more to the transaction to satisfy the witness script. This implies the counterparty can claim a `0.1BTC` fee for their services.  Here is what the Script looks like\n\n>OP_0 OP_1 OP_INOUT_AMOUNT ONE_BTC OP_EQUALVERIFY OP_DROP \n>OP_0 OP_2 OP_INOUT_AMOUNT ONE_BTC OP_EQUALVERIFY OP_DROP \n>OP_0 OP_4 OP_INOUT_AMOUNT ONE_BTC OP_EQUALVERIFY OP_DROP \n>OP_0 OP_8 OP_INOUT_AMOUNT ONE_BTC OP_EQUALVERIFY OP_DROP \n>OP_0 OP_16 OP_INOUT_AMOUNT ONE_BTC OP_EQUALVERIFY OP_DROP \n>OP_1\n\nYou could put these scripts in a tapscript tree to allow for more fees for larger output sets - you could imagine having an alternative tapleaf that requires `0.5BTC` outputs and paying a larger fee ( `0.6BTC`in this toy example) compensate for the larger network fee for more outputs and a larger witness script.\n\n## Design questions / problems that I see\n\nThese are design issues I've seen, I'm posting them so I've got them written down and out of my head. There are probably more issues that I haven't understood or realized yet, so please comment below if you see them. Perhaps someone cleverer than me can figure out a way to fix them, explain why they aren't a problem, or suggest why other blockchains such as Elements chose different designs to avoid these problems?\n\n### Bitmaps are too flexible?\n\nLets assume my use case is to make an `OP_INOUT_AMOUNT` Script that guarantees a max fee in a transaction. This means my Script needs to know about _all_ input and output values in the transaction. If my Script is unaware of all values, it cannot accurately calculate the absolute fee. This is a similar to the attack that possible before [BIP341](https://github.com/bitcoin/bips/blob/050d422b2ac24d8221edab0ff0053e0f585409f7/bip-0341.mediawiki#cite_note-18) adjusted its sighash algorithm to commit to all input values.\n\nOne way to solve this is to require that the bitmap specifies sets _all_ transaction inputs and outputs.\n\nHowever I believe this would exclude other use cases where you would only like to check a subset of inputs/outputs, like vaults or coinjoins.\n\nIn a coinjoin transaction, you may want to exclude 1 output from being required to have a uniform value to send \"change\" too. This is convenient as its unlikely that  `(sum(input_amounts) - network_fees) % COINJOIN_AMOUNT` is going to be a round number.\n\nTo put it simply, is there a way we have both of these features depending on the context\n\n1. A guarantee we know about all inputs/outputs\n2. The flexibility to specify subsets of inputs and outputs\n\nI guess this can be solved with another opcode like `OP_PUSHINPUTSET_BITMAP` / `OP_PUSHOUTPUTSET_BITMAP`, but that introduces more complexity...\n\n### Ordering of stack inputs\n\n`OP_INOUT_AMOUNT` as I've designed it consumes 2 inputs. The stack top is a bitmap of output indices, the second item on the stack is a bitmap of input indices.\n\nIf for some reason you would like to express a input value pattern, but allow the caller of the Script to express an output value pattern, this would not be possible. I can't think of a use case for this, but it does seem like a design issue. This probably means this opcode should be broken down into 2 opcodes, as done in elements?\n\n### Malleability\n\nLets assume my witness script looks like this\n\n>OP_1 OP_INOUT_AMOUNT ONE_BTC OP_DUP OP_EQUALVERIFY OP_EQUAL\n\nThis script checks that the output at index 0 is equal to `1BTC`. It also checks there exists at least 1 input that is equal to `1BTC`. The caller of this Script can specify the input index to check that its equal to exactly `1BTC`.\n\nIf you have multiple inputs that have exactly `1BTC`, 3rd parties on the network could malleate the witness stack and still have the bitcoin transaction be valid.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 193,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}