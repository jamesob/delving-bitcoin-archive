{
  "id": 4430,
  "name": "Sindura Saraswathi",
  "username": "sindurasaraswathi",
  "avatar_template": "/user_avatar/delvingbitcoin.org/sindurasaraswathi/{size}/1058_2.png",
  "created_at": "2025-03-07T21:33:51.174Z",
  "cooked": "<p>In the Lightning Network (LN), routing payments efficiently requires an effective pathfinding algorithm. To achieve this, a sender node uses a pathfinding strategy, which varies across different LN implementations. Notable implementations, including Lightning Network Daemon (LND), Core Lightning (CLN), Lightning Development Kit (LDK), and Eclair, have each developed their own approach to pathfinding. While mostly using a variant of a shortest-path algorithm, each of these node implementations differs in its pathfinding strategy in substantial details such as in the weight function that establishes underlying path costs, leading to variations in performance and trade-offs regarding fees, payment path length, routing delays, and payment reliability.</p>\n<p>Despite these differences, little research has been conducted on selecting the most suitable client or pathfinding strategy based on user-specific trade-offs. This gap in understanding motivated our study, where we systematically present a comprehensive analysis of the single-path pathfinding algorithms deployed by LND, CLN, LDK, and Eclair. Our objective is to compare the underlying channel weight functions, constraints, properties of deployed algorithms, and evaluate the performance and reveal the strengths and weaknesses of each client variant, providing insights for LN developers and researchers to guide future research and development efforts.</p>\n<p>In the Lightning Network, when the payment is initiated, the source node needs to select a path to the receiver node using pathfinding strategies on the LN graph <span class=\"math\">G(V,E)</span>. Existing LN clients employ instantiations of shortest path algorithms, such as Dijkstra\u2019s algorithm, modified Dijkstra-style algorithms or Yen\u2019s K-shortest path algorithm to find the path between specified source and receiver nodes.</p>\n<p>Dijkstra\u2019s algorithm is widely regarded as an efficient method for single-path pathfinding in the Lightning Network, with a worst-case complexity of <span class=\"math\">O((|E| +|V |) \\log (|V |))</span>. Dijkstra\u2019s algorithm ensures that the cheapest path is found based on an additive path cost. However, within LN clients, apart from the total path cost of a path <span class=\"math\">p</span>, pathfinding is subject to certain (one or more) side constraints that can be expressed as,\n<span class=\"math\">\n\\operatorname{x}(p) := \\sum_{e \\in p} y_e \\leq \\alpha,\n</span>\nwhere <span class=\"math\">\\operatorname{x}</span> defines the constraint function with non-negative <span class=\"math\">y_e</span>, <span class=\"math\">e \\in E</span> and <span class=\"math\">\\alpha \\geq 0</span> an upper bound.</p>\n<p>LN clients aim to enforce specific payment path characteristics, such as a maximum total fee (which, if exceeded by the path fee, makes a path non-desirable by the user) or a minimum path success probability. These constraints require modifications to the Dijkstra\u2019s algorithm, transforming it into a constrained shortest-path problem, which is <strong>NP-complete</strong>. While the adapted algorithm offers a practical approach, it does not guarantee optimal solutions for all instances.</p>\n<p>In the Lightning Network (LN), pathfinding must balance routing fees with path success probability \u2013\u2013\u2013 the likelihood that a payment will successfully reach its destination. Assuming that the routing success across one channel <span class=\"math\">e\\in p</span> is independent of the routing success across any other channel along the path, the overall path success probability <span class=\"math\">P_p</span> is given by the product of the individual channel probabilities:  <span class=\"math\">P_p = \\prod_{e \\in p} P_e</span>.</p>\n<p>In existing literature on LN pathfinding, there are two approaches for incorporating a path success probability estimate <span class=\"math\">P_p</span> into a total path cost <span class=\"math\">c(p)</span> of a payment path <span class=\"math\">p</span> \u2014 the first proportional to an <strong>inverse probability penalization</strong> <span class=\"math\">(\\frac{1}{P_p})</span>  and the second proportional to the <strong>negative logarithm of</strong> <span class=\"math\">P_p</span> <span class=\"math\">(\\log (\\frac{1}{P_p}) = -\\log\u2061 (\\prod_{e \\in p}P_{e}) = \\sum_{e \\in p} \\log (P_e)</span>).</p>\n<p>CLN, LDK and Eclair use the negative logarithmic success probability term in their weight function to prioritize paths with higher success probability within their pathfinding algorithms while keeping the cost function fully additive.\nIn contrast, LND\u2019s pathfinding penalizes unreliable paths using the inverse probability penalization, where the cost function is,\n<span class=\"math\">c(p) = F_p + \\frac{c_{\\text{attempt}}}{P_p}</span>.</p>\n<p>In this equation, the fee cost term <span class=\"math\">F_p = \\sum_{e \\in p} \\operatorname{weight_a}(e)</span>, where <span class=\"math\">\\operatorname{weight_a}: E \\to R_{\\geq 0}</span> is a non-negative, additive weight function. For the second summand, the situation is different, as an additive decomposition of <span class=\"math\">\\frac{c_{\\text{attempt}}}{P_p}</span> across edges cannot be mathematically justified. However, considering <span class=\"math\">P_p = \\prod_{e \\in p} P_e</span> (as discussed above), it is possible to decompose the second summand across edges if we introduce the multiplicative weight <span class=\"math\">\\operatorname{weight_m}: E \\to R_{\\geq 1}, e \\mapsto 1/P_e</span>  such that\n<span class=\"math\">c(p) = F_p + \\frac{c_{\\text{attempt}}}{P_p} = \\sum_{e \\in p} \\operatorname{weight_a}(e) + c_{\\text{attempt}} \\prod_{e \\in p} \\operatorname{weight_m}(e)</span>.</p>\n<p>Here,</p>\n<ul>\n<li>\n<p><span class=\"math\">\\operatorname{weight_a}(e)</span> represents the additive weight, such as routing fees.</p>\n</li>\n<li>\n<p><span class=\"math\">\\operatorname{weight_m}(e)</span> represents multiplicative weight derived from success probabilities, typically modeled as <span class=\"math\">\\frac{1}{P_e}</span> to penalize unreliable paths.</p>\n</li>\n<li>\n<p><span class=\"math\">c_{attempt}</span> is a virtual cost assigned to payment attempts.</p>\n</li>\n</ul>\n<p>LND\u2019s pathfinding approach uses a <strong>modified Dijkstra-style algorithm</strong> to minimize this <strong>additive-plus-multiplicative weight function</strong>. Unlike traditional Dijkstra\u2019s algorithm, it prioritizes paths based on a combined cost model, incorporating both additive and multiplicative weights. However, due to the nature of this weight function, the algorithm does not always guarantee the optimal path.</p>\n<p>A counterexample (Figure 1) illustrates how LND\u2019s modified Dijkstra-style algorithm may overlook a cheaper route, as it selects predecessors greedily based on the current weight. In this counterexample, each edge e comprises of an additive weight <span class=\"math\">\\operatorname{weight_a (e)}</span> and a multiplicative weight <span class=\"math\">\\operatorname{weight_m (e)}</span>, denoted with subscript <span class=\"math\">a</span> and with subscript <span class=\"math\">m</span>. The goal is to find the cheapest path from the source node <span class=\"math\">s</span> to the recipient node <span class=\"math\">r</span>.</p>\n<p>The algorithm begins by relaxing the neighbors of <span class=\"math\">s</span>, and updates the distances to <span class=\"math\">h</span> and <span class=\"math\">k</span>. As the algorithm progresses, it continues to relax nodes in a greedy manner, updating paths based on immediate costs. However, when it reaches node <span class=\"math\">j</span>, it fails to recognize that the path <span class=\"math\">s\u2192h\u2192j\u2192r</span> (cost 11) is cheaper than the path <span class=\"math\">s\u2192h\u2192i\u2192r</span> (cost 14) that it returns.</p>\n<p>This happens because the algorithm prioritizes paths based on the current additive and multiplicative costs, which leads to overlooking potentially cheaper paths in the long run. While parameter tuning can adjust the weighting, no single value of <span class=\"math\">c_{attempt}</span> in the above equation ensures optimality in all cases. The counterexample shows that, due to its greedy approach, <strong>modified Dijkstra-style algorithm does not always find the optimal path.</strong></p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/2X/e/e5e0dd33ac3696cfc29bc37399b3c09e46d710ab.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/e5e0dd33ac3696cfc29bc37399b3c09e46d710ab\" title=\"image\"><img src=\"https://delvingbitcoin.org/uploads/default/original/2X/e/e5e0dd33ac3696cfc29bc37399b3c09e46d710ab.png\" alt=\"image\" data-base62-sha1=\"wNB6NZIzoBbqoOMAwlPo05BZIOn\" width=\"674\" height=\"266\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">image</span><span class=\"informations\">674\u00d7266 11.7 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div>\nFigure 1: Counterexample graph for suboptimality of LND\u2019s modified Dijkstra-style algorithm for pathfinding with respect to additive-plus-multiplicative cost.</p>\n<p>While an inverse probability penalization <span class=\"math\">P_p</span> leads to difficulties in the pathfinding algorithms as mentioned above, an argument can be made that this modeling is more suitable to avoid unreliable paths as <span class=\"math\">\\frac{1}{P_p}</span>  grows faster for <span class=\"math\">P_p \u2192 0</span> than <span class=\"math\">-\\log (P_p)</span>, i.e., the penalization of unreliable vs. reliable paths is stronger in the modeling used by LND.</p>\n<p>We conducted simulations to study the empirical performance, across key metrics such as success rate, fee ratio, path length, and timelock, of LND-ap, LND-bm, CLN, LDK-un, LDK-bm, Eclair1, Eclair2, and Eclair3. LND-ap and LND-bm represent the LND implementation with Apriori and Bimodal estimators, respectively, for channel-wise success probability calculation. The LDK implementation with Uniform and Bimodal estimators for channel-wise success probability is represented as LDK-un and LDK-bm, respectively. Similarly, Eclair1, Eclair2, and Eclair3 denote three distinct cases of Eclair: heuristics ratios, heuristics constants (without logarithm) and heuristics constants (with logarithm), respectively. Building on the existing LND implementation, we propose and study a new weight function by assuming a uniform liquidity distribution for calculating channel-wise success probability, defined as <span class=\"math\">P_e =\\frac{capacity_e \u2013 amount_e}{capacity_e}</span> . This expression is used to compute the path success probability, which is subsequently incorporated into the LND weight function. We refer to this implementation as LND-un.</p>\n<p>We used an <a href=\"https://www.rene-pickhardt.de/%20listchannels20220412.json\" rel=\"noopener nofollow ugc\">LN snapshot</a> that consists of 13,129 nodes for simulations. Consistent with the available information of an arbitrary LN node operator who is not engaged in balance probing, the dataset does not contain information about channel balances, which is only known to the two participating nodes of channel. To simulate the channel balances, we use two random models for the balances. The first model is built by uniformly choosing channel balances between zero and the channel capacity. The second graph model is constructed by sampling channel balances from a bimodal distribution with density <span class=\"math\">P(x)</span> proportional to <span class=\"math\">P(x) \u223c e^{-\\frac{x}{s}}+e^{\\frac{x-capacity_e}{s}}</span> on <span class=\"math\">[0, capacity_e]</span>, where <span class=\"math\">s</span> is selected as a fixed fraction of the channel capacity, specifically <span class=\"math\">s = \\frac{capacity_e}{10}</span>.</p>\n<p>In the analysis of the Lightning Network (LN) clients under both uniform and bimodal balance distributions, several key performance trends emerge. For the uniform distribution graph, <strong>LND-un</strong> consistently achieves the highest success rates across most payment amounts <span class=\"math\">(1-10^8 sats)</span> compared to all other existing LN client variants, with an average success rate of <strong>76.25%</strong>. Among the eight existing LN client variants, <strong>Eclair3</strong> demonstrates a high success rate, with an average of <strong>75.61%</strong>. Eclair3 also provided the <strong>lowest fee ratios overall</strong>, with a median fee ratio of <strong>0.0116%</strong>, while LDK-bm had the highest at 0.0564%. However, it is worth noting that for larger payment amounts <span class=\"math\">(10^5-10^8 sats)</span>, both LDK-un and LDK-bm offer the lowest fee ratios compared to all other clients. Under the bimodal balance distribution, <strong>LND-bm</strong> with a liquidity broadening scale of <span class=\"math\">s = \\frac{capacity_e}{10}</span> in the bimodal estimator for success probability calculations achieves the highest success rates across most payment amounts <span class=\"math\">(1-10^8 sats)</span>, with an average of <strong>62.74%</strong>, outperforming LND-bm with the default value of <span class=\"math\">s = 3\u00d710^5 sats</span>. This suggests that the success rates of <strong>LND-bm can potentially be improved by fine-tuning the liquidity broadening scale <span class=\"math\">s</span></strong> based on historical channel liquidity data. CLN emerges as the top performer in terms of total timelock, offering paths with the lowest latency for routing payment amounts. Eclair1 and Eclair2 perform the best in terms of path length, while Eclair3 exhibits the highest path length and latency.</p>\n<p>In this study, we provide transparency into the pathfinding modules of the four prominent Lightning Network clients LND, CLN, LDK, and Eclair. Our study underscores the <strong>need for better-designed weight functions</strong> that can deliver better trade-offs between payment reliability, routing fees and other desired properties. We expect that <strong>there is room for substantial improvements in future work</strong>. From an algorithmic side, we conclude that it is worthwhile to consider more <strong>sophisticated algorithms than Dijkstra\u2019s algorithm and its ad-hoc modifications to improve pathfinding</strong> both in terms of computational efficiency (which corresponds to payment latency) and solution quality (which corresponds to routing fees and payment reliability).</p>\n<p>While beyond the scope of this study, we note that the insights gained in this study are also relevant for future improvements in multi-part payment pathfinding algorithms, as those algorithms are based on the solution of minimum cost flow problems, which are a generalization of shortest path problems. The choice of an appropriate channel-specific weight/cost function likewise significantly influences the solution quality in multi-part pathfinding.</p>\n<p>More details of our research can be found at: <a href=\"https://arxiv.org/pdf/2410.13784\" rel=\"noopener nofollow ugc\">https://arxiv.org/pdf/2410.13784</a></p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2025-03-07T21:33:51.174Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 4,
  "reads": 21,
  "readers_count": 20,
  "score": 69.0,
  "yours": false,
  "topic_id": 1500,
  "topic_slug": "an-exposition-of-pathfinding-strategies-within-lightning-network-clients",
  "topic_title": "An Exposition of Pathfinding Strategies Within Lightning Network Clients",
  "topic_html_title": "An Exposition of Pathfinding Strategies Within Lightning Network Clients",
  "category_id": 7,
  "display_username": "Sindura Saraswathi",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "In the Lightning Network (LN), routing payments efficiently requires an effective pathfinding algorithm. To achieve this, a sender node uses a pathfinding strategy, which varies across different LN implementations. Notable implementations, including Lightning Network Daemon (LND), Core Lightning (CLN), Lightning Development Kit (LDK), and Eclair, have each developed their own approach to pathfinding. While mostly using a variant of a shortest-path algorithm, each of these node implementations differs in its pathfinding strategy in substantial details such as in the weight function that establishes underlying path costs, leading to variations in performance and trade-offs regarding fees, payment path length, routing delays, and payment reliability.\n\nDespite these differences, little research has been conducted on selecting the most suitable client or pathfinding strategy based on user-specific trade-offs. This gap in understanding motivated our study, where we systematically present a comprehensive analysis of the single-path pathfinding algorithms deployed by LND, CLN, LDK, and Eclair. Our objective is to compare the underlying channel weight functions, constraints, properties of deployed algorithms, and evaluate the performance and reveal the strengths and weaknesses of each client variant, providing insights for LN developers and researchers to guide future research and development efforts.\n\nIn the Lightning Network, when the payment is initiated, the source node needs to select a path to the receiver node using pathfinding strategies on the LN graph $G(V,E)$. Existing LN clients employ instantiations of shortest path algorithms, such as Dijkstra\u2019s algorithm, modified Dijkstra-style algorithms or Yen\u2019s K-shortest path algorithm to find the path between specified source and receiver nodes.\n\nDijkstra\u2019s algorithm is widely regarded as an efficient method for single-path pathfinding in the Lightning Network, with a worst-case complexity of $O((|E| +|V |) \\log (|V |))$. Dijkstra\u2019s algorithm ensures that the cheapest path is found based on an additive path cost. However, within LN clients, apart from the total path cost of a path $p$, pathfinding is subject to certain (one or more) side constraints that can be expressed as,\n$\n\\operatorname{x}(p) := \\sum_{e \\in p} y_e \\leq \\alpha,\n$\nwhere $\\operatorname{x}$ defines the constraint function with non-negative $y_e$, $e \\in E$ and $\\alpha \\geq 0$ an upper bound.\n\nLN clients aim to enforce specific payment path characteristics, such as a maximum total fee (which, if exceeded by the path fee, makes a path non-desirable by the user) or a minimum path success probability. These constraints require modifications to the Dijkstra\u2019s algorithm, transforming it into a constrained shortest-path problem, which is **NP-complete**. While the adapted algorithm offers a practical approach, it does not guarantee optimal solutions for all instances.\n\nIn the Lightning Network (LN), pathfinding must balance routing fees with path success probability \u2013\u2013\u2013 the likelihood that a payment will successfully reach its destination. Assuming that the routing success across one channel $e\\in p$ is independent of the routing success across any other channel along the path, the overall path success probability $P_p$ is given by the product of the individual channel probabilities:  $P_p = \\prod_{e \\in p} P_e$. \n\nIn existing literature on LN pathfinding, there are two approaches for incorporating a path success probability estimate $P_p$ into a total path cost $c(p)$ of a payment path $p$ --- the first proportional to an **inverse probability penalization** $(\\frac{1}{P_p})$  and the second proportional to the **negative logarithm of** $P_p$ $(\\log (\\frac{1}{P_p}) = -\\log\u2061 (\\prod_{e \\in p}P_{e}) = \\sum_{e \\in p} \\log (P_e)$).\n\nCLN, LDK and Eclair use the negative logarithmic success probability term in their weight function to prioritize paths with higher success probability within their pathfinding algorithms while keeping the cost function fully additive.\nIn contrast, LND\u2019s pathfinding penalizes unreliable paths using the inverse probability penalization, where the cost function is,\n$c(p) = F_p + \\frac{c_{\\text{attempt}}}{P_p}$.\n\nIn this equation, the fee cost term $F_p = \\sum_{e \\in p} \\operatorname{weight_a}(e)$, where $\\operatorname{weight_a}: E \\to R_{\\geq 0}$ is a non-negative, additive weight function. For the second summand, the situation is different, as an additive decomposition of $\\frac{c_{\\text{attempt}}}{P_p}$ across edges cannot be mathematically justified. However, considering $P_p = \\prod_{e \\in p} P_e$ (as discussed above), it is possible to decompose the second summand across edges if we introduce the multiplicative weight $\\operatorname{weight_m}: E \\to R_{\\geq 1}, e \\mapsto 1/P_e$  such that\n$c(p) = F_p + \\frac{c_{\\text{attempt}}}{P_p} = \\sum_{e \\in p} \\operatorname{weight_a}(e) + c_{\\text{attempt}} \\prod_{e \\in p} \\operatorname{weight_m}(e)$. \n\nHere, \n* $\\operatorname{weight_a}(e)$ represents the additive weight, such as routing fees.\n\n* $\\operatorname{weight_m}(e)$ represents multiplicative weight derived from success probabilities, typically modeled as $\\frac{1}{P_e}$ to penalize unreliable paths.\n\n* $c_{attempt}$ is a virtual cost assigned to payment attempts.\n\nLND\u2019s pathfinding approach uses a **modified Dijkstra-style algorithm** to minimize this **additive-plus-multiplicative weight function**. Unlike traditional Dijkstra\u2019s algorithm, it prioritizes paths based on a combined cost model, incorporating both additive and multiplicative weights. However, due to the nature of this weight function, the algorithm does not always guarantee the optimal path.\n\nA counterexample (Figure 1) illustrates how LND\u2019s modified Dijkstra-style algorithm may overlook a cheaper route, as it selects predecessors greedily based on the current weight. In this counterexample, each edge e comprises of an additive weight $\\operatorname{weight_a (e)}$ and a multiplicative weight $\\operatorname{weight_m (e)}$, denoted with subscript $a$ and with subscript $m$. The goal is to find the cheapest path from the source node $s$ to the recipient node $r$.\n\nThe algorithm begins by relaxing the neighbors of $s$, and updates the distances to $h$ and $k$. As the algorithm progresses, it continues to relax nodes in a greedy manner, updating paths based on immediate costs. However, when it reaches node $j$, it fails to recognize that the path $s\u2192h\u2192j\u2192r$ (cost 11) is cheaper than the path $s\u2192h\u2192i\u2192r$ (cost 14) that it returns.\n\nThis happens because the algorithm prioritizes paths based on the current additive and multiplicative costs, which leads to overlooking potentially cheaper paths in the long run. While parameter tuning can adjust the weighting, no single value of $c_{attempt}$ in the above equation ensures optimality in all cases. The counterexample shows that, due to its greedy approach, **modified Dijkstra-style algorithm does not always find the optimal path.**\n\n![image|674x266](upload://wNB6NZIzoBbqoOMAwlPo05BZIOn.png)\nFigure 1: Counterexample graph for suboptimality of LND\u2019s modified Dijkstra-style algorithm for pathfinding with respect to additive-plus-multiplicative cost.\n\nWhile an inverse probability penalization $P_p$ leads to difficulties in the pathfinding algorithms as mentioned above, an argument can be made that this modeling is more suitable to avoid unreliable paths as $\\frac{1}{P_p}$  grows faster for $P_p \u2192 0$ than $-\\log (P_p)$, i.e., the penalization of unreliable vs. reliable paths is stronger in the modeling used by LND.\n\nWe conducted simulations to study the empirical performance, across key metrics such as success rate, fee ratio, path length, and timelock, of LND-ap, LND-bm, CLN, LDK-un, LDK-bm, Eclair1, Eclair2, and Eclair3. LND-ap and LND-bm represent the LND implementation with Apriori and Bimodal estimators, respectively, for channel-wise success probability calculation. The LDK implementation with Uniform and Bimodal estimators for channel-wise success probability is represented as LDK-un and LDK-bm, respectively. Similarly, Eclair1, Eclair2, and Eclair3 denote three distinct cases of Eclair: heuristics ratios, heuristics constants (without logarithm) and heuristics constants (with logarithm), respectively. Building on the existing LND implementation, we propose and study a new weight function by assuming a uniform liquidity distribution for calculating channel-wise success probability, defined as $P_e =\\frac{capacity_e \u2013 amount_e}{capacity_e}$ . This expression is used to compute the path success probability, which is subsequently incorporated into the LND weight function. We refer to this implementation as LND-un.\n\nWe used an [LN snapshot](https://www.rene-pickhardt.de/%20listchannels20220412.json) that consists of 13,129 nodes for simulations. Consistent with the available information of an arbitrary LN node operator who is not engaged in balance probing, the dataset does not contain information about channel balances, which is only known to the two participating nodes of channel. To simulate the channel balances, we use two random models for the balances. The first model is built by uniformly choosing channel balances between zero and the channel capacity. The second graph model is constructed by sampling channel balances from a bimodal distribution with density $P(x)$ proportional to $P(x) \u223c e^{-\\frac{x}{s}}+e^{\\frac{x-capacity_e}{s}}$ on $[0, capacity_e]$, where $s$ is selected as a fixed fraction of the channel capacity, specifically $s = \\frac{capacity_e}{10}$.\n\nIn the analysis of the Lightning Network (LN) clients under both uniform and bimodal balance distributions, several key performance trends emerge. For the uniform distribution graph, **LND-un** consistently achieves the highest success rates across most payment amounts $(1-10^8 sats)$ compared to all other existing LN client variants, with an average success rate of **76.25%**. Among the eight existing LN client variants, **Eclair3** demonstrates a high success rate, with an average of **75.61%**. Eclair3 also provided the **lowest fee ratios overall**, with a median fee ratio of **0.0116%**, while LDK-bm had the highest at 0.0564%. However, it is worth noting that for larger payment amounts $(10^5-10^8 sats)$, both LDK-un and LDK-bm offer the lowest fee ratios compared to all other clients. Under the bimodal balance distribution, **LND-bm** with a liquidity broadening scale of $s = \\frac{capacity_e}{10}$ in the bimodal estimator for success probability calculations achieves the highest success rates across most payment amounts $(1-10^8 sats)$, with an average of **62.74%**, outperforming LND-bm with the default value of $s = 3\u00d710^5 sats$. This suggests that the success rates of **LND-bm can potentially be improved by fine-tuning the liquidity broadening scale $s$** based on historical channel liquidity data. CLN emerges as the top performer in terms of total timelock, offering paths with the lowest latency for routing payment amounts. Eclair1 and Eclair2 perform the best in terms of path length, while Eclair3 exhibits the highest path length and latency.\n\nIn this study, we provide transparency into the pathfinding modules of the four prominent Lightning Network clients LND, CLN, LDK, and Eclair. Our study underscores the **need for better-designed weight functions** that can deliver better trade-offs between payment reliability, routing fees and other desired properties. We expect that **there is room for substantial improvements in future work**. From an algorithmic side, we conclude that it is worthwhile to consider more **sophisticated algorithms than Dijkstra\u2019s algorithm and its ad-hoc modifications to improve pathfinding** both in terms of computational efficiency (which corresponds to payment latency) and solution quality (which corresponds to routing fees and payment reliability).\n\nWhile beyond the scope of this study, we note that the insights gained in this study are also relevant for future improvements in multi-part payment pathfinding algorithms, as those algorithms are based on the solution of minimum cost flow problems, which are a generalization of shortest path problems. The choice of an appropriate channel-specific weight/cost function likewise significantly influences the solution quality in multi-part pathfinding.\n\nMore details of our research can be found at: [https://arxiv.org/pdf/2410.13784](https://arxiv.org/pdf/2410.13784)",
  "actions_summary": [
    {
      "id": 2,
      "count": 3
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 680,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "heart",
      "type": "emoji",
      "count": 2
    },
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 3,
  "current_user_used_main_reaction": false
}