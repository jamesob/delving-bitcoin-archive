{
  "id": 4424,
  "name": "Pieter Wuille",
  "username": "sipa",
  "avatar_template": "/user_avatar/delvingbitcoin.org/sipa/{size}/102_2.png",
  "created_at": "2025-03-07T04:02:17.839Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"stefanwouldgo\" data-post=\"51\" data-topic=\"303\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/stefanwouldgo/48/664_2.png\" class=\"avatar\"> stefanwouldgo:</div>\n<blockquote>\n<p>I\u2019d even argue that we don\u2019t much care for exact breakpoints if they are very close, so 64-bit arithmetic might be good enough.</p>\n</blockquote>\n</aside>\n<p>That is probably true. Even if cluster sizes are limited to 4 MWU, and feerates are limited to ~10000 sat/vB, <span class=\"math\">M = 461</span> can be used, which suffices to separate chunks whose feerate are just <span class=\"math\">0.004</span> sat/vB apart.</p>\n<p>That said, I think the cost of 128-bit vs 64-bit arithmetic is probably close to negligible. There is one division per chunk, and a few multiplications per transaction per chunk. Everything else (the bulk of min-cut itself) is just comparisons, additions, and subtractions. I expect the bulk of the runtime cost to come from iterating over nodes and edges, and maintaining the data structures for them.</p>\n<hr>\n<p>Unrelatedly, the <a href=\"https://sci-hub.se/10.1137/0218072\">paper</a> that introduced the <span class=\"math\">\\mathcal{O}(n^2 \\sqrt{m})</span> bound for max-height push-relabel also looks interesting. It appears to contain recipes for building worst cases for which that complexity is actually reached. This may be useful for us for benchmarking worst cases.</p>",
  "post_number": 52,
  "post_type": 1,
  "updated_at": "2025-03-07T04:03:46.090Z",
  "reply_count": 0,
  "reply_to_post_number": 51,
  "quote_count": 1,
  "incoming_link_count": 0,
  "reads": 7,
  "readers_count": 6,
  "score": 16.4,
  "yours": false,
  "topic_id": 303,
  "topic_slug": "how-to-linearize-your-cluster",
  "topic_title": "How to linearize your cluster",
  "topic_html_title": "How to linearize your cluster",
  "category_id": 8,
  "display_username": "Pieter Wuille",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"stefanwouldgo, post:51, topic:303\"]\nI\u2019d even argue that we don\u2019t much care for exact breakpoints if they are very close, so 64-bit arithmetic might be good enough.\n[/quote]\n\nThat is probably true. Even if cluster sizes are limited to 4 MWU, and feerates are limited to ~10000 sat/vB, $M = 461$ can be used, which suffices to separate chunks whose feerate are just $0.004$ sat/vB apart.\n\nThat said, I think the cost of 128-bit vs 64-bit arithmetic is probably close to negligible. There is one division per chunk, and a few multiplications per transaction per chunk. Everything else (the bulk of min-cut itself) is just comparisons, additions, and subtractions. I expect the bulk of the runtime cost to come from iterating over nodes and edges, and maintaining the data structures for them.\n\n---\n\nUnrelatedly, the [paper](https://sci-hub.se/10.1137/0218072) that introduced the $\\mathcal{O}(n^2 \\sqrt{m})$ bound for max-height push-relabel also looks interesting. It appears to contain recipes for building worst cases for which that complexity is actually reached. This may be useful for us for benchmarking worst cases.",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 96,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}