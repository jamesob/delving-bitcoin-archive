{
  "id": 4417,
  "name": "Pieter Wuille",
  "username": "sipa",
  "avatar_template": "/user_avatar/delvingbitcoin.org/sipa/{size}/102_2.png",
  "created_at": "2025-03-06T04:39:02.070Z",
  "cooked": "<p>So, short update.</p>\n<p>My plan is still to write a prototype of GGT (with max-distance selection strategy, not dynamic trees, so <span class=\"math\">\\mathcal{O}(n^2 \\sqrt{m}</span> complexity) to experiment with, but no code yet.</p>\n<p><a class=\"mention\" href=\"/u/ajtowns\">@ajtowns</a> and I spent some time thinking about how to represent capacities/flows internally. The paper only describes them as real numbers, but actual implementations need to represent them somehow:</p>\n<ul>\n<li>The most obvious choice is using floating-point data types, but these involve potential rounding issues. More conceptually, it\u2019s also unclear under what circumstances they actually result in exact results.</li>\n<li>A line of thinking we followed for a while was representing them as exact fractions. It turns out that within <strong>one</strong> min-cut (ignoring GGT slicing), all capacities will be a multiple of <span class=\"math\">1/S</span>, where <span class=\"math\">S =\\sum_{i \\in G} \\operatorname{size}(i)</span>, so one can easily represent all capacities/flows as integer multiples thereof, which can grow up to <span class=\"math\">\\mathcal{O}(FS)</span> (with <span class=\"math\">F = \\sum_{i \\in G} \\operatorname{fee}(i)</span>). Unfortunately, when slicing (descending into one side of the cut) in GGT, the flows are inherited by the child problem, which needs a different denominator. Bringing everything on the same denominator could lead to ever-growing numerators.</li>\n<li>A next line of thinking was to convert the problem from one denominator to another, by first mapping to the closest integer, and then getting rid of the remaining fractional parts using <a href=\"https://arxiv.org/pdf/1507.08139\">Flow Rounding</a>, which will find a flow with integer numerators for the subproblem using a flow for the parent with integer numerators these. It\u2019s not very costly computationally, but seems nontrivial, and just feels unnecessary.</li>\n<li><a href=\"https://www.cs.cmu.edu/~jonderry/maxflow.pdf\">This paper</a> suggests a simpler alternative: multiply the flows and capacities by a <em>fixed</em> constant (the same for the entire GGT problem, including subproblems) and represent them as <em>rounded</em> integer multiples. It argued that as long as this multiplier <span class=\"math\">M</span> is such that all distinct breakpoints (in our context: chunk feerates) multiplied by <span class=\"math\">M</span> are at least 2 apart, the found min-cuts will be exactly correct. No two chunk feerates can differ by less than <span class=\"math\">1/(S^2 - S)</span>, so picking <span class=\"math\">M=2S^2</span> would suffice for exact results. This involves <span class=\"math\">\\mathcal{O}(S^3 F)</span> multiplication results internally, but 128-bit integers should more than suffice in practice.</li>\n</ul>",
  "post_number": 50,
  "post_type": 1,
  "updated_at": "2025-03-06T04:40:15.719Z",
  "reply_count": 1,
  "reply_to_post_number": 48,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 8,
  "readers_count": 7,
  "score": 36.6,
  "yours": false,
  "topic_id": 303,
  "topic_slug": "how-to-linearize-your-cluster",
  "topic_title": "How to linearize your cluster",
  "topic_html_title": "How to linearize your cluster",
  "category_id": 8,
  "display_username": "Pieter Wuille",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "reply_to_user": {
    "username": "sipa",
    "name": "Pieter Wuille",
    "avatar_template": "/user_avatar/delvingbitcoin.org/sipa/{size}/102_2.png"
  },
  "bookmarked": false,
  "raw": "So, short update.\n\nMy plan is still to write a prototype of GGT (with max-distance selection strategy, not dynamic trees, so $\\mathcal{O}(n^2 \\sqrt{m}$ complexity) to experiment with, but no code yet.\n\n@ajtowns and I spent some time thinking about how to represent capacities/flows internally. The paper only describes them as real numbers, but actual implementations need to represent them somehow:\n* The most obvious choice is using floating-point data types, but these involve potential rounding issues. More conceptually, it's also unclear under what circumstances they actually result in exact results.\n* A line of thinking we followed for a while was representing them as exact fractions. It turns out that within **one** min-cut (ignoring GGT slicing), all capacities will be a multiple of $1/S$, where $S =\\sum_{i \\in G} \\operatorname{size}(i)$, so one can easily represent all capacities/flows as integer multiples thereof, which can grow up to $\\mathcal{O}(FS)$ (with $F = \\sum_{i \\in G} \\operatorname{fee}(i)$). Unfortunately, when slicing (descending into one side of the cut) in GGT, the flows are inherited by the child problem, which needs a different denominator. Bringing everything on the same denominator could lead to ever-growing numerators.\n* A next line of thinking was to convert the problem from one denominator to another, by first mapping to the closest integer, and then getting rid of the remaining fractional parts using [Flow Rounding](https://arxiv.org/pdf/1507.08139), which will find a flow with integer numerators for the subproblem using a flow for the parent with integer numerators these. It's not very costly computationally, but seems nontrivial, and just feels unnecessary.\n* [This paper](https://www.cs.cmu.edu/~jonderry/maxflow.pdf) suggests a simpler alternative: multiply the flows and capacities by a *fixed* constant (the same for the entire GGT problem, including subproblems) and represent them as *rounded* integer multiples. It argued that as long as this multiplier $M$ is such that all distinct breakpoints (in our context: chunk feerates) multiplied by $M$ are at least 2 apart, the found min-cuts will be exactly correct. No two chunk feerates can differ by less than $1/(S^2 - S)$, so picking $M=2S^2$ would suffice for exact results. This involves $\\mathcal{O}(S^3 F)$ multiplication results internally, but 128-bit integers should more than suffice in practice.",
  "actions_summary": [
    {
      "id": 2,
      "count": 2
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 96,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 2
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 2,
  "current_user_used_main_reaction": false
}