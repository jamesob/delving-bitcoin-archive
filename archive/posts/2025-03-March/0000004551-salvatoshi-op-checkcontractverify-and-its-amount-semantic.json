{
  "id": 4551,
  "name": "salvatoshi",
  "username": "salvatoshi",
  "avatar_template": "/user_avatar/delvingbitcoin.org/salvatoshi/{size}/72_2.png",
  "created_at": "2025-03-17T05:57:39.402Z",
  "cooked": "<p>I have done some work on formalizing the semantic of <code>OP_CHECKCONTRACTVERIFY</code>.  I also wrote the first draft BIP and an implementation in bitcoin-core:</p>\n<p>Links:</p>\n<ul>\n<li><a href=\"https://github.com/bitcoin/bips/pull/1793\" rel=\"noopener nofollow ugc\">BIP draft</a></li>\n<li><a href=\"https://github.com/bitcoin/bitcoin/pull/32080\" rel=\"noopener nofollow ugc\">bitcoin-core implementation draft</a></li>\n</ul>\n<p>In this post, I will briefly introduce the <code>OP_CCV</code> opcode semantic, then expand and discuss on an its amount-handling logic \u2014 an aspect that wasn\u2019t fully explored (and not properly formalized) in my previous posts on the topic. I will make the argument that it provides a convenient and compelling feature set that would be difficult to implement with more \u2018atomic\u2019 opcodes.</p>\n<h1><a name=\"p-4551-op_checkcontractverify-1\" class=\"anchor\" href=\"#p-4551-op_checkcontractverify-1\"></a>OP_CHECKCONTRACTVERIFY</h1>\n<p>I start with a brief intro on <code>OP_CHECKCONTRACTVERIFY</code>, for the sake of making this post self-contained.</p>\n<h2><a name=\"p-4551-in-a-nutshell-state-carrying-utxos-2\" class=\"anchor\" href=\"#p-4551-in-a-nutshell-state-carrying-utxos-2\"></a>in a nutshell: <em>state-carrying UTXOs</em></h2>\n<p><code>OP_CCV</code> enables <em>state-carrying UTXOs</em>: think of a UTXO as a locked box holding data, rules and an amount of coins. When you spend the UTXO, it lets you peek inside your own box (introspect the data), and decide the next box\u2019s rules (program), data and amount.</p>\n<h2><a name=\"p-4551-less-in-a-nutshell-3\" class=\"anchor\" href=\"#p-4551-less-in-a-nutshell-3\"></a>less in a nutshell</h2>\n<p><code>OP_CCV</code> works with P2TR inputs and outputs. It allows comparing the public key of an input.output with:</p>\n<ul>\n<li>a public key that we call the <em>naked key</em></li>\n<li>\u2026optionally tweaked with the hash of some data</li>\n<li>\u2026optionally taptweaked with the Merkle root of a taproot tree.</li>\n</ul>\n<p>Similarly to taproot, <em>tweaking</em> allows to create a commitment to a piece of data inside a public key. Therefore, by using a \u2018double\u2019 tweak, one can easily commit to an additional piece of arbitrary data.\nAn equality check of a double tweak with the input\u2019s taproot key is therefore enough to \u2018introspect\u2019 the current input\u2019s embedded data (if any), and an equality check with an output\u2019s taproot public key can force both the program (<em>naked key</em> and <em>taptree</em>) and the data of the output to be a desired value.</p>\n<p>In combination with an opcode that allows to create a <em>vector commitment</em> (like <code>OP_CAT</code>, <code>OP_PAIRCOMMIT</code> or an hypothetical <code>OP_VECTORCOMMIT</code> opcode), it is of course possible to commit to multiple pieces of data instead of a single one.</p>\n<p>While certainly not the only way to only way to implement a dynamic commitment inside a Script, this is the best I could come up with, and has some nice properties.</p>\n<p><strong>Pro:</strong></p>\n<ul>\n<li>Fully compatible with taproot. Keypath spending is still available, and cheap.</li>\n<li>No additional burden for nodes; state is committed in the UTXO, not explicitly stored.</li>\n<li>It keeps the <em>program</em> (the taptree) logically separated from the <em>data</em>.</li>\n<li>Spending paths that do not require access to the embedded data (if any) do not pay extra witness bytes because of its present.</li>\n</ul>\n<p><strong>Con:</strong></p>\n<ul>\n<li>Only compatible with P2TR.</li>\n<li>A tweak is computationally more expensive than other approaches</li>\n</ul>\n<h1><a name=\"p-4551-amount-logic-4\" class=\"anchor\" href=\"#p-4551-amount-logic-4\"></a>Amount logic</h1>\n<p>What about amounts?\nIt would be rather unusual to care about the output\u2019s Script, and then sending 0 sats to it. In most cases, you want to also specify how much money goes there.</p>\n<p>Therefore, when checking an output, <code>OP_CCV</code> allows a convenient semantic to specify the amount flow in a way that works for most cases. There are three options:</p>\n<ul>\n<li><em>default</em>: assign to the output the entire unassigned amount the current input</li>\n<li><em>deduct</em>: assign to the output the portion of current input\u2019s amount equal to this output\u2019s amount (the rest remain unassigned</li>\n<li><em>ignore</em>: only check the output\u2019s Script but not the amount.</li>\n</ul>\n<p>An output can be used with the <em>default</em> logic from different inputs, but no output can be used as the target of both a <em>deduct</em> check and a <em>default</em> check, nor multiple <em>deduct</em> checks.</p>\n<p>A well formed Script using <code>OP_CCV</code> would use:</p>\n<ul>\n<li>0 or more <code>OP_CCV</code> with the <em>deduct</em> logic, assigning parts of the input amount to some outputs</li>\n<li>exactly 1 <code>OP_CCV</code> with the <em>default</em> logic, assigning the (possibly residual) amount to an(other) output.</li>\n</ul>\n<p>This ensures that <em>all the amount of this input is accounted for in the outputs</em>.</p>\n<h2><a name=\"p-4551-examples-5\" class=\"anchor\" href=\"#p-4551-examples-5\"></a>Examples</h2>\n<h3><a name=\"p-4551-h-1-to-1-6\" class=\"anchor\" href=\"#p-4551-h-1-to-1-6\"></a>1-to-1</h3>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/2X/0/0988bb23f47f54ddecbae76333d58992f236c97c.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/0988bb23f47f54ddecbae76333d58992f236c97c\" title=\"A sends the entire amount to X\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/2X/0/0988bb23f47f54ddecbae76333d58992f236c97c_2_517x171.png\" alt=\"A sends the entire amount to X\" data-base62-sha1=\"1mlf0AhG7w6GRt5GcMGbZoWedys\" width=\"517\" height=\"171\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/2X/0/0988bb23f47f54ddecbae76333d58992f236c97c_2_517x171.png, https://delvingbitcoin.org/uploads/default/optimized/2X/0/0988bb23f47f54ddecbae76333d58992f236c97c_2_775x256.png 1.5x, https://delvingbitcoin.org/uploads/default/optimized/2X/0/0988bb23f47f54ddecbae76333d58992f236c97c_2_1034x342.png 2x\" data-dominant-color=\"F8E5F2\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">A sends the entire amount to X</span><span class=\"informations\">1200\u00d7400 2.95 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p><strong>A</strong> uses <code>CCV</code> with the <em>default</em> logic to send all its amount to <strong>X</strong>.</p>\n<p>This is common in all the situations where <strong>A</strong> wants to send the some predefined destination - either e terminal state, or another UTXO with a certain program and data.</p>\n<p>In some cases, <strong>X</strong> might in turn be a copy of <strong>A</strong>\u2019s program, after updating its embedded data. In this case, <strong>A</strong>\u2019s Script would first use <code>CCV</code> to inspect the input\u2019s program and data, then compute the new data for the output, then use <code>CCV</code> with the <em>default</em> logic to check the output\u2019s program and data. This allows long-living smart contracts that can <em>update</em> their own state.</p>\n<h3><a name=\"p-4551-many-to-1-aggregate-7\" class=\"anchor\" href=\"#p-4551-many-to-1-aggregate-7\"></a>many-to-1 (aggregate)</h3>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/2X/4/485e099c9551164dd456cdf84fe83996eb1859bc.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/485e099c9551164dd456cdf84fe83996eb1859bc\" title=\"A, B, C aggregate their amount towards X\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/2X/4/485e099c9551164dd456cdf84fe83996eb1859bc_2_517x171.png\" alt=\"A, B, C aggregate their amount towards X\" data-base62-sha1=\"akbQQz4AQ5TQ4ZMcycOvz23xk16\" width=\"517\" height=\"171\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/2X/4/485e099c9551164dd456cdf84fe83996eb1859bc_2_517x171.png, https://delvingbitcoin.org/uploads/default/optimized/2X/4/485e099c9551164dd456cdf84fe83996eb1859bc_2_775x256.png 1.5x, https://delvingbitcoin.org/uploads/default/optimized/2X/4/485e099c9551164dd456cdf84fe83996eb1859bc_2_1034x342.png 2x\" data-dominant-color=\"E4EFEA\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">A, B, C aggregate their amount towards X</span><span class=\"informations\">1200\u00d7400 16.8 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p><strong>A</strong>, <strong>B</strong> and <strong>C</strong> uses <code>CCV</code> with the <em>default</em> logic to send all its amount to <strong>X</strong>.</p>\n<h3><a name=\"p-4551-send-partial-amount-8\" class=\"anchor\" href=\"#p-4551-send-partial-amount-8\"></a>send partial amount</h3>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/2X/c/cc87ae0d904c2fc609151fbeaf1ec685f1cc475c.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/cc87ae0d904c2fc609151fbeaf1ec685f1cc475c\" title=\"A sends some 'to itself', the rest to X\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/2X/c/cc87ae0d904c2fc609151fbeaf1ec685f1cc475c_2_517x171.png\" alt=\"A sends some 'to itself', the rest to X\" data-base62-sha1=\"tbm607iNG8zKeImREfGKabeZKiM\" width=\"517\" height=\"171\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/2X/c/cc87ae0d904c2fc609151fbeaf1ec685f1cc475c_2_517x171.png, https://delvingbitcoin.org/uploads/default/optimized/2X/c/cc87ae0d904c2fc609151fbeaf1ec685f1cc475c_2_775x256.png 1.5x, https://delvingbitcoin.org/uploads/default/optimized/2X/c/cc87ae0d904c2fc609151fbeaf1ec685f1cc475c_2_1034x342.png 2x\" data-dominant-color=\"F8E6F2\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">A sends some 'to itself', the rest to X</span><span class=\"informations\">1200\u00d7400 13.5 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p><strong>A</strong> checks the program and data (if any) of the input using <code>CCV</code>, then it checks that the first input <strong>A\u2019</strong> has the same program/data using the <em>deduct</em> logic, then it uses <code>CCV</code> on the second output to send the residual amount to <strong>X</strong>.</p>\n<p>This is used in constructions like vaults, to allow immediate partial revaulting. It could also be used in shared-UTXO schemes, to allow one of the users to withdraw their balance from the UTXO while leaving the rest in the pool (however, this would likely require a <code>CHECKSIG</code> or additional introspection on the exact amount going to X, which <code>CCV</code> alone can\u2019t provide).</p>\n<p>(In other application, the partial amount could of course be sent to a completely different program, instead of <strong>A\u2019</strong>)</p>\n<h3><a name=\"p-4551-send-partial-amount-and-aggregate-9\" class=\"anchor\" href=\"#p-4551-send-partial-amount-and-aggregate-9\"></a>send partial amount, and aggregate</h3>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/2X/0/0a83cc8f27d35ecbec320897d020935e17f50829.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/0a83cc8f27d35ecbec320897d020935e17f50829\" title=\"Partial send from A, aggregate with B, toward X\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/2X/0/0a83cc8f27d35ecbec320897d020935e17f50829_2_517x171.png\" alt=\"Partial send from A, aggregate with B, toward X\" data-base62-sha1=\"1v19tHec3yXWqGPxu1c7421DA25\" width=\"517\" height=\"171\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/2X/0/0a83cc8f27d35ecbec320897d020935e17f50829_2_517x171.png, https://delvingbitcoin.org/uploads/default/optimized/2X/0/0a83cc8f27d35ecbec320897d020935e17f50829_2_775x256.png 1.5x, https://delvingbitcoin.org/uploads/default/optimized/2X/0/0a83cc8f27d35ecbec320897d020935e17f50829_2_1034x342.png 2x\" data-dominant-color=\"EFEAF3\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">Partial send from A, aggregate with B, toward X</span><span class=\"informations\">1200\u00d7400 16.4 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p><strong>A</strong> does the same as the previous case, but here a separate input <strong>B</strong> also sends its amount  to <strong>X</strong> using the <em>default</em> logic, therefore aggregating its amount to the residual amount of <strong>A</strong> (after deducting the portion going to <strong>A\u2019</strong>).</p>\n<h1><a name=\"p-4551-discussion-10\" class=\"anchor\" href=\"#p-4551-discussion-10\"></a>Discussion</h1>\n<p>I\u2019ve been suggested to separate the Script introspection of <code>CCV</code> from the amount logic. That\u2019s a possibility, however:</p>\n<ul>\n<li>you virtually <em>never</em> want to check an output Script without meaningful checks on their amount; so that would be wasteful and arguably less ergonomic.</li>\n<li>both the <em>default</em> and the <em>deduct</em> logic would be very difficult to implement with more atomic introspection opcodes.</li>\n</ul>\n<p>Even enabling all the opcodes in the <a href=\"https://youtu.be/rSp8918HLnA\" rel=\"noopener nofollow ugc\">Great Script Restoration</a> wouldn\u2019t be sufficient to easily emulate the amount logic described above. That\u2019s because the nature of these checks is inherently transaction-wide, and can\u2019t be expressed easily (or at all?) with individual input Script checks. Implementing it with a loop over all the involved inputs, it would result in quadratic complexity if every input performs this check. Of course, one could craft a single special input that checks the amount of all the other inputs (which in turn check the presence of the special input), but that\u2019s not quite an ergonomic solution - and to me it just feels wrong.</p>\n<p>By incorporating this amount logic where the amount of the input is <em>assigned</em> to the outputs, the actual computations related to the constraint amounts are moved out of the Script interpreter.</p>\n<p>I think the two amount behaviors (<em>default</em> and <em>deduct</em>) are very ergonomic, and cover the vast majority of the desirable amount checks in practice. The only extension I can think of is direct equality checks on the output amounts, which could be added with a simple <code>OP_AMOUNT</code> (or <a href=\"https://delvingbitcoin.org/t/op-inout-amount/549\"><code>OP_INOUT_AMOUNT</code></a>) opcode that pushes an input/output amount on the stack, or with a more generic introspection opcode like <code>OP_TXHASH</code>).</p>\n<p>I implemented <a href=\"https://github.com/Merkleize/pymatt/blob/e9cd2077880422ff74c3a5817c8affad74a0ed39/examples/vault/vault_contracts.py\" rel=\"noopener nofollow ugc\">fully featured vaults</a> using <code>OP_CCV + OP_CTV</code> that are roughly equivalent to <code>OP_VAULT + OP_VAULT_RECOVER + OP_CTV</code> in the python framework I developed for exploring MATT ideas. Moreover, a reduced-functionality version using just <code>OP_CCV</code> is implemented as a functional test in the bitcoin-core implementation of <code>OP_CCV</code>.</p>\n<h1><a name=\"p-4551-conclusions-11\" class=\"anchor\" href=\"#p-4551-conclusions-11\"></a>Conclusions</h1>\n<p>I look forward to your comments on the specifications, implementation, and applications of <code>OP_CHECKCONTRACTVERIFY</code>,</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2025-03-17T12:29:05.169Z",
  "reply_count": 1,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 66,
  "reads": 23,
  "readers_count": 22,
  "score": 369.6,
  "yours": false,
  "topic_id": 1527,
  "topic_slug": "op-checkcontractverify-and-its-amount-semantic",
  "topic_title": "OP_CHECKCONTRACTVERIFY and its amount semantic",
  "topic_html_title": "OP_CHECKCONTRACTVERIFY and its amount semantic",
  "category_id": 7,
  "display_username": "salvatoshi",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 5,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "I have done some work on formalizing the semantic of `OP_CHECKCONTRACTVERIFY`.  I also wrote the first draft BIP and an implementation in bitcoin-core:\n\nLinks:\n- [BIP draft](https://github.com/bitcoin/bips/pull/1793)\n- [bitcoin-core implementation draft](https://github.com/bitcoin/bitcoin/pull/32080)\n\nIn this post, I will briefly introduce the `OP_CCV` opcode semantic, then expand and discuss on an its amount-handling logic \u2014 an aspect that wasn't fully explored (and not properly formalized) in my previous posts on the topic. I will make the argument that it provides a convenient and compelling feature set that would be difficult to implement with more 'atomic' opcodes.\n\n# OP_CHECKCONTRACTVERIFY\nI start with a brief intro on `OP_CHECKCONTRACTVERIFY`, for the sake of making this post self-contained.\n\n## in a nutshell: *state-carrying UTXOs*\n\n`OP_CCV` enables *state-carrying UTXOs*: think of a UTXO as a locked box holding data, rules and an amount of coins. When you spend the UTXO, it lets you peek inside your own box (introspect the data), and decide the next box's rules (program), data and amount.\n\n## less in a nutshell\n\n`OP_CCV` works with P2TR inputs and outputs. It allows comparing the public key of an input.output with:\n- a public key that we call the *naked key*\n- ...optionally tweaked with the hash of some data\n- ...optionally taptweaked with the Merkle root of a taproot tree.\n\nSimilarly to taproot, *tweaking* allows to create a commitment to a piece of data inside a public key. Therefore, by using a 'double' tweak, one can easily commit to an additional piece of arbitrary data.\nAn equality check of a double tweak with the input's taproot key is therefore enough to 'introspect' the current input's embedded data (if any), and an equality check with an output's taproot public key can force both the program (*naked key* and *taptree*) and the data of the output to be a desired value.\n\nIn combination with an opcode that allows to create a *vector commitment* (like `OP_CAT`, `OP_PAIRCOMMIT` or an hypothetical `OP_VECTORCOMMIT` opcode), it is of course possible to commit to multiple pieces of data instead of a single one.\n\nWhile certainly not the only way to only way to implement a dynamic commitment inside a Script, this is the best I could come up with, and has some nice properties.\n\n**Pro:**\n- Fully compatible with taproot. Keypath spending is still available, and cheap.\n- No additional burden for nodes; state is committed in the UTXO, not explicitly stored.\n- It keeps the *program* (the taptree) logically separated from the *data*.\n- Spending paths that do not require access to the embedded data (if any) do not pay extra witness bytes because of its present.\n\n**Con:**\n- Only compatible with P2TR.\n- A tweak is computationally more expensive than other approaches\n\n# Amount logic\n\nWhat about amounts?\nIt would be rather unusual to care about the output's Script, and then sending 0 sats to it. In most cases, you want to also specify how much money goes there.\n\nTherefore, when checking an output, `OP_CCV` allows a convenient semantic to specify the amount flow in a way that works for most cases. There are three options:\n\n- *default*: assign to the output the entire unassigned amount the current input\n- *deduct*: assign to the output the portion of current input's amount equal to this output's amount (the rest remain unassigned\n- *ignore*: only check the output's Script but not the amount.\n\nAn output can be used with the *default* logic from different inputs, but no output can be used as the target of both a *deduct* check and a *default* check, nor multiple *deduct* checks.\n\nA well formed Script using `OP_CCV` would use:\n- 0 or more `OP_CCV` with the *deduct* logic, assigning parts of the input amount to some outputs\n- exactly 1 `OP_CCV` with the *default* logic, assigning the (possibly residual) amount to an(other) output.\n\nThis ensures that *all the amount of this input is accounted for in the outputs*.\n\n## Examples\n\n### 1-to-1\n![A sends the entire amount to X|690x229, 75%](upload://1mlf0AhG7w6GRt5GcMGbZoWedys.png)\n\n**A** uses `CCV` with the *default* logic to send all its amount to **X**.\n\nThis is common in all the situations where **A** wants to send the some predefined destination - either e terminal state, or another UTXO with a certain program and data.\n\nIn some cases, **X** might in turn be a copy of **A**'s program, after updating its embedded data. In this case, **A**'s Script would first use `CCV` to inspect the input's program and data, then compute the new data for the output, then use `CCV` with the *default* logic to check the output's program and data. This allows long-living smart contracts that can *update* their own state.\n\n### many-to-1 (aggregate)\n![**A**, B, C aggregate their amount towards X|690x229, 75%](upload://akbQQz4AQ5TQ4ZMcycOvz23xk16.png)\n\n**A**, **B** and **C** uses `CCV` with the *default* logic to send all its amount to **X**.\n\n### send partial amount\n\n![A sends some 'to itself', the rest to X|690x229, 75%](upload://tbm607iNG8zKeImREfGKabeZKiM.png)\n\n**A** checks the program and data (if any) of the input using `CCV`, then it checks that the first input **A'** has the same program/data using the *deduct* logic, then it uses `CCV` on the second output to send the residual amount to **X**.\n\nThis is used in constructions like vaults, to allow immediate partial revaulting. It could also be used in shared-UTXO schemes, to allow one of the users to withdraw their balance from the UTXO while leaving the rest in the pool (however, this would likely require a `CHECKSIG` or additional introspection on the exact amount going to X, which `CCV` alone can't provide).\n\n(In other application, the partial amount could of course be sent to a completely different program, instead of **A'**)\n\n### send partial amount, and aggregate\n\n![Partial send from A, aggregate with B, toward X|690x229, 75%](upload://1v19tHec3yXWqGPxu1c7421DA25.png)\n\n**A** does the same as the previous case, but here a separate input **B** also sends its amount  to **X** using the *default* logic, therefore aggregating its amount to the residual amount of **A** (after deducting the portion going to **A'**).\n\n# Discussion\n\nI've been suggested to separate the Script introspection of `CCV` from the amount logic. That's a possibility, however:\n\n- you virtually *never* want to check an output Script without meaningful checks on their amount; so that would be wasteful and arguably less ergonomic.\n- both the *default* and the *deduct* logic would be very difficult to implement with more atomic introspection opcodes.\n\nEven enabling all the opcodes in the [Great Script Restoration](https://youtu.be/rSp8918HLnA) wouldn't be sufficient to easily emulate the amount logic described above. That's because the nature of these checks is inherently transaction-wide, and can't be expressed easily (or at all?) with individual input Script checks. Implementing it with a loop over all the involved inputs, it would result in quadratic complexity if every input performs this check. Of course, one could craft a single special input that checks the amount of all the other inputs (which in turn check the presence of the special input), but that's not quite an ergonomic solution - and to me it just feels wrong.\n\nBy incorporating this amount logic where the amount of the input is *assigned* to the outputs, the actual computations related to the constraint amounts are moved out of the Script interpreter.   \n\nI think the two amount behaviors (*default* and *deduct*) are very ergonomic, and cover the vast majority of the desirable amount checks in practice. The only extension I can think of is direct equality checks on the output amounts, which could be added with a simple `OP_AMOUNT` (or [`OP_INOUT_AMOUNT`](https://delvingbitcoin.org/t/op-inout-amount/549)) opcode that pushes an input/output amount on the stack, or with a more generic introspection opcode like `OP_TXHASH`).\n\nI implemented [fully featured vaults](https://github.com/Merkleize/pymatt/blob/e9cd2077880422ff74c3a5817c8affad74a0ed39/examples/vault/vault_contracts.py) using `OP_CCV + OP_CTV` that are roughly equivalent to `OP_VAULT + OP_VAULT_RECOVER + OP_CTV` in the python framework I developed for exploring MATT ideas. Moreover, a reduced-functionality version using just `OP_CCV` is implemented as a functional test in the bitcoin-core implementation of `OP_CCV`.\n\n# Conclusions\n\nI look forward to your comments on the specifications, implementation, and applications of `OP_CHECKCONTRACTVERIFY`,",
  "actions_summary": [
    {
      "id": 2,
      "count": 2
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 81,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "clap",
      "type": "emoji",
      "count": 1
    },
    {
      "id": "tada",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 2,
  "current_user_used_main_reaction": false
}