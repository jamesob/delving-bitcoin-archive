{
  "id": 4652,
  "name": "Chris Stewart",
  "username": "Chris_Stewart_5",
  "avatar_template": "/user_avatar/delvingbitcoin.org/chris_stewart_5/{size}/296_2.png",
  "created_at": "2025-03-31T15:35:30.172Z",
  "cooked": "<h1><a name=\"p-4652-overflow-handling-in-script-1\" class=\"anchor\" href=\"#p-4652-overflow-handling-in-script-1\"></a>Overflow handling in Script</h1>\n<h2><a name=\"p-4652-motivation-2\" class=\"anchor\" href=\"#p-4652-motivation-2\"></a>Motivation</h2>\n<p>There is interest in enhancing Script\u2019s functionality. Re-enabling opcodes is one of the main feature enhancements that have been proposed. This overflow limitation has been talked about in the Rusty Russell\u2019s <a href=\"https://rusty.ozlabs.org/2023/12/30/arithmetic-opcodes.html\" rel=\"noopener nofollow ugc\">Great Script Restoration</a> project, as well as the <a href=\"https://delvingbitcoin.org/t/64-bit-arithmetic-soft-fork/397\">64-bit arithmetic delving bitcoin post</a>.</p>\n<p>Here are some highlights</p>\n<aside class=\"quote no-group\" data-username=\"sipa\" data-post=\"15\" data-topic=\"397\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/sipa/48/1100_2.png\" class=\"avatar\"><a href=\"https://delvingbitcoin.org/t/64-bit-arithmetic-soft-fork/397/15\">64 bit arithmetic soft fork</a></div>\n<blockquote>\n<p>If <code>OP_MUL</code> or a variant thereof is added, I can see why detecting/dealing with overflows becomes an issue that the existing interface doesn\u2019t deal well with.</p>\n</blockquote>\n</aside>\n<aside class=\"quote no-group\" data-username=\"sipa\" data-post=\"15\" data-topic=\"397\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/sipa/48/1100_2.png\" class=\"avatar\"><a href=\"https://delvingbitcoin.org/t/64-bit-arithmetic-soft-fork/397/15\">64 bit arithmetic soft fork</a></div>\n<blockquote>\n<p>I think you\u2019d want to add overflow-detecting versions for your use, but otherwise it already does everything.</p>\n</blockquote>\n</aside>\n<aside class=\"quote no-group\" data-username=\"dgpv\" data-post=\"20\" data-topic=\"397\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/dgpv/48/75_2.png\" class=\"avatar\"><a href=\"https://delvingbitcoin.org/t/64-bit-arithmetic-soft-fork/397/20\">64 bit arithmetic soft fork</a></div>\n<blockquote>\n<p>it definitely feels that there is value in being able to do computations using the same format as the numbers that are stored within the transaction, and with clearly defined ways to detect overflows etc.</p>\n</blockquote>\n</aside>\n<aside class=\"quote no-group\" data-username=\"dgpv\" data-post=\"21\" data-topic=\"397\" data-full=\"true\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/dgpv/48/75_2.png\" class=\"avatar\"><a href=\"https://delvingbitcoin.org/t/64-bit-arithmetic-soft-fork/397/21\">64 bit arithmetic soft fork</a></div>\n<blockquote>\n<p>On the second thought, maybe checking for overflows after each 64-bit arithmetic opcode is not that great, if we can have computations in (practically) arbitrary width integers and then only detect overflows on conversion to LE64/LE32.</p>\n<p>(but really, adding VERIFY after each 64-bit arith op does not add any mental load - it just increases script size a bit)</p>\n<p>(well, forgetting VERIFY after 64-bit arith op in Elements might lead to unexpected behavior in case of actual overflow\u2026)</p>\n</blockquote>\n</aside>\n<p>I would like to consolidate discussion on the <em>overflow handling</em> part of the Great Script restoration project here.</p>\n<p>While not an overflow exactly, you can imagine a world where <code>OP_DIV</code> is re-enabled. This error handling logic could also be used for the case where the user attempts to divide by 0.</p>\n<h2><a name=\"p-4652-background-3\" class=\"anchor\" href=\"#p-4652-background-3\"></a>Background</h2>\n<p><a href=\"https://github.com/bitcoin/bitcoin/blob/770d39a37652d40885533fecce37e9f71cc0d051/src/script/script.h#L226\" rel=\"noopener nofollow ugc\">CScriptNum</a> is the data type used in bitcoin core to handle numbers in Script. Here is what happens when a stack element is interpreted as a CScriptNum that results in an overflow</p>\n<blockquote>\n<p>operands must be in the range [-2^31 +1 to 2^31 -1]</p>\n</blockquote>\n<p>This means inputs to opcodes such as <code>OP_ADD</code>, <code>OP_SUB</code>, <code>OP_1ADD</code> etc must fall within the stated range. However</p>\n<blockquote>\n<p>results may overflow (and are valid as long as they are not used in a subsequent numeric operation). CScriptNum enforces those semantics by storing results as an int64 and allowing out-of-range values to be returned as a vector of bytes but throwing an exception if arithmetic is done or the result is interpreted as an integer.</p>\n</blockquote>\n<p>Simply put, if my Script is</p>\n<blockquote>\n<p>2^31-1 OP_1ADD</p>\n</blockquote>\n<p>the result on the stack would be <code>2^31</code>, which is a valid result. If I tried to do an <code>OP_1ADD</code> on <code>2^31</code> an <a href=\"https://github.com/bitcoin/bitcoin/blob/770d39a37652d40885533fecce37e9f71cc0d051/src/script/script.h#L249\" rel=\"noopener nofollow ugc\">this exception would occur</a></p>\n<p>which then would result in this error being propagated to the user</p>\n<blockquote>\n<p>mandatory-script-verify-flag-failed (unknown error)</p>\n</blockquote>\n<p>This is because the exception thrown in <code>CScriptNum</code>\u2019s constructor is caught in <code>EvalScript()</code>'s <code>catch</code> clause</p>\n<aside class=\"onebox githubblob\" data-onebox-src=\"https://github.com/bitcoin/bitcoin/blob/770d39a37652d40885533fecce37e9f71cc0d051/src/script/interpreter.cpp#L1227\">\n  <header class=\"source\">\n\n      <a href=\"https://github.com/bitcoin/bitcoin/blob/770d39a37652d40885533fecce37e9f71cc0d051/src/script/interpreter.cpp#L1227\" target=\"_blank\" rel=\"noopener nofollow ugc\">github.com</a>\n  </header>\n\n  <article class=\"onebox-body\">\n    <h4><a href=\"https://github.com/bitcoin/bitcoin/blob/770d39a37652d40885533fecce37e9f71cc0d051/src/script/interpreter.cpp#L1227\" target=\"_blank\" rel=\"noopener nofollow ugc\">bitcoin/bitcoin/blob/770d39a37652d40885533fecce37e9f71cc0d051/src/script/interpreter.cpp#L1227</a></h4>\n\n\n\n    <pre class=\"onebox\"><code class=\"lang-cpp\">\n      <ol class=\"start lines\" start=\"1217\" style=\"counter-reset: li-counter 1216 ;\">\n          <li>                    return set_error(serror, SCRIPT_ERR_BAD_OPCODE);</li>\n          <li>            }</li>\n          <li></li>\n          <li>            // Size limits</li>\n          <li>            if (stack.size() + altstack.size() &gt; MAX_STACK_SIZE)</li>\n          <li>                return set_error(serror, SCRIPT_ERR_STACK_SIZE);</li>\n          <li>        }</li>\n          <li>    }</li>\n          <li>    catch (...)</li>\n          <li>    {</li>\n          <li class=\"selected\">        return set_error(serror, SCRIPT_ERR_UNKNOWN_ERROR);</li>\n          <li>    }</li>\n          <li></li>\n          <li>    if (!vfExec.empty())</li>\n          <li>        return set_error(serror, SCRIPT_ERR_UNBALANCED_CONDITIONAL);</li>\n          <li></li>\n          <li>    return set_success(serror);</li>\n          <li>}</li>\n          <li></li>\n          <li>bool EvalScript(std::vector&lt;std::vector&lt;unsigned char&gt; &gt;&amp; stack, const CScript&amp; script, unsigned int flags, const BaseSignatureChecker&amp; checker, SigVersion sigversion, ScriptError* serror)</li>\n          <li>{</li>\n      </ol>\n    </code></pre>\n\n\n\n  </article>\n\n  <div class=\"onebox-metadata\">\n    \n    \n  </div>\n\n  <div style=\"clear: both\"></div>\n</aside>\n\n<h2><a name=\"p-4652-what-design-options-are-out-there-4\" class=\"anchor\" href=\"#p-4652-what-design-options-are-out-there-4\"></a>What design options are out there?</h2>\n<p>Here is the design space as I see it, please comment below if I\u2019ve missed any designs that have been deployed</p>\n<h3><a name=\"p-4652-elements-project-5\" class=\"anchor\" href=\"#p-4652-elements-project-5\"></a>Elements project</h3>\n<p><a href=\"https://github.com/ElementsProject/elements/blob/811d8359600477b38088d12f7a686291fdad211f/doc/tapscript_opcodes.md#new-opcodes-for-additional-functionality\" rel=\"noopener nofollow ugc\">In 2022</a> the Elements project introduced a new set of opcodes to handle the case of overflowing numbers in Script. This upgrade also added 64 bits of precision, 64 bit specific opcodes, and a new encoding format \u2013 all of which we will ignore for the purposes of this post.</p>\n<p>This soft fork introduces <em>overflow handling</em> when arithmetic computations are performed with the new 64 bit opcodes in elements.</p>\n<blockquote>\n<p>When dealing with overflows, we explicitly return the success bit as a <code>CScriptNum</code> at the top of the stack and the result being the second element from the top. If the operation overflows, first the operands are pushed onto the stack followed by success bit. [<code>a_second</code> <code>a_top</code>] overflows, the stack state after the operation is [<code>a_second</code> <code>a_top</code> <code>0</code>] and if the operation does not overflow, the stack state is [<code>res</code> <code>1</code>].</p>\n</blockquote>\n<blockquote>\n<p>This gives the user flexibility to deal if they script to have overflows using <code>OP_IF\\OP_ELSE</code> or <code>OP_VERIFY</code> the success bit if they expect that operation would never fail. When defining the opcodes which can fail, we only define the success path, and assume the overflow behavior as stated above.</p>\n</blockquote>\n<p>AJ Towns provided a critique to this design in the 64-bit arithmetic thread</p>\n<aside class=\"quote no-group\" data-username=\"ajtowns\" data-post=\"50\" data-topic=\"397\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/ajtowns/48/417_2.png\" class=\"avatar\"><a href=\"https://delvingbitcoin.org/t/64-bit-arithmetic-soft-fork/397/50\">64 bit arithmetic soft fork</a></div>\n<blockquote>\n<p>FWIW, the big concern I have with this is people writing scripts where they don\u2019t think an overflow is possible, so they just do an OP_DROP for the overflow indicator, and then someone thinks a bit harder, and figures out how to steal money via an overflow, and then they do exactly that. That\u2019s arguably easily mitigated: just use <code>OP_VERIFY</code> to guarantee there wasn\u2019t an overflow, but I noticed that an example script in <a href=\"https://bitcoincore.reviews/29221#l-86\" rel=\"noopener nofollow ugc\">review club</a> used the more obvious DROP:</p>\n<pre><code class=\"lang-auto\">&lt;Chris_Stewart_5&gt; Script: 0x000e876481700000 0x000e876481700000 OP_ADD64 OP_DROP OP_LE64TOSCRIPTNUM OP_SIZE OP_8 OP_EQUALVERIFY OP_SCRIPTNUMTOLE64 0x001d0ed902e00000 OP_EQUAL\n</code></pre>\n<p>Worries me a bit when the obvious way of doing something (\u201cthis won\u2019t ever overflow, so just drop it\u201d) is risky.</p>\n<p>You could imagine introducing two opcodes: \u201cOP_ADD64\u201d and \u201cOP_ADD64VERIFY\u201d the latter of which does an implicit VERIFY, and hence fails the script if there was overflow; but that would effectively be the existing behaviour of OP_ADD. So I guess what I\u2019m saying is: maybe consider an approach along the lines that sipa suggested:</p>\n</blockquote>\n</aside>\n<h3><a name=\"p-4652-bitcoin-cash-6\" class=\"anchor\" href=\"#p-4652-bitcoin-cash-6\"></a>Bitcoin Cash</h3>\n<p>Bitcoin cash seems to have re-added disabled opcodes such as <a href=\"https://gitlab.com/bitcoin-cash-node/bitcoin-cash-node/-/blob/master/src/script/interpreter.cpp#L884\" rel=\"noopener nofollow ugc\">OP_MUL</a> and <a href=\"https://gitlab.com/bitcoin-cash-node/bitcoin-cash-node/-/blob/master/src/script/interpreter.cpp#L895\" rel=\"noopener nofollow ugc\">OP_DIV</a>. They have decided to modify the exception handling behavior by <a href=\"https://gitlab.com/bitcoin-cash-node/bitcoin-cash-node/-/blob/master/src/script/interpreter.cpp#L887\" rel=\"noopener nofollow ugc\">setting <code>serror</code> exception</a> if the result overflows. Note, this is different than how bitcoin works currently as we catch an exception thrown by <code>CScriptNum</code>.</p>\n<h3><a name=\"p-4652-zcash-litecoin-7\" class=\"anchor\" href=\"#p-4652-zcash-litecoin-7\"></a>Zcash / Litecoin</h3>\n<p>Both <a href=\"https://github.com/zcash/zcash/blob/a3435336b0c561799ac6805a27993eca3f9656df/src/script/script.h#L209\" rel=\"noopener nofollow ugc\">Zcash</a> and <a href=\"https://github.com/litecoin-project/litecoin/blob/5fba5ad7c13c59d1e0854dd51ac0c22bea68c8f8/src/script/script.h#L254\" rel=\"noopener nofollow ugc\">Litecoin</a> have retained the original behavior from bitcoin as far as I can tell.</p>\n<h3><a name=\"p-4652-other-bitcoin-derivatives-8\" class=\"anchor\" href=\"#p-4652-other-bitcoin-derivatives-8\"></a>Other bitcoin derivatives?</h3>\n<p>If you know of any interesting design choices made by other forks of bitcoin, please share them below!</p>\n<h3><a name=\"p-4652-ethan-heilmans-suggested-design-9\" class=\"anchor\" href=\"#p-4652-ethan-heilmans-suggested-design-9\"></a>Ethan Heilmans suggested design</h3>\n<aside class=\"quote no-group\" data-username=\"EthanHeilman\" data-post=\"36\" data-topic=\"397\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/ethanheilman/48/328_2.png\" class=\"avatar\"><a href=\"https://delvingbitcoin.org/t/64-bit-arithmetic-soft-fork/397/36\">64 bit arithmetic soft fork</a></div>\n<blockquote>\n<p>The BIP states: \u201cIf the operation results in an overflow, push false onto the stack\u201d.</p>\n<p>I would propose altering this to so that the result and the overflow amount are pushed onto the stack.</p>\n<p><strong>Case 1, no overflow:</strong></p>\n<p>1, 1, OP_ADD64 \u2192 2, 0</p>\n<p>where 2 is the result and 0 is the overflow amount.</p>\n<p><strong>Case 2, overflow:</strong></p>\n<p>2^64 - 1, 5, OP_ADD64 \u2192 4, 1</p>\n<p>where 4 is the result (mod 2^64), and 1 is the overflow amount. You can think of these two stack values as representing the 128 bit number 2^64+4 broken into two 64 bit chunks.</p>\n<p>Push values on the stack in this fashion makes it esimple use these 64 opcodes to do math on numbers larger than 64 bits by chunking them into 64-bit stack elements. The overflow amount tells you how much to carry into the next chunk.</p>\n<p>You\u2019d still get the benefit of having a flag to check, if overflow amount is not 0, overflow occurred.</p>\n<p>I think the BIP as written lets you add numbers larger than 64-bits using a similar chunking approach, but it is less straight forward and requires IF statements and substructions operations.</p>\n</blockquote>\n</aside>\n<p>with suggestions from AJ Towns</p>\n<aside class=\"quote no-group quote-modified\" data-username=\"ajtowns\" data-post=\"40\" data-topic=\"397\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/ajtowns/48/417_2.png\" class=\"avatar\"><a href=\"https://delvingbitcoin.org/t/64-bit-arithmetic-soft-fork/397/40\">64 bit arithmetic soft fork</a></div>\n<blockquote>\n<p>I think there\u2019s a few choices here:</p>\n<ul>\n<li>what happens with \u201coverflows\u201d ?\n<ul>\n<li>they\u2019re not possible, everything happens modulo 2^n2n2^n</li>\n<li>if the inputs are \u201ctoo large\u201d, the script aborts</li>\n<li>you get an overflow indicator in every result</li>\n</ul>\n</li>\n<li>what is 2^n2n2^n or what constitutes \u201ctoo large\u201d ?\n<ul>\n<li>BTC\u2019s max supply is about 2^{51}2512^{51} satoshis, so 64bit is a fine minimum</li>\n<li>2^{256}22562^{256} would let you manipulate scalars for secp256k1 which might be useful</li>\n<li>2^{4160}241602^{4160} would let you do numbers of to 520 bytes which matches current stack entry limits</li>\n</ul>\n</li>\n<li>unsigned only, or signed\n<ul>\n<li>if we\u2019re doing modular arithmetic, unsigned seems easier</li>\n<li>signed maths probably makes some contracts a bunch easier though</li>\n</ul>\n</li>\n<li>what serialization format?\n<ul>\n<li>if signed, use a sign-bit or 2\u2019s complement?</li>\n<li>fixed length or variable length \u2013 if fixed length, that constrains the precision we could use</li>\n<li>if variable length, does every integer have a unique serialization, or can you have \u201c0000\u201d and \u201c0\u201d and \u201c-0\u201d all as different representations of 0?</li>\n</ul>\n</li>\n</ul>\n<p>I guess 64-bit unsigned modular arithmetic would be easiest (<code>uint64_t</code> already works), but 4160-bit signed numbers (or some similarly large value that benchmarks fast enough) with abort-on-overflow behaviour and stored/serialized like CScriptNum format might be more appropriate?</p>\n<p>Abort-on-overflow seems kind of appealing as far as writing contracts goes: we\u2019ve already had an \u201coverflow allows printing money\u201d bug in bitcoin proper, so immediately aborting if that happens in script seems like a wise protection. If people want to do modular arithmetic, they could perhaps manually calculate <code>((x % k) * (y % k)) % k</code> provided they pick k \\le \\sqrt{2^{n}}k\u2264\u221a2nk \\le \\sqrt{2^{n}} or similar.</p>\n</blockquote>\n</aside>\n<h2><a name=\"p-4652-future-research-10\" class=\"anchor\" href=\"#p-4652-future-research-10\"></a>Future research</h2>\n<p>As mentioned above, CScriptNum currently <a href=\"https://github.com/bitcoin/bitcoin/blob/998386d4462f5e06412303ba559791da83b913fb/src/script/script.h#L249\" rel=\"noopener nofollow ugc\">throws an exception if an overflow occurs</a>. If this is used in conjunction with an op code that interprets the stack top as a CScriptNum, this propagates the exception in to <code>EvalScript()</code> causing the main execution loop to be wrapped in a <a href=\"https://github.com/bitcoin/bitcoin/blob/998386d4462f5e06412303ba559791da83b913fb/src/script/interpreter.cpp#L1225\" rel=\"noopener nofollow ugc\"><code>try</code> <code>catch</code> block</a>. Questions I have are</p>\n<ol>\n<li>What are other opcodes that can result in an exception that are caught by this <code>try</code> <code>catch</code> block?</li>\n<li>What are the performance implications of wrapping the meat and potatoes of <code>EvalScript()</code> in a <code>try</code> <code>catch</code> block?</li>\n</ol>\n<p>While we will likely never be able to fully migrate from the <code>try</code> <code>catch</code> block, perhaps future soft forks could avoid having this logic?</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2025-03-31T20:04:35.217Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 1,
  "reads": 15,
  "readers_count": 14,
  "score": 2.8,
  "yours": false,
  "topic_id": 1549,
  "topic_slug": "overflow-handling-in-script",
  "topic_title": "Overflow handling in Script",
  "topic_html_title": "Overflow handling in Script",
  "category_id": 7,
  "display_username": "Chris Stewart",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 4,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "# Overflow handling in Script\n\n## Motivation\n\nThere is interest in enhancing Script's functionality. Re-enabling opcodes is one of the main feature enhancements that have been proposed. This overflow limitation has been talked about in the Rusty Russell's [Great Script Restoration](https://rusty.ozlabs.org/2023/12/30/arithmetic-opcodes.html) project, as well as the [64-bit arithmetic delving bitcoin post](https://delvingbitcoin.org/t/64-bit-arithmetic-soft-fork/397).\n\nHere are some highlights\n\n[quote=\"sipa, post:15, topic:397\"]\nIf `OP_MUL` or a variant thereof is added, I can see why detecting/dealing with overflows becomes an issue that the existing interface doesn\u2019t deal well with.\n[/quote]\n\n[quote=\"sipa, post:15, topic:397\"]\nI think you\u2019d want to add overflow-detecting versions for your use, but otherwise it already does everything.\n[/quote]\n\n[quote=\"dgpv, post:20, topic:397\"]\nit definitely feels that there is value in being able to do computations using the same format as the numbers that are stored within the transaction, and with clearly defined ways to detect overflows etc.\n[/quote]\n\n[quote=\"dgpv, post:21, topic:397, full:true\"]\nOn the second thought, maybe checking for overflows after each 64-bit arithmetic opcode is not that great, if we can have computations in (practically) arbitrary width integers and then only detect overflows on conversion to LE64/LE32.\n\n(but really, adding VERIFY after each 64-bit arith op does not add any mental load - it just increases script size a bit)\n\n(well, forgetting VERIFY after 64-bit arith op in Elements might lead to unexpected behavior in case of actual overflow\u2026)\n[/quote]\n\nI would like to consolidate discussion on the _overflow handling_ part of the Great Script restoration project here.\n\nWhile not an overflow exactly, you can imagine a world where `OP_DIV` is re-enabled. This error handling logic could also be used for the case where the user attempts to divide by 0.\n\n\n## Background\n\n[CScriptNum](https://github.com/bitcoin/bitcoin/blob/770d39a37652d40885533fecce37e9f71cc0d051/src/script/script.h#L226) is the data type used in bitcoin core to handle numbers in Script. Here is what happens when a stack element is interpreted as a CScriptNum that results in an overflow\n\n>operands must be in the range [-2^31 +1 to 2^31 -1]\n\nThis means inputs to opcodes such as `OP_ADD`, `OP_SUB`, `OP_1ADD` etc must fall within the stated range. However\n\n>results may overflow (and are valid as long as they are not used in a subsequent numeric operation). CScriptNum enforces those semantics by storing results as an int64 and allowing out-of-range values to be returned as a vector of bytes but throwing an exception if arithmetic is done or the result is interpreted as an integer.\n\nSimply put, if my Script is \n\n> 2^31-1 OP_1ADD \n\nthe result on the stack would be `2^31`, which is a valid result. If I tried to do an `OP_1ADD` on `2^31` an [this exception would occur](https://github.com/bitcoin/bitcoin/blob/770d39a37652d40885533fecce37e9f71cc0d051/src/script/script.h#L249)\n\nwhich then would result in this error being propagated to the user\n\n>mandatory-script-verify-flag-failed (unknown error)\n\nThis is because the exception thrown in `CScriptNum`'s constructor is caught in `EvalScript()`'s `catch` clause\n\nhttps://github.com/bitcoin/bitcoin/blob/770d39a37652d40885533fecce37e9f71cc0d051/src/script/interpreter.cpp#L1227\n\n## What design options are out there?\n\nHere is the design space as I see it, please comment below if I've missed any designs that have been deployed\n\n### Elements project\n[In 2022](https://github.com/ElementsProject/elements/blob/811d8359600477b38088d12f7a686291fdad211f/doc/tapscript_opcodes.md#new-opcodes-for-additional-functionality) the Elements project introduced a new set of opcodes to handle the case of overflowing numbers in Script. This upgrade also added 64 bits of precision, 64 bit specific opcodes, and a new encoding format -- all of which we will ignore for the purposes of this post. \n\nThis soft fork introduces _overflow handling_ when arithmetic computations are performed with the new 64 bit opcodes in elements.\n\n>When dealing with overflows, we explicitly return the success bit as a `CScriptNum` at the top of the stack and the result being the second element from the top. If the operation overflows, first the operands are pushed onto the stack followed by success bit. [`a_second` `a_top`] overflows, the stack state after the operation is [`a_second` `a_top` `0`] and if the operation does not overflow, the stack state is [`res` `1`].\n\n>This gives the user flexibility to deal if they script to have overflows using `OP_IF\\OP_ELSE` or `OP_VERIFY` the success bit if they expect that operation would never fail. When defining the opcodes which can fail, we only define the success path, and assume the overflow behavior as stated above.\n\nAJ Towns provided a critique to this design in the 64-bit arithmetic thread\n\n[quote=\"ajtowns, post:50, topic:397\"]\nFWIW, the big concern I have with this is people writing scripts where they don\u2019t think an overflow is possible, so they just do an OP_DROP for the overflow indicator, and then someone thinks a bit harder, and figures out how to steal money via an overflow, and then they do exactly that. That\u2019s arguably easily mitigated: just use `OP_VERIFY` to guarantee there wasn\u2019t an overflow, but I noticed that an example script in [review club](https://bitcoincore.reviews/29221#l-86) used the more obvious DROP:\n\n```\n<Chris_Stewart_5> Script: 0x000e876481700000 0x000e876481700000 OP_ADD64 OP_DROP OP_LE64TOSCRIPTNUM OP_SIZE OP_8 OP_EQUALVERIFY OP_SCRIPTNUMTOLE64 0x001d0ed902e00000 OP_EQUAL\n```\n\nWorries me a bit when the obvious way of doing something (\u201cthis won\u2019t ever overflow, so just drop it\u201d) is risky.\n\nYou could imagine introducing two opcodes: \u201cOP_ADD64\u201d and \u201cOP_ADD64VERIFY\u201d the latter of which does an implicit VERIFY, and hence fails the script if there was overflow; but that would effectively be the existing behaviour of OP_ADD. So I guess what I\u2019m saying is: maybe consider an approach along the lines that sipa suggested:\n[/quote]\n\n\n### Bitcoin Cash\n\nBitcoin cash seems to have re-added disabled opcodes such as [OP_MUL](https://gitlab.com/bitcoin-cash-node/bitcoin-cash-node/-/blob/master/src/script/interpreter.cpp#L884) and [OP_DIV](https://gitlab.com/bitcoin-cash-node/bitcoin-cash-node/-/blob/master/src/script/interpreter.cpp#L895). They have decided to modify the exception handling behavior by [setting `serror` exception](https://gitlab.com/bitcoin-cash-node/bitcoin-cash-node/-/blob/master/src/script/interpreter.cpp#L887) if the result overflows. Note, this is different than how bitcoin works currently as we catch an exception thrown by `CScriptNum`.\n\n### Zcash / Litecoin\n\nBoth [Zcash](https://github.com/zcash/zcash/blob/a3435336b0c561799ac6805a27993eca3f9656df/src/script/script.h#L209) and [Litecoin](https://github.com/litecoin-project/litecoin/blob/5fba5ad7c13c59d1e0854dd51ac0c22bea68c8f8/src/script/script.h#L254) have retained the original behavior from bitcoin as far as I can tell.\n\n### Other bitcoin derivatives?\n\nIf you know of any interesting design choices made by other forks of bitcoin, please share them below!\n\n### Ethan Heilmans suggested design\n\n[quote=\"EthanHeilman, post:36, topic:397\"]\nThe BIP states: \u201cIf the operation results in an overflow, push false onto the stack\u201d.\n\nI would propose altering this to so that the result and the overflow amount are pushed onto the stack.\n\n**Case 1, no overflow:**\n\n1, 1, OP_ADD64 \u2192 2, 0\n\nwhere 2 is the result and 0 is the overflow amount.\n\n**Case 2, overflow:**\n\n2^64 - 1, 5, OP_ADD64 \u2192 4, 1\n\nwhere 4 is the result (mod 2^64), and 1 is the overflow amount. You can think of these two stack values as representing the 128 bit number 2^64+4 broken into two 64 bit chunks.\n\nPush values on the stack in this fashion makes it esimple use these 64 opcodes to do math on numbers larger than 64 bits by chunking them into 64-bit stack elements. The overflow amount tells you how much to carry into the next chunk.\n\nYou\u2019d still get the benefit of having a flag to check, if overflow amount is not 0, overflow occurred.\n\nI think the BIP as written lets you add numbers larger than 64-bits using a similar chunking approach, but it is less straight forward and requires IF statements and substructions operations.\n[/quote]\n\nwith suggestions from AJ Towns\n\n[quote=\"ajtowns, post:40, topic:397\"]\nI think there\u2019s a few choices here:\n\n* what happens with \u201coverflows\u201d ?\n  * they\u2019re not possible, everything happens modulo 2^n2n2^n\n  * if the inputs are \u201ctoo large\u201d, the script aborts\n  * you get an overflow indicator in every result\n* what is 2^n2n2^n or what constitutes \u201ctoo large\u201d ?\n  * BTC\u2019s max supply is about 2^{51}2512^{51} satoshis, so 64bit is a fine minimum\n  * 2^{256}22562^{256} would let you manipulate scalars for secp256k1 which might be useful\n  * 2^{4160}241602^{4160} would let you do numbers of to 520 bytes which matches current stack entry limits\n* unsigned only, or signed\n  * if we\u2019re doing modular arithmetic, unsigned seems easier\n  * signed maths probably makes some contracts a bunch easier though\n* what serialization format?\n  * if signed, use a sign-bit or 2\u2019s complement?\n  * fixed length or variable length \u2013 if fixed length, that constrains the precision we could use\n  * if variable length, does every integer have a unique serialization, or can you have \u201c0000\u201d and \u201c0\u201d and \u201c-0\u201d all as different representations of 0?\n\nI guess 64-bit unsigned modular arithmetic would be easiest (`uint64_t` already works), but 4160-bit signed numbers (or some similarly large value that benchmarks fast enough) with abort-on-overflow behaviour and stored/serialized like CScriptNum format might be more appropriate?\n\nAbort-on-overflow seems kind of appealing as far as writing contracts goes: we\u2019ve already had an \u201coverflow allows printing money\u201d bug in bitcoin proper, so immediately aborting if that happens in script seems like a wise protection. If people want to do modular arithmetic, they could perhaps manually calculate `((x % k) * (y % k)) % k` provided they pick k \\le \\sqrt{2^{n}}k\u2264\u221a2nk \\le \\sqrt{2^{n}} or similar.\n[/quote]\n\n\n## Future research\n\nAs mentioned above, CScriptNum currently [throws an exception if an overflow occurs](https://github.com/bitcoin/bitcoin/blob/998386d4462f5e06412303ba559791da83b913fb/src/script/script.h#L249). If this is used in conjunction with an op code that interprets the stack top as a CScriptNum, this propagates the exception in to `EvalScript()` causing the main execution loop to be wrapped in a [`try` `catch` block](https://github.com/bitcoin/bitcoin/blob/998386d4462f5e06412303ba559791da83b913fb/src/script/interpreter.cpp#L1225). Questions I have are\n\n1. What are other opcodes that can result in an exception that are caught by this `try` `catch` block?\n2. What are the performance implications of wrapping the meat and potatoes of `EvalScript()` in a `try` `catch` block?\n\nWhile we will likely never be able to fully migrate from the `try` `catch` block, perhaps future soft forks could avoid having this logic?",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 193,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}