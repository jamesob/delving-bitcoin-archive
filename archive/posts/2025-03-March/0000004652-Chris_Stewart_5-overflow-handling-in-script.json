{
  "id": 4652,
  "name": "Chris Stewart",
  "username": "Chris_Stewart_5",
  "avatar_template": "/user_avatar/delvingbitcoin.org/chris_stewart_5/{size}/296_2.png",
  "created_at": "2025-03-31T15:35:30.172Z",
  "cooked": "<h1><a name=\"p-4652-overflow-handling-in-script-1\" class=\"anchor\" href=\"#p-4652-overflow-handling-in-script-1\"></a>Overflow handling in Script</h1>\n<h2><a name=\"p-4652-motivation-2\" class=\"anchor\" href=\"#p-4652-motivation-2\"></a>Motivation</h2>\n<p>There is interest in enhancing Script\u2019s functionality. Re-enabling new opcodes one of the main feature enhancements that have been proposed. This overflow limitation has been talked about in the Rusty Russell\u2019s <a href=\"https://rusty.ozlabs.org/2023/12/30/arithmetic-opcodes.html\" rel=\"noopener nofollow ugc\">Great Script Restoration</a> project, as well as the <a href=\"https://delvingbitcoin.org/t/64-bit-arithmetic-soft-fork/397\">64-bit arithmetic delving bitcoin post</a>.</p>\n<p>Here are some highlights</p>\n<aside class=\"quote no-group\" data-username=\"sipa\" data-post=\"15\" data-topic=\"397\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/sipa/48/1100_2.png\" class=\"avatar\"><a href=\"https://delvingbitcoin.org/t/64-bit-arithmetic-soft-fork/397/15\">64 bit arithmetic soft fork</a></div>\n<blockquote>\n<p>If <code>OP_MUL</code> or a variant thereof is added, I can see why detecting/dealing with overflows becomes an issue that the existing interface doesn\u2019t deal well with.</p>\n</blockquote>\n</aside>\n<aside class=\"quote no-group\" data-username=\"sipa\" data-post=\"15\" data-topic=\"397\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/sipa/48/1100_2.png\" class=\"avatar\"><a href=\"https://delvingbitcoin.org/t/64-bit-arithmetic-soft-fork/397/15\">64 bit arithmetic soft fork</a></div>\n<blockquote>\n<p>I think you\u2019d want to add overflow-detecting versions for your use, but otherwise it already does everything.</p>\n</blockquote>\n</aside>\n<aside class=\"quote no-group\" data-username=\"dgpv\" data-post=\"20\" data-topic=\"397\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/dgpv/48/75_2.png\" class=\"avatar\"><a href=\"https://delvingbitcoin.org/t/64-bit-arithmetic-soft-fork/397/20\">64 bit arithmetic soft fork</a></div>\n<blockquote>\n<p>it definitely feels that there is value in being able to do computations using the same format as the numbers that are stored within the transaction, and with clearly defined ways to detect overflows etc.</p>\n</blockquote>\n</aside>\n<aside class=\"quote no-group\" data-username=\"dgpv\" data-post=\"21\" data-topic=\"397\" data-full=\"true\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/dgpv/48/75_2.png\" class=\"avatar\"><a href=\"https://delvingbitcoin.org/t/64-bit-arithmetic-soft-fork/397/21\">64 bit arithmetic soft fork</a></div>\n<blockquote>\n<p>On the second thought, maybe checking for overflows after each 64-bit arithmetic opcode is not that great, if we can have computations in (practically) arbitrary width integers and then only detect overflows on conversion to LE64/LE32.</p>\n<p>(but really, adding VERIFY after each 64-bit arith op does not add any mental load - it just increases script size a bit)</p>\n<p>(well, forgetting VERIFY after 64-bit arith op in Elements might lead to unexpected behavior in case of actual overflow\u2026)</p>\n</blockquote>\n</aside>\n<p>I would like to consolidate discussion on the <em>overflow handling</em> part of the Great Script restoration project here.</p>\n<p>While not an overflow exactly, you can imagine a world where <code>OP_DIV</code> is re-enabled. This error handling logic could also be used for the case where the user attempts to divide by 0.</p>\n<h2><a name=\"p-4652-background-3\" class=\"anchor\" href=\"#p-4652-background-3\"></a>Background</h2>\n<p><a href=\"https://github.com/bitcoin/bitcoin/blob/770d39a37652d40885533fecce37e9f71cc0d051/src/script/script.h#L226\" rel=\"noopener nofollow ugc\">CScriptNum</a> is the data type used in bitcoin core to handle numbers in Script. Here is what happens when a stack element is interpreted as a CScriptNum that results in an overflow</p>\n<blockquote>\n<p>operands must be in the range [-2^31 +1 to 2^31 -1]</p>\n</blockquote>\n<p>This means inputs to opcodes such as <code>OP_ADD</code>, <code>OP_SUB</code>, <code>OP_1ADD</code> etc must fall within the stated range. However</p>\n<blockquote>\n<p>results may overflow (and are valid as long as they are not used in a subsequent numeric operation). CScriptNum enforces those semantics by storing results as an int64 and allowing out-of-range values to be returned as a vector of bytes but throwing an exception if arithmetic is done or the result is interpreted as an integer.</p>\n</blockquote>\n<p>Simply put, if my Script is</p>\n<blockquote>\n<p>2^31-1 OP_1ADD</p>\n</blockquote>\n<p>the result on the stack would be <code>2^31</code>, which is a valid result. If I tried to do an <code>OP_1ADD</code> on <code>2^31</code> an <a href=\"https://github.com/bitcoin/bitcoin/blob/770d39a37652d40885533fecce37e9f71cc0d051/src/script/script.h#L249\" rel=\"noopener nofollow ugc\">this exception would occur</a></p>\n<p>which then would result in this error being propagated to the user</p>\n<blockquote>\n<p>mandatory-script-verify-flag-failed (unknown error)</p>\n</blockquote>\n<p>This is because the exception thrown in <code>CScriptNum</code>\u2019s constructor is caught in <code>EvalScript()</code>'s <code>catch</code> clause</p>\n<aside class=\"onebox githubblob\" data-onebox-src=\"https://github.com/bitcoin/bitcoin/blob/770d39a37652d40885533fecce37e9f71cc0d051/src/script/interpreter.cpp#L1227\">\n  <header class=\"source\">\n\n      <a href=\"https://github.com/bitcoin/bitcoin/blob/770d39a37652d40885533fecce37e9f71cc0d051/src/script/interpreter.cpp#L1227\" target=\"_blank\" rel=\"noopener nofollow ugc\">github.com</a>\n  </header>\n\n  <article class=\"onebox-body\">\n    <h4><a href=\"https://github.com/bitcoin/bitcoin/blob/770d39a37652d40885533fecce37e9f71cc0d051/src/script/interpreter.cpp#L1227\" target=\"_blank\" rel=\"noopener nofollow ugc\">bitcoin/bitcoin/blob/770d39a37652d40885533fecce37e9f71cc0d051/src/script/interpreter.cpp#L1227</a></h4>\n\n\n\n    <pre class=\"onebox\"><code class=\"lang-cpp\">\n      <ol class=\"start lines\" start=\"1217\" style=\"counter-reset: li-counter 1216 ;\">\n          <li>                    return set_error(serror, SCRIPT_ERR_BAD_OPCODE);</li>\n          <li>            }</li>\n          <li></li>\n          <li>            // Size limits</li>\n          <li>            if (stack.size() + altstack.size() &gt; MAX_STACK_SIZE)</li>\n          <li>                return set_error(serror, SCRIPT_ERR_STACK_SIZE);</li>\n          <li>        }</li>\n          <li>    }</li>\n          <li>    catch (...)</li>\n          <li>    {</li>\n          <li class=\"selected\">        return set_error(serror, SCRIPT_ERR_UNKNOWN_ERROR);</li>\n          <li>    }</li>\n          <li></li>\n          <li>    if (!vfExec.empty())</li>\n          <li>        return set_error(serror, SCRIPT_ERR_UNBALANCED_CONDITIONAL);</li>\n          <li></li>\n          <li>    return set_success(serror);</li>\n          <li>}</li>\n          <li></li>\n          <li>bool EvalScript(std::vector&lt;std::vector&lt;unsigned char&gt; &gt;&amp; stack, const CScript&amp; script, unsigned int flags, const BaseSignatureChecker&amp; checker, SigVersion sigversion, ScriptError* serror)</li>\n          <li>{</li>\n      </ol>\n    </code></pre>\n\n\n\n  </article>\n\n  <div class=\"onebox-metadata\">\n    \n    \n  </div>\n\n  <div style=\"clear: both\"></div>\n</aside>\n\n<h2><a name=\"p-4652-what-design-options-are-out-there-4\" class=\"anchor\" href=\"#p-4652-what-design-options-are-out-there-4\"></a>What design options are out there?</h2>\n<p>Here is the design space as I see it, please comment below if I\u2019ve missed any designs that have been deployed</p>\n<h3><a name=\"p-4652-elements-project-5\" class=\"anchor\" href=\"#p-4652-elements-project-5\"></a>Elements project</h3>\n<p><a href=\"https://github.com/ElementsProject/elements/blob/811d8359600477b38088d12f7a686291fdad211f/doc/tapscript_opcodes.md#new-opcodes-for-additional-functionality\" rel=\"noopener nofollow ugc\">In 2022</a> the Elements project introduced a new set of opcodes to handle the case of overflowing numbers in Script. This upgrade also added 64 bits of precision, 64 bit specific opcodes, and a new encoding format \u2013 all of which we will ignore for the purposes of this post.</p>\n<p>This soft fork introduces <em>overflow handling</em> when arithmetic computations are performed with the new 64 bit opcodes in elements.</p>\n<blockquote>\n<p>When dealing with overflows, we explicitly return the success bit as a <code>CScriptNum</code> at the top of the stack and the result being the second element from the top. If the operation overflows, first the operands are pushed onto the stack followed by success bit. [<code>a_second</code> <code>a_top</code>] overflows, the stack state after the operation is [<code>a_second</code> <code>a_top</code> <code>0</code>] and if the operation does not overflow, the stack state is [<code>res</code> <code>1</code>].</p>\n</blockquote>\n<blockquote>\n<p>This gives the user flexibility to deal if they script to have overflows using <code>OP_IF\\OP_ELSE</code> or <code>OP_VERIFY</code> the success bit if they expect that operation would never fail. When defining the opcodes which can fail, we only define the success path, and assume the overflow behavior as stated above.</p>\n</blockquote>\n<h3><a name=\"p-4652-bitcoin-cash-6\" class=\"anchor\" href=\"#p-4652-bitcoin-cash-6\"></a>Bitcoin Cash</h3>\n<p>Bitcoin cash seems to have re-added disabled opcodes such as <a href=\"https://gitlab.com/bitcoin-cash-node/bitcoin-cash-node/-/blob/master/src/script/interpreter.cpp#L884\" rel=\"noopener nofollow ugc\">OP_MUL</a> and <a href=\"https://gitlab.com/bitcoin-cash-node/bitcoin-cash-node/-/blob/master/src/script/interpreter.cpp#L895\" rel=\"noopener nofollow ugc\">OP_DIV</a>. They have decided to modify the exception handling behavior by <a href=\"https://gitlab.com/bitcoin-cash-node/bitcoin-cash-node/-/blob/master/src/script/interpreter.cpp#L887\" rel=\"noopener nofollow ugc\">setting <code>serror</code> exception</a> if the result overflows. Note, this is different than how bitcoin works currently as we catch an exception thrown by <code>CScriptNum</code>.</p>\n<h3><a name=\"p-4652-zcash-litecoin-7\" class=\"anchor\" href=\"#p-4652-zcash-litecoin-7\"></a>Zcash / Litecoin</h3>\n<p>Both <a href=\"https://github.com/zcash/zcash/blob/a3435336b0c561799ac6805a27993eca3f9656df/src/script/script.h#L209\" rel=\"noopener nofollow ugc\">Zcash</a> and <a href=\"https://github.com/litecoin-project/litecoin/blob/5fba5ad7c13c59d1e0854dd51ac0c22bea68c8f8/src/script/script.h#L254\" rel=\"noopener nofollow ugc\">Litecoin</a> have retained the original behavior from bitcoin as far as I can tell.</p>\n<h3><a name=\"p-4652-other-bitcoin-derivatives-8\" class=\"anchor\" href=\"#p-4652-other-bitcoin-derivatives-8\"></a>Other bitcoin derivatives?</h3>\n<p>If you know of any interesting design choices made by other forks of bitcoin, please share them below!</p>\n<h2><a name=\"p-4652-future-research-9\" class=\"anchor\" href=\"#p-4652-future-research-9\"></a>Future research</h2>\n<p>As mentioned above, CScriptNum currently <a href=\"https://github.com/bitcoin/bitcoin/blob/998386d4462f5e06412303ba559791da83b913fb/src/script/script.h#L249\" rel=\"noopener nofollow ugc\">throws an exception if an overflow occurs</a>. If this is used in conjunction with an op code that interprets the stack top as a CScriptNum, this propagates the exception in to <code>EvalScript()</code> causing the main execution loop to be wrapped in a <a href=\"https://github.com/bitcoin/bitcoin/blob/998386d4462f5e06412303ba559791da83b913fb/src/script/interpreter.cpp#L1225\" rel=\"noopener nofollow ugc\"><code>try</code> <code>catch</code> block</a>. Questions I have are</p>\n<ol>\n<li>What are other opcodes that can result in an exception that are caught by this <code>try</code> <code>catch</code> block?</li>\n<li>What are the performance implications of wrapping the meat and potatoes of <code>EvalScript()</code> in a <code>try</code> <code>catch</code> block?</li>\n</ol>\n<p>While we will likely never be able to fully migrate from the <code>try</code> <code>catch</code> block, perhaps future soft forks could avoid having this logic?</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2025-03-31T15:45:13.523Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 4,
  "readers_count": 3,
  "score": 0,
  "yours": false,
  "topic_id": 1549,
  "topic_slug": "overflow-handling-in-script",
  "topic_title": "Overflow handling in Script",
  "topic_html_title": "Overflow handling in Script",
  "category_id": 7,
  "display_username": "Chris Stewart",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 3,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "# Overflow handling in Script\n\n## Motivation\n\nThere is interest in enhancing Script's functionality. Re-enabling new opcodes one of the main feature enhancements that have been proposed. This overflow limitation has been talked about in the Rusty Russell's [Great Script Restoration](https://rusty.ozlabs.org/2023/12/30/arithmetic-opcodes.html) project, as well as the [64-bit arithmetic delving bitcoin post](https://delvingbitcoin.org/t/64-bit-arithmetic-soft-fork/397).\n\nHere are some highlights\n\n[quote=\"sipa, post:15, topic:397\"]\nIf `OP_MUL` or a variant thereof is added, I can see why detecting/dealing with overflows becomes an issue that the existing interface doesn\u2019t deal well with.\n[/quote]\n\n[quote=\"sipa, post:15, topic:397\"]\nI think you\u2019d want to add overflow-detecting versions for your use, but otherwise it already does everything.\n[/quote]\n\n[quote=\"dgpv, post:20, topic:397\"]\nit definitely feels that there is value in being able to do computations using the same format as the numbers that are stored within the transaction, and with clearly defined ways to detect overflows etc.\n[/quote]\n\n[quote=\"dgpv, post:21, topic:397, full:true\"]\nOn the second thought, maybe checking for overflows after each 64-bit arithmetic opcode is not that great, if we can have computations in (practically) arbitrary width integers and then only detect overflows on conversion to LE64/LE32.\n\n(but really, adding VERIFY after each 64-bit arith op does not add any mental load - it just increases script size a bit)\n\n(well, forgetting VERIFY after 64-bit arith op in Elements might lead to unexpected behavior in case of actual overflow\u2026)\n[/quote]\n\nI would like to consolidate discussion on the _overflow handling_ part of the Great Script restoration project here.\n\nWhile not an overflow exactly, you can imagine a world where `OP_DIV` is re-enabled. This error handling logic could also be used for the case where the user attempts to divide by 0.\n\n\n## Background\n\n[CScriptNum](https://github.com/bitcoin/bitcoin/blob/770d39a37652d40885533fecce37e9f71cc0d051/src/script/script.h#L226) is the data type used in bitcoin core to handle numbers in Script. Here is what happens when a stack element is interpreted as a CScriptNum that results in an overflow\n\n>operands must be in the range [-2^31 +1 to 2^31 -1]\n\nThis means inputs to opcodes such as `OP_ADD`, `OP_SUB`, `OP_1ADD` etc must fall within the stated range. However\n\n>results may overflow (and are valid as long as they are not used in a subsequent numeric operation). CScriptNum enforces those semantics by storing results as an int64 and allowing out-of-range values to be returned as a vector of bytes but throwing an exception if arithmetic is done or the result is interpreted as an integer.\n\nSimply put, if my Script is \n\n> 2^31-1 OP_1ADD \n\nthe result on the stack would be `2^31`, which is a valid result. If I tried to do an `OP_1ADD` on `2^31` an [this exception would occur](https://github.com/bitcoin/bitcoin/blob/770d39a37652d40885533fecce37e9f71cc0d051/src/script/script.h#L249)\n\nwhich then would result in this error being propagated to the user\n\n>mandatory-script-verify-flag-failed (unknown error)\n\nThis is because the exception thrown in `CScriptNum`'s constructor is caught in `EvalScript()`'s `catch` clause\n\nhttps://github.com/bitcoin/bitcoin/blob/770d39a37652d40885533fecce37e9f71cc0d051/src/script/interpreter.cpp#L1227\n\n## What design options are out there?\n\nHere is the design space as I see it, please comment below if I've missed any designs that have been deployed\n\n### Elements project\n[In 2022](https://github.com/ElementsProject/elements/blob/811d8359600477b38088d12f7a686291fdad211f/doc/tapscript_opcodes.md#new-opcodes-for-additional-functionality) the Elements project introduced a new set of opcodes to handle the case of overflowing numbers in Script. This upgrade also added 64 bits of precision, 64 bit specific opcodes, and a new encoding format -- all of which we will ignore for the purposes of this post. \n\nThis soft fork introduces _overflow handling_ when arithmetic computations are performed with the new 64 bit opcodes in elements.\n\n>When dealing with overflows, we explicitly return the success bit as a `CScriptNum` at the top of the stack and the result being the second element from the top. If the operation overflows, first the operands are pushed onto the stack followed by success bit. [`a_second` `a_top`] overflows, the stack state after the operation is [`a_second` `a_top` `0`] and if the operation does not overflow, the stack state is [`res` `1`].\n\n>This gives the user flexibility to deal if they script to have overflows using `OP_IF\\OP_ELSE` or `OP_VERIFY` the success bit if they expect that operation would never fail. When defining the opcodes which can fail, we only define the success path, and assume the overflow behavior as stated above.\n\n### Bitcoin Cash\n\nBitcoin cash seems to have re-added disabled opcodes such as [OP_MUL](https://gitlab.com/bitcoin-cash-node/bitcoin-cash-node/-/blob/master/src/script/interpreter.cpp#L884) and [OP_DIV](https://gitlab.com/bitcoin-cash-node/bitcoin-cash-node/-/blob/master/src/script/interpreter.cpp#L895). They have decided to modify the exception handling behavior by [setting `serror` exception](https://gitlab.com/bitcoin-cash-node/bitcoin-cash-node/-/blob/master/src/script/interpreter.cpp#L887) if the result overflows. Note, this is different than how bitcoin works currently as we catch an exception thrown by `CScriptNum`.\n\n### Zcash / Litecoin\n\nBoth [Zcash](https://github.com/zcash/zcash/blob/a3435336b0c561799ac6805a27993eca3f9656df/src/script/script.h#L209) and [Litecoin](https://github.com/litecoin-project/litecoin/blob/5fba5ad7c13c59d1e0854dd51ac0c22bea68c8f8/src/script/script.h#L254) have retained the original behavior from bitcoin as far as I can tell.\n\n### Other bitcoin derivatives?\n\nIf you know of any interesting design choices made by other forks of bitcoin, please share them below!\n\n## Future research\n\nAs mentioned above, CScriptNum currently [throws an exception if an overflow occurs](https://github.com/bitcoin/bitcoin/blob/998386d4462f5e06412303ba559791da83b913fb/src/script/script.h#L249). If this is used in conjunction with an op code that interprets the stack top as a CScriptNum, this propagates the exception in to `EvalScript()` causing the main execution loop to be wrapped in a [`try` `catch` block](https://github.com/bitcoin/bitcoin/blob/998386d4462f5e06412303ba559791da83b913fb/src/script/interpreter.cpp#L1225). Questions I have are\n\n1. What are other opcodes that can result in an exception that are caught by this `try` `catch` block?\n2. What are the performance implications of wrapping the meat and potatoes of `EvalScript()` in a `try` `catch` block?\n\nWhile we will likely never be able to fully migrate from the `try` `catch` block, perhaps future soft forks could avoid having this logic?",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 193,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}