{
  "id": 3035,
  "name": "moonsettler",
  "username": "moonsettler",
  "avatar_template": "/user_avatar/delvingbitcoin.org/moonsettler/{size}/38_2.png",
  "created_at": "2024-08-21T19:17:07.244Z",
  "cooked": "<p><em>Can we turn this into a quadratic hashing problem for the attacker, by introducing a 4 bit checksum of our own that needs to be ground out?</em></p>\n<p>Ofc it\u2019s not quadratic if it\u2019s a constant. I guess that\u2019s just hardening with c iterations. Something like 2 seconds target for a single signature should work well, because then attempting to leak more than 1 bit at a time would start to be really noticeable.</p>\n<p>Any problems with this approach?</p>\n<h4><a name=\"p-3035-added-the-following-to-qa-section-1\" class=\"anchor\" href=\"#p-3035-added-the-following-to-qa-section-1\"></a>Added the following to Q&amp;A section:</h4>\n<p>Q: Are low bandwidth attacks still possible?</p>\n<p>Yes, theoretically the SD with malicious firmware could churn the final R point to leak information using for example FEC codes (Pieter Wuille on delving) with 2<sup>n</sup> rounds of churning SD can leak the seed phrase by creating <code>bits(seed)/n</code> signatures. For example if the attacker chooses to leak 4 bits each time it takes 32 signatures to leak a 128 bit (12 word) seed phrase. Due to the public transaction graph and plainly observable wallet characteristics the attacker can make good guesses at which signatures could belong to the same seed.</p>\n<ul>\n<li>The attacker can just generate a random <code>q</code>, normally this can not be detected</li>\n<li>The verifier needs to know the private key to verify generation of <code>q</code> (same as RFC6979)</li>\n<li>The attacker can encrypt and obfuscate his own channel</li>\n<li>The attacker decides his channel bandwidth making it impossible to estimate \u201cseed health\u201d</li>\n<li>Transactions may have multiple inputs making signing them not deterministic in time</li>\n<li>Said attack is likely to be \u201calways on\u201d and would be caught by verifying generation of <code>q</code></li>\n<li>Evil maid scenario is still problematic, factory and user acceptance tests are already passed</li>\n<li>Tamper evident storage of signing devices is still heavily recommended</li>\n<li>This is not a huge concern for cold storage scenarios with very infrequent signing</li>\n<li>This protocol offers protection from immediate catastrophic leaks via chosen nonce</li>\n<li>24 words are better in this scheme than 12 words</li>\n</ul>",
  "post_number": 13,
  "post_type": 1,
  "updated_at": "2024-08-22T07:58:37.963Z",
  "reply_count": 0,
  "reply_to_post_number": 12,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 9,
  "readers_count": 8,
  "score": 1.8,
  "yours": false,
  "topic_id": 1081,
  "topic_slug": "non-interactive-anti-exfil-airgap-compatible",
  "topic_title": "Non interactive anti-exfil (airgap compatible)",
  "topic_html_title": "Non interactive anti-exfil (airgap compatible)",
  "category_id": 7,
  "display_username": "moonsettler",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 3,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "reply_to_user": {
    "username": "sipa",
    "name": "Pieter Wuille",
    "avatar_template": "/user_avatar/delvingbitcoin.org/sipa/{size}/102_2.png"
  },
  "bookmarked": false,
  "raw": "*Can we turn this into a quadratic hashing problem for the attacker, by introducing a 4 bit checksum of our own that needs to be ground out?*\n\nOfc it's not quadratic if it's a constant. I guess that's just hardening with c iterations. Something like 2 seconds target for a single signature should work well, because then attempting to leak more than 1 bit at a time would start to be really noticeable.\n\nAny problems with this approach?\n\n\n#### Added the following to Q&A section:\nQ: Are low bandwidth attacks still possible?\n\nYes, theoretically the SD with malicious firmware could churn the final R point to leak information using for example FEC codes (Pieter Wuille on delving) with 2<sup>n</sup> rounds of churning SD can leak the seed phrase by creating `bits(seed)/n` signatures. For example if the attacker chooses to leak 4 bits each time it takes 32 signatures to leak a 128 bit (12 word) seed phrase. Due to the public transaction graph and plainly observable wallet characteristics the attacker can make good guesses at which signatures could belong to the same seed.\n\n* The attacker can just generate a random `q`, normally this can not be detected\n* The verifier needs to know the private key to verify generation of `q` (same as RFC6979)\n* The attacker can encrypt and obfuscate his own channel\n* The attacker decides his channel bandwidth making it impossible to estimate \"seed health\"\n* Transactions may have multiple inputs making signing them not deterministic in time\n* Said attack is likely to be \"always on\" and would be caught by verifying generation of `q`\n* Evil maid scenario is still problematic, factory and user acceptance tests are already passed\n* Tamper evident storage of signing devices is still heavily recommended\n* This is not a huge concern for cold storage scenarios with very infrequent signing\n* This protocol offers protection from immediate catastrophic leaks via chosen nonce\n* 24 words are better in this scheme than 12 words",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 48,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}