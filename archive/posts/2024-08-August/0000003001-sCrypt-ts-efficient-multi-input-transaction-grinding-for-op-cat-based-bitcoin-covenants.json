{
  "id": 3001,
  "name": "sCrypt",
  "username": "sCrypt-ts",
  "avatar_template": "/user_avatar/delvingbitcoin.org/scrypt-ts/{size}/746_2.png",
  "created_at": "2024-08-20T09:27:09.441Z",
  "cooked": "<p>In a <a href=\"https://scryptplatform.medium.com/trustless-ordinal-sales-using-op-cat-enabled-covenants-on-bitcoin-0318052f02b2\" rel=\"noopener nofollow ugc\">previous post</a>, we have implemented Bitcoin covenants using OP_CAT, based on <a href=\"https://www.wpsoftware.net/andrew/blog/cat-and-schnorr-tricks-i.html\" rel=\"noopener nofollow ugc\">this Schnorr trick</a>. We can greatly simplify signature calculation (<strong>s</strong>) by choosing specific signing key and ephemeral key.</p>\n<blockquote>\n<p><em><strong>s = 1 + e</strong></em></p>\n</blockquote>\n<p>Bitcoin Script, more specifically <strong>OP_ADD</strong>, only works on 32-bit signed integer and thus cannot directly add 1 to <strong>e</strong> by using the following script, because <strong>e</strong> is a 256-bit integer. It is the SHA256 hash of the transaction data among other things.</p>\n<p><code>&lt;1&gt; OP_ADD</code></p>\n<p>The proposed workaround is to break <strong>e</strong> into two parts: the Least Significant Byte (e[-1])\u00b9 and the rest (e_).</p>\n<blockquote>\n<p><em><strong>e = e_ || e[-1]</strong></em></p>\n</blockquote>\n<p><strong>||</strong> denotes concatenation, i.e., OP_CAT.</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/1X/8959f89ff9adeb3956a99871e74b7f6f3c05c91b.jpeg\" data-download-href=\"https://delvingbitcoin.org/uploads/default/8959f89ff9adeb3956a99871e74b7f6f3c05c91b\" title=\"\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/1X/8959f89ff9adeb3956a99871e74b7f6f3c05c91b_2_500x500.jpeg\" alt=\"\" data-base62-sha1=\"jB4aTVqr4ngZwGbV4INlUsMaxwD\" width=\"500\" height=\"500\" role=\"presentation\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/1X/8959f89ff9adeb3956a99871e74b7f6f3c05c91b_2_500x500.jpeg, https://delvingbitcoin.org/uploads/default/original/1X/8959f89ff9adeb3956a99871e74b7f6f3c05c91b.jpeg 1.5x, https://delvingbitcoin.org/uploads/default/original/1X/8959f89ff9adeb3956a99871e74b7f6f3c05c91b.jpeg 2x\" data-dominant-color=\"6B5F4F\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\"></span><span class=\"informations\">700\u00d7700 156 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>We keep changing the transaction till its hash ends in 1. This is akin to proof of work in Bitcoin mining, but with a negligible difficulty. Typically, we can malleate the <em>nLockTime</em> or <em>nSeq</em> field of a transaction, since slightly changing them generally do not affect the validity of the transaction. Then <strong>s</strong> is simply</p>\n<blockquote>\n<p><em><strong>s = e_ || 2</strong></em></p>\n</blockquote>\n<h1><a name=\"p-3001-the-problem-1\" class=\"anchor\" href=\"#p-3001-the-problem-1\"></a>The Problem</h1>\n<p>This transaction grinding is blazingly fast, since each hashing try has <em>1/256</em> chance of success. It only takes <em>256</em> tries on average and completes in milliseconds on a personal computer. Problem arises when the transaction involves multiple inputs (<strong>N</strong>) using covenants.</p>\n<p>To see why, note <strong>e</strong> value differs from input to input when computing signatures. That is why each input in a transaction has to be individually signed. An <em>nLockTime</em> value makes <strong>e</strong> for one input end with 1 may make it end with 5 for another input. The probability of finding a common <em>nLockTime</em> value that makes <strong>e</strong>\u2019s in all inputs end with 1 is now</p>\n<blockquote>\n<p><em><strong>(1/256)^N</strong></em></p>\n</blockquote>\n<p>In many applications that require contract interaction and complex business logic, <strong>N</strong> could easily be 4 or 5. Now it could take minutes to finish the grinding. If <strong>N</strong> is even larger like 10, it is computationally infeasible.</p>\n<p>Besides inefficiency, another issue is the limiting range of mutable fields. For example, <em><strong>nLocktime</strong></em> is only 32 bit long and can only support <strong>N</strong> up to 4. This issue cannot be circumvented if ASICs are used for the hashing.</p>\n<h1><a name=\"p-3001-the-solution-2\" class=\"anchor\" href=\"#p-3001-the-solution-2\"></a>The Solution</h1>\n<p>To address this, we leverage Script\u2019s ability to perform arithmetic on signed 32-bit integers. Instead of limiting <strong>e[-1]</strong> to a specific value like 1, we allow it to be in a much wider range.</p>\n<p>If the range is extended to non-negative integers, <strong>e[-1]</strong> can be any integer other than 127, which causes overflows. Now we can use <code>OP_ADD</code> to calculate <strong>(e[-1]</strong> + 1)</p>\n<p><code>&lt;1&gt; OP_ADD</code></p>\n<p><strong>s</strong> becomes</p>\n<blockquote>\n<p><em><strong>s = e_ || (e[-1] + 1)</strong></em></p>\n</blockquote>\n<p>The following sCrypt code demonstrates this process.</p>\n<pre data-code-wrap=\"ts\"><code class=\"lang-ts\">@method()\nstatic checkSHPreimage(shPreimage: SHPreimage): Sig {\n    // Check e[-1] is in range.\n    assert(shPreimage.eSuffix &lt; 127n, 'e suffix not in range [0, 127)')\n\n    const e = sha256(SigHashUtils.ePreimagePrefix + shPreimage.sigHash)\n    assert(e == shPreimage._e + int2ByteString(shPreimage.eSuffix), 'invalid value of _e')\n\n    const s = SigHashUtils.Gx + shPreimage._e + int2ByteString(shPreimage.eSuffix + 1n)\n    \n    ...\n}\n\n</code></pre>\n<p>With this change, the probability of finding a valid <em>nLockTime increases</em> to</p>\n<blockquote>\n<p><em><strong>(127/256)^N ~= (1/2)^N</strong></em></p>\n</blockquote>\n<p>Even for <strong>N</strong> of 10, the grinding only takes less than a second.</p>\n<h2><a name=\"p-3001-alternative-3\" class=\"anchor\" href=\"#p-3001-alternative-3\"></a>Alternative</h2>\n<p>We can accelerate the grinding by further expanding <strong>e[-1]</strong>\u2019s range to [-126, 126]. That is, we only exclude -127 and 127 to avoid underflows and overflows. Note integer is encoded using <a href=\"https://en.wikipedia.org/wiki/Signed_number_representations\" rel=\"noopener nofollow ugc\">signed magnitude</a> in Script. When we increment a negative integer by one, we actually have to do the following.</p>\n<p><code>&lt;-1&gt; OP_ADD</code></p>\n<p>To see why, let us look at <strong>e[-1]</strong> of <em>0x83</em>, which is treated as <em>-3</em> in Script. If we want to it to be 0x84 (interpreted as <em>-4</em>) after increment, we subtract 1 from it.</p>\n<pre data-code-wrap=\"ts\"><code class=\"lang-ts\">@method()\nstatic checkSHPreimage(shPreimage: SHPreimage): Sig {\n    // Check e[-1] is in range.\n    assert(\n          shPreimage.eSuffix &gt; -127n &amp;&amp; shPreimage.eSuffix &lt; 127n, \n          'e suffix not in range [-126, 127)'\n    )\n\n    const e = sha256(SigHashUtils.ePreimagePrefix + shPreimage.sigHash)\n    assert(e == shPreimage._e + int2ByteString(shPreimage.eSuffix), 'invalid value of _e')\n\n    // If e[-1] is negative, we have to substract. (e.g. 0x83 - 0x01 = 0x84)\n    const sDelta: bigint = shPreimage.eSuffix &lt; 0n ? -1n : 1n;\n    const s = SigHashUtils.Gx + shPreimage._e + int2ByteString(shPreimage.eSuffix + sDelta)\n\n    ...\n}\n</code></pre>\n<p>Now the success probability increases to</p>\n<blockquote>\n<p><em><strong>(254/256)^N</strong></em></p>\n</blockquote>\n<p>Full change can be found in <a href=\"https://github.com/sCrypt-Inc/cat-contracts/commit/3f48ae33da08046a3c2121083031ef523dd7aef9\" rel=\"noopener nofollow ugc\">this Github commit</a>.</p>\n<p>[1] We use python notation here: <code>my_array[-1]</code> returns the last element of the array <code>my_array</code>.</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2024-08-20T09:32:12.134Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 13,
  "readers_count": 12,
  "score": 2.2,
  "yours": false,
  "topic_id": 1080,
  "topic_slug": "efficient-multi-input-transaction-grinding-for-op-cat-based-bitcoin-covenants",
  "topic_title": "Efficient Multi-Input Transaction Grinding for OP_CAT-based Bitcoin Covenants",
  "topic_html_title": "Efficient Multi-Input Transaction Grinding for OP_CAT-based Bitcoin Covenants",
  "category_id": 8,
  "display_username": "sCrypt",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": "",
  "bookmarked": false,
  "raw": "In a [previous post](https://scryptplatform.medium.com/trustless-ordinal-sales-using-op-cat-enabled-covenants-on-bitcoin-0318052f02b2), we have implemented Bitcoin covenants using OP_CAT, based on [this Schnorr trick](https://www.wpsoftware.net/andrew/blog/cat-and-schnorr-tricks-i.html). We can greatly simplify signature calculation (**s**) by choosing specific signing key and ephemeral key.\n\n> ***s = 1 + e***\n\nBitcoin Script, more specifically **OP_ADD**, only works on 32-bit signed integer and thus cannot directly add 1 to **e** by using the following script, because **e** is a 256-bit integer. It is the SHA256 hash of the transaction data among other things.\n\n`<1> OP_ADD`\n\nThe proposed workaround is to break **e** into two parts: the Least Significant Byte (e[-1])\u00b9 and the rest (e_).\n\n> ***e = e_ || e[-1]***\n\n**||** denotes concatenation, i.e., OP_CAT.\n\n![|700x700](upload://jB4aTVqr4ngZwGbV4INlUsMaxwD.jpeg)\n\nWe keep changing the transaction till its hash ends in 1. This is akin to proof of work in Bitcoin mining, but with a negligible difficulty. Typically, we can malleate the *nLockTime* or *nSeq* field of a transaction, since slightly changing them generally do not affect the validity of the transaction. Then **s** is simply\n\n> ***s = e_ || 2***\n\n# The Problem\n\nThis transaction grinding is blazingly fast, since each hashing try has *1/256* chance of success. It only takes *256* tries on average and completes in milliseconds on a personal computer. Problem arises when the transaction involves multiple inputs (**N**) using covenants.\n\nTo see why, note **e** value differs from input to input when computing signatures. That is why each input in a transaction has to be individually signed. An *nLockTime* value makes **e** for one input end with 1 may make it end with 5 for another input. The probability of finding a common *nLockTime* value that makes **e**\u2019s in all inputs end with 1 is now\n\n> ***(1/256)^N***\n\nIn many applications that require contract interaction and complex business logic, **N** could easily be 4 or 5. Now it could take minutes to finish the grinding. If **N** is even larger like 10, it is computationally infeasible.\n\nBesides inefficiency, another issue is the limiting range of mutable fields. For example, ***nLocktime*** is only 32 bit long and can only support **N** up to 4. This issue cannot be circumvented if ASICs are used for the hashing.\n\n# The Solution\n\nTo address this, we leverage Script\u2019s ability to perform arithmetic on signed 32-bit integers. Instead of limiting **e[-1]** to a specific value like 1, we allow it to be in a much wider range.\n\nIf the range is extended to non-negative integers, **e[-1]** can be any integer other than 127, which causes overflows. Now we can use `OP_ADD` to calculate **(e[-1]** + 1)\n\n`<1> OP_ADD`\n\n**s** becomes\n\n> ***s = e_ || (e[-1] + 1)***\n\nThe following sCrypt code demonstrates this process.\n\n```ts\n@method()\nstatic checkSHPreimage(shPreimage: SHPreimage): Sig {\n    // Check e[-1] is in range.\n    assert(shPreimage.eSuffix < 127n, 'e suffix not in range [0, 127)')\n\n    const e = sha256(SigHashUtils.ePreimagePrefix + shPreimage.sigHash)\n    assert(e == shPreimage._e + int2ByteString(shPreimage.eSuffix), 'invalid value of _e')\n\n    const s = SigHashUtils.Gx + shPreimage._e + int2ByteString(shPreimage.eSuffix + 1n)\n    \n    ...\n}\n\n```\n\nWith this change, the probability of finding a valid *nLockTime increases* to\n\n> ***(127/256)^N ~= (1/2)^N***\n\nEven for **N** of 10, the grinding only takes less than a second.\n\n## Alternative\n\nWe can accelerate the grinding by further expanding **e[-1]**\u2019s range to [-126, 126]. That is, we only exclude -127 and 127 to avoid underflows and overflows. Note integer is encoded using [signed magnitude](https://en.wikipedia.org/wiki/Signed_number_representations) in Script. When we increment a negative integer by one, we actually have to do the following.\n\n`<-1> OP_ADD`\n\nTo see why, let us look at **e[-1]** of *0x83*, which is treated as *-3* in Script. If we want to it to be 0x84 (interpreted as *-4*) after increment, we subtract 1 from it.\n\n```ts\n@method()\nstatic checkSHPreimage(shPreimage: SHPreimage): Sig {\n    // Check e[-1] is in range.\n    assert(\n          shPreimage.eSuffix > -127n && shPreimage.eSuffix < 127n, \n          'e suffix not in range [-126, 127)'\n    )\n\n    const e = sha256(SigHashUtils.ePreimagePrefix + shPreimage.sigHash)\n    assert(e == shPreimage._e + int2ByteString(shPreimage.eSuffix), 'invalid value of _e')\n\n    // If e[-1] is negative, we have to substract. (e.g. 0x83 - 0x01 = 0x84)\n    const sDelta: bigint = shPreimage.eSuffix < 0n ? -1n : 1n;\n    const s = SigHashUtils.Gx + shPreimage._e + int2ByteString(shPreimage.eSuffix + sDelta)\n\n    ...\n}\n```\n\nNow the success probability increases to\n\n> ***(254/256)^N***\n\nFull change can be found in [this Github commit](https://github.com/sCrypt-Inc/cat-contracts/commit/3f48ae33da08046a3c2121083031ef523dd7aef9).\n\n[1] We use python notation here: `my_array[-1]` returns the last element of the array `my_array`.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 477,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": "downloaded local copies of images",
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}