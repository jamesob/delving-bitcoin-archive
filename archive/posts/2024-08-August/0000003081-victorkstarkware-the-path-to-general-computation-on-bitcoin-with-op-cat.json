{
  "id": 3081,
  "name": "Victor Kolobov",
  "username": "victorkstarkware",
  "avatar_template": "/user_avatar/delvingbitcoin.org/victorkstarkware/{size}/772_2.png",
  "created_at": "2024-08-29T11:00:08.070Z",
  "cooked": "<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/1X/266cd200baba5f0c8f16e291164988caf2966d4e.jpeg\" data-download-href=\"https://delvingbitcoin.org/uploads/default/266cd200baba5f0c8f16e291164988caf2966d4e\" title=\"The path to general computation on Bitcoin\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/1X/266cd200baba5f0c8f16e291164988caf2966d4e_2_690x388.jpeg\" alt=\"The path to general computation on Bitcoin\" data-base62-sha1=\"5tVi05nWVNaSzs4HwtstLetGmZM\" width=\"690\" height=\"388\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/1X/266cd200baba5f0c8f16e291164988caf2966d4e_2_690x388.jpeg, https://delvingbitcoin.org/uploads/default/optimized/1X/266cd200baba5f0c8f16e291164988caf2966d4e_2_1035x582.jpeg 1.5x, https://delvingbitcoin.org/uploads/default/optimized/1X/266cd200baba5f0c8f16e291164988caf2966d4e_2_1380x776.jpeg 2x\" data-dominant-color=\"3F3C96\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">The path to general computation on Bitcoin</span><span class=\"informations\">1456\u00d7819 266 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<h2><a name=\"p-3081-h-1-introduction-1\" class=\"anchor\" href=\"#p-3081-h-1-introduction-1\"></a>1. Introduction</h2>\n<p>In this post, we will discuss the task of achieving general computation on Bitcoin and the various steps it entails. Indeed, the ability to compute arbitrary logic in Bitcoin script is a very compelling goal, as it opens Bitcoin to the realms of non-custodial applications and decentralized finance.</p>\n<p>Previously, general computation on Bitcoin was deemed all but impossible due to two severe limitations: Bitcoin script length and opcode expressibility. The former prohibits transactions with anything but short scripts, and the latter limits what the script opcodes can compute. Jointly, these paint a dire picture of Bitcoin\u2019s computation viability, as many applications are not possible to implement within these constraints.</p>\n<p>Nevertheless, in recent years, this state of affairs has significantly improved. Indeed, the script length limitation was lifted with the 2021 Taproot upgrade, allowing for significantly longer Bitcoin scripts (in fact, Taproot scripts even allow to sometimes only pay onchain for <strong>a</strong> <strong>part of the script</strong>, but we\u2019ll not explore this property in this post). Moreover, to deal with the opcode expressibility limitation, a single simple opcode was identified to be sufficient for effectively unlimited expressibility.</p>\n<p>The aforementioned opcode is known as <strong>OP_CAT</strong>, and it has been disabled in Bitcoin script since 2010. It\u2019s a very simple opcode that allows <strong>concatenating elements on the stack</strong> and requires just <strong>13 lines of code</strong> to be activated on Bitcoin non-intrusively <a href=\"https://github.com/bitcoin/bips/blob/97012a82064c7247df502a170c03b053825cdd15/bip-0347.mediawiki\" rel=\"noopener nofollow ugc\">via a soft fork</a>. Deriving so much power from this seemingly unassuming opcode is highly nontrivial, and hence, a central goal for this blog is to elaborate on this point.</p>\n<p>In what follows, we will dive deeper into computation on Bitcoin, starting from how it\u2019s done, and what are the limitations.</p>\n<p>Following that, we\u2019ll overview two tools\u2014<strong>covenants</strong> and <strong>STARK proofs</strong>\u2014and show that if made possible in Bitcoin script, they will enable general computation. Furthermore, we will argue in this blog post that, thanks to STARK Proofs, this computation can be bestowed with additional useful properties:</p>\n<ul>\n<li><strong>Scalability</strong> \u2013 Onchain transaction processing and computation becomes feasible, with very low fees.</li>\n<li><strong>Expressibility</strong> \u2013 The logic can be programmed in a different, more powerful, programming language than Bitcoin script. This is vital for making programming on Bitcoin ergonomic and safe.</li>\n<li><strong>Onchain safety</strong> \u2013 No matter what the computation is, Bitcoin script is only ever verifying a mathematical proof of delegated computation.</li>\n<li><strong>Flexibility</strong> \u2013 Computation on Bitcoin can store global state, enabling a plethora of applications.</li>\n</ul>\n<p>Finally, we\u2019ll discuss OP_CAT and how it enables the tools mentioned above. We\u2019ll also reference some of our efforts in this direction and discuss what\u2019s to come.</p>\n<p><em><strong>Warning: This post simplifies some technicalities to provide a clear mental model. When it comes to actually implementing the presented ideas, \u201cthe devil is in the details.\u201d</strong></em></p>\n<h2><a name=\"p-3081-h-2-utxo-model-and-locking-scripts-2\" class=\"anchor\" href=\"#p-3081-h-2-utxo-model-and-locking-scripts-2\"></a>2. UTXO model and locking scripts</h2>\n<p>In this section, we briefly outline Bitcoin\u2019s UTXO model, where each UTXO is locked behind a locking script. If you are familiar with this, you can skip to the next section.</p>\n<p>The first step to understanding transactions on Bitcoin is to note they are arranged and processed according to the <strong>unspent transaction output</strong> (UTXO) model, as in Figure 1. Bitcoin transactions can have multiple inputs and outputs, where each output represents an amount of bitcoins that can be spent by another transaction. Accordingly, a transaction\u2019s input represents the spending of another Bitcoin transaction\u2019s output. Naturally, we require that the cumulative amount of bitcoins in the inputs be roughly equal to the amount in the outputs (with the difference being the fee paid to the miners).</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/1X/103c3ec64d46477cb94cf56af6edc24e0628e634.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/103c3ec64d46477cb94cf56af6edc24e0628e634\" title=\"Bitcoin transactions in the UTXO model\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/1X/103c3ec64d46477cb94cf56af6edc24e0628e634_2_690x388.png\" alt=\"Bitcoin transactions in the UTXO model\" data-base62-sha1=\"2jCIhM2ReIBTqKLX61VroY976rW\" width=\"690\" height=\"388\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/1X/103c3ec64d46477cb94cf56af6edc24e0628e634_2_690x388.png, https://delvingbitcoin.org/uploads/default/optimized/1X/103c3ec64d46477cb94cf56af6edc24e0628e634_2_1035x582.png 1.5x, https://delvingbitcoin.org/uploads/default/optimized/1X/103c3ec64d46477cb94cf56af6edc24e0628e634_2_1380x776.png 2x\" data-dominant-color=\"F8FAFE\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">Bitcoin transactions in the UTXO model</span><span class=\"informations\">1456\u00d7819 35.1 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p><em><strong>Figure 1</strong>: Transactions in the UTXO model. Each input and output of a transaction has an amount of Bitcoins associated with it, where the cumulative amount in the outputs can\u2019t exceed that of the inputs. Unspent transaction outputs (UTXOs) are colored in blue.</em></p>\n<p>Each transaction output is locked behind a <strong>locking script</strong> (scriptPubKey), which will either accept or reject an input (scriptSig) it is given (by the so-called <strong>spender</strong>). Thus if you want to transfer the funds from an <strong>unspent transaction output</strong> (UTXO), you need to be able to generate the correct scriptSig and include this UTXO as an input in your generated transaction.</p>\n<p>By default, the locking script will simply verify digital signatures against a hardcoded public key, which defines the <strong>ownership</strong> of the locked bitcoins. More generally, whenever there is a UTXO, we say that the person who is able to produce the correct scriptSig is the <strong>owner</strong> of the bitcoins locked behind the corresponding locking script. Hence, the <strong>total balance of each Bitcoin owner</strong> is <strong>dictated cumulatively</strong> by all <strong>UTXOs</strong> associated with this owner (for example, all UTXOs requiring a digital signature from the same person).</p>\n<h2><a name=\"p-3081-h-3-limitations-of-bitcoin-script-3\" class=\"anchor\" href=\"#p-3081-h-3-limitations-of-bitcoin-script-3\"></a>3. Limitations of Bitcoin script</h2>\n<p>The above section outlines locking scripts in general, and how they interact with Bitcoin transactions and Bitcoins. In this section, we focus on the locking scripts themselves and what they consist of.</p>\n<p>Locking scripts on Bitcoin are written in a <a href=\"https://en.wikipedia.org/wiki/Forth_(programming_language)\" rel=\"noopener nofollow ugc\">Forth</a>-like Stack-based language known as \u201cBitcoin script.\u201d Since Bitcoin script does not have loops, we measure the cost of a script by how many opcodes it requires, as the length of a script is proportional to its running time. In Figure 2, you can see an illustration of a simple program that checks whether the sum of two inputs is 12.</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/1X/d1fe02fd40df87442fc1eb6adc39931408aef0fe.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/d1fe02fd40df87442fc1eb6adc39931408aef0fe\" title=\"A simple program that checks whether the sum of two inputs is 12 (Bitcoin script)\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/1X/d1fe02fd40df87442fc1eb6adc39931408aef0fe_2_690x388.png\" alt=\"A simple program that checks whether the sum of two inputs is 12 (Bitcoin script)\" data-base62-sha1=\"tXG0xWOmShwMLg4rI1WNDlRyFqK\" width=\"690\" height=\"388\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/1X/d1fe02fd40df87442fc1eb6adc39931408aef0fe_2_690x388.png, https://delvingbitcoin.org/uploads/default/optimized/1X/d1fe02fd40df87442fc1eb6adc39931408aef0fe_2_1035x582.png 1.5x, https://delvingbitcoin.org/uploads/default/optimized/1X/d1fe02fd40df87442fc1eb6adc39931408aef0fe_2_1380x776.png 2x\" data-dominant-color=\"FAFBFD\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">A simple program that checks whether the sum of two inputs is 12 (Bitcoin script)</span><span class=\"informations\">1456\u00d7819 29.9 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p><em><strong>Figure 2:</strong> A simple program that checks whether the sum of two inputs is 12. The execution is performed by concatenating the scriptSig with the locking script itself, after which the opcodes are processed from left to right. The scriptSig only pushes elements onto the stack. <strong>(a)</strong> The first step of computation. <strong>(b)</strong> In the middle of computation. <strong>(c)</strong> Final step of computation (the locking script accepts the input).</em></p>\n<p>We pointed out that Bitcoin Script <strong>has many limitations</strong>, which makes developing even simple logic for it extremely nontrivial, if not downright impossible. Some of these include:</p>\n<ul>\n<li>Stack size is limited to at most 1000 elements.</li>\n<li>No opcodes for multiplications (indeed, even a 31-bit integer multiplication needs to be emulated by <a href=\"https://github.com/Bitcoin-Wildlife-Sanctuary/rust-bitcoin-m31\" rel=\"noopener nofollow ugc\">~1.4k opcodes</a>).</li>\n<li>The total number of opcodes that can fit inside a single transaction is at most ~4 million for <a href=\"https://en.bitcoin.it/wiki/BIP_0341\" rel=\"noopener nofollow ugc\"><strong>Pay2Taproot</strong></a> output types (following the Taproot upgrade), filling an entire block, and just 10k opcodes for other output types.</li>\n<li>Arithmetic operations (addition, subtraction) are limited to 4-byte elements.</li>\n</ul>\n<p>The 4-byte limitation mentioned in the last point is especially problematic. Indeed, it implies you <strong>can\u2019t modify</strong> long elements, for example, elements of the order of 20 bytes or more, which is required for <strong>cryptographic operations</strong>.</p>\n<p>For instance, the very common operation of <strong>concatenating</strong> data together and applying a cryptographic operation is impossible, unless you <strong>ignore the cryptographic opcodes, and emulate them as operations on data represented by 4-byte element arrays.</strong> The latter is prohibitively expensive, as a single hash operation could require hundreds of thousands of opcodes to emulate.</p>\n<p>As a final remark, we point out that due to the difficulty of developing in Bitcoin script, the code would naturally be more prone to bugs and vulnerabilities.</p>\n<h2><a name=\"p-3081-h-4-the-challenge-of-keeping-state-in-bitcoin-script-4\" class=\"anchor\" href=\"#p-3081-h-4-the-challenge-of-keeping-state-in-bitcoin-script-4\"></a>4. The challenge of keeping state in Bitcoin script</h2>\n<p>While the previous section demonstrated that Bitcoin scripting leaves much to be desired, we argue that the biggest limitation of Bitcoin locking scripts is the fact <strong>they are only able to read the input they are given by the spender.</strong> Unassuming at first, this implies two severe limitations:</p>\n<ul>\n<li>Bitcoin scripts <strong>are not stateful</strong>. Namely, they cannot read/write storage cell data. In analogy to Ethereum VM, there are no <strong>SLOAD</strong>/<strong>SSTORE</strong> opcode analogs, which is an essential feature for general computation.</li>\n<li>Bitcoin scripts <strong>can\u2019t enforce how bitcoins are spent</strong> (with a few exceptions). This is solved via <strong>covenants</strong>, which give the locking script this ability. (You can imagine a simple application for this: <strong>onchain vaults</strong>, which work by restricting the address to which spending is allowed. More generally, covenants are an extremely powerful tool with a wide range of applications.)</li>\n</ul>\n<p>Subsequently, we will see that constructing covenants already gives you statefulness. Intuitively, this is the case because you can use a covenant to emulate storage reads/writes in the transaction data itself.</p>\n<p>Indeed, all of the above does not scratch the surface of the breadth of what there is to know about Bitcoin scripting and its intricacies. But suffice it to say that writing scripts for Bitcoin is not easy, to say the least. To conclude, Bitcoin scripting emerges as having very strict constraints:</p>\n<ul>\n<li>You mustn\u2019t exceed the stack size limit of 1000 elements.</li>\n<li>You must emulate simple operations such as multiplications with many opcodes. In general, you must write your logic in the cumbersome Bitcoin scripting language.</li>\n<li>You must operate on elements encoded in 4-byte form. In particular, you cannot operate on and change the inputs to cryptographic opcodes.</li>\n<li>Your logic cannot hold state and must fit in a single transaction.</li>\n<li>Your logic cannot have control over how bitcoins are being spent once authentication occurs.</li>\n</ul>\n<p>In addition, writing code subject to the above constraints is prone to bugs and vulnerabilities.</p>\n<p>While very simple applications such as payments can meet the above constraints, anything slightly more complicated will encounter a roadblock. In the following, we will see how <strong>covenants</strong> and <strong>STARK proofs</strong> enable us to break free from these limitations. Furthermore, we will discuss how OP_CAT facilitates the possibility of the above in Bitcoin script.</p>\n<h2><a name=\"p-3081-h-5-smart-contracts-on-bitcoin-via-covenants-5\" class=\"anchor\" href=\"#p-3081-h-5-smart-contracts-on-bitcoin-via-covenants-5\"></a>5. Smart Contracts on Bitcoin via Covenants</h2>\n<p>In this section, we will see how covenants in Bitcoin allow logic to keep state, and, more generally, what a \u201c<strong>smart contract</strong>\u201d looks like on Bitcoin. A smart contract here means some sort of stateful logic, with a collection of functions that can be invoked to transition the state to a different, valid one, according to predefined rules.</p>\n<p>More concretely, Bitcoin contracts need the following functionalities:</p>\n<ul>\n<li>Persistent logic and state</li>\n<li>Ability to control how logic/state is changed</li>\n</ul>\n<p>As previously mentioned, the above can be achieved through <strong>covenants</strong>. Recall that by default, a locking script can only read data that is directly fed to it (scriptSig). However, through a covenant, a locking script can read <strong>all the data fields of the spender transaction</strong>, as well as <strong>the data fields of the transaction where the locking script is located,</strong> and even data from other transactions. Figure 3 illustrates the different parts a locking script can access using a covenant.</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/1X/ca9433de8df7c0298a7a225121104f6e496d4d24.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/ca9433de8df7c0298a7a225121104f6e496d4d24\" title=\"Some of the data fields a locking script can access (Bitcoin script).\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/1X/ca9433de8df7c0298a7a225121104f6e496d4d24_2_690x388.png\" alt=\"Some of the data fields a locking script can access (Bitcoin script).\" data-base62-sha1=\"sU5Yf5KbnsQnSDgwSCEoHN0czKQ\" width=\"690\" height=\"388\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/1X/ca9433de8df7c0298a7a225121104f6e496d4d24_2_690x388.png, https://delvingbitcoin.org/uploads/default/optimized/1X/ca9433de8df7c0298a7a225121104f6e496d4d24_2_1035x582.png 1.5x, https://delvingbitcoin.org/uploads/default/optimized/1X/ca9433de8df7c0298a7a225121104f6e496d4d24_2_1380x776.png 2x\" data-dominant-color=\"FCFDFE\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">Some of the data fields a locking script can access (Bitcoin script).</span><span class=\"informations\">1456\u00d7819 27.4 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p><em><strong>Figure 3:</strong> Some of the data fields a locking script (visualized as a lock) can access (shown by the red arrows). Beyond accessing the data fields of the spender transaction, the locking script can also access the data fields of the transaction where the locking script is (tx1), as well as the data fields of another transaction that is also spent by the spender transaction (tx2).</em></p>\n<p>We claim the covenant described above is sufficient to build general smart contracts on Bitcoin. Indeed, the general approach would be to encode the state in the transaction data itself and check the validity of its transitions to new values. To this end, our transaction will have two outputs:</p>\n<ul>\n<li>The first output holds the logic of the contract (via a locking script), as well as the funds locked in the contract.</li>\n<li>The second output holds the <strong>current state</strong> of the smart contract. This UTXO\u2019s locking script only holds state and will never be spent (it locks practically 0 bitcoins).</li>\n</ul>\n<p>The locking script logic will enforce the following rules:</p>\n<ul>\n<li>The spender transaction <strong>must have the same exact form</strong> (two outputs only, and all funds locked in the first output),</li>\n<li>The first output <strong>must have the same locking script logic</strong></li>\n<li>The second output <strong>must be a valid state</strong></li>\n<li>The input provided to the current locking script <strong>must convince it the transition from the current state to the new state is valid</strong> (the validity is defined by the logic designer)</li>\n</ul>\n<p>You can see an illustration of this construction in Figure 4. As written <a href=\"https://github.com/Bitcoin-Wildlife-Sanctuary/covenants-examples\" rel=\"noopener nofollow ugc\">here</a> by Weikeng Chen, a number of people have been suggesting a formal name for this construction, and \u201c<strong>state</strong> <strong>caboose</strong>\u201d stands out as a candidate. Caboose refers to a railroad car coupled at the <strong>end</strong> of a freight train as a shelter and working space for the crew.</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/1X/4c027ef47076ce547a0541e18adae1a8fa8eef40.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/4c027ef47076ce547a0541e18adae1a8fa8eef40\" title=\"Bitcoin post figure 4\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/1X/4c027ef47076ce547a0541e18adae1a8fa8eef40_2_690x388.png\" alt=\"Bitcoin post figure 4\" data-base62-sha1=\"aQpDnPF8zZbSrgyZ8gSdWxPbWrm\" width=\"690\" height=\"388\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/1X/4c027ef47076ce547a0541e18adae1a8fa8eef40_2_690x388.png, https://delvingbitcoin.org/uploads/default/optimized/1X/4c027ef47076ce547a0541e18adae1a8fa8eef40_2_1035x582.png 1.5x, https://delvingbitcoin.org/uploads/default/optimized/1X/4c027ef47076ce547a0541e18adae1a8fa8eef40_2_1380x776.png 2x\" data-dominant-color=\"FCFDFE\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">Bitcoin post figure 4</span><span class=\"informations\">1456\u00d7819 18.6 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p><em><strong>Figure 4:</strong> Smart contracts on Bitcoin via covenants that follow the \u201cstate caboose\u201d design pattern. The locking script enforces that the spender transaction has the same form and locking script, and that it has a valid state S\u2019, whose transition from the previous state S was also valid.</em></p>\n<p>As an illustrative example, you can think of a simple counting smart contract. This contract\u2019s state is always incremented by the value provided by the spender, which effectively invokes an \u201caccumulate\u201d function. This counting smart contract is shown in Figure 5.</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/1X/e7d2e5dfad692fa3f0a348d18bc408ec2955b0f5.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/e7d2e5dfad692fa3f0a348d18bc408ec2955b0f5\" title=\"A simple smart contract that accumulates inputs (scriptSig) into its state by adding them together.\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/1X/e7d2e5dfad692fa3f0a348d18bc408ec2955b0f5_2_690x388.png\" alt=\"A simple smart contract that accumulates inputs (scriptSig) into its state by adding them together.\" data-base62-sha1=\"x4O8PwmFo0Q24vMo7sBDWmMQLzv\" width=\"690\" height=\"388\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/1X/e7d2e5dfad692fa3f0a348d18bc408ec2955b0f5_2_690x388.png, https://delvingbitcoin.org/uploads/default/optimized/1X/e7d2e5dfad692fa3f0a348d18bc408ec2955b0f5_2_1035x582.png 1.5x, https://delvingbitcoin.org/uploads/default/optimized/1X/e7d2e5dfad692fa3f0a348d18bc408ec2955b0f5_2_1380x776.png 2x\" data-dominant-color=\"FCFDFF\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">A simple smart contract that accumulates inputs (scriptSig) into its state by adding them together.</span><span class=\"informations\">1456\u00d7819 18.4 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p><em><strong>Figure 5:</strong> A simple smart contract that accumulates inputs (scriptSig) into its state by adding them together.</em></p>\n<p>As a final remark, we note that to \u201ccall the contract\u201d and transition the contract to a new valid state, a user needs to create a new spender transaction for each call. In this way, <strong>unlike Ethereum smart contracts, Bitcoin smart contracts are inherently sequential,</strong> requiring the transaction to commit to both the current and new state. <strong>This sequential property must be taken into account when building smart contracts on Bitcoin.</strong> There are some possible mitigations to this, but we won\u2019t discuss them in this post.</p>\n<p>To conclude, we\u2019ve seen that covenants enable smart contracts on Bitcoin, which, in theory, allows for <strong>arbitrarily long computation</strong> to be carried on top of Bitcoin when split across sufficiently many transactions. Nevertheless, using covenants alone still suffers from most of the limitations of Bitcoin script, namely, stack size limitations, a limited number of opcodes, and, in general, programming according to the Bitcoin script language constraints.</p>\n<p>In the following, we will see how <strong>STARK proof systems</strong> can alleviate the above limitations by reducing the blockchain footprint of computation on Bitcoin and enabling scripting in an entirely different language, which dramatically improves programming efficiency and safety.</p>\n<h2><a name=\"p-3081-h-6-a-bitcoin-stark-verifier-6\" class=\"anchor\" href=\"#p-3081-h-6-a-bitcoin-stark-verifier-6\"></a>6. A Bitcoin STARK verifier</h2>\n<p>The goal of this section is to discuss how computation can be done on Bitcoin, while keeping the actual computing done via Bitcoin script to a minimum. Our general approach to this will be through <strong>computation delegation</strong>, where the computing will happen offchain (multiple entities can potentially contribute), with only verification happening onchain, in Bitcoin script.</p>\n<p>This begs the question, how can we trust that offchain computation was carried out correctly? Indeed, a very natural candidate to solve this problem is <strong>a proof system</strong>. Put simply, a proof system allows Alice (a <strong>prover</strong>) to convince Bob (a <strong>verifier</strong>) of the correctness of some statement by providing a \u201cproof,\u201d and, crucially:</p>\n<ul>\n<li>The verifier needs to do <strong>less work</strong> to verify this statement, as opposed to how much he had to work without the prover\u2019s help.</li>\n<li>Furthermore, the verifier is <strong>protected</strong>, in that the prover can\u2019t cheat the verifier and convince them of a false statement.</li>\n</ul>\n<p>The proven statement can be virtually any statement, from the solution to a difficult puzzle, to the more relevant example of computation delegation. More concretely, Alice will prove to Bob that \u201cf(x)=y\u201d, instead of Bob having to do the computation of \u201cf(x)\u201d himself, as shown in Figure 6.</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/1X/c608d1446e4bec9af4205f2cc0be0f402828aa7c.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/c608d1446e4bec9af4205f2cc0be0f402828aa7c\" title=\"A proof system for computation delegation.\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/1X/c608d1446e4bec9af4205f2cc0be0f402828aa7c_2_690x388.png\" alt=\"A proof system for computation delegation.\" data-base62-sha1=\"sfTqGE7IsQKwNHa1srozIqbZ1ms\" width=\"690\" height=\"388\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/1X/c608d1446e4bec9af4205f2cc0be0f402828aa7c_2_690x388.png, https://delvingbitcoin.org/uploads/default/optimized/1X/c608d1446e4bec9af4205f2cc0be0f402828aa7c_2_1035x582.png 1.5x, https://delvingbitcoin.org/uploads/default/optimized/1X/c608d1446e4bec9af4205f2cc0be0f402828aa7c_2_1380x776.png 2x\" data-dominant-color=\"FAFCFE\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">A proof system for computation delegation.</span><span class=\"informations\">1456\u00d7819 27.5 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p><em><strong>Figure 6:</strong> A proof system for computation delegation. The prover computes y=f(x) and convinces the verifier of the correctness of this statement. Crucially, if y\u2260f(x), the prover couldn\u2019t have convinced the verifier of this fact.</em></p>\n<p>Hence, our approach to minimizing the blockchain footprint of computation will be to implement a proof system verifier in Bitcoin script. Thus, to invoke the smart contract, the caller will provide a proof of a correct state transition, and the Bitcoin smart contract will verify the correctness of the proof of this state transition, as opposed to checking the state transition directly (see Figure 7).</p>\n<p>Moreover, an additional crucial benefit of this approach is that the Bitcoin script logic can stay <strong>fixed regardless of application</strong>, which significantly reduces the chances of bugs and eases auditing. This stems from the simple fact that the same verifier algorithm can be made to verify either a \u201cy=f(x)\u201d statement or a \u201cy=g(x)\u201d statement without needing to know the function to be computed beforehand.</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/1X/55d5c808e719d755d36d06b59375e5e5b0a436b2.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/55d5c808e719d755d36d06b59375e5e5b0a436b2\" title=\"Smart contracts on Bitcoin via covenants that follow the \u201cstate caboose\u201d design pattern, as in Figure 4, but with a verifier.\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/1X/55d5c808e719d755d36d06b59375e5e5b0a436b2_2_690x388.png\" alt=\"Smart contracts on Bitcoin via covenants that follow the \u201cstate caboose\u201d design pattern, as in Figure 4, but with a verifier.\" data-base62-sha1=\"cfkBMTIgb99AC6uuFTcWxKN0eEW\" width=\"690\" height=\"388\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/1X/55d5c808e719d755d36d06b59375e5e5b0a436b2_2_690x388.png, https://delvingbitcoin.org/uploads/default/optimized/1X/55d5c808e719d755d36d06b59375e5e5b0a436b2_2_1035x582.png 1.5x, https://delvingbitcoin.org/uploads/default/optimized/1X/55d5c808e719d755d36d06b59375e5e5b0a436b2_2_1380x776.png 2x\" data-dominant-color=\"FCFDFE\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">Smart contracts on Bitcoin via covenants that follow the \u201cstate caboose\u201d design pattern, as in Figure 4, but with a verifier.</span><span class=\"informations\">1456\u00d7819 18.8 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p><em><strong>Figure 7:</strong> Smart contracts on Bitcoin via covenants that follow the \u201cstate caboose\u201d design pattern, as in Figure 4, but with a verifier. This time, instead of checking the validity of the transition from S to S\u2019 directly, the locking script verifies a proof that the transition was correct.</em></p>\n<p>There are many proof systems, however, we choose to use STARK proof systems (STARKs) because of their many extremely attractive features:</p>\n<ul>\n<li>Post-quantum secure</li>\n<li>No trusted setup</li>\n<li>No new cryptographic assumptions for Bitcoin</li>\n<li>Fastest to scale</li>\n<li>Battle-tested, trusted with over $1T settled</li>\n</ul>\n<p>Finally, in contrast to other proof systems, STARKs are Bitcoin-friendly, namely, their verifier component can be more easily implemented in Bitcoin script. In essence, this is due to the fact STARKs are mostly hash-based, with very few algebraic operations, compared with pairing-based proofs. Since algebraic operations are very costly in Bitcoin script, this explains the Bitcoin-friendliness of STARKs. Furthermore, the <a href=\"https://eprint.iacr.org/2024/278\" rel=\"noopener nofollow ugc\">Circle-STARK</a> variant is especially Bitcoin-friendly, thanks to its small field size.</p>\n<p>Thus, since the Bitcoin verifier can relatively easily verify any computation, we <strong>can choose which type of computation it verifies</strong>. Remarkably, this can even be some kind of <strong>CPU execution</strong>. Furthermore, one can design high-level programming languages built on top of this CPU. To this end, at StarkWare, we have developed <a href=\"https://www.cairo-lang.org/\" rel=\"noopener nofollow ugc\">Cairo</a>, a Rust-like, ergonomic, and safe programming language <strong>designed specifically for efficient proving and verification.</strong> Proving the execution of Cairo on Bitcoin can be very advantageous.</p>\n<p>To conclude, using a STARK verifier, together with covenants, we are able to achieve general computation on Bitcoin. Moreover, this computation has the following attractive additional features:</p>\n<ul>\n<li><strong>Scalability</strong> \u2013 onchain transaction processing and computation becomes feasible, with very low fees.</li>\n<li><strong>Expressibility</strong> \u2013 The logic can be programmed in a different, more powerful, programming language than Bitcoin script. This is vital for making programming on Bitcoin ergonomic and safe.</li>\n<li><strong>Onchain safety</strong> \u2013 No matter what the computation is, Bitcoin script is only ever verifying a mathematical proof of delegated computation.</li>\n<li><strong>Flexibility</strong> \u2013 Computation on Bitcoin can store global state, enabling a plethora of applications.</li>\n</ul>\n<h2><a name=\"p-3081-h-7-using-op_cat-for-concatenation-and-beyond-7\" class=\"anchor\" href=\"#p-3081-h-7-using-op_cat-for-concatenation-and-beyond-7\"></a>7. Using OP_CAT for concatenation and beyond</h2>\n<p>As mentioned above, OP_CAT is a simple, currently disabled, opcode that could allow Bitcoin script to concatenate elements on the stack. The importance of this simple operation cannot be overstated, as it simultaneously enables <strong>covenants</strong> and <strong>STARKs</strong> on Bitcoin. It does so in the following way:</p>\n<ul>\n<li>\n<p><strong>STARKs</strong> \u2013 In fact, this is somewhat unsurprising. This is because STARKs practically consist of just <strong>concatenating</strong> data together and hashing it, which leads to great savings as hashing is a native Bitcoin script operation, unlike algebraic operations. The main hashing operations in STARKs are <strong>Merkle path verification</strong> (see Figure 8), and the <strong>Fiat-Shamir transform</strong>. (Furthermore, the field size of the Circle-STARK variant is only 31 bits, so it fits in the 4-byte restriction of Bitcoin script, making it a Bitcoin-friendly algorithm.)</p>\n</li>\n<li>\n<p><strong>Covenants</strong> \u2013 In 2021, Andrew Poelstra made the <a href=\"https://medium.com/blockstream/cat-and-schnorr-tricks-i-faf1b59bd298\" rel=\"noopener nofollow ugc\">nontrivial observation</a> that OP_CAT can enable covenants on Bitcoin, through something called the <strong>Schnorr trick</strong>, where Schnorr\u2019s algorithm is the digital signature of <strong>Pay2Taproot</strong> output types (for other output types, a similar <strong>ECDSA trick</strong> can be used, <a href=\"https://gist.github.com/RobinLinus/9a69f5552be94d13170ec79bf34d5e85\" rel=\"noopener nofollow ugc\">as observed by Robin Linus</a>). To briefly describe the idea, to get covenants, we need to use OP_CHECKSIG, which is the only opcode that is capable of putting data related to the spender transaction onto the stack. It\u2019s not entirely straightforward, but through some manipulations, you can access all the necessary data.</p>\n</li>\n</ul>\n<p>Regarding the last point, keeping state inside <strong>Pay2Taproot</strong> outputs involves some technical difficulties. However, it is possible to store the state using other output types, such as <strong>Pay2WitnessScriptHash</strong>. This yields the aforementioned \u201cstate caboose\u201d technique from Figures 4 and 5, with two outputs in the transaction.</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/1X/360711a4e5ffe6658ff6e70a4fa845f1f65edbd4.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/360711a4e5ffe6658ff6e70a4fa845f1f65edbd4\" title=\"Merkle path verification, an operation that involves hashing and string concatenation.\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/1X/360711a4e5ffe6658ff6e70a4fa845f1f65edbd4_2_690x389.png\" alt=\"Merkle path verification, an operation that involves hashing and string concatenation.\" data-base62-sha1=\"7HWVz9HtWeItPM7Y2AycdBUleBK\" width=\"690\" height=\"389\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/1X/360711a4e5ffe6658ff6e70a4fa845f1f65edbd4_2_690x389.png, https://delvingbitcoin.org/uploads/default/optimized/1X/360711a4e5ffe6658ff6e70a4fa845f1f65edbd4_2_1035x583.png 1.5x, https://delvingbitcoin.org/uploads/default/optimized/1X/360711a4e5ffe6658ff6e70a4fa845f1f65edbd4_2_1380x778.png 2x\" data-dominant-color=\"F4F8FD\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">Merkle path verification, an operation that involves hashing and string concatenation.</span><span class=\"informations\">1464\u00d7827 19.6 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p><em><strong>Figure 8:</strong> Merkle path verification, an operation that involves hashing and string concatenation. The Merkle path parts (blue strings) are concatenated and hashed accordingly. Then, equality is checked with the Merkle root. <strong>OP_CAT</strong> operations are written as \u201c||\u201d.</em></p>\n<h2><a name=\"p-3081-h-8-present-and-future-8\" class=\"anchor\" href=\"#p-3081-h-8-present-and-future-8\"></a>8. Present and future</h2>\n<p>In an open-source effort, led by Weikeng Chen and Pinghzou Yuan, we\u2019re working on building the <a href=\"https://github.com/Bitcoin-Wildlife-Sanctuary\" rel=\"noopener nofollow ugc\">Bitcoin Wildlife Sanctuary</a>. Two primary projects there are:</p>\n<ul>\n<li>A <a href=\"https://github.com/Bitcoin-Wildlife-Sanctuary/bitcoin-circle-stark\" rel=\"noopener nofollow ugc\">Circle-STARK verifier</a> with a working demo that <strong>verifies a STARK proof of a simple statement (related to Fibonacci numbers) on Bitcoin signet,</strong> which you can track through this <a href=\"https://mempool.space/signet/address/tb1p2jczsavv377s46epv9ry6uydy67fqew0ghdhxtz2xp5f56ghj5wqlexrvn\" rel=\"noopener nofollow ugc\">address</a>.</li>\n<li>A <a href=\"https://github.com/Bitcoin-Wildlife-Sanctuary/covenants-gadgets\" rel=\"noopener nofollow ugc\">framework for covenants</a>, already with an application via a <a href=\"https://github.com/Bitcoin-Wildlife-Sanctuary/covenants-examples\" rel=\"noopener nofollow ugc\">simple counting covenant</a>. The verifier also uses this framework.</li>\n</ul>\n<p>Through this effort, we aim to bring OP_CAT-enabled smart contracts to Bitcoin that are efficient, secure, and developer-friendly. We feel that this is a promising and exciting prospect for the realm of computation on Bitcoin.</p>\n<h2><a name=\"p-3081-h-9-closing-words-9\" class=\"anchor\" href=\"#p-3081-h-9-closing-words-9\"></a>9. Closing words</h2>\n<p>To conclude, in this post we\u2019ve seen that:</p>\n<ul>\n<li>\n<p><strong>Covenants</strong> are a powerful tool for Bitcoin Script that allows for the creation of smart contracts on Bitcoin. They expand Bitcoin\u2019s capabilities beyond simple value transfers.</p>\n</li>\n<li>\n<p>However, even with covenants, Bitcoin script has many limitations, including restrictions on stack size and the types of opcodes that can be used. This limits the complexity and expressiveness of smart contracts that can be implemented using covenants alone.</p>\n</li>\n<li>\n<p><strong>STARKs</strong> offer a promising solution to alleviate these limitations, as they can efficiently verify the execution of computations offchain. By leveraging STARKs, it is possible to perform more complex computations within Bitcoin smart contracts and minimize their onchain footprint.</p>\n</li>\n<li>\n<p><strong>Cairo</strong> is a programming language specifically designed for efficient proving and verification using STARKs, making it well-suited for use in Bitcoin smart contracts. It enables the creation of more sophisticated smart contracts with increased ergonomics, functionality, and safety.</p>\n</li>\n<li>\n<p><strong>OP_CAT</strong> is a Bitcoin script opcode that concatenates elements. It plays a crucial role in implementing covenants and STARKs on Bitcoin, which, in turn, brings powerful general computation to Bitcoin.</p>\n</li>\n</ul>\n<p><em>Thanks to Weikeng Chen, Pingzhou Yuan, and the team at StarkWare for input on drafts of this post.</em></p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2024-08-29T11:21:23.206Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 17,
  "reads": 19,
  "readers_count": 18,
  "score": 87.4,
  "yours": false,
  "topic_id": 1106,
  "topic_slug": "the-path-to-general-computation-on-bitcoin-with-op-cat",
  "topic_title": "The path to general computation on Bitcoin (with OP_CAT)",
  "topic_html_title": "The path to general computation on Bitcoin (with OP_CAT)",
  "category_id": 8,
  "display_username": "Victor Kolobov",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 4,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": "",
  "bookmarked": false,
  "raw": "![The path to general computation on Bitcoin|1456x819](upload://5tVi05nWVNaSzs4HwtstLetGmZM.jpeg)\n\n## 1. Introduction\n\nIn this post, we will discuss the task of achieving general computation on Bitcoin and the various steps it entails. Indeed, the ability to compute arbitrary logic in Bitcoin script is a very compelling goal, as it opens Bitcoin to the realms of non-custodial applications and decentralized finance.\n\nPreviously, general computation on Bitcoin was deemed all but impossible due to two severe limitations: Bitcoin script length and opcode expressibility. The former prohibits transactions with anything but short scripts, and the latter limits what the script opcodes can compute. Jointly, these paint a dire picture of Bitcoin\u2019s computation viability, as many applications are not possible to implement within these constraints.\n\nNevertheless, in recent years, this state of affairs has significantly improved. Indeed, the script length limitation was lifted with the 2021 Taproot upgrade, allowing for significantly longer Bitcoin scripts (in fact, Taproot scripts even allow to sometimes only pay onchain for **a** **part of the script**, but we\u2019ll not explore this property in this post). Moreover, to deal with the opcode expressibility limitation, a single simple opcode was identified to be sufficient for effectively unlimited expressibility.\n\nThe aforementioned opcode is known as **OP_CAT**, and it has been disabled in Bitcoin script since 2010. It\u2019s a very simple opcode that allows **concatenating elements on the stack** and requires just **13 lines of code** to be activated on Bitcoin non-intrusively [via a soft fork](https://github.com/bitcoin/bips/blob/97012a82064c7247df502a170c03b053825cdd15/bip-0347.mediawiki). Deriving so much power from this seemingly unassuming opcode is highly nontrivial, and hence, a central goal for this blog is to elaborate on this point.\n\nIn what follows, we will dive deeper into computation on Bitcoin, starting from how it\u2019s done, and what are the limitations.\n\nFollowing that, we\u2019ll overview two tools\u2014**covenants** and **STARK proofs**\u2014and show that if made possible in Bitcoin script, they will enable general computation. Furthermore, we will argue in this blog post that, thanks to STARK Proofs, this computation can be bestowed with additional useful properties:\n\n* **Scalability** \u2013 Onchain transaction processing and computation becomes feasible, with very low fees.\n* **Expressibility** \u2013 The logic can be programmed in a different, more powerful, programming language than Bitcoin script. This is vital for making programming on Bitcoin ergonomic and safe.\n* **Onchain safety** \u2013 No matter what the computation is, Bitcoin script is only ever verifying a mathematical proof of delegated computation.\n* **Flexibility** \u2013 Computation on Bitcoin can store global state, enabling a plethora of applications.\n\nFinally, we\u2019ll discuss OP_CAT and how it enables the tools mentioned above. We\u2019ll also reference some of our efforts in this direction and discuss what\u2019s to come.\n\n***Warning: This post simplifies some technicalities to provide a clear mental model. When it comes to actually implementing the presented ideas, \u201cthe devil is in the details.\u201d***\n\n## 2. UTXO model and locking scripts\n\nIn this section, we briefly outline Bitcoin\u2019s UTXO model, where each UTXO is locked behind a locking script. If you are familiar with this, you can skip to the next section.\n\nThe first step to understanding transactions on Bitcoin is to note they are arranged and processed according to the **unspent transaction output** (UTXO) model, as in Figure 1. Bitcoin transactions can have multiple inputs and outputs, where each output represents an amount of bitcoins that can be spent by another transaction. Accordingly, a transaction\u2019s input represents the spending of another Bitcoin transaction\u2019s output. Naturally, we require that the cumulative amount of bitcoins in the inputs be roughly equal to the amount in the outputs (with the difference being the fee paid to the miners).\n\n![Bitcoin transactions in the UTXO model|1456x819](upload://2jCIhM2ReIBTqKLX61VroY976rW.png)\n\n***Figure 1**: Transactions in the UTXO model. Each input and output of a transaction has an amount of Bitcoins associated with it, where the cumulative amount in the outputs can\u2019t exceed that of the inputs. Unspent transaction outputs (UTXOs) are colored in blue.*\n\nEach transaction output is locked behind a **locking script** (scriptPubKey), which will either accept or reject an input (scriptSig) it is given (by the so-called **spender**). Thus if you want to transfer the funds from an **unspent transaction output** (UTXO), you need to be able to generate the correct scriptSig and include this UTXO as an input in your generated transaction.\n\nBy default, the locking script will simply verify digital signatures against a hardcoded public key, which defines the **ownership** of the locked bitcoins. More generally, whenever there is a UTXO, we say that the person who is able to produce the correct scriptSig is the **owner** of the bitcoins locked behind the corresponding locking script. Hence, the **total balance of each Bitcoin owner** is **dictated cumulatively** by all **UTXOs** associated with this owner (for example, all UTXOs requiring a digital signature from the same person).\n\n## 3. Limitations of Bitcoin script\n\nThe above section outlines locking scripts in general, and how they interact with Bitcoin transactions and Bitcoins. In this section, we focus on the locking scripts themselves and what they consist of.\n\nLocking scripts on Bitcoin are written in a [Forth](https://en.wikipedia.org/wiki/Forth_(programming_language))-like Stack-based language known as \u201cBitcoin script.\u201d Since Bitcoin script does not have loops, we measure the cost of a script by how many opcodes it requires, as the length of a script is proportional to its running time. In Figure 2, you can see an illustration of a simple program that checks whether the sum of two inputs is 12.\n\n![A simple program that checks whether the sum of two inputs is 12 (Bitcoin script)|1456x819](upload://tXG0xWOmShwMLg4rI1WNDlRyFqK.png)\n\n***Figure 2:** A simple program that checks whether the sum of two inputs is 12. The execution is performed by concatenating the scriptSig with the locking script itself, after which the opcodes are processed from left to right. The scriptSig only pushes elements onto the stack. **(a)** The first step of computation. **(b)** In the middle of computation. **(c)** Final step of computation (the locking script accepts the input).*\n\nWe pointed out that Bitcoin Script **has many limitations**, which makes developing even simple logic for it extremely nontrivial, if not downright impossible. Some of these include:\n\n* Stack size is limited to at most 1000 elements.\n* No opcodes for multiplications (indeed, even a 31-bit integer multiplication needs to be emulated by [~1.4k opcodes](https://github.com/Bitcoin-Wildlife-Sanctuary/rust-bitcoin-m31)).\n* The total number of opcodes that can fit inside a single transaction is at most ~4 million for [**Pay2Taproot**](https://en.bitcoin.it/wiki/BIP_0341) output types (following the Taproot upgrade), filling an entire block, and just 10k opcodes for other output types.\n* Arithmetic operations (addition, subtraction) are limited to 4-byte elements.\n\nThe 4-byte limitation mentioned in the last point is especially problematic. Indeed, it implies you **can\u2019t modify** long elements, for example, elements of the order of 20 bytes or more, which is required for **cryptographic operations**.\n\nFor instance, the very common operation of **concatenating** data together and applying a cryptographic operation is impossible, unless you **ignore the cryptographic opcodes, and emulate them as operations on data represented by 4-byte element arrays.** The latter is prohibitively expensive, as a single hash operation could require hundreds of thousands of opcodes to emulate.\n\nAs a final remark, we point out that due to the difficulty of developing in Bitcoin script, the code would naturally be more prone to bugs and vulnerabilities.\n\n## 4. The challenge of keeping state in Bitcoin script\n\nWhile the previous section demonstrated that Bitcoin scripting leaves much to be desired, we argue that the biggest limitation of Bitcoin locking scripts is the fact **they are only able to read the input they are given by the spender.** Unassuming at first, this implies two severe limitations:\n\n* Bitcoin scripts **are not stateful**. Namely, they cannot read/write storage cell data. In analogy to Ethereum VM, there are no **SLOAD**/**SSTORE** opcode analogs, which is an essential feature for general computation.\n* Bitcoin scripts **can\u2019t enforce how bitcoins are spent** (with a few exceptions). This is solved via **covenants**, which give the locking script this ability. (You can imagine a simple application for this: **onchain vaults**, which work by restricting the address to which spending is allowed. More generally, covenants are an extremely powerful tool with a wide range of applications.)\n\nSubsequently, we will see that constructing covenants already gives you statefulness. Intuitively, this is the case because you can use a covenant to emulate storage reads/writes in the transaction data itself.\n\nIndeed, all of the above does not scratch the surface of the breadth of what there is to know about Bitcoin scripting and its intricacies. But suffice it to say that writing scripts for Bitcoin is not easy, to say the least. To conclude, Bitcoin scripting emerges as having very strict constraints:\n\n* You mustn\u2019t exceed the stack size limit of 1000 elements.\n* You must emulate simple operations such as multiplications with many opcodes. In general, you must write your logic in the cumbersome Bitcoin scripting language.\n* You must operate on elements encoded in 4-byte form. In particular, you cannot operate on and change the inputs to cryptographic opcodes.\n* Your logic cannot hold state and must fit in a single transaction.\n* Your logic cannot have control over how bitcoins are being spent once authentication occurs.\n\nIn addition, writing code subject to the above constraints is prone to bugs and vulnerabilities.\n\nWhile very simple applications such as payments can meet the above constraints, anything slightly more complicated will encounter a roadblock. In the following, we will see how **covenants** and **STARK proofs** enable us to break free from these limitations. Furthermore, we will discuss how OP_CAT facilitates the possibility of the above in Bitcoin script.\n\n## 5. Smart Contracts on Bitcoin via Covenants\n\nIn this section, we will see how covenants in Bitcoin allow logic to keep state, and, more generally, what a \u201c**smart contract**\u201d looks like on Bitcoin. A smart contract here means some sort of stateful logic, with a collection of functions that can be invoked to transition the state to a different, valid one, according to predefined rules.\n\nMore concretely, Bitcoin contracts need the following functionalities:\n\n* Persistent logic and state\n* Ability to control how logic/state is changed\n\nAs previously mentioned, the above can be achieved through **covenants**. Recall that by default, a locking script can only read data that is directly fed to it (scriptSig). However, through a covenant, a locking script can read **all the data fields of the spender transaction**, as well as **the data fields of the transaction where the locking script is located,** and even data from other transactions. Figure 3 illustrates the different parts a locking script can access using a covenant.\n\n![Some of the data fields a locking script can access (Bitcoin script).|1456x819](upload://sU5Yf5KbnsQnSDgwSCEoHN0czKQ.png)\n\n***Figure 3:** Some of the data fields a locking script (visualized as a lock) can access (shown by the red arrows). Beyond accessing the data fields of the spender transaction, the locking script can also access the data fields of the transaction where the locking script is (tx1), as well as the data fields of another transaction that is also spent by the spender transaction (tx2).*\n\nWe claim the covenant described above is sufficient to build general smart contracts on Bitcoin. Indeed, the general approach would be to encode the state in the transaction data itself and check the validity of its transitions to new values. To this end, our transaction will have two outputs:\n\n* The first output holds the logic of the contract (via a locking script), as well as the funds locked in the contract.\n* The second output holds the **current state** of the smart contract. This UTXO\u2019s locking script only holds state and will never be spent (it locks practically 0 bitcoins).\n\nThe locking script logic will enforce the following rules:\n\n* The spender transaction **must have the same exact form** (two outputs only, and all funds locked in the first output),\n* The first output **must have the same locking script logic**\n* The second output **must be a valid state**\n* The input provided to the current locking script **must convince it the transition from the current state to the new state is valid** (the validity is defined by the logic designer)\n\nYou can see an illustration of this construction in Figure 4. As written [here](https://github.com/Bitcoin-Wildlife-Sanctuary/covenants-examples) by Weikeng Chen, a number of people have been suggesting a formal name for this construction, and \u201c**state** **caboose**\u201d stands out as a candidate. Caboose refers to a railroad car coupled at the **end** of a freight train as a shelter and working space for the crew.\n\n![Bitcoin post figure 4|1456x819](upload://aQpDnPF8zZbSrgyZ8gSdWxPbWrm.png)\n\n***Figure 4:** Smart contracts on Bitcoin via covenants that follow the \u201cstate caboose\u201d design pattern. The locking script enforces that the spender transaction has the same form and locking script, and that it has a valid state S\u2019, whose transition from the previous state S was also valid.*\n\nAs an illustrative example, you can think of a simple counting smart contract. This contract\u2019s state is always incremented by the value provided by the spender, which effectively invokes an \u201caccumulate\u201d function. This counting smart contract is shown in Figure 5.\n\n![A simple smart contract that accumulates inputs (scriptSig) into its state by adding them together.|1456x819](upload://x4O8PwmFo0Q24vMo7sBDWmMQLzv.png)\n\n***Figure 5:** A simple smart contract that accumulates inputs (scriptSig) into its state by adding them together.*\n\nAs a final remark, we note that to \u201ccall the contract\u201d and transition the contract to a new valid state, a user needs to create a new spender transaction for each call. In this way, **unlike Ethereum smart contracts, Bitcoin smart contracts are inherently sequential,** requiring the transaction to commit to both the current and new state. **This sequential property must be taken into account when building smart contracts on Bitcoin.** There are some possible mitigations to this, but we won\u2019t discuss them in this post.\n\nTo conclude, we\u2019ve seen that covenants enable smart contracts on Bitcoin, which, in theory, allows for **arbitrarily long computation** to be carried on top of Bitcoin when split across sufficiently many transactions. Nevertheless, using covenants alone still suffers from most of the limitations of Bitcoin script, namely, stack size limitations, a limited number of opcodes, and, in general, programming according to the Bitcoin script language constraints.\n\nIn the following, we will see how **STARK proof systems** can alleviate the above limitations by reducing the blockchain footprint of computation on Bitcoin and enabling scripting in an entirely different language, which dramatically improves programming efficiency and safety.\n\n## 6. A Bitcoin STARK verifier\n\nThe goal of this section is to discuss how computation can be done on Bitcoin, while keeping the actual computing done via Bitcoin script to a minimum. Our general approach to this will be through **computation delegation**, where the computing will happen offchain (multiple entities can potentially contribute), with only verification happening onchain, in Bitcoin script.\n\nThis begs the question, how can we trust that offchain computation was carried out correctly? Indeed, a very natural candidate to solve this problem is **a proof system**. Put simply, a proof system allows Alice (a **prover**) to convince Bob (a **verifier**) of the correctness of some statement by providing a \u201cproof,\u201d and, crucially:\n\n* The verifier needs to do **less work** to verify this statement, as opposed to how much he had to work without the prover\u2019s help.\n* Furthermore, the verifier is **protected**, in that the prover can\u2019t cheat the verifier and convince them of a false statement.\n\nThe proven statement can be virtually any statement, from the solution to a difficult puzzle, to the more relevant example of computation delegation. More concretely, Alice will prove to Bob that \u201cf(x)=y\u201d, instead of Bob having to do the computation of \u201cf(x)\u201d himself, as shown in Figure 6.\n\n![A proof system for computation delegation.|1456x819](upload://sfTqGE7IsQKwNHa1srozIqbZ1ms.png)\n\n***Figure 6:** A proof system for computation delegation. The prover computes y=f(x) and convinces the verifier of the correctness of this statement. Crucially, if y\u2260f(x), the prover couldn\u2019t have convinced the verifier of this fact.*\n\nHence, our approach to minimizing the blockchain footprint of computation will be to implement a proof system verifier in Bitcoin script. Thus, to invoke the smart contract, the caller will provide a proof of a correct state transition, and the Bitcoin smart contract will verify the correctness of the proof of this state transition, as opposed to checking the state transition directly (see Figure 7).\n\nMoreover, an additional crucial benefit of this approach is that the Bitcoin script logic can stay **fixed regardless of application**, which significantly reduces the chances of bugs and eases auditing. This stems from the simple fact that the same verifier algorithm can be made to verify either a \u201cy=f(x)\u201d statement or a \u201cy=g(x)\u201d statement without needing to know the function to be computed beforehand.\n\n![Smart contracts on Bitcoin via covenants that follow the \u201cstate caboose\u201d design pattern, as in Figure 4, but with a verifier.|1456x819](upload://cfkBMTIgb99AC6uuFTcWxKN0eEW.png)\n\n***Figure 7:** Smart contracts on Bitcoin via covenants that follow the \u201cstate caboose\u201d design pattern, as in Figure 4, but with a verifier. This time, instead of checking the validity of the transition from S to S\u2019 directly, the locking script verifies a proof that the transition was correct.*\n\nThere are many proof systems, however, we choose to use STARK proof systems (STARKs) because of their many extremely attractive features:\n\n* Post-quantum secure\n* No trusted setup\n* No new cryptographic assumptions for Bitcoin\n* Fastest to scale\n* Battle-tested, trusted with over $1T settled\n\nFinally, in contrast to other proof systems, STARKs are Bitcoin-friendly, namely, their verifier component can be more easily implemented in Bitcoin script. In essence, this is due to the fact STARKs are mostly hash-based, with very few algebraic operations, compared with pairing-based proofs. Since algebraic operations are very costly in Bitcoin script, this explains the Bitcoin-friendliness of STARKs. Furthermore, the [Circle-STARK](https://eprint.iacr.org/2024/278) variant is especially Bitcoin-friendly, thanks to its small field size.\n\nThus, since the Bitcoin verifier can relatively easily verify any computation, we **can choose which type of computation it verifies**. Remarkably, this can even be some kind of **CPU execution**. Furthermore, one can design high-level programming languages built on top of this CPU. To this end, at StarkWare, we have developed [Cairo](https://www.cairo-lang.org/), a Rust-like, ergonomic, and safe programming language **designed specifically for efficient proving and verification.** Proving the execution of Cairo on Bitcoin can be very advantageous.\n\nTo conclude, using a STARK verifier, together with covenants, we are able to achieve general computation on Bitcoin. Moreover, this computation has the following attractive additional features:\n\n* **Scalability** \u2013 onchain transaction processing and computation becomes feasible, with very low fees.\n* **Expressibility** \u2013 The logic can be programmed in a different, more powerful, programming language than Bitcoin script. This is vital for making programming on Bitcoin ergonomic and safe.\n* **Onchain safety** \u2013 No matter what the computation is, Bitcoin script is only ever verifying a mathematical proof of delegated computation.\n* **Flexibility** \u2013 Computation on Bitcoin can store global state, enabling a plethora of applications.\n\n## 7. Using OP_CAT for concatenation and beyond\n\nAs mentioned above, OP_CAT is a simple, currently disabled, opcode that could allow Bitcoin script to concatenate elements on the stack. The importance of this simple operation cannot be overstated, as it simultaneously enables **covenants** and **STARKs** on Bitcoin. It does so in the following way:\n\n* **STARKs** \u2013 In fact, this is somewhat unsurprising. This is because STARKs practically consist of just **concatenating** data together and hashing it, which leads to great savings as hashing is a native Bitcoin script operation, unlike algebraic operations. The main hashing operations in STARKs are **Merkle path verification** (see Figure 8), and the **Fiat-Shamir transform**. (Furthermore, the field size of the Circle-STARK variant is only 31 bits, so it fits in the 4-byte restriction of Bitcoin script, making it a Bitcoin-friendly algorithm.)\n\n* **Covenants** \u2013 In 2021, Andrew Poelstra made the [nontrivial observation](https://medium.com/blockstream/cat-and-schnorr-tricks-i-faf1b59bd298) that OP_CAT can enable covenants on Bitcoin, through something called the **Schnorr trick**, where Schnorr\u2019s algorithm is the digital signature of **Pay2Taproot** output types (for other output types, a similar **ECDSA trick** can be used, [as observed by Robin Linus](https://gist.github.com/RobinLinus/9a69f5552be94d13170ec79bf34d5e85)). To briefly describe the idea, to get covenants, we need to use OP_CHECKSIG, which is the only opcode that is capable of putting data related to the spender transaction onto the stack. It\u2019s not entirely straightforward, but through some manipulations, you can access all the necessary data.\n\nRegarding the last point, keeping state inside **Pay2Taproot** outputs involves some technical difficulties. However, it is possible to store the state using other output types, such as **Pay2WitnessScriptHash**. This yields the aforementioned \u201cstate caboose\u201d technique from Figures 4 and 5, with two outputs in the transaction.\n\n![Merkle path verification, an operation that involves hashing and string concatenation. |1464x827](upload://7HWVz9HtWeItPM7Y2AycdBUleBK.png)\n\n***Figure 8:** Merkle path verification, an operation that involves hashing and string concatenation. The Merkle path parts (blue strings) are concatenated and hashed accordingly. Then, equality is checked with the Merkle root. **OP_CAT** operations are written as \u201c||\u201d.*\n\n## 8. Present and future\n\nIn an open-source effort, led by Weikeng Chen and Pinghzou Yuan, we\u2019re working on building the [Bitcoin Wildlife Sanctuary](https://github.com/Bitcoin-Wildlife-Sanctuary). Two primary projects there are:\n\n* A [Circle-STARK verifier](https://github.com/Bitcoin-Wildlife-Sanctuary/bitcoin-circle-stark) with a working demo that **verifies a STARK proof of a simple statement (related to Fibonacci numbers) on Bitcoin signet,** which you can track through this [address](https://mempool.space/signet/address/tb1p2jczsavv377s46epv9ry6uydy67fqew0ghdhxtz2xp5f56ghj5wqlexrvn).\n* A [framework for covenants](https://github.com/Bitcoin-Wildlife-Sanctuary/covenants-gadgets), already with an application via a [simple counting covenant](https://github.com/Bitcoin-Wildlife-Sanctuary/covenants-examples). The verifier also uses this framework.\n\nThrough this effort, we aim to bring OP_CAT-enabled smart contracts to Bitcoin that are efficient, secure, and developer-friendly. We feel that this is a promising and exciting prospect for the realm of computation on Bitcoin.\n\n## 9. Closing words\n\nTo conclude, in this post we\u2019ve seen that:\n\n* **Covenants** are a powerful tool for Bitcoin Script that allows for the creation of smart contracts on Bitcoin. They expand Bitcoin\u2019s capabilities beyond simple value transfers.\n* However, even with covenants, Bitcoin script has many limitations, including restrictions on stack size and the types of opcodes that can be used. This limits the complexity and expressiveness of smart contracts that can be implemented using covenants alone.\n\n* **STARKs** offer a promising solution to alleviate these limitations, as they can efficiently verify the execution of computations offchain. By leveraging STARKs, it is possible to perform more complex computations within Bitcoin smart contracts and minimize their onchain footprint.\n* **Cairo** is a programming language specifically designed for efficient proving and verification using STARKs, making it well-suited for use in Bitcoin smart contracts. It enables the creation of more sophisticated smart contracts with increased ergonomics, functionality, and safety.\n* **OP_CAT** is a Bitcoin script opcode that concatenates elements. It plays a crucial role in implementing covenants and STARKs on Bitcoin, which, in turn, brings powerful general computation to Bitcoin.\n\n*Thanks to Weikeng Chen, Pingzhou Yuan, and the team at StarkWare for input on drafts of this post.*",
  "actions_summary": [
    {
      "id": 2,
      "count": 2
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 517,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": "Github link was replaced with a permanent link",
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "rocket",
      "type": "emoji",
      "count": 2
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 2,
  "current_user_used_main_reaction": false
}