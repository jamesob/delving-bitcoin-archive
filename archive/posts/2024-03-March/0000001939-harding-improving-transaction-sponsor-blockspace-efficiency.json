{
  "id": 1939,
  "name": "David A. Harding",
  "username": "harding",
  "avatar_template": "/user_avatar/delvingbitcoin.org/harding/{size}/6_2.png",
  "created_at": "2024-03-19T18:58:52.870Z",
  "cooked": "<p>Jeremy Rubin previously proposed <a href=\"https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html\">transaction fee sponsors</a>, a\nsoft fork that would allow a <em>sponsor transaction</em> to only be valid if\nit was included later in the same block as another transaction it explicitly\nreferences.  Those explicit references are placed in the sponsor\ntransaction\u2019s output script.  For example, to sponsor txid\n<code>0x1234...90ab</code>, the sponsor transaction would have a 33-byte output\nscript consisting of:</p>\n<pre><code>0x62 0x01234567890abcdef01234567890abcdef01234567890abcdef01234567890ab\n</code></pre>\n<p>During a casual conversation a few months ago, Jeremy and I realized\nthat this could be done more efficiently.  The simplest and most\nefficient form would only support sponsoring a single other transaction:</p>\n<ol>\n<li>\n<p>An input in the sponsor transaction has a signature message\n(signature hash) that commits to the txid to be sponsored.  This\nfield is signed, preventing third parties from changing it, but it is\nnot explicitly included in the transaction, saving vbytes.</p>\n</li>\n<li>\n<p>The sponsor transaction must appear in a block immediately after the\ntransaction it sponsors.  This allows the verifier of the sponsor\ntransaction to infer the txid of the transaction it sponsors,\nallowing it to construct the signature message.</p>\n</li>\n</ol>\n<p>Depending on exactly how the above was added to Bitcoin, the overhead\nfor indicating the txid of the transaction to sponsor would be between\nzero vbytes and a few vbytes, a reduction from 42 vbytes in Jeremy\u2019s original\nproposal (8-vbyte output amount, size byte, 33-vbyte output\nscript).  It\u2019s also a reduction in space and overhead compared to\n<a href=\"https://bitcoinops.org/en/topics/ephemeral-anchors/\">ephemeral anchors</a>, which requires (1) a relationship between the\ntransactions, (2) the parent transaction to have an output of about 12\nvbytes, (3) the child transaction to have an input of about 41 vbytes.</p>\n<p>Of course, the sponsor transaction itself still takes up space, but if\nsomeone was going to send a transaction anyway, then this allows that\ntransaction to sponsor another unrelated transaction with zero (or near\nzero) block space overhead.</p>\n<p>Jeremy\u2019s original proposal only had mempool policy consider a sponsor\ntransaction that sponsored a single other transaction.  He also only\nallowed a transaction to be sponsored by a single sponsor transaction.\nHowever, at the consensus level he proposed allowing a sponsor\ntransaction to sponsor multiple other transactions (all of which had to\nbe included in the same block for the sponsor to be valid) and for\nmultiple sponsor transactions to all sponsor one or more of the same\nunrelated transactions.  Sponsors transactions could also sponsor other\nsponsor transactions.  Additionally, sponsor transactions and the\ntransactions they sponsor are still subject to the regular consensus\ntransaction ordering constraint requiring ancestors appear before\ndescendants.</p>\n<p>That means supporting an arbitrary number of sponsor transactions and\nthe transactions they sponsor is impractical with fixed orderings like\ndescribed above.  Instead, sponsor transactions would need to contain a\nrewritable vector indicating where in a block to find the transactions\nthey sponsor.  For example:</p>\n<ol>\n<li>\n<p>Similar to before, an input in the sponsor transaction has a\nsignature message that commits to a list of txids.</p>\n</li>\n<li>\n<p>A malleable item on that input\u2019s witness stack indicates (1) the\nnumber of sponsored transactions and (2) the offset location of each\nsponsored transaction within a block.  For example, if the commitment\nmessage sponsored three transactions with txids\n{txid0,txid1,txid2}, the malleable witness item could be written to\nuse <code>0x0002 0x0003 0x0000 0x0001</code> to indicate that there are three transactions (<code>0x0002</code>),\nthat txid0 is located four transactions before the sponsor transaction (<code>0x0003</code>),\nthat txid1 is located immediately before the sponsor transaction(<code>0x0000</code>), and\nthat txid2 is located two transactions before the sponsor transaction (<code>0x0001</code>).\nUsing fixed two-byte values is a simple way to support sponsoring up\nto 65k transactions at any position within a block (65k is about 4x\nthe greatest number of tranactions possible in a single block without\na hard fork).  Switching to fixed single-byte values halves the\noverhead and still allows a single sponsor transaction input to\nsponsor up to 256 unrelated transactions in any of the 256 preceding slots.  There may be more\nefficient encodings.</p>\n<p>For relayed transactions that are not yet included within a block,\nthe malleable witness item could instead contain a list of 32-byte\ntxids instead of two-byte offsets.  These would be extracted before\nthe witness was evaluated to avoid them being misparsed or violating\nstack size limits.  Because the txids are conveyed directly here, the\nsponsor transaction\u2019s commitment hash can be validated without extra external lookups,\nallowing a mutated sponsor transaction to be dropped before we check\nthe mempool for the transactions it sponsors.</p>\n</li>\n</ol>\n<p>In this variation with fixed two-byte offsets in witness data, the\namount of data that goes onchain is about 0.5 vbytes per sponsored\ntransaction.  That remains much more efficient than ephemeral anchors.</p>\n<p>If someone is planning on creating a transaction anyway, they can\nsponsor multiple other transactions with minimal overhead.  Even to\nsponsor a minimal-sized 62-vbyte transaction, the sponsorship overhead\nis significantly smaller than the amount that would be overpaid on\naverage using an exponential presigned RBF fee bumping strategy with 10%\nincrements.  E.g., 10% RBF increments implies overpaying on average by\nabout 5%, which is equivalent to paying for about 3 extra vbytes on\naverage on a 62-vbyte transaction.</p>\n<p>Due to the high efficiency, I don\u2019t see any way for someone to\ntrustlessly pay a third party for sponsorship without prior setup and\nthe creation of a shared UTXO.  However, for anyone willing to depend on\ntrust and reputation, it\u2019s possible for any high frequency spenders to\noffer a sponsorship service.  For example, Alice sends a transaction\nevery block; Bob wants txid_x to be sponsored; he trusts Alice and sends her an payment\nover LN; she claims the payment, keeps part of it as profit, and uses\nthe rest to increase the feerate of her next transaction while adding a\nsponsor dependency on txid_x.  Alice must check that sponsoring txid_x\nwon\u2019t slow down her transaction too much, she must be willing to\nrewrite her transaction if a conflict of txid_x gets confirmed, and she\nmust also be aware of any mempool policies that could affect her, but\notherwise this seems a straightforward service to provide, so there\ncould develop a robust and reliable market for it.</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2024-03-19T20:19:34.753Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 6,
  "reads": 14,
  "readers_count": 13,
  "score": 32.8,
  "yours": false,
  "topic_id": 696,
  "topic_slug": "improving-transaction-sponsor-blockspace-efficiency",
  "topic_title": "Improving transaction sponsor blockspace efficiency",
  "topic_html_title": "Improving transaction sponsor blockspace efficiency",
  "category_id": 7,
  "display_username": "David A. Harding",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Jeremy Rubin previously proposed [transaction fee sponsors][sponsors], a\nsoft fork that would allow a _sponsor transaction_ to only be valid if\nit was included later in the same block as another transaction it explicitly\nreferences.  Those explicit references are placed in the sponsor\ntransaction's output script.  For example, to sponsor txid\n`0x1234...90ab`, the sponsor transaction would have a 33-byte output\nscript consisting of:\n\n    0x62 0x01234567890abcdef01234567890abcdef01234567890abcdef01234567890ab\n\nDuring a casual conversation a few months ago, Jeremy and I realized\nthat this could be done more efficiently.  The simplest and most\nefficient form would only support sponsoring a single other transaction:\n\n1. An input in the sponsor transaction has a signature message\n   (signature hash) that commits to the txid to be sponsored.  This\n   field is signed, preventing third parties from changing it, but it is\n   not explicitly included in the transaction, saving vbytes.\n\n2. The sponsor transaction must appear in a block immediately after the\n   transaction it sponsors.  This allows the verifier of the sponsor\n   transaction to infer the txid of the transaction it sponsors,\n   allowing it to construct the signature message.\n\nDepending on exactly how the above was added to Bitcoin, the overhead\nfor indicating the txid of the transaction to sponsor would be between\nzero vbytes and a few vbytes, a reduction from 42 vbytes in Jeremy's original\nproposal (8-vbyte output amount, size byte, 33-vbyte output\nscript).  It's also a reduction in space and overhead compared to\n[ephemeral anchors][], which requires (1) a relationship between the\ntransactions, (2) the parent transaction to have an output of about 12\nvbytes, (3) the child transaction to have an input of about 41 vbytes.\n\nOf course, the sponsor transaction itself still takes up space, but if\nsomeone was going to send a transaction anyway, then this allows that\ntransaction to sponsor another unrelated transaction with zero (or near\nzero) block space overhead.\n\nJeremy's original proposal only had mempool policy consider a sponsor\ntransaction that sponsored a single other transaction.  He also only\nallowed a transaction to be sponsored by a single sponsor transaction.\nHowever, at the consensus level he proposed allowing a sponsor\ntransaction to sponsor multiple other transactions (all of which had to\nbe included in the same block for the sponsor to be valid) and for\nmultiple sponsor transactions to all sponsor one or more of the same\nunrelated transactions.  Sponsors transactions could also sponsor other\nsponsor transactions.  Additionally, sponsor transactions and the\ntransactions they sponsor are still subject to the regular consensus\ntransaction ordering constraint requiring ancestors appear before\ndescendants.\n\nThat means supporting an arbitrary number of sponsor transactions and\nthe transactions they sponsor is impractical with fixed orderings like\ndescribed above.  Instead, sponsor transactions would need to contain a\nrewritable vector indicating where in a block to find the transactions\nthey sponsor.  For example:\n\n1. Similar to before, an input in the sponsor transaction has a\n   signature message that commits to a list of txids.\n\n2. A malleable item on that input's witness stack indicates (1) the\n   number of sponsored transactions and (2) the offset location of each\n   sponsored transaction within a block.  For example, if the commitment\n   message sponsored three transactions with txids\n   {txid0,txid1,txid2}, the malleable witness item could be written to\n   use `0x0002 0x0003 0x0000 0x0001` to indicate that there are three transactions (`0x0002`),\n   that txid0 is located four transactions before the sponsor transaction (`0x0003`),\n   that txid1 is located immediately before the sponsor transaction(`0x0000`), and\n   that txid2 is located two transactions before the sponsor transaction (`0x0001`).\n   Using fixed two-byte values is a simple way to support sponsoring up\n   to 65k transactions at any position within a block (65k is about 4x\n   the greatest number of tranactions possible in a single block without\n   a hard fork).  Switching to fixed single-byte values halves the\n   overhead and still allows a single sponsor transaction input to\n   sponsor up to 256 unrelated transactions in any of the 256 preceding slots.  There may be more\n   efficient encodings.\n\n   For relayed transactions that are not yet included within a block,\n   the malleable witness item could instead contain a list of 32-byte\n   txids instead of two-byte offsets.  These would be extracted before\n   the witness was evaluated to avoid them being misparsed or violating\n   stack size limits.  Because the txids are conveyed directly here, the\n   sponsor transaction's commitment hash can be validated without extra external lookups,\n   allowing a mutated sponsor transaction to be dropped before we check\n   the mempool for the transactions it sponsors.\n\nIn this variation with fixed two-byte offsets in witness data, the\namount of data that goes onchain is about 0.5 vbytes per sponsored\ntransaction.  That remains much more efficient than ephemeral anchors.\n\nIf someone is planning on creating a transaction anyway, they can\nsponsor multiple other transactions with minimal overhead.  Even to\nsponsor a minimal-sized 62-vbyte transaction, the sponsorship overhead\nis significantly smaller than the amount that would be overpaid on\naverage using an exponential presigned RBF fee bumping strategy with 10%\nincrements.  E.g., 10% RBF increments implies overpaying on average by\nabout 5%, which is equivalent to paying for about 3 extra vbytes on\naverage on a 62-vbyte transaction.\n\nDue to the high efficiency, I don't see any way for someone to\ntrustlessly pay a third party for sponsorship without prior setup and\nthe creation of a shared UTXO.  However, for anyone willing to depend on\ntrust and reputation, it's possible for any high frequency spenders to\noffer a sponsorship service.  For example, Alice sends a transaction\nevery block; Bob wants txid_x to be sponsored; he trusts Alice and sends her an payment\nover LN; she claims the payment, keeps part of it as profit, and uses\nthe rest to increase the feerate of her next transaction while adding a\nsponsor dependency on txid_x.  Alice must check that sponsoring txid_x\nwon't slow down her transaction too much, she must be willing to\nrewrite her transaction if a conflict of txid_x gets confirmed, and she\nmust also be aware of any mempool policies that could affect her, but\notherwise this seems a straightforward service to provide, so there\ncould develop a robust and reliable market for it.\n\n[sponsors]: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html\n[topic sponsors]: https://bitcoinops.org/en/topics/fee-sponsorship/\n[ephemeral anchors]: https://bitcoinops.org/en/topics/ephemeral-anchors/",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 6,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "rocket",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}