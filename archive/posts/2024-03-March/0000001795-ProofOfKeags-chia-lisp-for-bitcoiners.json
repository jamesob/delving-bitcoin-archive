{
  "id": 1795,
  "name": "ProofOfKeags",
  "username": "ProofOfKeags",
  "avatar_template": "/user_avatar/delvingbitcoin.org/proofofkeags/{size}/156_2.png",
  "created_at": "2024-03-05T21:08:10.149Z",
  "cooked": "<p>Seconding some of what you\u2019re saying here. It shouldn\u2019t be hard to match Simplicity up with the SOTA proof assistants which are also very related to things like Idris/Agda. Idris/Idris2 have Chez Scheme code-generators (Scheme being a slimmer, cleaner LISP variant).</p>\n<p>At the end of the day, we may not care as much about formally verifying the output, although such a property would be nice. We make a fundamental tradeoff when we erase structural information during the compiling procedure. The advantage of formally verifying the compiler target language (the interpreted language from the perspective of the consensus VM) is that we can derive the properties we want regardless of the source language. The downside is that preserving this extra structural information can be costly, both in space, as well as if we choose to check those structural invariants at transaction validation time (particularly costly).</p>\n<p>The other option is to not do the formal verification on the target language but rather do the verification of the program semantics in the source language, and just ensure that certain properties are preserved by the transformation from source to target. The benefit of this is alleviating the network cost of validation, but you end up making the source language for which you do this the de-facto standard, which has its own downsides.</p>\n<p>I think ultimately a LISP like target language would be a good line of research as it gives us a lot of the same flexibility as Simplicity, albeit without having to verify computation all the way down to the formalism of <s>Cartesian Closed</s> Distributive Categories.</p>",
  "post_number": 5,
  "post_type": 1,
  "updated_at": "2024-03-05T21:08:41.406Z",
  "reply_count": 0,
  "reply_to_post_number": 3,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 10,
  "readers_count": 9,
  "score": 17.0,
  "yours": false,
  "topic_id": 636,
  "topic_slug": "chia-lisp-for-bitcoiners",
  "topic_title": "Chia Lisp For Bitcoiners",
  "topic_html_title": "Chia Lisp For Bitcoiners",
  "category_id": 7,
  "display_username": "ProofOfKeags",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "reply_to_user": {
    "username": "ajtowns",
    "name": "Anthony Towns",
    "avatar_template": "/user_avatar/delvingbitcoin.org/ajtowns/{size}/3_2.png"
  },
  "bookmarked": false,
  "raw": "Seconding some of what you're saying here. It shouldn't be hard to match Simplicity up with the SOTA proof assistants which are also very related to things like Idris/Agda. Idris/Idris2 have Chez Scheme code-generators (Scheme being a slimmer, cleaner LISP variant).\n\nAt the end of the day, we may not care as much about formally verifying the output, although such a property would be nice. We make a fundamental tradeoff when we erase structural information during the compiling procedure. The advantage of formally verifying the compiler target language (the interpreted language from the perspective of the consensus VM) is that we can derive the properties we want regardless of the source language. The downside is that preserving this extra structural information can be costly, both in space, as well as if we choose to check those structural invariants at transaction validation time (particularly costly).\n\nThe other option is to not do the formal verification on the target language but rather do the verification of the program semantics in the source language, and just ensure that certain properties are preserved by the transformation from source to target. The benefit of this is alleviating the network cost of validation, but you end up making the source language for which you do this the de-facto standard, which has its own downsides.\n\nI think ultimately a LISP like target language would be a good line of research as it gives us a lot of the same flexibility as Simplicity, albeit without having to verify computation all the way down to the formalism of ~~Cartesian Closed~~ Distributive Categories.",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 138,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}