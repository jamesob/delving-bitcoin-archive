{
  "id": 1930,
  "name": "Anthony Towns",
  "username": "ajtowns",
  "avatar_template": "/user_avatar/delvingbitcoin.org/ajtowns/{size}/417_2.png",
  "created_at": "2024-03-19T00:48:28.411Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"roconnor-blockstream\" data-post=\"7\" data-topic=\"682\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/roconnor-blockstream/48/427_2.png\" class=\"avatar\"> roconnor-blockstream:</div>\n<blockquote>\n<p>I understand you are somewhat cool to the idea of using Simplicity, and I\u2019d like to try to get you a little bit more excited about Simplicity.</p>\n</blockquote>\n</aside>\n<p>I think Simplicity is plenty cool; it\u2019s more that I\u2019m not convinced that it\u2019s hitting the sweet spot for a consensus language. If that\u2019s true, in the worst case it\u2019s because Simplicity has some fundamental feature that\u2019s a bad fit, so trying other approaches is definitely a good idea; but in the best case, exploring the problem space with other approaches seems like it should reveal solutions that Simplicity could adapt and adopt and end up as a better language. And maybe I\u2019m wrong entirely, in which case working on a lisp alternative will just end up with me saying \u201clook, I can do <code>X</code> with lisp, how awesome is that?\u201d and you replying \u201cha, you think that\u2019s cool, here\u2019s <code>++X</code> in simplicity\u201d and it being much better for objectively verifiable reasons <code>Y</code>, <code>Z</code> and <code>W</code>. All of which seem like good outcomes to me.</p>\n<p>I\u2019m not super well-informed about Simplicity; if you\u2019re in the mood to educate me, then maybe a good starting point would be:</p>\n<aside class=\"quote no-group\" data-username=\"roconnor-blockstream\" data-post=\"7\" data-topic=\"682\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/roconnor-blockstream/48/427_2.png\" class=\"avatar\"> roconnor-blockstream:</div>\n<blockquote>\n<p>(There is a forth fundamental composition for computation which is looping, something that Chia Lisp can do, but neither Simplicity nor Bitcoin Script can do (though it can be kinda-faked with Simplicity)).</p>\n</blockquote>\n</aside>\n<p>That doesn\u2019t really make sense to me. For example, when calculating a bip342-style signature hash of a transaction, you naturally loop over each input and each output, applying the same computation to each part. I believe you already have jets for those sorts of things in the form of <code>sighash-all</code> etc. How do you specify something like that in simplicity more directly when you don\u2019t know what value the <code>num-outputs</code> jet will return, but want to define a custom sighash (like BIP 118, eg) that doesn\u2019t already exist as a jet? I would have guessed that what you\u2019d do is define a recursive calculation that could recurse up to <span class=\"math\">2^{32}-1</span> times as far as the type system is concerned, but will actually only recurse <code>num-outputs</code> times; but if so, that sure sounds like regular looping to me, so I don\u2019t really understand what the distinction you\u2019re getting at is.</p>\n<p>Maybe you just mean a function can\u2019t ever call itself per se, but you end up having to define <code>sighash[&lt;2^32]</code> which can call <code>sighash[&lt;2^31]</code> etc, and maybe you end up with a program whose size is logarithmic in the size of the data it can deal with?</p>\n<p>(Feel free to start a separate topic discussing this if you like, rather than leaving it hidden as a response here)</p>\n<p>For what it\u2019s worth, I don\u2019t really think of Lisp/Simplicity as being in competition per se \u2013 I think you could probably describe all the \u201clisp\u201d opcodes in Simplicity terms by parameterising the opcodes with the length of their operands, and perhaps by adding a \u201cvirtual\u201d parameter to \u201capply\u201d to forcibly bound any potential recursion, for instance.</p>\n<p>Actually, let me draw a little picture of how I think about this:</p>\n<pre data-code-height=\"327\" data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">flowchart LR\n   d--&gt;h--&gt;c--&gt;f\n\n   subgraph d[Development Environment]\n   direction LR\n   mod[Packages]\n   tst[Testing]\n   dbg[Debugger]\n   end\n\n   subgraph h[High Level Language]\n   direction LR\n   sym[Symbolic names]\n   fun[Functions]\n   fam[Familiarity]\n   con[Consistency with Consensus Language]\n   end\n\n   subgraph c[Consensus Language]\n   direction LR\n   rev[Reviewability]\n   pred[Predictability]\n   cap[Capability]\n   ser[Serialisation]\n   per[Performance]\n   end\n\n   subgraph f[Formalisation]\n   direction LR\n   spec[Specification]\n   conc[Useful conclusions]\n   link[Link to higher levels]\n   end\n</code></pre>\n<p>(arrows could be read as \u201cbuilds on\u201d)</p>\n<p>For Bitcoin script as it stands, we don\u2019t have much in the way of formalisation; the consensus language is well known and pretty well understood, thanks to it not being very novel in the first place and more than a decade of experience with it on top of that; though in many ways it\u2019s not incredibly capable. As a higher level language, miniscript and miniscript policy are one approach, sapio is another \u2013 miniscript being by design very consistent with script, and miniscript policy a little less so; while sapio is very different to script. For the dev environment there are things like <a href=\"https://github.com/bitcoin-core/btcdeb\">btcdeb</a>, <a href=\"https://github.com/dgpv/bsst\">bsst</a> and <a href=\"https://delvingbitcoin.org/t/tapsim-bitcoin-tapscript-debugger/292\">tapsim</a>. I suppose you could argue that miniscript introduces something of a formalism for the subset of a script that it covers, and bsst perhaps implies a formalisation in the way it analyses scripts.</p>\n<p>AIUI, Simplicity is building up from the right, with an excellent formalism, a mostly complete consensus language that directly builds on that formalism, with the high level tooling still being very much a work in progress (at least, googling for \u201cSimphony\u201d didn\u2019t seem to find much). Being able to say \u201cas long as this typechecks, all operations will be within bounds\u201d is the sort of thing I mean by \u201cuseful conclusions\u201d. (I would probably describe \u201cSimplicity\u201d as the formalism, \u201cthe bit machine\u201d as the consensus language, then presumably \u201cSymphony\u201d will fill out some of the higher levels)</p>\n<p>Chia on the other hand doesn\u2019t have much of a formalism, but has a fine consensus language and a fine high level language built on top of it, and based on some of the comments here is mostly looking to improve things in the dev env and high level areas. I think it\u2019s fair to say that more formalism could have helped avoid things like the <a href=\"https://www.chia.net/2022/03/04/divided-we-fork/\">negative division bug</a>, but there\u2019s a cost/benefit tradeoff there, of course.</p>\n<p>I guess my main issue with Simplicity is as a \u201cConsensus Language\u201d, particularly the reviewability aspect \u2013 implementing Simplicity is a sizable amount of code (<a href=\"https://github.com/ElementsProject/elements/pull/1219\">Elements#1219</a> is currently +41238-18 eg), and even if the path of least resistance to understanding that code is to treat much of it as generated (ie better to spend your time understanding the formal specification and the code generation tools than looking at C/C++ code directly) that\u2019s also a lot of complexity and requires a pretty high baseline of expertise.</p>\n<p>I guess it feels like while the formalism fundamentals certainly live up to the \u201cSimplicity\u201d name, everything beyond that ends up being uncomfortably complex, and, maybe I\u2019m dreaming, but I\u2019d like it better if it things were simple at each layer even looking at them in isolation?</p>\n<p>I don\u2019t mean that as criticism per se, more as an explanation of why I\u2019m looking at alternatives. Maybe it will turn out all the alternatives are terrible for other reasons; but even so, learning why/how they suck is still a valuable outcome.</p>\n<aside class=\"quote no-group\" data-username=\"roconnor-blockstream\" data-post=\"7\" data-topic=\"682\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/roconnor-blockstream/48/427_2.png\" class=\"avatar\"> roconnor-blockstream:</div>\n<blockquote>\n<p>Probably the most significant lowish level difference between Chia Lisp and Simplicity is that Chia Lisp is dynamically typed and Simplicity is statically typed.</p>\n</blockquote>\n</aside>\n<p>I guess I don\u2019t really see that as a fundamental difference for a consensus language: the first time you see the program in consensus is when you\u2019re evaluating the program against a particular piece of input data, at which point you can examine both of them and infer everything\u2019s exact type.</p>\n<p>That obviously sucks in some sense: if you\u2019ve got to essentially run the program to figure out its types, you\u2019re not really getting much benefit from knowing the types; but it\u2019s not clear to me how much benefit that types can actually bring to a consensus language. Certainly they bring lots of benefits to a high level language, where they can prevent bugs before you even make them; but at the consensus level, it\u2019s already too late for detecting bugs to do anyone much good (\u201cwould have be nice to know I was burning my funds before I burnt them\u2026\u201d), and even if the type checking is cheaper than evaluating the program, an attacker can always come up with something that type checks but fails during evaluation if they\u2019re trying to make you waste CPU by sending invalid transactions.</p>\n<aside class=\"quote no-group\" data-username=\"roconnor-blockstream\" data-post=\"7\" data-topic=\"682\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/roconnor-blockstream/48/427_2.png\" class=\"avatar\"> roconnor-blockstream:</div>\n<blockquote>\n<p>Theoretically, some sort of JIT Simplicity compiler implementation could potentially operate quite fast without safety concerns.</p>\n</blockquote>\n</aside>\n<p>That seems a bit unappealing to me \u2013 better to have something that\u2019s simple (and reviewable) than something that pushes the edges of being optimally fast? I understand that there\u2019s the possibility of proving the JIT code will always be equivalent to the non-JIT code which in theory allows offloading the review to an automated proof verification tool, but that again adds a lot of complexity, just in different ways.</p>\n<p>(If you had a blockchain with a very high transaction rate, and correspondingly few fully validating nodes, then also having a level of complexity that\u2019s hard to verify is probably worth the tradeoff of having better performance. So it\u2019s at least a potentially interesting feature for language design in general, it just doesn\u2019t feel like it\u2019s a win here)</p>\n<aside class=\"quote no-group\" data-username=\"roconnor-blockstream\" data-post=\"8\" data-topic=\"682\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/roconnor-blockstream/48/427_2.png\" class=\"avatar\"> roconnor-blockstream:</div>\n<blockquote>\n<p>Oh one last thing I forgot to add is that since we want this low-level / high-level consensus / non-consensus language split regardless, the details of the low-level language become somewhat less important.</p>\n</blockquote>\n</aside>\n<p>I think there\u2019s also value in being able to go from the consensus language to a formalism, if that allows you to analyse your scripts for high-level issues, eg analysing what possible witnesses will allow for valid transactions. It would be nice if that also turns out to be somewhat language independent, so that a similar framework could be used in different contexts.</p>\n<p>(Treating current bitcoin script as the \u201chigh level language\u201d and compiling/translating it to lisp/simplicity, then analysing that via the corresponding formalisation might also be interesting)</p>",
  "post_number": 9,
  "post_type": 1,
  "updated_at": "2024-03-19T00:48:28.411Z",
  "reply_count": 0,
  "reply_to_post_number": 7,
  "quote_count": 2,
  "incoming_link_count": 0,
  "reads": 8,
  "readers_count": 7,
  "score": 16.4,
  "yours": false,
  "topic_id": 682,
  "topic_slug": "btc-lisp-as-an-alternative-to-script",
  "topic_title": "BTC Lisp as an alternative to Script",
  "topic_html_title": "BTC Lisp as an alternative to Script",
  "category_id": 7,
  "display_username": "Anthony Towns",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"roconnor-blockstream, post:7, topic:682\"]\nI understand you are somewhat cool to the idea of using Simplicity, and I\u2019d like to try to get you a little bit more excited about Simplicity.\n[/quote]\n\nI think Simplicity is plenty cool; it's more that I'm not convinced that it's hitting the sweet spot for a consensus language. If that's true, in the worst case it's because Simplicity has some fundamental feature that's a bad fit, so trying other approaches is definitely a good idea; but in the best case, exploring the problem space with other approaches seems like it should reveal solutions that Simplicity could adapt and adopt and end up as a better language. And maybe I'm wrong entirely, in which case working on a lisp alternative will just end up with me saying \"look, I can do `X` with lisp, how awesome is that?\" and you replying \"ha, you think that's cool, here's `++X` in simplicity\" and it being much better for objectively verifiable reasons `Y`, `Z` and `W`. All of which seem like good outcomes to me.\n\nI'm not super well-informed about Simplicity; if you're in the mood to educate me, then maybe a good starting point would be:\n\n[quote=\"roconnor-blockstream, post:7, topic:682\"]\n(There is a forth fundamental composition for computation which is looping, something that Chia Lisp can do, but neither Simplicity nor Bitcoin Script can do (though it can be kinda-faked with Simplicity)).\n[/quote]\n\nThat doesn't really make sense to me. For example, when calculating a bip342-style signature hash of a transaction, you naturally loop over each input and each output, applying the same computation to each part. I believe you already have jets for those sorts of things in the form of `sighash-all` etc. How do you specify something like that in simplicity more directly when you don't know what value the `num-outputs` jet will return, but want to define a custom sighash (like BIP 118, eg) that doesn't already exist as a jet? I would have guessed that what you'd do is define a recursive calculation that could recurse up to $2^{32}-1$ times as far as the type system is concerned, but will actually only recurse `num-outputs` times; but if so, that sure sounds like regular looping to me, so I don't really understand what the distinction you're getting at is.\n\nMaybe you just mean a function can't ever call itself per se, but you end up having to define `sighash[<2^32]` which can call `sighash[<2^31]` etc, and maybe you end up with a program whose size is logarithmic in the size of the data it can deal with?\n\n(Feel free to start a separate topic discussing this if you like, rather than leaving it hidden as a response here)\n\nFor what it's worth, I don't really think of Lisp/Simplicity as being in competition per se -- I think you could probably describe all the \"lisp\" opcodes in Simplicity terms by parameterising the opcodes with the length of their operands, and perhaps by adding a \"virtual\" parameter to \"apply\" to forcibly bound any potential recursion, for instance.\n\nActually, let me draw a little picture of how I think about this:\n\n```mermaid height=327,auto\nflowchart LR\n   d-->h-->c-->f\n\n   subgraph d[Development Environment]\n   direction LR\n   mod[Packages]\n   tst[Testing]\n   dbg[Debugger]\n   end\n\n   subgraph h[High Level Language]\n   direction LR\n   sym[Symbolic names]\n   fun[Functions]\n   fam[Familiarity]\n   con[Consistency with Consensus Language]\n   end\n\n   subgraph c[Consensus Language]\n   direction LR\n   rev[Reviewability]\n   pred[Predictability]\n   cap[Capability]\n   ser[Serialisation]\n   per[Performance]\n   end\n\n   subgraph f[Formalisation]\n   direction LR\n   spec[Specification]\n   conc[Useful conclusions]\n   link[Link to higher levels]\n   end\n```\n\n(arrows could be read as \"builds on\")\n\nFor Bitcoin script as it stands, we don't have much in the way of formalisation; the consensus language is well known and pretty well understood, thanks to it not being very novel in the first place and more than a decade of experience with it on top of that; though in many ways it's not incredibly capable. As a higher level language, miniscript and miniscript policy are one approach, sapio is another -- miniscript being by design very consistent with script, and miniscript policy a little less so; while sapio is very different to script. For the dev environment there are things like [btcdeb](https://github.com/bitcoin-core/btcdeb), [bsst](https://github.com/dgpv/bsst) and [tapsim](https://delvingbitcoin.org/t/tapsim-bitcoin-tapscript-debugger/292). I suppose you could argue that miniscript introduces something of a formalism for the subset of a script that it covers, and bsst perhaps implies a formalisation in the way it analyses scripts.\n\nAIUI, Simplicity is building up from the right, with an excellent formalism, a mostly complete consensus language that directly builds on that formalism, with the high level tooling still being very much a work in progress (at least, googling for \"Simphony\" didn't seem to find much). Being able to say \"as long as this typechecks, all operations will be within bounds\" is the sort of thing I mean by \"useful conclusions\". (I would probably describe \"Simplicity\" as the formalism, \"the bit machine\" as the consensus language, then presumably \"Symphony\" will fill out some of the higher levels)\n\nChia on the other hand doesn't have much of a formalism, but has a fine consensus language and a fine high level language built on top of it, and based on some of the comments here is mostly looking to improve things in the dev env and high level areas. I think it's fair to say that more formalism could have helped avoid things like the [negative division bug](https://www.chia.net/2022/03/04/divided-we-fork/), but there's a cost/benefit tradeoff there, of course.\n\nI guess my main issue with Simplicity is as a \"Consensus Language\", particularly the reviewability aspect -- implementing Simplicity is a sizable amount of code ([Elements#1219](https://github.com/ElementsProject/elements/pull/1219) is currently +41238-18 eg), and even if the path of least resistance to understanding that code is to treat much of it as generated (ie better to spend your time understanding the formal specification and the code generation tools than looking at C/C++ code directly) that's also a lot of complexity and requires a pretty high baseline of expertise.\n\nI guess it feels like while the formalism fundamentals certainly live up to the \"Simplicity\" name, everything beyond that ends up being uncomfortably complex, and, maybe I'm dreaming, but I'd like it better if it things were simple at each layer even looking at them in isolation?\n\nI don't mean that as criticism per se, more as an explanation of why I'm looking at alternatives. Maybe it will turn out all the alternatives are terrible for other reasons; but even so, learning why/how they suck is still a valuable outcome.\n\n[quote=\"roconnor-blockstream, post:7, topic:682\"]\nProbably the most significant lowish level difference between Chia Lisp and Simplicity is that Chia Lisp is dynamically typed and Simplicity is statically typed.\n[/quote]\n\nI guess I don't really see that as a fundamental difference for a consensus language: the first time you see the program in consensus is when you're evaluating the program against a particular piece of input data, at which point you can examine both of them and infer everything's exact type.\n\nThat obviously sucks in some sense: if you've got to essentially run the program to figure out its types, you're not really getting much benefit from knowing the types; but it's not clear to me how much benefit that types can actually bring to a consensus language. Certainly they bring lots of benefits to a high level language, where they can prevent bugs before you even make them; but at the consensus level, it's already too late for detecting bugs to do anyone much good (\"would have be nice to know I was burning my funds before I burnt them...\"), and even if the type checking is cheaper than evaluating the program, an attacker can always come up with something that type checks but fails during evaluation if they're trying to make you waste CPU by sending invalid transactions.\n\n[quote=\"roconnor-blockstream, post:7, topic:682\"]\nTheoretically, some sort of JIT Simplicity compiler implementation could potentially operate quite fast without safety concerns.\n[/quote]\n\nThat seems a bit unappealing to me -- better to have something that's simple (and reviewable) than something that pushes the edges of being optimally fast? I understand that there's the possibility of proving the JIT code will always be equivalent to the non-JIT code which in theory allows offloading the review to an automated proof verification tool, but that again adds a lot of complexity, just in different ways.\n\n(If you had a blockchain with a very high transaction rate, and correspondingly few fully validating nodes, then also having a level of complexity that's hard to verify is probably worth the tradeoff of having better performance. So it's at least a potentially interesting feature for language design in general, it just doesn't feel like it's a win here)\n\n[quote=\"roconnor-blockstream, post:8, topic:682\"]\nOh one last thing I forgot to add is that since we want this low-level / high-level consensus / non-consensus language split regardless, the details of the low-level language become somewhat less important.\n[/quote]\n\nI think there's also value in being able to go from the consensus language to a formalism, if that allows you to analyse your scripts for high-level issues, eg analysing what possible witnesses will allow for valid transactions. It would be nice if that also turns out to be somewhat language independent, so that a similar framework could be used in different contexts.\n\n(Treating current bitcoin script as the \"high level language\" and compiling/translating it to lisp/simplicity, then analysing that via the corresponding formalisation might also be interesting)",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": true,
  "admin": true,
  "staff": true,
  "user_id": 3,
  "hidden": false,
  "trust_level": 4,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}