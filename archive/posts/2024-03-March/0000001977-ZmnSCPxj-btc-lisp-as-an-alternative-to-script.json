{
  "id": 1977,
  "name": "ZmnSCPxj jxPCSnmZ",
  "username": "ZmnSCPxj",
  "avatar_template": "/letter_avatar_proxy/v4/letter/z/ee7513/{size}.png",
  "created_at": "2024-03-21T00:19:14.595Z",
  "cooked": "<h1><a name=\"environment-objects-1\" class=\"anchor\" href=\"#environment-objects-1\"></a>Environment Objects</h1>\n<p>A thing I should note from my days as a programming language theory nerd is that a Scheme (a kind of Lisp) can be implemented such that a Scheme interpreter is really a Scheme compiler that targets a stack virtual machine, and in fact toy implementations of Scheme often do this.</p>\n<p>Now in Scheme a function may capture variables that are not defined in its arguments or in its <code>let</code> forms, but outside of the function.  This gets compiled down to an array of values, the values being the captured variables.  These arrays are often called \u201cclosures\u201d or \u201cenvironments\u201d \u2014 it is likely that chialisp actually got the \u201cenvironment\u201d from this concept, and an actual chialisp virtual machine can probably optimize by putting the binary tree into an array and using array indexes to look up environments.</p>\n<p>Note that stack-based Scheme toy implementations will in fact allow you to create such closure/environment structures by popping of some number of items off the stack, and usually have a concept of \u201cthe current environment\u201d which is often loaded when a function is entered.  Then there are convenient stack operations that just push corresponding items from the environment on the stack.</p>\n<p>As we know, when experimenting with more complex SCRPT utilizing more complex covenants stuff like <code>OP_CAT</code>, a fair amount of code is futzing around the stack.  We could instead have a \u201cload stack items into current environment\u201d and \u201cpush an item from a specific index of the current environment onto the stack\u201d as part of the stack-based actual underlying language, in order to assist this.</p>\n<p>In particular, a Lisp expression <code>(f (g 2 3) (h 4 (i 6)))</code> can be compiled to a stack-based language like <code>&lt;6&gt; OP_I &lt;4&gt; OP_H &lt;3&gt; &lt;2&gt; OP_G OP_F</code>, i.e. reverse polish notation.  The problem with current Bitcoin SCRIPT is that accessing variables \u2014 \u201ccaptured\u201d variables that are part of the SCRIPT commited to in the <code>scriptPubKey</code>, such as public keys, as well as \u201cargument\u201d variables that are part of the <code>witness</code> \u2014 requires stack gymnastics.  Having operations to load a \u201ccurrent environment\u201d from the stack (which then contains the witness i.e. arguments, as well as some of the captured variables such as public keys or hashes) and accessing that environment by index would drastically reduce stack gymnastics while still retaining SCRIPT.</p>\n<h1><a name=\"softfork-semantics-2\" class=\"anchor\" href=\"#softfork-semantics-2\"></a>Softfork Semantics</h1>\n<p>A really cute part of chialisp is how they handle new opcodes.</p>\n<p>Before Taproot our only way to create new opcodes was by replacing <code>OP_NOP</code>.  This was restrictive because <code>OP_NOP</code> cannot change the stack, so it seemed that new opcodes that manipulate the stack were impossible to add.</p>\n<p>However, we can imagine an <code>OP_EVALINSOFTFORK</code> operation that can replace <code>OP_NOP</code> while allowing new opcodes that pop and push items onto the stack, congruent to the chialisp <code>softfork</code> form.</p>\n<p>The arguments to <code>OP_EVALINSOFTFORK</code> would be, from stack top:</p>\n<ul>\n<li>A softfork identifier</li>\n<li>A script to run with the softfork identified above.</li>\n<li>A number, specifying additional stack items to load into the initial stack of the given script (or alternatively, to load into the \u201ccurrent environment\u201d of the given script).</li>\n</ul>\n<p><code>OP_EVALINSOFTFORK</code> then evaluates the given script under the rules of the identified softfork with  a fresh separate stack from the outer script. If the softfork identifier is not recognized, then no validation is done \u2014 to allow softforks.  The script simply needs to succeed \u2014 it does not affect the stack of the outer script. This allows <code>OP_EVALINSOFTFORK</code> to replace <code>OP_NOP</code>, but the inner script can have new opcodes that change the stack because the inner stack is separate from the outer stack, and the only thing the inner script can signal is \u201cpass / fail\u201d.</p>\n<p>Of course as we all know, any <code>OP_EVAL</code> allows arbitrary looping, and <code>OP_EVALINSOFTFORK</code> allows this as well.  We can quine a script by loading itself into the \u201ccopy these items\u201d part of <code>OP_EVALINSOFTFORK</code>, which is sufficient to allow arbitrary looping.</p>\n<p>To prevent looping, we can turn to our inherent assumptions.  In Bitcoin, we assume that the cost of validating a transaction is proportional to its weight, i.e. the number of bytes, which is why feerates are based on weight.  To limit looping, we can require that if an <code>OP_EVALINSOFTFORK</code> evaluates its script, it keeps track of the number of actual operations executed, and continually compares it to the size of the input script.  All operations are counted as 1, except sub-<code>OP_EVALINSOFTFORK</code>, which is the actual number of operations executed inside it.  When an <code>OP_EVALINSOFTFORK</code> is executed inside another <code>OP_EVALINSOFTFORK</code>, the limit of the outer <code>OP_EVALINSOFTFORK</code>, as well as its accumulated number-of-operations, is passed to the inner <code>OP_EVALINSOFTFORK</code> (or stated differently, the outermost <code>OP_EVALINSOFTFORK</code> sets the limit and initializes number-of-operations to 0 for all inner <code>OP_EVALINSOFTFORK</code>, and inner <code>OP_EVALINSOFTFORK</code> just continue the same limit and number-of-operations variable).  Thus, quining must eventually terminate.  For non-looping uses, the size of the script must be greater than or equal to the number of <code>OP_</code> codes.</p>\n<p>The advantage of <code>OP_EVALINSOFTFORK</code> is that it replaces <code>OP_NOP</code> and can be used in pre-Taproot P2SH and P2WSH.  Another advantage of <code>OP_NOP</code> replacement is that we can use the scheme in <a href=\"https://delvingbitcoin.org/t/economic-majority-signaling-for-op-ctv-activation/635/6\" class=\"inline-onebox\">Economic-Majority Signaling for OP_CTV Activation - #6 by ZmnSCPxj</a> as well, even for activation of opcodes that manipulate stack (because such opcodes are inside an <code>OP_NOP</code>-replacing <code>OP_EVALINSOFTFORK</code>).</p>",
  "post_number": 10,
  "post_type": 1,
  "updated_at": "2024-03-21T00:19:14.595Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 15,
  "reads": 17,
  "readers_count": 16,
  "score": 78.4,
  "yours": false,
  "topic_id": 682,
  "topic_slug": "btc-lisp-as-an-alternative-to-script",
  "topic_title": "BTC Lisp as an alternative to Script",
  "topic_html_title": "BTC Lisp as an alternative to Script",
  "category_id": 7,
  "display_username": "ZmnSCPxj jxPCSnmZ",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Environment Objects\n===============\n\nA thing I should note from my days as a programming language theory nerd is that a Scheme (a kind of Lisp) can be implemented such that a Scheme interpreter is really a Scheme compiler that targets a stack virtual machine, and in fact toy implementations of Scheme often do this.\n\nNow in Scheme a function may capture variables that are not defined in its arguments or in its `let` forms, but outside of the function.  This gets compiled down to an array of values, the values being the captured variables.  These arrays are often called \"closures\" or \"environments\" --- it is likely that chialisp actually got the \"environment\" from this concept, and an actual chialisp virtual machine can probably optimize by putting the binary tree into an array and using array indexes to look up environments.\n\nNote that stack-based Scheme toy implementations will in fact allow you to create such closure/environment structures by popping of some number of items off the stack, and usually have a concept of \"the current environment\" which is often loaded when a function is entered.  Then there are convenient stack operations that just push corresponding items from the environment on the stack.\n\nAs we know, when experimenting with more complex SCRPT utilizing more complex covenants stuff like `OP_CAT`, a fair amount of code is futzing around the stack.  We could instead have a \"load stack items into current environment\" and \"push an item from a specific index of the current environment onto the stack\" as part of the stack-based actual underlying language, in order to assist this.\n\nIn particular, a Lisp expression `(f (g 2 3) (h 4 (i 6)))` can be compiled to a stack-based language like `<6> OP_I <4> OP_H <3> <2> OP_G OP_F`, i.e. reverse polish notation.  The problem with current Bitcoin SCRIPT is that accessing variables --- \"captured\" variables that are part of the SCRIPT commited to in the `scriptPubKey`, such as public keys, as well as \"argument\" variables that are part of the `witness` --- requires stack gymnastics.  Having operations to load a \"current environment\" from the stack (which then contains the witness i.e. arguments, as well as some of the captured variables such as public keys or hashes) and accessing that environment by index would drastically reduce stack gymnastics while still retaining SCRIPT.\n\nSoftfork Semantics\n===========\n\nA really cute part of chialisp is how they handle new opcodes.\n\nBefore Taproot our only way to create new opcodes was by replacing `OP_NOP`.  This was restrictive because `OP_NOP` cannot change the stack, so it seemed that new opcodes that manipulate the stack were impossible to add.\n\nHowever, we can imagine an `OP_EVALINSOFTFORK` operation that can replace `OP_NOP` while allowing new opcodes that pop and push items onto the stack, congruent to the chialisp `softfork` form.\n\nThe arguments to `OP_EVALINSOFTFORK` would be, from stack top:\n\n* A softfork identifier\n* A script to run with the softfork identified above.\n* A number, specifying additional stack items to load into the initial stack of the given script (or alternatively, to load into the \"current environment\" of the given script).\n\n`OP_EVALINSOFTFORK` then evaluates the given script under the rules of the identified softfork with  a fresh separate stack from the outer script. If the softfork identifier is not recognized, then no validation is done --- to allow softforks.  The script simply needs to succeed --- it does not affect the stack of the outer script. This allows `OP_EVALINSOFTFORK` to replace `OP_NOP`, but the inner script can have new opcodes that change the stack because the inner stack is separate from the outer stack, and the only thing the inner script can signal is \"pass / fail\".\n\nOf course as we all know, any `OP_EVAL` allows arbitrary looping, and `OP_EVALINSOFTFORK` allows this as well.  We can quine a script by loading itself into the \"copy these items\" part of `OP_EVALINSOFTFORK`, which is sufficient to allow arbitrary looping.\n\nTo prevent looping, we can turn to our inherent assumptions.  In Bitcoin, we assume that the cost of validating a transaction is proportional to its weight, i.e. the number of bytes, which is why feerates are based on weight.  To limit looping, we can require that if an `OP_EVALINSOFTFORK` evaluates its script, it keeps track of the number of actual operations executed, and continually compares it to the size of the input script.  All operations are counted as 1, except sub-`OP_EVALINSOFTFORK`, which is the actual number of operations executed inside it.  When an `OP_EVALINSOFTFORK` is executed inside another `OP_EVALINSOFTFORK`, the limit of the outer `OP_EVALINSOFTFORK`, as well as its accumulated number-of-operations, is passed to the inner `OP_EVALINSOFTFORK` (or stated differently, the outermost `OP_EVALINSOFTFORK` sets the limit and initializes number-of-operations to 0 for all inner `OP_EVALINSOFTFORK`, and inner `OP_EVALINSOFTFORK` just continue the same limit and number-of-operations variable).  Thus, quining must eventually terminate.  For non-looping uses, the size of the script must be greater than or equal to the number of `OP_` codes.\n\nThe advantage of `OP_EVALINSOFTFORK` is that it replaces `OP_NOP` and can be used in pre-Taproot P2SH and P2WSH.  Another advantage of `OP_NOP` replacement is that we can use the scheme in https://delvingbitcoin.org/t/economic-majority-signaling-for-op-ctv-activation/635/6 as well, even for activation of opcodes that manipulate stack (because such opcodes are inside an `OP_NOP`-replacing `OP_EVALINSOFTFORK`).",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 104,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}