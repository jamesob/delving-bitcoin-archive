{
  "id": 1928,
  "name": "Murch",
  "username": "murch",
  "avatar_template": "/user_avatar/delvingbitcoin.org/murch/{size}/139_2.png",
  "created_at": "2024-03-18T19:48:30.462Z",
  "cooked": "<p>This seems like a reasonable approach.</p>\n<aside class=\"quote no-group\" data-username=\"remyers\" data-post=\"1\" data-topic=\"600\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/remyers/48/159_2.png\" class=\"avatar\"> remyers:</div>\n<blockquote>\n<p>When fee rates are low, or a bucket is extremely depleted, we should proactively create change outputs to refill buckets. Initially I propose adding the largest utxo that is not in a bucket as an additional input to the transaction.</p>\n</blockquote>\n</aside>\n<p>I\u2019m confused here by the phrasing of an <em>additional</em> input? If the feerate is higher and you still need to refill, why not just pick a single large non-bucketed UTXO and create a several change outputs for the bucket you want to refill? If the feerate is low enough that you are proactively refilling buckets, why not sum up the amounts of several or all of the UTXOs you want to create and create all of those UTXOs alongside the liquidity transaction output by picking as many of the large non-bucketed UTXOs as necessary to create them?</p>\n<aside class=\"quote no-group\" data-username=\"remyers\" data-post=\"1\" data-topic=\"600\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/remyers/48/159_2.png\" class=\"avatar\"> remyers:</div>\n<blockquote>\n<p>That change output should opportunistically refill one (or more) of our target buckets. This can be done in different ways. Initially I propose setting the minimum change output size to an amount that refills the most depleted target bucket. This may add utxos from existing buckets.</p>\n</blockquote>\n</aside>\n<p>Perhaps you could make a few attempts at trying to find a \u201cchangeless solution\u201d to creating the liquidity transaction output plus one, two, or three amounts that your buckets are missing. You could perhaps generate a dozen or so different target amounts by combining various missing amounts and try to build transactions for each of them independently, and then use whatever gets a hit. I\u2019m surprised that you consider using bucketed UTXOs for this\u2014I expect that bucketed UTXOs would only be a fallback if you cannot fulfill the amount from non-bucketed UTXOs?</p>\n<aside class=\"quote no-group\" data-username=\"remyers\" data-post=\"1\" data-topic=\"600\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/remyers/48/159_2.png\" class=\"avatar\"> remyers:</div>\n<blockquote>\n<ul>\n<li>Does the concept of performing pre/post processing on the parameters of coin selection make sense or is there some way to optimize coin selection itself for this scenario?</li>\n</ul>\n</blockquote>\n</aside>\n<p>I am not sure I understand which coin selection parameters you consider pre- and post-processing here. If you mean the <code>min_change</code>, I think that you might get limited leverage out of that. I expect that the feerate is foreign determined by the general mempool situation. You may consider creating P2WPKH and P2TR outputs depending on the current feerate and what sort of change outputs you are creating. If you are creating bucketed change outputs at low feerates, you may want to make P2TR outputs, while you might want to opt for P2WPKH non-bucketed change outputs when building transactions at high feerates. Are there other parameters that you were considering?</p>\n<aside class=\"quote no-group\" data-username=\"remyers\" data-post=\"1\" data-topic=\"600\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/remyers/48/159_2.png\" class=\"avatar\"> remyers:</div>\n<blockquote>\n<ul>\n<li>Would it make sense to only use branch-and-bound and <a href=\"https://github.com/bitcoin/bitcoin/pull/27877\">CoinGrinder</a> as coin selection algorithms for this problem to reduce fees?</li>\n</ul>\n</blockquote>\n</aside>\n<p>I would agree that CoinGrinder and BnB would be more useful in your scenario than Knapsack and SRD. It might make sense to modify the <code>sendmany</code> RPC to allow restricting the coin selection to a subset of the coin selection algorithms or to patch out the calls to Knapsack and SRD from your node. Given that the post-processing of input set candidates is currently only based on the waste metric, It seems to me that you might want one call with the target consisting only of the liquidity transaction output, and if it doesn\u2019t return a changeless solution, several calls with targets composed from the liquidity transaction output plus one or multiple of the amounts missing from buckets. Given the intent to refill the buckets, perhaps the latter calls should be restricted to the non-bucketed UTXOs. Which brings me to the question, how would you distinguish non-bucketed and bucketed UTXOs? Would they be kept in separate wallets, separate amount ranges, marked in some manner?</p>\n<aside class=\"quote no-group\" data-username=\"remyers\" data-post=\"1\" data-topic=\"600\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/remyers/48/159_2.png\" class=\"avatar\"> remyers:</div>\n<blockquote>\n<ul>\n<li>Any ideas for a better algorithm for adding inputs and splitting change to converge on our target utxo set with the least on-chain fees?</li>\n</ul>\n</blockquote>\n</aside>\n<p>The approach seems reasonable to me. The only thing that comes to mind right now is that I have seen cases of oversplitting before: perhaps one thing to look out for in your simulations would be how often UTXOs split up later get recombined when a larger denomination would have been required and was unavailable. I suspect that being too proactive in refilling buckets may actually reduce the savings.</p>\n<aside class=\"quote no-group\" data-username=\"remyers\" data-post=\"1\" data-topic=\"600\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/remyers/48/159_2.png\" class=\"avatar\"> remyers:</div>\n<blockquote>\n<ul>\n<li>Are there other use cases that could use this functionality? coin join users perhaps?</li>\n</ul>\n</blockquote>\n</aside>\n<p>Your usage pattern reminds me of send-only exchange wallets, but there the possibility to batch many withdrawals into one transaction shifts the concerns to only needing a sufficient minimum of large-amount UTXOs rather than numerous specific values.</p>",
  "post_number": 3,
  "post_type": 1,
  "updated_at": "2024-03-18T19:48:30.462Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 1,
  "incoming_link_count": 0,
  "reads": 4,
  "readers_count": 3,
  "score": 0.2,
  "yours": false,
  "topic_id": 600,
  "topic_slug": "liquidity-provider-utxo-management",
  "topic_title": "Liquidity provider utxo management",
  "topic_html_title": "Liquidity provider utxo management",
  "category_id": 8,
  "display_username": "Murch",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": "",
  "bookmarked": false,
  "raw": "This seems like a reasonable approach.\n\n[quote=\"remyers, post:1, topic:600\"]\nWhen fee rates are low, or a bucket is extremely depleted, we should proactively create change outputs to refill buckets. Initially I propose adding the largest utxo that is not in a bucket as an additional input to the transaction.\n[/quote]\n\nI\u2019m confused here by the phrasing of an *additional* input? If the feerate is higher and you still need to refill, why not just pick a single large non-bucketed UTXO and create a several change outputs for the bucket you want to refill? If the feerate is low enough that you are proactively refilling buckets, why not sum up the amounts of several or all of the UTXOs you want to create and create all of those UTXOs alongside the liquidity transaction output by picking as many of the large non-bucketed UTXOs as necessary to create them?\n\n[quote=\"remyers, post:1, topic:600\"]\nThat change output should opportunistically refill one (or more) of our target buckets. This can be done in different ways. Initially I propose setting the minimum change output size to an amount that refills the most depleted target bucket. This may add utxos from existing buckets.\n[/quote]\n\nPerhaps you could make a few attempts at trying to find a \"changeless solution\" to creating the liquidity transaction output plus one, two, or three amounts that your buckets are missing. You could perhaps generate a dozen or so different target amounts by combining various missing amounts and try to build transactions for each of them independently, and then use whatever gets a hit. I\u2019m surprised that you consider using bucketed UTXOs for this\u2014I expect that bucketed UTXOs would only be a fallback if you cannot fulfill the amount from non-bucketed UTXOs?\n\n[quote=\"remyers, post:1, topic:600\"]\n* Does the concept of performing pre/post processing on the parameters of coin selection make sense or is there some way to optimize coin selection itself for this scenario?\n[/quote]\n\nI am not sure I understand which coin selection parameters you consider pre- and post-processing here. If you mean the `min_change`, I think that you might get limited leverage out of that. I expect that the feerate is foreign determined by the general mempool situation. You may consider creating P2WPKH and P2TR outputs depending on the current feerate and what sort of change outputs you are creating. If you are creating bucketed change outputs at low feerates, you may want to make P2TR outputs, while you might want to opt for P2WPKH non-bucketed change outputs when building transactions at high feerates. Are there other parameters that you were considering?\n\n[quote=\"remyers, post:1, topic:600\"]\n* Would it make sense to only use branch-and-bound and [CoinGrinder](https://github.com/bitcoin/bitcoin/pull/27877) as coin selection algorithms for this problem to reduce fees?\n[/quote]\n\nI would agree that CoinGrinder and BnB would be more useful in your scenario than Knapsack and SRD. It might make sense to modify the `sendmany` RPC to allow restricting the coin selection to a subset of the coin selection algorithms or to patch out the calls to Knapsack and SRD from your node. Given that the post-processing of input set candidates is currently only based on the waste metric, It seems to me that you might want one call with the target consisting only of the liquidity transaction output, and if it doesn\u2019t return a changeless solution, several calls with targets composed from the liquidity transaction output plus one or multiple of the amounts missing from buckets. Given the intent to refill the buckets, perhaps the latter calls should be restricted to the non-bucketed UTXOs. Which brings me to the question, how would you distinguish non-bucketed and bucketed UTXOs? Would they be kept in separate wallets, separate amount ranges, marked in some manner?\n\n[quote=\"remyers, post:1, topic:600\"]\n* Any ideas for a better algorithm for adding inputs and splitting change to converge on our target utxo set with the least on-chain fees?\n[/quote]\n\nThe approach seems reasonable to me. The only thing that comes to mind right now is that I have seen cases of oversplitting before: perhaps one thing to look out for in your simulations would be how often UTXOs split up later get recombined when a larger denomination would have been required and was unavailable. I suspect that being too proactive in refilling buckets may actually reduce the savings.\n\n[quote=\"remyers, post:1, topic:600\"]\n* Are there other use cases that could use this functionality? coin join users perhaps?\n[/quote]\n\nYour usage pattern reminds me of send-only exchange wallets, but there the possibility to batch many withdrawals into one transaction shifts the concerns to only needing a sufficient minimum of large-amount UTXOs rather than numerous specific values.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 58,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}