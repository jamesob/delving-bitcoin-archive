{
  "id": 1947,
  "name": "Anthony Towns",
  "username": "ajtowns",
  "avatar_template": "/user_avatar/delvingbitcoin.org/ajtowns/{size}/417_2.png",
  "created_at": "2024-03-20T02:18:55.989Z",
  "cooked": "<p>Some thoughts:</p>\n<ul>\n<li>\n<p>If you require the commitmed txids were sorted by txid before being committed to, you could index the txs in the block slightly more efficiently: for your example, <code>[2, 3, 0, 1]</code> could instead be expressed as <code>[2, 0, 0, 1]</code> which would indicate that you have three txs (2), one of which is immediately prior (skip 0 txs, txid1), another is immediately prior to that (skip 0 txs, txid2) and the final one is two txs prior to that (skip 1, txid0). Since you\u2019re getting smaller numbers (perhaps mostly 0), you should be able to do a pretty efficient bit-oriented encoding. Once you know you\u2019re commiting to [txid1, txid2, txid0], you just sort them, then hash the result to validate the commitment. OTOH, perhaps a larger tx that has constant size is better than a smaller one with variable size.</p>\n</li>\n<li>\n<p>I was going to say that I figure this would warrant a new mempool structure for a set of dependent txs that need to be mined together, but I think perhaps cluster mempool\u2019s chunking might be sufficient for that? If you have <code>tx1</code> and <code>tx2</code>, then a sponsor <code>s2</code> of <code>tx2</code>, followed by a sponsor <code>s12</code> of both, followed by a much higher feerate sponsor <code>s1</code> of just <code>tx1</code>, then that would perhaps cluster as <code>[tx1 s1], [tx2 s2 s12]</code>, and the only special processing you would need to do is to evict <code>s12</code> from the mempool if <code>tx1</code> is mined first. Note that in this case <code>tx1</code> might be much earlier in the block than <code>s12</code>, so the commitment index might be large. Obviously you need to track the relationship between <code>s12</code> and <code>tx1, tx2</code> etc, so that you can update the indexes in <code>s12</code> when including it in a block, and remove it from the mempool if either <code>tx1, tx2</code> were included in a block or if either of them are removed from the mempool for any other reason.</p>\n</li>\n<li>\n<p>Having sponsors and the tx they sponsor in the same chunk means the commitment index won\u2019t change depending on where in the block the tx goes; having it in a different chunk means it will change. Having the commitment index be unpredictable means the wtxid changes, which makes it difficult to cache the tx\u2019s validity (did the wtxid just change because of the commitment, or does it also have a different signature?), which presumably slows down block validation somewhat, which kind-of sucks. I guess we could introduce another txid type that skips committing to the sponsored txs\u2019 indexes, and cache validity based on that txid type.</p>\n</li>\n<li>\n<p>For a miner who isn\u2019t aware of sponsoring behaviour; they would consider any sponsoring tx non-standard in the first place and not accept them into their mempool at all, which would mean this mostly isn\u2019t a big deal for reorg safety as far as miners are concerned. This is different from coinbase outputs in that you\u2019d expect most reorgs to pick up the same sponsored tx, so spends of the sponsored tx would remain valid \u2013 contrast this to coinbase outputs, where ~100% of reorgs will involve the reward/fees going to a different miner/pool, ensuring spends of the original output would become invalid ~100% of the time.</p>\n</li>\n<li>\n<p>I think the incremental costs of different options of paying for a tx look like:</p>\n<ul>\n<li>adding an input and change: 100vb</li>\n<li>rbf\u2019ing a tx that already has a change output: 0vb</li>\n<li>cpfp\u2019ing a tx via its change output: 110vb</li>\n<li>adding an input and change via an ephemeral anchor: 160vb</li>\n<li>off-chain payment to a sponsor who has to create a new sponsoring tx: 112vb</li>\n<li>off-chain payment to a sponsor who can rbf an existing sponsoring tx with an additional 2B index: 0.5vb</li>\n<li>off-chain payment to a miner: 0vb</li>\n</ul>\n</li>\n</ul>",
  "post_number": 5,
  "post_type": 1,
  "updated_at": "2024-03-20T02:18:55.989Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 5,
  "readers_count": 4,
  "score": 0.8,
  "yours": false,
  "topic_id": 696,
  "topic_slug": "improving-transaction-sponsor-blockspace-efficiency",
  "topic_title": "Improving transaction sponsor blockspace efficiency",
  "topic_html_title": "Improving transaction sponsor blockspace efficiency",
  "category_id": 7,
  "display_username": "Anthony Towns",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Some thoughts:\n\n * If you require the commitmed txids were sorted by txid before being committed to, you could index the txs in the block slightly more efficiently: for your example, `[2, 3, 0, 1]` could instead be expressed as `[2, 0, 0, 1]` which would indicate that you have three txs (2), one of which is immediately prior (skip 0 txs, txid1), another is immediately prior to that (skip 0 txs, txid2) and the final one is two txs prior to that (skip 1, txid0). Since you're getting smaller numbers (perhaps mostly 0), you should be able to do a pretty efficient bit-oriented encoding. Once you know you're commiting to [txid1, txid2, txid0], you just sort them, then hash the result to validate the commitment. OTOH, perhaps a larger tx that has constant size is better than a smaller one with variable size.\n\n * I was going to say that I figure this would warrant a new mempool structure for a set of dependent txs that need to be mined together, but I think perhaps cluster mempool's chunking might be sufficient for that? If you have `tx1` and `tx2`, then a sponsor `s2` of `tx2`, followed by a sponsor `s12` of both, followed by a much higher feerate sponsor `s1` of just `tx1`, then that would perhaps cluster as `[tx1 s1], [tx2 s2 s12]`, and the only special processing you would need to do is to evict `s12` from the mempool if `tx1` is mined first. Note that in this case `tx1` might be much earlier in the block than `s12`, so the commitment index might be large. Obviously you need to track the relationship between `s12` and `tx1, tx2` etc, so that you can update the indexes in `s12` when including it in a block, and remove it from the mempool if either `tx1, tx2` were included in a block or if either of them are removed from the mempool for any other reason.\n\n * Having sponsors and the tx they sponsor in the same chunk means the commitment index won't change depending on where in the block the tx goes; having it in a different chunk means it will change. Having the commitment index be unpredictable means the wtxid changes, which makes it difficult to cache the tx's validity (did the wtxid just change because of the commitment, or does it also have a different signature?), which presumably slows down block validation somewhat, which kind-of sucks. I guess we could introduce another txid type that skips committing to the sponsored txs' indexes, and cache validity based on that txid type.\n\n * For a miner who isn't aware of sponsoring behaviour; they would consider any sponsoring tx non-standard in the first place and not accept them into their mempool at all, which would mean this mostly isn't a big deal for reorg safety as far as miners are concerned. This is different from coinbase outputs in that you'd expect most reorgs to pick up the same sponsored tx, so spends of the sponsored tx would remain valid -- contrast this to coinbase outputs, where ~100% of reorgs will involve the reward/fees going to a different miner/pool, ensuring spends of the original output would become invalid ~100% of the time.\n\n * I think the incremental costs of different options of paying for a tx look like:\n    * adding an input and change: 100vb\n    * rbf'ing a tx that already has a change output: 0vb\n    * cpfp'ing a tx via its change output: 110vb\n    * adding an input and change via an ephemeral anchor: 160vb\n    * off-chain payment to a sponsor who has to create a new sponsoring tx: 112vb\n    * off-chain payment to a sponsor who can rbf an existing sponsoring tx with an additional 2B index: 0.5vb\n    * off-chain payment to a miner: 0vb",
  "actions_summary": [],
  "moderator": true,
  "admin": true,
  "staff": true,
  "user_id": 3,
  "hidden": false,
  "trust_level": 4,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}