{
  "id": 1849,
  "name": "ProofOfKeags",
  "username": "ProofOfKeags",
  "avatar_template": "/user_avatar/delvingbitcoin.org/proofofkeags/{size}/156_2.png",
  "created_at": "2024-03-11T22:02:04.803Z",
  "cooked": "<p>Depending on how much pre-computation you want to do. You can embed all the different possibilities of which participant unilaterally exits as sibling tapleaves where the transaction creates utxos, one where the individual\u2019s share is ejected entirely, and another where the remaining participants share the utxo:</p>\n<p>Let\u2019s say you have a set of N parties, P, indexed from [0, N). You would construct N presigned transactions, with two outputs each, one that pays the ejected party their share, the other pays the remaining set their combined share. From there you have a recursively smaller problem, and you can do this all the way to 0. At first this looks like it has factorial complexity since every sequence of unilateral exits would create a different sequence of shared utxo outpoints. With APO or CTV you can cut it down to <span class=\"math\"> \\sum_{i=2}^{N} nCi  = O(N^3) </span> in offchain computation by sharing common scriptPubKeys since ejections commute. On chain, you get <span class=\"math\"> O(N) </span> I think.</p>\n<p>Regarding accumulators, it seems like the key requirement is that the consensus rules are capable of either computing or verifying the removal operation. Having an operation that could do this is probably a really useful general opcode.</p>\n<blockquote>\n<p>but those frikkin mathists like 1-character variable names too much, often with characters being in a different font being different things, which is crazy, like this is the first thing programmers get taught, do not use single-character variable names, what is wrong with mathists???</p>\n</blockquote>\n<p>It can be useful to do this because sometimes the shape is more important than the name when trying to grapple with the idea. By using single letter variable names it forces you to contend with the structure of the idea directly. Sometimes any name you give it necessarily forces you to look at it through an overly reductive lens. They could also just be dicks and be doing it unnecessarily, though <img src=\"https://delvingbitcoin.org/images/emoji/twitter/man_shrugging/2.png?v=12\" title=\":man_shrugging:t2:\" class=\"emoji\" alt=\":man_shrugging:t2:\" loading=\"lazy\" width=\"20\" height=\"20\"></p>",
  "post_number": 5,
  "post_type": 1,
  "updated_at": "2024-03-11T22:02:04.803Z",
  "reply_count": 1,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 21,
  "readers_count": 20,
  "score": 9.2,
  "yours": false,
  "topic_id": 664,
  "topic_slug": "unilateral-exit",
  "topic_title": "Unilateral Exit",
  "topic_html_title": "Unilateral Exit",
  "category_id": 7,
  "display_username": "ProofOfKeags",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Depending on how much pre-computation you want to do. You can embed all the different possibilities of which participant unilaterally exits as sibling tapleaves where the transaction creates utxos, one where the individual's share is ejected entirely, and another where the remaining participants share the utxo:\n\nLet's say you have a set of N parties, P, indexed from [0, N). You would construct N presigned transactions, with two outputs each, one that pays the ejected party their share, the other pays the remaining set their combined share. From there you have a recursively smaller problem, and you can do this all the way to 0. At first this looks like it has factorial complexity since every sequence of unilateral exits would create a different sequence of shared utxo outpoints. With APO or CTV you can cut it down to $ \\sum_{i=2}^{N} nCi  = O(N^3) $ in offchain computation by sharing common scriptPubKeys since ejections commute. On chain, you get $ O(N) $ I think.\n\nRegarding accumulators, it seems like the key requirement is that the consensus rules are capable of either computing or verifying the removal operation. Having an operation that could do this is probably a really useful general opcode.\n\n> but those frikkin mathists like 1-character variable names too much, often with characters being in a different font being different things, which is crazy, like this is the first thing programmers get taught, do not use single-character variable names, what is wrong with mathists???\n\nIt can be useful to do this because sometimes the shape is more important than the name when trying to grapple with the idea. By using single letter variable names it forces you to contend with the structure of the idea directly. Sometimes any name you give it necessarily forces you to look at it through an overly reductive lens. They could also just be dicks and be doing it unnecessarily, though \ud83e\udd37\ud83c\udffb\u200d\u2642\ufe0f",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 138,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}