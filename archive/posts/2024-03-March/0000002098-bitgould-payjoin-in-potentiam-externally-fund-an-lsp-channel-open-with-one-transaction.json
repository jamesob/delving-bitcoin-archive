{
  "id": 2098,
  "name": "Dan Gould",
  "username": "bitgould",
  "avatar_template": "/letter_avatar_proxy/v4/letter/b/ac91a4/{size}.png",
  "created_at": "2024-03-30T17:02:46.714Z",
  "cooked": "<p>Thanks very much for the prompt response and corrections. I understand this nuance and see how the steps I\u2019ve described failed to describe it accurately. It is confusing to have combined Alice\u2019s node and the Source of Funds in the flows. I\u2019ve edited the original post to make a distinction.</p>\n<h2><a name=\"the-problem-payjoin-in-potentiam-solves-1\" class=\"anchor\" href=\"#the-problem-payjoin-in-potentiam-solves-1\"></a>The problem payjoin-in-potentiam solves</h2>\n<blockquote>\n<p>The whole point of swap-in-potentiam is that it is an onchain address, with onchain address rules (including miniimum confirmation depth), that can be magically spent in Lightning (after minimum confirmation depth). The inputs to the transaction should be swap-in-potentiam addresses, not outputs.</p>\n</blockquote>\n<blockquote>\n<p>i.e. somebody else (NOT Alice!) funds the swap-in-potentiam address. That somebody else might not even know who the Bob is.</p>\n</blockquote>\n<p>Swap-in-potentiam always posts two transactions. Funds are be confirmed into a swap address before a channel is opened. Payjoin-in-potentiam adds an optimistic case to the protocol. Alice generates a payjoin bip21 URI containing a swap-in-potentiam address, tells the source of funds about it and the source of funds starts a payjoin sending to the swap address with Bob. <em>If alice is found NOT to be asleep</em> before the payjoin protocol expires, Bob takes advantage of that and combines a channel open with proposed external input from the source of funds in a single transaction rather than confirming funds into a swap-in contract first and then following that confirmation with a channel opening transaction. If alice is asleep for the payjoin protocol (e.g. after 1 minute payjoin expiration), Bob broadcasts the original PSBT transaction funding the swap-in-potentiam address and can open a channel with the swap address funding after the fact. This cuts the on-chain footprint of swap-in-potentiam channel opens by about half in the best case and maintains the magic of swap-in-potentiam.</p>\n<h2><a name=\"fetching-the-public-key-from-the-lsp-2\" class=\"anchor\" href=\"#fetching-the-public-key-from-the-lsp-2\"></a>Fetching the public key from the LSP</h2>\n<blockquote>\n<p>There is no need for steps 1 and 2. Alice knows a public key controlled by Bob, namely, the node ID of Bob. Alice can generate its own keypair. The Alice pubkey is expected to be made by some form of BIP32 (HD derivation). The reason for not asking for a swap address is that it allows Alice to implement a watch-only onchain wallet using only BIP32 HD derivation.</p>\n</blockquote>\n<p>At some point Alice does need to fetch Bob\u2019s public key after which it can be derived. Neat. I\u2019ve changed the post to reflect.</p>\n<h2><a name=\"musig2-3\" class=\"anchor\" href=\"#musig2-3\"></a>MuSig2</h2>\n<blockquote>\n<p>all inputs to the funding transaction MUST be those with the same LSP-as-Bob. The Alice keys can differ. For this reason, PSBT is specifically not used, instead this sub-protocol sends the inputs and the order of the outputs in a bespoke format. This also allows this sub-protocol to use MuSig2 path as current PSBT has no MuSig2 support yet.</p>\n</blockquote>\n<p>Payjoin-in-potentiam removes this hard input requirement in the case that both Alice comes online before the payjoin window expires by using interaction. If Alice comes online before the payjoin expires, Alice can MuSig2 with Bob to create the channel output and create a transaction with external funds as input in a single transaction before funds land in a swap address. If the payjoin fails, funds still end up in the swap address and the swap-in-potentiam protocol is executed.</p>\n<p>If I were designing a bespoke MuSig2 protocol, I\u2019d still consider PSBT instead of something totally bespoke so that once the MuSig2 support is added to PSBT, software supporting PSBT already can quickly support swap-in-potentiam. Have you considered using the <a href=\"https://gist.github.com/sanket1729/4b525c6049f4d9e034d27368c49f28a6\" rel=\"noopener nofollow ugc\">MuSig2 PSBT extension draft by Sanket</a> and <a href=\"https://bitcoinops.org/en/bitgo-musig2/\" rel=\"noopener nofollow ugc\">deployed by BitGo</a> in your bespoke protocol?</p>\n<p>I\u2019m sure you\u2019ve already thought deeply about how the bespoke sub-protocol operates, so please excuse my suggestions as naive if you\u2019ve already given them thought. I know how hard protocol design can be and have only recently explored swap-in-potentiam as an avenue to make lightning onboarding cheaper and easier.</p>",
  "post_number": 4,
  "post_type": 1,
  "updated_at": "2024-03-30T17:02:46.714Z",
  "reply_count": 1,
  "reply_to_post_number": 3,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 5,
  "readers_count": 4,
  "score": 6.0,
  "yours": false,
  "topic_id": 749,
  "topic_slug": "payjoin-in-potentiam-externally-fund-an-lsp-channel-open-with-one-transaction",
  "topic_title": "Payjoin-in-Potentiam: Externally fund an LSP channel open with one transaction",
  "topic_html_title": "Payjoin-in-Potentiam: Externally fund an LSP channel open with one transaction",
  "category_id": 7,
  "display_username": "Dan Gould",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "reply_to_user": {
    "username": "ZmnSCPxj",
    "name": "ZmnSCPxj jxPCSnmZ",
    "avatar_template": "/letter_avatar_proxy/v4/letter/z/ee7513/{size}.png"
  },
  "bookmarked": false,
  "raw": "Thanks very much for the prompt response and corrections. I understand this nuance and see how the steps I've described failed to describe it accurately. It is confusing to have combined Alice's node and the Source of Funds in the flows. I've edited the original post to make a distinction.\n\n## The problem payjoin-in-potentiam solves\n\n> The whole point of swap-in-potentiam is that it is an onchain address, with onchain address rules (including miniimum confirmation depth), that can be magically spent in Lightning (after minimum confirmation depth). The inputs to the transaction should be swap-in-potentiam addresses, not outputs.\n\n> i.e. somebody else (NOT Alice!) funds the swap-in-potentiam address. That somebody else might not even know who the Bob is.\n\nSwap-in-potentiam always posts two transactions. Funds are be confirmed into a swap address before a channel is opened. Payjoin-in-potentiam adds an optimistic case to the protocol. Alice generates a payjoin bip21 URI containing a swap-in-potentiam address, tells the source of funds about it and the source of funds starts a payjoin sending to the swap address with Bob. *If alice is found NOT to be asleep* before the payjoin protocol expires, Bob takes advantage of that and combines a channel open with proposed external input from the source of funds in a single transaction rather than confirming funds into a swap-in contract first and then following that confirmation with a channel opening transaction. If alice is asleep for the payjoin protocol (e.g. after 1 minute payjoin expiration), Bob broadcasts the original PSBT transaction funding the swap-in-potentiam address and can open a channel with the swap address funding after the fact. This cuts the on-chain footprint of swap-in-potentiam channel opens by about half in the best case and maintains the magic of swap-in-potentiam.\n\n## Fetching the public key from the LSP\n\n> There is no need for steps 1 and 2. Alice knows a public key controlled by Bob, namely, the node ID of Bob. Alice can generate its own keypair. The Alice pubkey is expected to be made by some form of BIP32 (HD derivation). The reason for not asking for a swap address is that it allows Alice to implement a watch-only onchain wallet using only BIP32 HD derivation.\n\nAt some point Alice does need to fetch Bob's public key after which it can be derived. Neat. I've changed the post to reflect.\n\n## MuSig2\n\n> all inputs to the funding transaction MUST be those with the same LSP-as-Bob. The Alice keys can differ. For this reason, PSBT is specifically not used, instead this sub-protocol sends the inputs and the order of the outputs in a bespoke format. This also allows this sub-protocol to use MuSig2 path as current PSBT has no MuSig2 support yet.\n\nPayjoin-in-potentiam removes this hard input requirement in the case that both Alice comes online before the payjoin window expires by using interaction. If Alice comes online before the payjoin expires, Alice can MuSig2 with Bob to create the channel output and create a transaction with external funds as input in a single transaction before funds land in a swap address. If the payjoin fails, funds still end up in the swap address and the swap-in-potentiam protocol is executed.\n\nIf I were designing a bespoke MuSig2 protocol, I'd still consider PSBT instead of something totally bespoke so that once the MuSig2 support is added to PSBT, software supporting PSBT already can quickly support swap-in-potentiam. Have you considered using the [MuSig2 PSBT extension draft by Sanket](https://gist.github.com/sanket1729/4b525c6049f4d9e034d27368c49f28a6) and [deployed by BitGo](https://bitcoinops.org/en/bitgo-musig2/) in your bespoke protocol?\n\nI'm sure you've already thought deeply about how the bespoke sub-protocol operates, so please excuse my suggestions as naive if you've already given them thought. I know how hard protocol design can be and have only recently explored swap-in-potentiam as an avenue to make lightning onboarding cheaper and easier.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 17,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}