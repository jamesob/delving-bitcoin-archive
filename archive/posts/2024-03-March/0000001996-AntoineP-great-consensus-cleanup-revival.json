{
  "id": 1996,
  "name": "Antoine Poinsot",
  "username": "AntoineP",
  "avatar_template": "/letter_avatar_proxy/v4/letter/a/8e8cbc/{size}.png",
  "created_at": "2024-03-24T17:29:42.691Z",
  "cooked": "<p>I\u2019ve been working on revisiting Matt Corallo\u2019s <a href=\"https://github.com/TheBlueMatt/bips/blob/7f9670b643b7c943a0cc6d2197d3eabe661050c2/bip-XXXX.mediawiki\">Great Consensus Cleanup proposal</a>. I was interested in figuring:</p>\n<ol>\n<li>How bad the bugs actually are;</li>\n<li>How much the proposed fixes improve the worst case;</li>\n<li>Whether we can do better now we\u2019ve had 5 more years of experience;</li>\n<li>Whether there is anything else which would be worth fixing.</li>\n</ol>\n<p><strong>TL;DR</strong>: i think it\u2019s bad. The worst case block validation time is concerning. I also believe it\u2019s more important to fix the timewarp vulnerability than people usually think. Finally i think we can include a fix to avoid performing BIP30 validation after block 1,983,702 as well as an additional limitation on the maximum size of legacy transactions would provide a desirable safety margin with regard to block validation time.</p>\n<p>With this post i intend to kick off a discussion about the protocol bugs mitigated by the Great Consensus Cleanup proposal. I\u2019d like to gather comments and opinions about each of the mitigations proposed, as well as potential suggestions for more fixes. I will go through each of the bugs one by one. The section about the block validation time was significantly redacted: i\u2019m sharing the numbers publicly but the details of the strategies to come up with a bad block will only be shared with regular Bitcoin Core contributors and a few other Bitcoin protocol developers.</p>\n<h2><a name=\"timewarp-1\" class=\"anchor\" href=\"#timewarp-1\"></a>Timewarp</h2>\n<p>The timewarp vulnerability exploits how difficulty adjustment periods don\u2019t overlap. Miners can take advantage of this by setting the timestamp of the last block in a retarget period as much in the future as possible (now + 2h) while holding back the timestamps of all the other blocks to artificially reduce the difficulty. See <a href=\"https://bitcoin.stackexchange.com/a/75834/101498\">this stackexchange answer</a> for a more detailed explanation.</p>\n<h3><a name=\"how-bad-is-it-2\" class=\"anchor\" href=\"#how-bad-is-it-2\"></a>How bad is it?</h3>\n<p>It\u2019s interesting to consider both how it worsens the situation and what it enables concretely. After all, miners can always hold back the timestamps even without exploiting the timewarp vulnerability.  But without setting the timestamp of the first block of a period before the timestamp of the last block of the preceding period, taking advantage of this necessarily involves bumping the difficulty back up. Therefore such an attack wouldn\u2019t achieve much: at best it could allow to mine 3 retarget intervals in 5 weeks instead of 6. On the other hand by setting the timestamp of the first block of a period below the one of the preceding period\u2019s last block an attacker can continuously take advantage of the low difficulty while continuing to reduce it.</p>\n<p>In practice an attacker could fatally hurt the network within a bit over a month of starting the attack. By starting at time <code>t</code> and period <code>N</code>, the attacker can already halve the difficulty at the end of period <code>N+1</code>. Which allows him to mine period <code>N+2</code> in a single week, further reducing the difficulty by a 2.5x factor. Etc\u2026 Within less than 40 days the attacker would bring the difficulty down to 1, letting him mine millions of blocks. Besides claiming all the remaining subsidy, this would destroy the security of any L2 protocol relying on timelocks as well as exacerbate DoS vectors (for instance if this is combined with a spam of the UTxO set).</p>\n<p>This disregards the MTP rule which would anyways at best be a small annoyance to the attacker.  However this begs the question: although the attack requires a majority hashrate, is it a winning strategy for a minority hashrate to try to opportunistically exploit this? That is, if mining the last block of a retarget period set the timestamp as much in the future as possible and if mining any other block set the timestamp as far back as the MTP rule will let you. Technically it comes at no (measurable) cost to the miner, but it <em>might</em> give him (and other miners) a slight increase in block reward at the expense of future miners. Turns out the marginal gain by adopting this strategy is ridiculously small for any minority hashrate therefore we can reasonably expect miners to not try to opportunistically exploit timewarp.</p>\n<h3><a name=\"should-we-really-fix-it-3\" class=\"anchor\" href=\"#should-we-really-fix-it-3\"></a>Should we really fix it?</h3>\n<p>Some have argued miners would not purposefully shoot themselves in the foot. In fact, it\u2019s not realistic to expect they would kill the chain. Instead they would likely settle on an equilibrium of increasing the frequency of blocks by X%. I\u2019ll let readers draw their own conclusion with regard to the political implications of miners being able to increase the available block space without a change in nodes\u2019 consensus rules. Let\u2019s point out however that a cartel of miners forming to, even if only slightly, decrease the difficulty by exploiting the timewarp vulnerability would put the network constantly on the brink of getting taken down in a few weeks.</p>\n<p>Another common arguments is how it\u2019s less of a priority to fix because the attack would be obvious and take time. I\u2019m fairly sceptical of any argument which involves users coordinating and deciding of the validity of a block at any given height independently of the current consensus rules.  Besides, a month isn\u2019t a lot of time to coordinate and change Bitcoin\u2019s consensus rules. Further, as mentioned previously it\u2019s not even clear there would be widespread consensus for doing so. Users like lower fees and miners like more subsidy. Given the current distribution of control over hashrate and the exponentially decreasing block subsidy, it\u2019s not unreasonable to think a cartel could form to exploit the timewarp vulnerability.</p>\n<p>Finally, some have argued it\u2019s less of a priority because the attack requires a majority of the hashpower anyways. I believe it\u2019s severely lacking nuance. Exploiting the timewarp vulnerability significantly increases the harm which a 51% attacker can do. He can normally \u201conly\u201d temporarily censor transactions. With timewarp he can potentially ruin the network.</p>\n<h3><a name=\"can-we-come-up-with-a-better-fix-4\" class=\"anchor\" href=\"#can-we-come-up-with-a-better-fix-4\"></a>Can we come up with a better fix?</h3>\n<p>Probably not. The fix is straightforward: make the retarget periods overlap. Matt\u2019s proposed change is the most simple and obvious way of achieving this: constrain the timestamp of the first block in a period compared to the timestamp of the last block of the preceding period.</p>\n<h2><a name=\"worst-case-block-validation-time-5\" class=\"anchor\" href=\"#worst-case-block-validation-time-5\"></a>Worst case block validation time</h2>\n<p>It\u2019s well known maliciously crafted non-Segwit transactions can be pretty expensive to validate.  Large block validation times could give attacking miners an unfair advantage, hinder block propagation (and its uniformity) across the network or even have detrimental consequences on software relying on block availability. To this effect the Great Consensus Cleanup proposal includes a number of additional constraints on legacy Script usage.</p>\n<h3><a name=\"how-bad-is-it-6\" class=\"anchor\" href=\"#how-bad-is-it-6\"></a>How bad is it?</h3>\n<p>It\u2019s bad. The worst block i could come up with takes around 3 minutes to validate with all 16 cores of my modern laptop\u2019s CPU and a hour and a half of a RPi4. For obvious reasons i\u2019ve redacted here the details of such block, as well as the various approaches to create similarly expensive-to-validate blocks. I\u2019ll share them in a semi-private companion post to other protocol developers using the private working group feature of Delving. If you think you should be in this working group and i forgot to add you, let me know.</p>\n<p><a href=\"https://delvingbitcoin.org/t/worst-block-validation-time-inquiry/711/3#redacted-block-1-1\"><em>REDACTED #1</em></a></p>\n<h3><a name=\"how-much-does-the-proposal-improve-the-worst-case-can-we-come-up-with-more-effective-mitigations-7\" class=\"anchor\" href=\"#how-much-does-the-proposal-improve-the-worst-case-can-we-come-up-with-more-effective-mitigations-7\"></a>How much does the proposal improve the worst case? Can we come up with more effective mitigations?</h3>\n<p>The mitigation proposed in the Great Consensus Cleanup makes the block i came up with in the previous section invalid. The worst block under the new constraints takes 5 seconds to validate on my laptop. I believe we could further introduce a limitation on the size of legacy transactions to be on the safe side.</p>\n<p>Some confiscation concerns were raised about the proposed mitigations. I believe those concerns are reasonable and could be addressed by only applying the new rules when checking the script for an output created after a certain block height.</p>\n<p><a href=\"https://delvingbitcoin.org/t/worst-block-validation-time-inquiry/711/3#redacted-block-2-1\"><em>REDACTED #2</em></a></p>\n<h2><a name=\"merkle-tree-attacks-using-64-bytes-transactions-8\" class=\"anchor\" href=\"#merkle-tree-attacks-using-64-bytes-transactions-8\"></a>Merkle tree attacks using 64 bytes transactions</h2>\n<p>There are two (known) remaining attacks with how the merkle root in Bitcoin blocks is computed. Both involve creating a catenation of two 32 bytes hashes which successfully deserializes as a Bitcoin transaction. One (probably the most famous) is about \u201cgoing down\u201d the merkle tree by tricking a light client into accepting as payment a transaction which was not in fact committed into a block: a 64 bytes transaction is committed to the block whose last 32 bytes correspond to the txid of a non-committed transaction paying the victim. The other one \u201cgoes up\u201d the merkle tree, by tricking a node into treating a valid block as permanently invalid: find a row of tree nodes which all deserialize as (invalid) 64-bytes transactions. For more details see <a href=\"https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-February/016697.html\">this writeup</a> by Suhas Daftuar.</p>\n<p>The Great Consensus Cleanup proposes to make 64-bytes-or-less transactions invalid altogether, fixing both vulnerabilities.</p>\n<h3><a name=\"how-bad-is-it-9\" class=\"anchor\" href=\"#how-bad-is-it-9\"></a>How bad is it?</h3>\n<p>The attack against light clients (or anything which may accept a merkle proof, like a sidechain) requires to bruteforce between 61 and ~75 bits, depending on the amount of bitcoins dedicated to the attack. This is expensive, and simple mitigations exist. For instance checking the depth of the tree, which gives you the number of transactions in the block, by asking for a merkle proof of the coinbase transaction).</p>\n<p>That said, the attack <a href=\"https://bitslog.com/2018/06/09/leaf-node-weakness-in-bitcoin-merkle-tree-design/\">was estimated to cost around $1M</a> when \u201cstate-of-the-art Bitcoin [ASICS] reached 14 TH/s\u201d. Nowadays, <a href=\"https://whatsminer-microbt.com/product/whatsminer-m63s/\">looks like</a> top ASICs reach 400TH/s. In addition, this attack allows to fake an arbitrary number of confirmations for the transaction. And the cost to simply mine a single fake block to fool an SPV client, which doesn\u2019t, is now higher (80 bits).</p>\n<p>The attack to fork Bitcoin nodes is mitigated in Bitcoin Core for invalid transactions by not caching contextless block checks (<code>CheckBlock()</code>). Creating valid transactions is not practical: the first one must be a coinbase transaction, which requires bruteforcing 224 bits.</p>\n<p>64 bytes transactions, due to how the merkle root in blocks is computed, is a core weakness in Bitcoin.  Although both (known) attacks it enables can be mitigated it would be nice to avoid this footgun as well as being able to cache contextless block checks in Bitcoin Core.</p>\n<h3><a name=\"can-we-come-up-with-a-better-fix-10\" class=\"anchor\" href=\"#can-we-come-up-with-a-better-fix-10\"></a>Can we come up with a better fix?</h3>\n<p>64 bytes transactions cannot be \u201csecure\u201d, as in 64 bytes in a transaction is not enough to have an output whose locking script won\u2019t be anyone-can-spend or lock the coins forever. They have no known use and have been non-standard for half a decade. Given the vulnerabilities they introduce and their lack of use, it is more than reasonable to make them invalid.</p>\n<p>However the BIP proposes to also make less-than-64-bytes transactions invalid. Although they are of no (or little) use, such transactions are not harmful. I believe considering a type of transaction useless is not sufficient motivation for making them invalid through a soft fork.</p>\n<p>Making (exactly) 64 bytes long transactions invalid is also what AJ implemented in <a href=\"https://github.com/bitcoin-inquisition/bitcoin/pull/24\">his pull request to Bitcoin-inquisition</a>.</p>\n<h2><a name=\"wishlist-11\" class=\"anchor\" href=\"#wishlist-11\"></a>Wishlist</h2>\n<h3><a name=\"bip30-verification-12\" class=\"anchor\" href=\"#bip30-verification-12\"></a>BIP30 verification</h3>\n<p>BIP34 temporarily made it possible to avoid the relatively expensive BIP30 check on every block connection. Starting at block height 1,983,702 it won\u2019t be possible to rely solely on BIP34 anymore.  If a soft fork is proposed to cleanup long standing protocol bugs it would be nice if it made coinbase transactions unique once and for all.</p>\n<p>A neat fix would be to simply requires the <code>nLockTime</code> field of the coinbase transaction to be set to the height of the block being created. However there is a more roundabout fix which is potentially easier for miners to deploy: make the witness commitment mandatory in all coinbase transactions (h/t Greg Sanders). I have yet to check if there is any violation of this but i\u2019d be surprised if there is a pre-Segwit coinbase transaction with an output pushing exactly the witness commitment header followed by 32 <code>0x00</code> bytes.</p>\n<h3><a name=\"your-favorite-bug-13\" class=\"anchor\" href=\"#your-favorite-bug-13\"></a>Your favorite bug!</h3>\n<p>At this stage i\u2019m interested in gathering as many suggestions for cleanups as i can, to make sure that if such a soft fork were to be proposed, we would have carefully analyzed all the fixes we\u2019d like to include.</p>\n<p>Of course, suggestions need to be reasonable to be considered. For instance, \u201cbanning ordinals\u201d is an uninteresting suggestion and i doubt many would engage with it. In addition, let\u2019s keep suggestions focused on long-standing uncontroversial bugs. For instance \u201ca block which takes 30 minutes to validate is bad\u201d, \u201cthe broken merkle tree calculation is creating footguns\u201d or \u201clet\u2019s make coinbase transactions <em>actually</em> unique\u201d seem fairly uncontroversial. On the other hand while reasonable arguments for \u201clet\u2019s decrease the block size limit\u201d can be put forth, it seems much more controversial to me.</p>\n<p>For instance here is a couple things i wasn\u2019t convinced were worth proposing:</p>\n<ul>\n<li>Requiring standard SIGHASH type bytes for Segwit v0 too;</li>\n<li>Limiting the maximum size of scriptPubKey\u2019s to reduce the worst case UTxO set growth.</li>\n</ul>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2024-03-24T19:53:27.073Z",
  "reply_count": 1,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 95,
  "reads": 25,
  "readers_count": 24,
  "score": 640.0,
  "yours": false,
  "topic_id": 710,
  "topic_slug": "great-consensus-cleanup-revival",
  "topic_title": "Great Consensus Cleanup Revival",
  "topic_html_title": "Great Consensus Cleanup Revival",
  "category_id": 7,
  "display_username": "Antoine Poinsot",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 3,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "I've been working on revisiting Matt Corallo's [Great Consensus Cleanup proposal](https://github.com/TheBlueMatt/bips/blob/7f9670b643b7c943a0cc6d2197d3eabe661050c2/bip-XXXX.mediawiki). I was interested in figuring:\n1. How bad the bugs actually are;\n2. How much the proposed fixes improve the worst case;\n3. Whether we can do better now we've had 5 more years of experience;\n4. Whether there is anything else which would be worth fixing.\n\n**TL;DR**: i think it's bad. The worst case block validation time is concerning. I also believe it's more important to fix the timewarp vulnerability than people usually think. Finally i think we can include a fix to avoid performing BIP30 validation after block 1,983,702 as well as an additional limitation on the maximum size of legacy transactions would provide a desirable safety margin with regard to block validation time.\n\nWith this post i intend to kick off a discussion about the protocol bugs mitigated by the Great Consensus Cleanup proposal. I'd like to gather comments and opinions about each of the mitigations proposed, as well as potential suggestions for more fixes. I will go through each of the bugs one by one. The section about the block validation time was significantly redacted: i'm sharing the numbers publicly but the details of the strategies to come up with a bad block will only be shared with regular Bitcoin Core contributors and a few other Bitcoin protocol developers.\n\n## Timewarp\n\nThe timewarp vulnerability exploits how difficulty adjustment periods don't overlap. Miners can take advantage of this by setting the timestamp of the last block in a retarget period as much in the future as possible (now + 2h) while holding back the timestamps of all the other blocks to artificially reduce the difficulty. See [this stackexchange answer](https://bitcoin.stackexchange.com/a/75834/101498) for a more detailed explanation.\n\n### How bad is it?\n\nIt's interesting to consider both how it worsens the situation and what it enables concretely. After all, miners can always hold back the timestamps even without exploiting the timewarp vulnerability.  But without setting the timestamp of the first block of a period before the timestamp of the last block of the preceding period, taking advantage of this necessarily involves bumping the difficulty back up. Therefore such an attack wouldn't achieve much: at best it could allow to mine 3 retarget intervals in 5 weeks instead of 6. On the other hand by setting the timestamp of the first block of a period below the one of the preceding period's last block an attacker can continuously take advantage of the low difficulty while continuing to reduce it.\n\nIn practice an attacker could fatally hurt the network within a bit over a month of starting the attack. By starting at time `t` and period `N`, the attacker can already halve the difficulty at the end of period `N+1`. Which allows him to mine period `N+2` in a single week, further reducing the difficulty by a 2.5x factor. Etc.. Within less than 40 days the attacker would bring the difficulty down to 1, letting him mine millions of blocks. Besides claiming all the remaining subsidy, this would destroy the security of any L2 protocol relying on timelocks as well as exacerbate DoS vectors (for instance if this is combined with a spam of the UTxO set).\n\nThis disregards the MTP rule which would anyways at best be a small annoyance to the attacker.  However this begs the question: although the attack requires a majority hashrate, is it a winning strategy for a minority hashrate to try to opportunistically exploit this? That is, if mining the last block of a retarget period set the timestamp as much in the future as possible and if mining any other block set the timestamp as far back as the MTP rule will let you. Technically it comes at no (measurable) cost to the miner, but it *might* give him (and other miners) a slight increase in block reward at the expense of future miners. Turns out the marginal gain by adopting this strategy is ridiculously small for any minority hashrate therefore we can reasonably expect miners to not try to opportunistically exploit timewarp.\n\n### Should we really fix it?\n\nSome have argued miners would not purposefully shoot themselves in the foot. In fact, it's not realistic to expect they would kill the chain. Instead they would likely settle on an equilibrium of increasing the frequency of blocks by X%. I'll let readers draw their own conclusion with regard to the political implications of miners being able to increase the available block space without a change in nodes' consensus rules. Let's point out however that a cartel of miners forming to, even if only slightly, decrease the difficulty by exploiting the timewarp vulnerability would put the network constantly on the brink of getting taken down in a few weeks.\n\nAnother common arguments is how it's less of a priority to fix because the attack would be obvious and take time. I'm fairly sceptical of any argument which involves users coordinating and deciding of the validity of a block at any given height independently of the current consensus rules.  Besides, a month isn't a lot of time to coordinate and change Bitcoin's consensus rules. Further, as mentioned previously it's not even clear there would be widespread consensus for doing so. Users like lower fees and miners like more subsidy. Given the current distribution of control over hashrate and the exponentially decreasing block subsidy, it's not unreasonable to think a cartel could form to exploit the timewarp vulnerability.\n\nFinally, some have argued it's less of a priority because the attack requires a majority of the hashpower anyways. I believe it's severely lacking nuance. Exploiting the timewarp vulnerability significantly increases the harm which a 51% attacker can do. He can normally \"only\" temporarily censor transactions. With timewarp he can potentially ruin the network.\n\n### Can we come up with a better fix?\n\nProbably not. The fix is straightforward: make the retarget periods overlap. Matt's proposed change is the most simple and obvious way of achieving this: constrain the timestamp of the first block in a period compared to the timestamp of the last block of the preceding period.\n\n\n## Worst case block validation time\n\nIt's well known maliciously crafted non-Segwit transactions can be pretty expensive to validate.  Large block validation times could give attacking miners an unfair advantage, hinder block propagation (and its uniformity) across the network or even have detrimental consequences on software relying on block availability. To this effect the Great Consensus Cleanup proposal includes a number of additional constraints on legacy Script usage.\n\n### How bad is it?\n\nIt's bad. The worst block i could come up with takes around 3 minutes to validate with all 16 cores of my modern laptop's CPU and a hour and a half of a RPi4. For obvious reasons i've redacted here the details of such block, as well as the various approaches to create similarly expensive-to-validate blocks. I'll share them in a semi-private companion post to other protocol developers using the private working group feature of Delving. If you think you should be in this working group and i forgot to add you, let me know.\n\n[*REDACTED #1*](https://delvingbitcoin.org/t/worst-block-validation-time-inquiry/711/3?u=antoinep#redacted-block-1-1)\n\n### How much does the proposal improve the worst case? Can we come up with more effective mitigations?\n\nThe mitigation proposed in the Great Consensus Cleanup makes the block i came up with in the previous section invalid. The worst block under the new constraints takes 5 seconds to validate on my laptop. I believe we could further introduce a limitation on the size of legacy transactions to be on the safe side.\n\nSome confiscation concerns were raised about the proposed mitigations. I believe those concerns are reasonable and could be addressed by only applying the new rules when checking the script for an output created after a certain block height.\n\n[*REDACTED #2*](https://delvingbitcoin.org/t/worst-block-validation-time-inquiry/711/3?u=antoinep#redacted-block-2-1)\n\n\n## Merkle tree attacks using 64 bytes transactions\n\nThere are two (known) remaining attacks with how the merkle root in Bitcoin blocks is computed. Both involve creating a catenation of two 32 bytes hashes which successfully deserializes as a Bitcoin transaction. One (probably the most famous) is about \"going down\" the merkle tree by tricking a light client into accepting as payment a transaction which was not in fact committed into a block: a 64 bytes transaction is committed to the block whose last 32 bytes correspond to the txid of a non-committed transaction paying the victim. The other one \"goes up\" the merkle tree, by tricking a node into treating a valid block as permanently invalid: find a row of tree nodes which all deserialize as (invalid) 64-bytes transactions. For more details see [this writeup](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-February/016697.html) by Suhas Daftuar.\n\nThe Great Consensus Cleanup proposes to make 64-bytes-or-less transactions invalid altogether, fixing both vulnerabilities.\n\n### How bad is it?\n\nThe attack against light clients (or anything which may accept a merkle proof, like a sidechain) requires to bruteforce between 61 and ~75 bits, depending on the amount of bitcoins dedicated to the attack. This is expensive, and simple mitigations exist. For instance checking the depth of the tree, which gives you the number of transactions in the block, by asking for a merkle proof of the coinbase transaction).\n\nThat said, the attack [was estimated to cost around $1M](https://bitslog.com/2018/06/09/leaf-node-weakness-in-bitcoin-merkle-tree-design/) when \"state-of-the-art Bitcoin [ASICS] reached 14 TH/s\". Nowadays, [looks like](https://whatsminer-microbt.com/product/whatsminer-m63s/) top ASICs reach 400TH/s. In addition, this attack allows to fake an arbitrary number of confirmations for the transaction. And the cost to simply mine a single fake block to fool an SPV client, which doesn't, is now higher (80 bits).\n\nThe attack to fork Bitcoin nodes is mitigated in Bitcoin Core for invalid transactions by not caching contextless block checks (`CheckBlock()`). Creating valid transactions is not practical: the first one must be a coinbase transaction, which requires bruteforcing 224 bits.\n\n64 bytes transactions, due to how the merkle root in blocks is computed, is a core weakness in Bitcoin.  Although both (known) attacks it enables can be mitigated it would be nice to avoid this footgun as well as being able to cache contextless block checks in Bitcoin Core.\n\n### Can we come up with a better fix?\n\n64 bytes transactions cannot be \"secure\", as in 64 bytes in a transaction is not enough to have an output whose locking script won't be anyone-can-spend or lock the coins forever. They have no known use and have been non-standard for half a decade. Given the vulnerabilities they introduce and their lack of use, it is more than reasonable to make them invalid.\n\nHowever the BIP proposes to also make less-than-64-bytes transactions invalid. Although they are of no (or little) use, such transactions are not harmful. I believe considering a type of transaction useless is not sufficient motivation for making them invalid through a soft fork.\n\nMaking (exactly) 64 bytes long transactions invalid is also what AJ implemented in [his pull request to Bitcoin-inquisition](https://github.com/bitcoin-inquisition/bitcoin/pull/24).\n\n## Wishlist\n\n### BIP30 verification\n\nBIP34 temporarily made it possible to avoid the relatively expensive BIP30 check on every block connection. Starting at block height 1,983,702 it won't be possible to rely solely on BIP34 anymore.  If a soft fork is proposed to cleanup long standing protocol bugs it would be nice if it made coinbase transactions unique once and for all.\n\nA neat fix would be to simply requires the `nLockTime` field of the coinbase transaction to be set to the height of the block being created. However there is a more roundabout fix which is potentially easier for miners to deploy: make the witness commitment mandatory in all coinbase transactions (h/t Greg Sanders). I have yet to check if there is any violation of this but i'd be surprised if there is a pre-Segwit coinbase transaction with an output pushing exactly the witness commitment header followed by 32 `0x00` bytes.\n\n### Your favorite bug!\n\nAt this stage i'm interested in gathering as many suggestions for cleanups as i can, to make sure that if such a soft fork were to be proposed, we would have carefully analyzed all the fixes we'd like to include.\n\nOf course, suggestions need to be reasonable to be considered. For instance, \"banning ordinals\" is an uninteresting suggestion and i doubt many would engage with it. In addition, let's keep suggestions focused on long-standing uncontroversial bugs. For instance \"a block which takes 30 minutes to validate is bad\", \"the broken merkle tree calculation is creating footguns\" or \"let's make coinbase transactions *actually* unique\" seem fairly uncontroversial. On the other hand while reasonable arguments for \"let's decrease the block size limit\" can be put forth, it seems much more controversial to me.\n\nFor instance here is a couple things i wasn't convinced were worth proposing:\n- Requiring standard SIGHASH type bytes for Segwit v0 too;\n- Limiting the maximum size of scriptPubKey's to reduce the worst case UTxO set growth.",
  "actions_summary": [
    {
      "id": 2,
      "count": 11
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 12,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 7
    },
    {
      "id": "rocket",
      "type": "emoji",
      "count": 2
    },
    {
      "id": "heart",
      "type": "emoji",
      "count": 1
    },
    {
      "id": "tada",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 11,
  "current_user_used_main_reaction": false
}