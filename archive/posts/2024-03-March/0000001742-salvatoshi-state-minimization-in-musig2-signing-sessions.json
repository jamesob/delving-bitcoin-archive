{
  "id": 1742,
  "name": "salvatoshi",
  "username": "salvatoshi",
  "avatar_template": "/user_avatar/delvingbitcoin.org/salvatoshi/{size}/72_2.png",
  "created_at": "2024-03-01T09:07:45.084Z",
  "cooked": "<p><a href=\"https://github.com/bitcoin/bips/blob/b3701faef2bdb98a0d7ace4eedbeefa2da4c89ed/bip-0327.mediawiki\" rel=\"noopener nofollow ugc\">BIP-0327</a> discusses at length the necessity to keep some state during a signing session. However, a \u201csigning session\u201d in BIP-0327 only refers to the production of a single signature.</p>\n<p>In the typical signing flow of a wallet, it\u2019s more logical to consider a <em>session</em> at the level of an entire transaction. All transaction inputs are likely obtained from the same <a href=\"https://github.com/bitcoin/bips/pull/1540\" rel=\"noopener nofollow ugc\">descriptor containing musig()</a>, with the signer producing the pubnonce/signature for all the inputs at once.</p>\n<p>Therefore, in the flow of BIP-0327, you would expect at least <em>one MuSig2 signing session per input</em> to be active at the same time. In the context of hardware signing device support, that\u2019s somewhat problematic: it would require to persist state for an unbounded number of signing sessions, for example for a wallet that received a large number of small UTXOs. Persistent storage is often a scarce resource in embedded signing devices, and a naive approach would likely impose a maximum limit on the number of inputs of the transactions, depending on the hardware limitations.</p>\n<p>In this post, I draft an approach that is compatible with, and builds on top of BIP-0327 in order to define a <em>psbt-level session</em> with only a small amount of state persisted on the device. This approach enables the completion of a full signing flow for a PSBT spending from a musig-based wallet by synthetically generating the necessary state for each individual MuSig2 session.</p>\n<h2><a name=\"signing-flow-with-synthetic-randomness-1\" class=\"anchor\" href=\"#signing-flow-with-synthetic-randomness-1\"></a>Signing flow with synthetic randomness</h2>\n<h3><a name=\"synthetic-generation-of-bip-0327-state-2\" class=\"anchor\" href=\"#synthetic-generation-of-bip-0327-state-2\"></a>Synthetic generation of BIP-0327 state</h3>\n<p>This section presents the core of the idea, while the next section makes it more precise in the context of signing devices.</p>\n<p>In BIP-0327, the internal state that is kept by the signing device is essentially the <em>secnonce</em>, which in turn is computed from a random number <em>rand\u2019</em>, and optionally from other parameters of <em>NonceGen</em> which depend on the transaction being signed.</p>\n<p>The core idea in this post is to compute a global random <code>rand_root</code>; then, for the <em>i</em>-th input and for the <em>j</em>-th <code>musig()</code>  key that the device is signing for in the <a href=\"https://github.com/bitcoin/bips/pull/1389\" rel=\"noopener nofollow ugc\">wallet policy</a>, one defines the <em>rand\u2019</em> in <em>NonceGen</em> as:</p>\n<p><span class=\"math\">\\qquad rand_{i,j} = SHA256(rand\\_root || i || j)</span></p>\n<p>In the concatenation, a fixed-length encoding of <span class=\"math\">i</span> and <span class=\"math\">j</span> is used in order to avoid collisions. That is used as the <em>rand\u2019</em> value in the <em>NonceGen</em> algorithm for that input/KEY pair.</p>\n<p>The <em>j</em> parameter allows to handle wallet policies that contain more than one <code>musig()</code> key expression involving the signing device.</p>\n<h3><a name=\"signing-flow-in-detail-3\" class=\"anchor\" href=\"#signing-flow-in-detail-3\"></a>Signing flow in detail</h3>\n<p>This section describes the handling of the psbt-level sessions, plugging on top of the default signing flow of BIP-0327.</p>\n<p>We assume that the signing device handles a single psbt-level session; this can be generalized to multiple parallel psbt-level sessions, where each session computes and stores a different <code>rand_root</code>.</p>\n<p>In the following, a <em>session</em> always refers to the psbt-level signing session; it contains <code>rand_root</code>, and possibly any other auxiliary data that the device wishes to save while signing is in progress.</p>\n<p><strong>Phase 1: pubnonce generation:</strong> A PSBT is sent to the signing device, and it does not contain any pubnonce.</p>\n<ul>\n<li>If a session already exists, it is deleted from the persistent memory.</li>\n<li>A new session is created in volatile memory.</li>\n<li>The device produces a fresh random number <span class=\"math\">rand\\_root</span>, and saves it in the current session.</li>\n<li>The device generates the randomness for the <span class=\"math\">i</span>-th input and for the <span class=\"math\">j</span>-th key as: <span class=\"math\">rand_{i,j} = SHA256(rand\\_root || i || j)</span>.</li>\n<li>Compute each <em>(secnonce, pubnonce)</em> as per the <code>NonceGen</code> algorithm.</li>\n<li>At completion (after all the pubnonces are returned), the session secret <span class=\"math\">rand\\_root</span> is copied into the persistent memory.</li>\n</ul>\n<p><strong>Phase 2: partial signature generation:</strong> A PSBT containing all the pubnonces is sent to the device.</p>\n<ul>\n<li><em>A copy of the session is stored in the volatile memory, and the session is deleted from the persistent memory</em>.</li>\n<li>For each input/musig-key pair <span class=\"math\">(i, j)</span>:\n<ul>\n<li>Recompute the pubnonce/secnonce pair using <code>NonceGen</code> with the synthetic randomness <span class=\"math\">rand_{i,j}</span> as above.</li>\n<li>Verify that the pubnonce contained in the PSBT matches the one synthetically recomputed.</li>\n<li>Continue the signing flow as per BIP-0327, generating the partial signature.</li>\n</ul>\n</li>\n</ul>\n<h2><a name=\"security-considerations-4\" class=\"anchor\" href=\"#security-considerations-4\"></a>Security considerations</h2>\n<h3><a name=\"state-reuse-avoidance-5\" class=\"anchor\" href=\"#state-reuse-avoidance-5\"></a>State reuse avoidance</h3>\n<p>Storing the session in persistent memory only at the end of Phase 1, and deleting it before beginning Phase 2 simplifies auditing and making sure that there is no reuse of state across signing sessions.</p>\n<h3><a name=\"security-of-synthetic-randomness-6\" class=\"anchor\" href=\"#security-of-synthetic-randomness-6\"></a>Security of synthetic randomness</h3>\n<p>Generating <span class=\"math\">rand_{i, j}</span> synthetically is not a problem, since the <span class=\"math\">rand\\_root</span> value is kept secret and never leaves the device. This ensures that all the values produced for different <span class=\"math\">i</span> and <span class=\"math\">j</span> not predictable for an attacker.</p>\n<h3><a name=\"malleability-of-the-psbt-7\" class=\"anchor\" href=\"#malleability-of-the-psbt-7\"></a>Malleability of the PSBT</h3>\n<p>If the optional parameters are passed to the <em>NonceGen</em> function, they will depend on the transaction data present in the PSBT. Therefore, there is no guarantee that they will be unchanged the next time the PSBT is provided.</p>\n<p>However, that does not constitute a security risk, as those parameters are only used as additional sources of entropy in <em>NonceGen</em>. A malicious software wallet can\u2019t affect the <em>secnonce</em>/<em>pubnonce</em> pairs in any predictable way. Changing any of the parameters used in <em>NonceGen</em> would cause a failure during Phase 2, as the recomputed <em>pubnonce</em> would not match the one in the psbt.</p>\n<h2><a name=\"generalization-to-multiple-psbt-signing-sessions-8\" class=\"anchor\" href=\"#generalization-to-multiple-psbt-signing-sessions-8\"></a>Generalization to multiple PSBT signing sessions</h2>\n<p>The approach described above assumes that no attempt to sign a PSBT containing for a wallet policy containing <code>musig()</code> keys is initiated while a session is already in progress.</p>\n<p>It is possible to generalize this to an arbitrary number of parallel signing sessions. Each session could be identified by a <code>psbt_id</code> computed by hashing enough information to (practically) uniquely identify the transaction being signed (making sure that the updated psbt presented in Phase 2 is unchanged); for example, it could be the <code>txid</code> of the unsigned transaction contained in the PSBT.</p>\n<h2><a name=\"acknowledgments-9\" class=\"anchor\" href=\"#acknowledgments-9\"></a>Acknowledgments</h2>\n<p>I would like to thank Yannick Seurin for numerous discussions on the topic, and for reviewing an earlier draft of this post.</p>\n<p>Mistakes are my own.</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2024-03-01T09:12:51.573Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 14,
  "reads": 8,
  "readers_count": 7,
  "score": 131.4,
  "yours": false,
  "topic_id": 626,
  "topic_slug": "state-minimization-in-musig2-signing-sessions",
  "topic_title": "State minimization in MuSig2 signing sessions",
  "topic_html_title": "State minimization in MuSig2 signing sessions",
  "category_id": 8,
  "display_username": "salvatoshi",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[BIP-0327](https://github.com/bitcoin/bips/blob/b3701faef2bdb98a0d7ace4eedbeefa2da4c89ed/bip-0327.mediawiki) discusses at length the necessity to keep some state during a signing session. However, a \"signing session\" in BIP-0327 only refers to the production of a single signature.\n\nIn the typical signing flow of a wallet, it's more logical to consider a _session_ at the level of an entire transaction. All transaction inputs are likely obtained from the same [descriptor containing musig()](https://github.com/bitcoin/bips/pull/1540), with the signer producing the pubnonce/signature for all the inputs at once.\n\nTherefore, in the flow of BIP-0327, you would expect at least _one MuSig2 signing session per input_ to be active at the same time. In the context of hardware signing device support, that's somewhat problematic: it would require to persist state for an unbounded number of signing sessions, for example for a wallet that received a large number of small UTXOs. Persistent storage is often a scarce resource in embedded signing devices, and a naive approach would likely impose a maximum limit on the number of inputs of the transactions, depending on the hardware limitations.\n\nIn this post, I draft an approach that is compatible with, and builds on top of BIP-0327 in order to define a _psbt-level session_ with only a small amount of state persisted on the device. This approach enables the completion of a full signing flow for a PSBT spending from a musig-based wallet by synthetically generating the necessary state for each individual MuSig2 session.\n\n## Signing flow with synthetic randomness\n\n### Synthetic generation of BIP-0327 state\n\nThis section presents the core of the idea, while the next section makes it more precise in the context of signing devices.\n\nIn BIP-0327, the internal state that is kept by the signing device is essentially the *secnonce*, which in turn is computed from a random number _rand'_, and optionally from other parameters of _NonceGen_ which depend on the transaction being signed.\n\nThe core idea in this post is to compute a global random `rand_root`; then, for the *i*-th input and for the *j*-th `musig()`  key that the device is signing for in the [wallet policy](https://github.com/bitcoin/bips/pull/1389), one defines the *rand'* in _NonceGen_ as:\n\n$\\qquad rand_{i,j} = SHA256(rand\\_root || i || j)$\n\nIn the concatenation, a fixed-length encoding of $i$ and $j$ is used in order to avoid collisions. That is used as the *rand'* value in the *NonceGen* algorithm for that input/KEY pair.\n\nThe *j* parameter allows to handle wallet policies that contain more than one `musig()` key expression involving the signing device.\n\n### Signing flow in detail\n\nThis section describes the handling of the psbt-level sessions, plugging on top of the default signing flow of BIP-0327.\n\nWe assume that the signing device handles a single psbt-level session; this can be generalized to multiple parallel psbt-level sessions, where each session computes and stores a different `rand_root`.\n\nIn the following, a _session_ always refers to the psbt-level signing session; it contains `rand_root`, and possibly any other auxiliary data that the device wishes to save while signing is in progress.\n\n**Phase 1: pubnonce generation:** A PSBT is sent to the signing device, and it does not contain any pubnonce.\n- If a session already exists, it is deleted from the persistent memory.\n- A new session is created in volatile memory.\n- The device produces a fresh random number $rand\\_root$, and saves it in the current session.\n- The device generates the randomness for the $i$-th input and for the $j$-th key as: $rand_{i,j} = SHA256(rand\\_root || i || j)$.\n- Compute each *(secnonce, pubnonce)* as per the `NonceGen` algorithm.\n- At completion (after all the pubnonces are returned), the session secret $rand\\_root$ is copied into the persistent memory.\n\n**Phase 2: partial signature generation:** A PSBT containing all the pubnonces is sent to the device.\n- *A copy of the session is stored in the volatile memory, and the session is deleted from the persistent memory*.\n- For each input/musig-key pair $(i, j)$:\n  - Recompute the pubnonce/secnonce pair using `NonceGen` with the synthetic randomness $rand_{i,j}$ as above.\n  - Verify that the pubnonce contained in the PSBT matches the one synthetically recomputed.\n  - Continue the signing flow as per BIP-0327, generating the partial signature.\n\n## Security considerations\n### State reuse avoidance\nStoring the session in persistent memory only at the end of Phase 1, and deleting it before beginning Phase 2 simplifies auditing and making sure that there is no reuse of state across signing sessions.\n\n### Security of synthetic randomness\n\nGenerating $rand_{i, j}$ synthetically is not a problem, since the $rand\\_root$ value is kept secret and never leaves the device. This ensures that all the values produced for different $i$ and $j$ not predictable for an attacker.\n\n### Malleability of the PSBT\nIf the optional parameters are passed to the _NonceGen_ function, they will depend on the transaction data present in the PSBT. Therefore, there is no guarantee that they will be unchanged the next time the PSBT is provided.\n\nHowever, that does not constitute a security risk, as those parameters are only used as additional sources of entropy in _NonceGen_. A malicious software wallet can't affect the _secnonce_/_pubnonce_ pairs in any predictable way. Changing any of the parameters used in _NonceGen_ would cause a failure during Phase 2, as the recomputed _pubnonce_ would not match the one in the psbt.\n\n## Generalization to multiple PSBT signing sessions\n\nThe approach described above assumes that no attempt to sign a PSBT containing for a wallet policy containing `musig()` keys is initiated while a session is already in progress.\n\nIt is possible to generalize this to an arbitrary number of parallel signing sessions. Each session could be identified by a `psbt_id` computed by hashing enough information to (practically) uniquely identify the transaction being signed (making sure that the updated psbt presented in Phase 2 is unchanged); for example, it could be the `txid` of the unsigned transaction contained in the PSBT.\n\n## Acknowledgments\n\nI would like to thank Yannick Seurin for numerous discussions on the topic, and for reviewing an earlier draft of this post.\n\nMistakes are my own.",
  "actions_summary": [
    {
      "id": 2,
      "count": 2
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 81,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": "Github link was replaced with a permanent link",
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 2
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 2,
  "current_user_used_main_reaction": false
}