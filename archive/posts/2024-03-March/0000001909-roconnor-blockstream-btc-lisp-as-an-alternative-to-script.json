{
  "id": 1909,
  "name": "",
  "username": "roconnor-blockstream",
  "avatar_template": "/user_avatar/delvingbitcoin.org/roconnor-blockstream/{size}/427_2.png",
  "created_at": "2024-03-15T21:59:44.349Z",
  "cooked": "<p>Last thread I commented on a high-level comparison between Chia Lisp and Simplicity.\nIn this thread I want to comment on some lower-level comparisons between Chia Lisp and Simplicity.</p>\n<p>I understand you are somewhat cool to the idea of using Simplicity, and I\u2019d like to try to get you a little bit more excited about Simplicity.  The use of combinators in Simplicity likely seems unfamiliar and in comparison lisp has a more familiar feeling and feels like it ought to be easier to write.  But I want to argue that in an extremely broad sense, Simplicity, Chia Lisp, and even Bitcoin Script are all kinda the same.</p>\n<p>I write about this in more detail at <a href=\"https://github.com/BlockstreamResearch/simplicity/discussions/89#discussioncomment-2700904\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">Is it theoretically possible to have a better Operational Semantics than the BitMachine \u00b7 BlockstreamResearch/simplicity \u00b7 Discussion #89 \u00b7 GitHub</a> but there are three fundamental ways of composing computations: sequential composition where the output of one composition is used in the input of another computation; parallel computation (parallel in the logical sense rather than necessarily an operational sense) where the same input is used by two different computations; and conditional composition where an input is sent to one of two or more alternative computations and the output of the chosen computation is returned. (There is a forth fundamental composition for computation which is looping, something that Chia Lisp can do, but neither Simplicity nor Bitcoin Script can do (though it can be kinda-faked with Simplicity)).</p>\n<p>Bitcoin Script, with it\u2019s various duping, swapping and op_if-ing, Simplicity, and Chia Lisp can all perform these three sorts of compositions and, in some sense, it is just a matter of how they end up being expressed.</p>\n<p>As you noted before, in Chia Lisp, expressions are evaluated in the context of an environment, where data is stored in a binary tree that is accessed by numbers that index into that environment.  Put this way, you can view a Chia Lisp expression as a function from the environment to some resulting computation on that environment.</p>\n<p>The way that Simplicity\u2019s combinators work is fundamentally the same.  In Simplicity, an expression is a function from an input type to an output type.\nIn practice that input type is almost always some nested product type, e.g. ((A \u00d7 B) \u00d7 (C \u00d7 D)) whose value is an \u201cenvironment\u201d of values of data types A B C and D.  In turn, a product of types in Simplicity is fundamentally the same as the cons cells in Lisp, it holds a pair of values, which in turn can hold other pairs of values.</p>\n<p>In Simplicity, if you want to access part of the input, which you can think of as an environment, you use Simplicity\u2019s take and drop combinators to access that.  So if you want to fetch the B value from the previous \u201cenviroment\u201d you would use the Simplicity expression (take (drop iden)) which has type ((A \u00d7 B) \u00d7 (C \u00d7 D)) \u2192 B.  If you want to fetch the D value you use the simplicity expression (drop (drop iden)) of type ((A \u00d7 B) \u00d7 (C \u00d7 D)) \u2192 D.</p>\n<p>This take, drop, iden, idiom is so prevalent in Simplicity for \u201clooking up values in the environment\u201d, that I typically use a short hand where O means drop and I means take and H means iden. I can write these examples as OIH : ((A \u00d7 B) \u00d7 (C \u00d7 D)) \u2192 B and IIH : ((A \u00d7 B) \u00d7 (C \u00d7 D)) \u2192 D.  The O\u2019s and I\u2019s are meant to evoke the idea that you have encoded an index in binary and are lookup up a value of that index from the environment.</p>\n<p>So while Simplicity\u2019s combinators are all formally defined in terms of combining functions, you can think of those functions as denoting  \u201ca value given an environment\u201d.</p>\n<p>For example in Chia Lisp, if you have two expressions L and R, and you build a cons expression from them, yielding (cons L R), you get a Chia Lisp expression that represents a function from an environment that passes that environment into L and into R, forming a pair of resulting two values. This is exactly the \u201cparallel composition\u201d described earlier.  In Simplicity we have a pair combinator which is fundamentally the same.  If you have two Simplicity expressions, s : A \u2192 B and t : A \u2192 C, then (pair s t) (also written as (s \u25b3 t)) is an expression of type A \u2192 (B \u00d7 C), which takes an input of type A and passes it to s and t, and then pairs the two results.  This is exactly the same.</p>\n<p>Simplicity is comparable to the clvm. clvm expressions such as (a (q a 2 (c 2 (c 5 ()))) (c (q a (i (= 5 (q . 1)) (q 1 . 1) (q 18 5 (a 2 (c 2 (c (- 5 (q . 1)) ()))))) 1) 1)) are just as unreadable as simplicity expressions like drop (OOH \u25b3 IOH) \u25b3 (OH \u25b3 drop (OIH \u25b3 IIH) ; full-add\u2099) ; IIH \u25b3 (IOH \u25b3 OH ; full-add\u2099) ; IOH \u25b3 (IIH \u25b3 OH).  In both cases expressions can be programed by hand, but they are not meant to be programmed by hand.  They are meant to be the target language of a compiler from some human readable language and are instead mean to be easy to machine evaluate (which is why in the all the cases, Bitcoin Script, Simplicity and clvm, there are no variable names, as such, in the language).  As you noted, you want to translate from a higher-level language to produce BTC lisp, and same goes for Simplicity where Sanket and now Chris have been working on a higher-level language (code named Simphony) that can be translated to Simplicity, but where the higher-level language is not itself consensus critical.</p>\n<p>Even though I\u2019m arguing that all these languages are, in a very broad sense, fundamentally the same, they are indeed different, and these differences are not necessarily immaterial, and are worth debating.  There are <em>lots</em> of low level choices to be made: what fundamental data types are there going to be to handle, integers, digital signatures, elliptic curve points, compressed points, scalar curve values, hash values, strings, lock times, sequence numbers, optional values (and in the case of Elements additionally, asset ids, confidential values, range proofs \u2026), how are they going to be represented, which ones can be converted to each other, what set of operations are going to be made available etc.  There is a huge variety of choices that can be made and Simplicity and Chia Lisp have made quite different choices here.</p>\n<p>Probably the most significant lowish level difference between Chia Lisp and Simplicity is that Chia Lisp is dynamically typed and Simplicity is statically typed.  This difference likely leads other design choices mentioned before down different paths.  I\u2019m doubtful we are going to solve the computer science question of dynamic types vs static types in this thread.  However I will mention that the choice static typing of Simplicity does have operational consequences.  It means that, once a Simplicity program passes type checking (type checking runs in quasi-linear time in the size of the program), the Simplicity interpreter can run without bounds checking. (e.g. every \u201cindex\u201d into \u201cthe environment\u201d fetches its value without failure because otherwise the Simplicity program wouldn\u2019t be well-typed).  Theoretically, some sort of JIT Simplicity compiler implementation could potentially operate quite fast without safety concerns.</p>\n<p>In conclusion, Simplicity and the clvm are both low level languages that are meant to be easy for machines to evaluate which causes tradeoffs that make them hard for humans to read. They are intended to be the compiled from some different, human-readable, non-consesnus-critical language.  Simplicity and the clvm are different ways of expressing the same old things: fetching data from an environment, tupling up bits of data, running conditional statements, and a whole bunch of primitive operations of some sorts.  Like clvm code, Simplicity code is pretty annoying to write by hand, and while no one else should be doing this, I have written, for example, an entire implementation of Schnorr signature verification on the secp256k1 curve, including its own implementation of libsecp256k1, in raw Simplicity.  Of course, you would use a primitives instead (what I\u2019d call jets in Simplicity), but the point is that you can indeed build programs of that sort of complexity in Simplicity.</p>",
  "post_number": 7,
  "post_type": 1,
  "updated_at": "2024-03-15T21:59:44.349Z",
  "reply_count": 1,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 2,
  "reads": 3,
  "readers_count": 2,
  "score": 15.6,
  "yours": false,
  "topic_id": 682,
  "topic_slug": "btc-lisp-as-an-alternative-to-script",
  "topic_title": "BTC Lisp as an alternative to Script",
  "topic_html_title": "BTC Lisp as an alternative to Script",
  "category_id": 7,
  "display_username": "",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Last thread I commented on a high-level comparison between Chia Lisp and Simplicity.\nIn this thread I want to comment on some lower-level comparisons between Chia Lisp and Simplicity.\n\nI understand you are somewhat cool to the idea of using Simplicity, and I'd like to try to get you a little bit more excited about Simplicity.  The use of combinators in Simplicity likely seems unfamiliar and in comparison lisp has a more familiar feeling and feels like it ought to be easier to write.  But I want to argue that in an extremely broad sense, Simplicity, Chia Lisp, and even Bitcoin Script are all kinda the same.\n\nI write about this in more detail at https://github.com/BlockstreamResearch/simplicity/discussions/89#discussioncomment-2700904 but there are three fundamental ways of composing computations: sequential composition where the output of one composition is used in the input of another computation; parallel computation (parallel in the logical sense rather than necessarily an operational sense) where the same input is used by two different computations; and conditional composition where an input is sent to one of two or more alternative computations and the output of the chosen computation is returned. (There is a forth fundamental composition for computation which is looping, something that Chia Lisp can do, but neither Simplicity nor Bitcoin Script can do (though it can be kinda-faked with Simplicity)).\n\nBitcoin Script, with it's various duping, swapping and op_if-ing, Simplicity, and Chia Lisp can all perform these three sorts of compositions and, in some sense, it is just a matter of how they end up being expressed.\n\nAs you noted before, in Chia Lisp, expressions are evaluated in the context of an environment, where data is stored in a binary tree that is accessed by numbers that index into that environment.  Put this way, you can view a Chia Lisp expression as a function from the environment to some resulting computation on that environment.\n\nThe way that Simplicity's combinators work is fundamentally the same.  In Simplicity, an expression is a function from an input type to an output type.\nIn practice that input type is almost always some nested product type, e.g. ((A \u00d7 B) \u00d7 (C \u00d7 D)) whose value is an \"environment\" of values of data types A B C and D.  In turn, a product of types in Simplicity is fundamentally the same as the cons cells in Lisp, it holds a pair of values, which in turn can hold other pairs of values.\n\nIn Simplicity, if you want to access part of the input, which you can think of as an environment, you use Simplicity's take and drop combinators to access that.  So if you want to fetch the B value from the previous \"enviroment\" you would use the Simplicity expression (take (drop iden)) which has type ((A \u00d7 B) \u00d7 (C \u00d7 D)) \u2192 B.  If you want to fetch the D value you use the simplicity expression (drop (drop iden)) of type ((A \u00d7 B) \u00d7 (C \u00d7 D)) \u2192 D.\n\nThis take, drop, iden, idiom is so prevalent in Simplicity for \"looking up values in the environment\", that I typically use a short hand where O means drop and I means take and H means iden. I can write these examples as OIH : ((A \u00d7 B) \u00d7 (C \u00d7 D)) \u2192 B and IIH : ((A \u00d7 B) \u00d7 (C \u00d7 D)) \u2192 D.  The O's and I's are meant to evoke the idea that you have encoded an index in binary and are lookup up a value of that index from the environment.\n\nSo while Simplicity's combinators are all formally defined in terms of combining functions, you can think of those functions as denoting  \"a value given an environment\".\n\nFor example in Chia Lisp, if you have two expressions L and R, and you build a cons expression from them, yielding (cons L R), you get a Chia Lisp expression that represents a function from an environment that passes that environment into L and into R, forming a pair of resulting two values. This is exactly the \"parallel composition\" described earlier.  In Simplicity we have a pair combinator which is fundamentally the same.  If you have two Simplicity expressions, s : A \u2192 B and t : A \u2192 C, then (pair s t) (also written as (s \u25b3 t)) is an expression of type A \u2192 (B \u00d7 C), which takes an input of type A and passes it to s and t, and then pairs the two results.  This is exactly the same.\n\nSimplicity is comparable to the clvm. clvm expressions such as (a (q a 2 (c 2 (c 5 ()))) (c (q a (i (= 5 (q . 1)) (q 1 . 1) (q 18 5 (a 2 (c 2 (c (- 5 (q . 1)) ()))))) 1) 1)) are just as unreadable as simplicity expressions like drop (OOH \u25b3 IOH) \u25b3 (OH \u25b3 drop (OIH \u25b3 IIH) ; full-add\u2099) ; IIH \u25b3 (IOH \u25b3 OH ; full-add\u2099) ; IOH \u25b3 (IIH \u25b3 OH).  In both cases expressions can be programed by hand, but they are not meant to be programmed by hand.  They are meant to be the target language of a compiler from some human readable language and are instead mean to be easy to machine evaluate (which is why in the all the cases, Bitcoin Script, Simplicity and clvm, there are no variable names, as such, in the language).  As you noted, you want to translate from a higher-level language to produce BTC lisp, and same goes for Simplicity where Sanket and now Chris have been working on a higher-level language (code named Simphony) that can be translated to Simplicity, but where the higher-level language is not itself consensus critical.\n\nEven though I'm arguing that all these languages are, in a very broad sense, fundamentally the same, they are indeed different, and these differences are not necessarily immaterial, and are worth debating.  There are *lots* of low level choices to be made: what fundamental data types are there going to be to handle, integers, digital signatures, elliptic curve points, compressed points, scalar curve values, hash values, strings, lock times, sequence numbers, optional values (and in the case of Elements additionally, asset ids, confidential values, range proofs ...), how are they going to be represented, which ones can be converted to each other, what set of operations are going to be made available etc.  There is a huge variety of choices that can be made and Simplicity and Chia Lisp have made quite different choices here.\n\nProbably the most significant lowish level difference between Chia Lisp and Simplicity is that Chia Lisp is dynamically typed and Simplicity is statically typed.  This difference likely leads other design choices mentioned before down different paths.  I'm doubtful we are going to solve the computer science question of dynamic types vs static types in this thread.  However I will mention that the choice static typing of Simplicity does have operational consequences.  It means that, once a Simplicity program passes type checking (type checking runs in quasi-linear time in the size of the program), the Simplicity interpreter can run without bounds checking. (e.g. every \"index\" into \"the environment\" fetches its value without failure because otherwise the Simplicity program wouldn't be well-typed).  Theoretically, some sort of JIT Simplicity compiler implementation could potentially operate quite fast without safety concerns.\n\nIn conclusion, Simplicity and the clvm are both low level languages that are meant to be easy for machines to evaluate which causes tradeoffs that make them hard for humans to read. They are intended to be the compiled from some different, human-readable, non-consesnus-critical language.  Simplicity and the clvm are different ways of expressing the same old things: fetching data from an environment, tupling up bits of data, running conditional statements, and a whole bunch of primitive operations of some sorts.  Like clvm code, Simplicity code is pretty annoying to write by hand, and while no one else should be doing this, I have written, for example, an entire implementation of Schnorr signature verification on the secp256k1 curve, including its own implementation of libsecp256k1, in raw Simplicity.  Of course, you would use a primitives instead (what I'd call jets in Simplicity), but the point is that you can indeed build programs of that sort of complexity in Simplicity.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 351,
  "hidden": false,
  "trust_level": 0,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}