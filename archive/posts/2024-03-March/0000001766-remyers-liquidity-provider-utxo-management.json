{
  "id": 1766,
  "name": "Richard Myers",
  "username": "remyers",
  "avatar_template": "/user_avatar/delvingbitcoin.org/remyers/{size}/159_2.png",
  "created_at": "2024-03-02T13:03:49.806Z",
  "cooked": "<p>Perhaps it would help people understand this proposal faster if I translated it to pseudo code.</p>\n<h2><a name=\"inputs-1\" class=\"anchor\" href=\"#inputs-1\"></a>Inputs:</h2>\n<ul>\n<li><code>Spend_Amount</code>: the amount from a set of liquidity amounts (eg. 10,000 sat, 50,000 sat, 200,000 sat, 1,000,000 sat)</li>\n<li><code>Effective_Feerate</code>: the feerate we want to pay for the transaction</li>\n</ul>\n<h2><a name=\"outputs-2\" class=\"anchor\" href=\"#outputs-2\"></a>Outputs:</h2>\n<ul>\n<li><code>Liquidity_Transaction</code>: a transaction funded by <code>Funding_Inputs</code> and with optional <code>Change_Outputs</code> added\n<ul>\n<li><code>Funding_Inputs</code>: a subset of <code>Available_Coins</code> with a total amount greater than <code>Spend_Amount</code></li>\n<li><code>Change_Outputs</code>: a set of outputs that will be added to <code>Available_Coins</code> when the <code>Liquidity_Transaction</code> confirms</li>\n</ul>\n</li>\n</ul>\n<h2><a name=\"configuration-data-3\" class=\"anchor\" href=\"#configuration-data-3\"></a>Configuration Data:</h2>\n<pre data-code-wrap=\"c\"><code class=\"lang-c\">Target_Bucket {\n  start_satoshis     // defined by the user\n  end_satoshis       // defined by the user\n  target_utxo_count  // defined by the user\n  current_utxo_count // computed from available coins and pending txs\n\n  Capacity() = current_utxo_count / target_utxo_count \n  Target_Amount() = random(start_satoshis, end_satoshis)\n}\n</code></pre>\n<ul>\n<li><code>Target_Buckets</code> = array of <code>Target_Bucket</code>, one element per possible <code>Spend_Amount</code></li>\n<li><code>Available_Coins</code>: set of confirmed and unspent UTXOs in the wallet</li>\n<li><code>Unconfirmed_Liquidity_Txs</code>: set of unconfirmed <code>Liquidity_Transactions</code> previously created with <code>Fund_Liquidity()</code></li>\n<li><code>Bucket_Refill_Feerate</code>: the feerate below which we should create more change outputs than we consume as inputs from the <code>Target_Buckets</code>.</li>\n</ul>\n<h2><a name=\"goals-4\" class=\"anchor\" href=\"#goals-4\"></a>Goals:</h2>\n<ul>\n<li>Find the set of <code>Funding_Inputs</code> and <code>Change_Outputs</code> with the least <code>Cost</code> for the the current <code>Spend_Amount</code> and <code>Effective_Feerate</code></li>\n<li><code>Cost</code>: is the amount of all <code>Funding_Inputs</code> minus the <code>Spend_Amount</code> and minus the <code>Change_Outputs</code></li>\n<li>Minimize the overall <code>Cost</code> over many transactions with different <code>Spend_Amount</code> and <code>Effective_Feerate</code></li>\n<li>The set of <code>Available_Coins</code> should always have enough value to find a solution</li>\n</ul>\n<h2><a name=\"algorithm-5\" class=\"anchor\" href=\"#algorithm-5\"></a>Algorithm:</h2>\n<pre data-code-wrap=\"c\"><code class=\"lang-c\">Fund_Liquidity(Spend_Amount, Effective_Feerate)\n  Funding_Inputs = []\n  Change_Outputs = []\n  \n  // Compute the `current_utxo_count` for each target bucket from the available coins and  \n  // the change outputs of pending liquidity txs.\n  Target_Buckets = Compute_Capacity(Target_Buckets, Available_Coins, Unconfirmed_Liquidity_Txs)\n  \n  // Find the target bucket with least capacity().\n  Min_Target_Bucket = Target_Buckets.Min_Capacity()\n  \n  if Min_Target_Bucket.Capacity() &lt; 0.7:\n    // Check if the capacity of our least full bucket is very low, or fees are low.\n    if Min_Target_Bucket.Capacity() &lt; 0.3 or Current_Feerate &lt; Bucket_Refill_Feerate:\n      // Ensure we create change to refill buckets by adding the largest coin we can spend as an input.\n      Largest_Coin = Available_Coins.Max()\n      Preset_Inputs = [Largest_Coin]\n  \n  // Add sufficient new inputs to fund the transaction with an optional change output.\n  Change_Target_Amount = Min_Target_Bucket.Target_Amount()\n  CS_Result = SelectCoins(Available_Coins, Funding_Inputs, Change_Target_Amount)\n  \n  if CS_Result.Change_Output_Amount &gt; 0:\n    // If a change output is added, split the change output into multiple outputs (see below)\n    Split_Change_Outputs = Split_Change(CS_Result.Change_Output_Amount, Change_Target_Amount, Target_Buckets)\n    Tx = CreateTransaction(CS_Result.Inputs, Split_Change_Outputs)\n    \n  else:\n    // Otherwise, create a changeless tx.\n    Tx = Change_Outputs(CS_Result.Inputs, CS_Result.Change_Output_Amount)\n</code></pre>\n<h2><a name=\"splitting-change-6\" class=\"anchor\" href=\"#splitting-change-6\"></a>Splitting Change</h2>\n<p>We split the single change output added by coin selection into multiple change outputs that opportunistically refill target buckets with random amounts within the range of the most depleted buckets first.</p>\n<pre data-code-wrap=\"c\"><code class=\"lang-c\">Split_Change(Change_Output_Amount, Change_Target_Amount, Target_Buckets):\n  // Add the initial change target used by coin selection to the array of output amounts.\n  Change_Outputs = [Change_Target_Amount]\n\n  // Deduct the initial output amount from our total change amount.\n  Change_Amount = Change_Output_Amount - Change_Target_Amount\n  \n  // Increment the count of the utxo target bucket that matches our initial output.\n  Target_Bucket = Target_Buckets.Find(Change_Target_Amount)\n  Target_Bucket.current_utxo_count += 1\n\n  do {\n    // Find the target bucket with least capacity().\n    min_target_bucket = Target_Buckets.Min_Capacity()\n    \n    if min_target_bucket.current_utxo_count &gt;= min_target_bucket.target_utxo_count:\n      // If no target buckets at less than full capacity; exit the loop.\n      break\n      \n    // Compute a random target amount in the range of the least full bucket.\n    target_amount = min_target_bucket.target_amount()\n\n    if change_amount &lt; (change_fee + target_amount):\n      // If there is not enough change available for a new output; exit the loop.\n      break\n    \n    // Deduct the change amount AND the fee cost of adding a new output from the change amount.\n    change_amount -= change_fee + target_amount\n    \n    // Increment the current count of the least full target bucket.\n    min_target_bucket.current_utxo_count += 1\n    \n    // Add the new change output to the end of the array of output amounts.\n    change_outputs = change_outputs + target_amount\n  }\n\n  // any remaining change goes into the last change output\n  change_outputs.last() += change_amount\n\n  return change_outputs\n</code></pre>",
  "post_number": 2,
  "post_type": 1,
  "updated_at": "2024-03-02T13:03:49.806Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 10,
  "readers_count": 9,
  "score": 1.8,
  "yours": false,
  "topic_id": 600,
  "topic_slug": "liquidity-provider-utxo-management",
  "topic_title": "Liquidity provider utxo management",
  "topic_html_title": "Liquidity provider utxo management",
  "category_id": 8,
  "display_username": "Richard Myers",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": "",
  "bookmarked": false,
  "raw": "Perhaps it would help people understand this proposal faster if I translated it to pseudo code.\n\n## Inputs:\n\n* `Spend_Amount`: the amount from a set of liquidity amounts (eg. 10,000 sat, 50,000 sat, 200,000 sat, 1,000,000 sat)\n* `Effective_Feerate`: the feerate we want to pay for the transaction\n\n## Outputs:\n* `Liquidity_Transaction`: a transaction funded by `Funding_Inputs` and with optional `Change_Outputs` added\n  * `Funding_Inputs`: a subset of `Available_Coins` with a total amount greater than `Spend_Amount` \n  * `Change_Outputs`: a set of outputs that will be added to `Available_Coins` when the `Liquidity_Transaction` confirms\n\n## Configuration Data:\n\n```c\nTarget_Bucket {\n  start_satoshis     // defined by the user\n  end_satoshis       // defined by the user\n  target_utxo_count  // defined by the user\n  current_utxo_count // computed from available coins and pending txs\n\n  Capacity() = current_utxo_count / target_utxo_count \n  Target_Amount() = random(start_satoshis, end_satoshis)\n}\n```\n\n* `Target_Buckets` = array of `Target_Bucket`, one element per possible `Spend_Amount`\n* `Available_Coins`: set of confirmed and unspent UTXOs in the wallet\n* `Unconfirmed_Liquidity_Txs`: set of unconfirmed `Liquidity_Transactions` previously created with `Fund_Liquidity()`\n* `Bucket_Refill_Feerate`: the feerate below which we should create more change outputs than we consume as inputs from the `Target_Buckets`.\n\n## Goals:\n* Find the set of `Funding_Inputs` and `Change_Outputs` with the least `Cost` for the the current `Spend_Amount` and `Effective_Feerate`\n* `Cost`: is the amount of all `Funding_Inputs` minus the `Spend_Amount` and minus the `Change_Outputs`\n* Minimize the overall `Cost` over many transactions with different `Spend_Amount` and `Effective_Feerate`\n* The set of `Available_Coins` should always have enough value to find a solution\n\n## Algorithm:\n\n```c\nFund_Liquidity(Spend_Amount, Effective_Feerate)\n  Funding_Inputs = []\n  Change_Outputs = []\n  \n  // Compute the `current_utxo_count` for each target bucket from the available coins and  \n  // the change outputs of pending liquidity txs.\n  Target_Buckets = Compute_Capacity(Target_Buckets, Available_Coins, Unconfirmed_Liquidity_Txs)\n  \n  // Find the target bucket with least capacity().\n  Min_Target_Bucket = Target_Buckets.Min_Capacity()\n  \n  if Min_Target_Bucket.Capacity() < 0.7:\n    // Check if the capacity of our least full bucket is very low, or fees are low.\n    if Min_Target_Bucket.Capacity() < 0.3 or Current_Feerate < Bucket_Refill_Feerate:\n      // Ensure we create change to refill buckets by adding the largest coin we can spend as an input.\n      Largest_Coin = Available_Coins.Max()\n      Preset_Inputs = [Largest_Coin]\n  \n  // Add sufficient new inputs to fund the transaction with an optional change output.\n  Change_Target_Amount = Min_Target_Bucket.Target_Amount()\n  CS_Result = SelectCoins(Available_Coins, Funding_Inputs, Change_Target_Amount)\n  \n  if CS_Result.Change_Output_Amount > 0:\n    // If a change output is added, split the change output into multiple outputs (see below)\n    Split_Change_Outputs = Split_Change(CS_Result.Change_Output_Amount, Change_Target_Amount, Target_Buckets)\n    Tx = CreateTransaction(CS_Result.Inputs, Split_Change_Outputs)\n    \n  else:\n    // Otherwise, create a changeless tx.\n    Tx = Change_Outputs(CS_Result.Inputs, CS_Result.Change_Output_Amount)\n```\n\n## Splitting Change\n\nWe split the single change output added by coin selection into multiple change outputs that opportunistically refill target buckets with random amounts within the range of the most depleted buckets first.\n\n```c\nSplit_Change(Change_Output_Amount, Change_Target_Amount, Target_Buckets):\n  // Add the initial change target used by coin selection to the array of output amounts.\n  Change_Outputs = [Change_Target_Amount]\n\n  // Deduct the initial output amount from our total change amount.\n  Change_Amount = Change_Output_Amount - Change_Target_Amount\n  \n  // Increment the count of the utxo target bucket that matches our initial output.\n  Target_Bucket = Target_Buckets.Find(Change_Target_Amount)\n  Target_Bucket.current_utxo_count += 1\n\n  do {\n    // Find the target bucket with least capacity().\n    min_target_bucket = Target_Buckets.Min_Capacity()\n    \n    if min_target_bucket.current_utxo_count >= min_target_bucket.target_utxo_count:\n      // If no target buckets at less than full capacity; exit the loop.\n      break\n      \n    // Compute a random target amount in the range of the least full bucket.\n    target_amount = min_target_bucket.target_amount()\n\n    if change_amount < (change_fee + target_amount):\n      // If there is not enough change available for a new output; exit the loop.\n      break\n    \n    // Deduct the change amount AND the fee cost of adding a new output from the change amount.\n    change_amount -= change_fee + target_amount\n    \n    // Increment the current count of the least full target bucket.\n    min_target_bucket.current_utxo_count += 1\n    \n    // Add the new change output to the end of the array of output amounts.\n    change_outputs = change_outputs + target_amount\n  }\n\n  // any remaining change goes into the last change output\n  change_outputs.last() += change_amount\n\n  return change_outputs\n```",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 55,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}