{
  "id": 1953,
  "name": "Richard Myers",
  "username": "remyers",
  "avatar_template": "/user_avatar/delvingbitcoin.org/remyers/{size}/159_2.png",
  "created_at": "2024-03-20T14:39:32.741Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"murch\" data-post=\"3\" data-topic=\"600\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/murch/48/139_2.png\" class=\"avatar\"> murch:</div>\n<blockquote>\n<p>I would agree that CoinGrinder and BnB would be more useful in your scenario than Knapsack and SRD. It might make sense to modify the <code>sendmany</code> RPC to allow restricting the coin selection to a subset of the coin selection algorithms or to patch out the calls to Knapsack and SRD from your node. Given that the post-processing of input set candidates is currently only based on the waste metric, It seems to me that you might want one call with the target consisting only of the liquidity transaction output, and if it doesn\u2019t return a changeless solution, several calls with targets composed from the liquidity transaction output plus one or multiple of the amounts missing from buckets. Given the intent to refill the buckets, perhaps the latter calls should be restricted to the non-bucketed UTXOs.</p>\n</blockquote>\n</aside>\n<p>I created a branch where I can set which algos are enabled. I have been running some simulations to compare using bnb+cg vs all algos. I\u2019m using the same funding scenario file from my other tests, but none of the other changes related to targeting buckets.</p>\n<p>Counter intuitively my initial tests showed all algos having slightly lower total fees and fewer median inputs than using only bnb+cg. I\u2019m running more tests to try to figure out why.</p>\n<aside class=\"quote no-group\" data-username=\"murch\" data-post=\"3\" data-topic=\"600\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/murch/48/139_2.png\" class=\"avatar\"> murch:</div>\n<blockquote>\n<p>Which brings me to the question, how would you distinguish non-bucketed and bucketed UTXOs? Would they be kept in separate wallets, separate amount ranges, marked in some manner?</p>\n</blockquote>\n</aside>\n<p>I do not restrict which UTXOs coin selection can pick, except when refilling buckets I pre-select as an input the single \u201cmaximum value UTXO that is not in a bucket.\u201d I use the bucket ranges preloaded from a json file to pre-filter the available coins based on if they are in a bucket or not.</p>\n<p>That makes sense to initially try to select from UTXOs that are in a bucket to create a changeless transaction, but when that fails try to select from only non-bucketed UTXOs. This is related to <strong>suggestion 1</strong>.</p>",
  "post_number": 7,
  "post_type": 1,
  "updated_at": "2024-03-20T14:39:32.741Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 1,
  "incoming_link_count": 0,
  "reads": 4,
  "readers_count": 3,
  "score": 0.8,
  "yours": false,
  "topic_id": 600,
  "topic_slug": "liquidity-provider-utxo-management",
  "topic_title": "Liquidity provider utxo management",
  "topic_html_title": "Liquidity provider utxo management",
  "category_id": 8,
  "display_username": "Richard Myers",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": "",
  "bookmarked": false,
  "raw": "[quote=\"murch, post:3, topic:600\"]\nI would agree that CoinGrinder and BnB would be more useful in your scenario than Knapsack and SRD. It might make sense to modify the `sendmany` RPC to allow restricting the coin selection to a subset of the coin selection algorithms or to patch out the calls to Knapsack and SRD from your node. Given that the post-processing of input set candidates is currently only based on the waste metric, It seems to me that you might want one call with the target consisting only of the liquidity transaction output, and if it doesn\u2019t return a changeless solution, several calls with targets composed from the liquidity transaction output plus one or multiple of the amounts missing from buckets. Given the intent to refill the buckets, perhaps the latter calls should be restricted to the non-bucketed UTXOs.\n[/quote]\n\nI created a branch where I can set which algos are enabled. I have been running some simulations to compare using bnb+cg vs all algos. I'm using the same funding scenario file from my other tests, but none of the other changes related to targeting buckets. \n\nCounter intuitively my initial tests showed all algos having slightly lower total fees and fewer median inputs than using only bnb+cg. I'm running more tests to try to figure out why.\n\n[quote=\"murch, post:3, topic:600\"]\nWhich brings me to the question, how would you distinguish non-bucketed and bucketed UTXOs? Would they be kept in separate wallets, separate amount ranges, marked in some manner?\n[/quote]\n\nI do not restrict which UTXOs coin selection can pick, except when refilling buckets I pre-select as an input the single \"maximum value UTXO that is not in a bucket.\" I use the bucket ranges preloaded from a json file to pre-filter the available coins based on if they are in a bucket or not.\n\nThat makes sense to initially try to select from UTXOs that are in a bucket to create a changeless transaction, but when that fails try to select from only non-bucketed UTXOs. This is related to **suggestion 1**.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 55,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}