{
  "id": 2051,
  "name": "Suhas Daftuar",
  "username": "sdaftuar",
  "avatar_template": "/letter_avatar_proxy/v4/letter/s/0ea827/{size}.png",
  "created_at": "2024-03-26T23:36:27.655Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"harding\" data-post=\"7\" data-topic=\"696\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/harding/48/6_2.png\" class=\"avatar\"> harding:</div>\n<blockquote>\n<p>I made the assumption (perhaps incorrectly?) that anything that enables <code>OP_CAT</code> or an equivalent allows verifying a merkle proof in conjunction with existing opcodes (namely <code>OP_SHA256</code>/<code>OP_HASH256</code>). Similarly, those functions also allow verifying proof of work and header chains. With OP_IF, I think you could be accommodate any consensus-compatible shape of the partial merkle branch.</p>\n</blockquote>\n</aside>\n<p>Unless I\u2019m missing something, I think any scripts that could be deployed using just tools like this would in fact be reorg safe \u2013 you\u2019d need a way for a script to pull in data from the active headers chain itself in order to become invalid on a reorg.</p>\n<p>(Thanks for linking to those examples \u2013 from a quick look, I don\u2019t believe any of them propose op codes that would allow for inspecting anything outside of the transaction that is being validated, so as far as I can tell each of those proposals would be reorg safe.  Please let me know if I\u2019m mistaken!)</p>\n<aside class=\"quote no-group\" data-username=\"harding\" data-post=\"7\" data-topic=\"696\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/harding/48/6_2.png\" class=\"avatar\"> harding:</div>\n<blockquote>\n<p>Any time I create an output paying someone I don\u2019t trust, doesn\u2019t that have the same problem?</p>\n</blockquote>\n</aside>\n<p>I believe there\u2019s a substantial difference between a single transaction being able to be griefed by someone else, and anyone on the network always being able to grief anyone else on the network at any time.</p>\n<aside class=\"quote no-group\" data-username=\"harding\" data-post=\"7\" data-topic=\"696\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/harding/48/6_2.png\" class=\"avatar\"> harding:</div>\n<blockquote>\n<p>But there\u2019s another problem which has come to my attention more recently, which is the high cost of exogenous fee bumping compared to paying miners out of band.</p>\n</blockquote>\n</aside>\n<p>I think it may be helpful to adopt the terminology that <a class=\"mention\" href=\"/u/instagibbs\">@instagibbs</a> has described in <a href=\"https://delvingbitcoin.org/t/taxonomy-of-transaction-fees-in-smart-contracts/512\" class=\"inline-onebox\">Taxonomy of Transaction Fees in Smart Contracts</a>.</p>\n<p>As <a class=\"mention\" href=\"/u/instagibbs\">@instagibbs</a> points out there, exogenous fees can (in theory) be used to pay for a transaction with or without CPFP; similarly, endogenous fees can also in theory arise with or without CPFP.</p>\n<p>If we wanted to be true blockchain-space-minimalists, we would be arguing that all protocols move towards an endogenous-single-tx model only.  I don\u2019t work on layer 2 protocols myself and so don\u2019t consider myself well-versed in what is possible and what is not, but my inclination is to think that this is probably overly restrictive.  Of course, if people come up with protocols that work within that guideline, then that\u2019s of course great.</p>\n<p>I think what the transaction sponsor model is trying to do is make CPFP cheaper/more efficient in situations where a protocol is unable to bring endogenous fees to a transaction, compared with using anyone-can-spend outputs.  However, in order to be workable, Jeremy had proposed a number of policy rules on top of the consensus change, which were needed in order to make sponsors useful as a CPFP/RBF alternative. From his <a href=\"https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018179.html\">mailing list post</a>:</p>\n<blockquote>\n<p>In this BIP, we only care to ensure a subset of behavior sufficient to replace CPFP and RBF for fee\nbumping.</p>\n<p>Thus we restrict the mempool policy such that:</p>\n<ol>\n<li>No Transaction with a Sponsor Vector may have any child spends; and</li>\n<li>No Transaction with a Sponsor Vector may have any unconfirmed parents; and</li>\n<li>The Sponsor Vector must have exactly 1 entry; and</li>\n<li>The Sponsor Vector\u2019s entry must be present in the mempool; and</li>\n<li>Every Transaction may have exactly 1 sponsor in the mempool; except</li>\n<li>Transactions with a Sponsor Vector may not be sponsored.</li>\n</ol>\n<p>The mempool treats ancestors and descendants limits as follows:</p>\n<ol>\n<li>Sponsors are counted as children transactions for descendants; but</li>\n<li>Sponsoring transactions are exempted from any limits saturated at the time of submission.</li>\n</ol>\n<p>This ensures that within a given package, every child transaction may have a sponsor, but that the\nmempool prefers to not accept new true children while there are parents that can be cleared.</p>\n<p>To prevent garbage sponsors, we also require that:</p>\n<ol>\n<li>The Sponsor\u2019s feerate must be greater than the Sponsored\u2019s ancestor fee rate</li>\n</ol>\n<p>We allow one Sponsor to replace another subject to normal replacement policies, they are treated as\nconflicts.</p>\n</blockquote>\n<p>Looking at this now, this seems extremely similar to the rule set for v3 (TRUC!) children<sup class=\"footnote-ref\"><a href=\"#footnote-2051-1\" id=\"footnote-ref-2051-1\">[1]</a></sup> \u2013 an opt-in policy to make RBF work better, while still allowing for CPFP.  In Jeremy\u2019s original post, he suggested that:</p>\n<blockquote>\n<p>What is wanted is a minimal mechanism that allows arbitrary unconnected third parties to attach\nfees to an arbitrary transaction. The set of rules given tightly bounds how much extra work the\nmempool might have to do to account for the new sponsors in the worst case, while providing a \u201cit\nalways works\u201d API for end users that is not subject to traditional issues around pinning.</p>\n</blockquote>\n<p>What I argue instead is that the <em>policy changes</em>, not the <em>consensus changes</em> are what allow us to avoid the \u201ctraditional issues around pinning\u201d \u2013 and the v3/TRUC proposal is an example of this.</p>\n<p>So given that the policy changes are what is helpful here, the question becomes: is it worth changing the consensus model in order to save ~52 vbytes for protocols that rely on exogenous-fee-CPFP in order to fund transaction fees?</p>\n<p>Exogenous-fee-CPFP is already still less efficient than paying a miner out of band to mine a given transaction, so if the concern is the miner-centralization-issue, then we should really abandon such protocols in favor of endogenous-fee-single-tx schemes.  Given that we\u2019re willing to tolerate some level of blockchain-inefficiency to make such protocols work, my personal view is that tradeoff to save those ~52vbytes is not worth it, and at a minimum, I\u2019d suggest that the community first deploy exogenous-fee-CPFP protocols using existing methodologies (like anyone-can-spend outputs) to demonstrate utility and adoption before we seriously consider changing the consensus model.</p>\n<p>And even if somehow such protocols gained enough adoption that shaving a few bytes to make them more efficient catches on, I\u2019d still argue that we should not opt existing transactions into this behavior, because I believe there will always be unintended policy side effects from allowing arbitrary third parties to attach to the transaction graph, and I think good soft-fork design should compel us to avoid causing any potential harm to existing use cases/users when rolling out new features.</p>\n<hr class=\"footnotes-sep\">\n\n<ol class=\"footnotes-list\">\n<li id=\"footnote-2051-1\" class=\"footnote-item\"><p>If I\u2019m not mistaken, Jeremy\u2019s original proposal didn\u2019t seem to include a bound on the size of a sponsor transaction, something which is part of the TRUC/v3 proposal \u2013 without that, RBF pinning is still possible in a situation where someone creates a large sponsor transaction that is low feerate (but still above the feerate of the parent), making it difficult to replace with another higher feerate sponsor transaction. <a href=\"#footnote-ref-2051-1\" class=\"footnote-backref\">\u21a9\ufe0e</a></p>\n</li>\n</ol>",
  "post_number": 8,
  "post_type": 1,
  "updated_at": "2024-03-26T23:36:27.655Z",
  "reply_count": 0,
  "reply_to_post_number": 7,
  "quote_count": 1,
  "incoming_link_count": 0,
  "reads": 6,
  "readers_count": 5,
  "score": 1.2,
  "yours": false,
  "topic_id": 696,
  "topic_slug": "improving-transaction-sponsor-blockspace-efficiency",
  "topic_title": "Improving transaction sponsor blockspace efficiency",
  "topic_html_title": "Improving transaction sponsor blockspace efficiency",
  "category_id": 7,
  "display_username": "Suhas Daftuar",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"harding, post:7, topic:696\"]\nI made the assumption (perhaps incorrectly?) that anything that enables `OP_CAT` or an equivalent allows verifying a merkle proof in conjunction with existing opcodes (namely `OP_SHA256`/`OP_HASH256`). Similarly, those functions also allow verifying proof of work and header chains. With OP_IF, I think you could be accommodate any consensus-compatible shape of the partial merkle branch.\n[/quote]\n\nUnless I'm missing something, I think any scripts that could be deployed using just tools like this would in fact be reorg safe -- you'd need a way for a script to pull in data from the active headers chain itself in order to become invalid on a reorg.\n\n(Thanks for linking to those examples -- from a quick look, I don't believe any of them propose op codes that would allow for inspecting anything outside of the transaction that is being validated, so as far as I can tell each of those proposals would be reorg safe.  Please let me know if I'm mistaken!)\n\n[quote=\"harding, post:7, topic:696\"]\nAny time I create an output paying someone I don\u2019t trust, doesn\u2019t that have the same problem?\n[/quote]\n\nI believe there's a substantial difference between a single transaction being able to be griefed by someone else, and anyone on the network always being able to grief anyone else on the network at any time.\n\n[quote=\"harding, post:7, topic:696\"]\nBut there\u2019s another problem which has come to my attention more recently, which is the high cost of exogenous fee bumping compared to paying miners out of band.\n[/quote]\n\nI think it may be helpful to adopt the terminology that @instagibbs has described in https://delvingbitcoin.org/t/taxonomy-of-transaction-fees-in-smart-contracts/512.\n\nAs @instagibbs points out there, exogenous fees can (in theory) be used to pay for a transaction with or without CPFP; similarly, endogenous fees can also in theory arise with or without CPFP.\n\nIf we wanted to be true blockchain-space-minimalists, we would be arguing that all protocols move towards an endogenous-single-tx model only.  I don't work on layer 2 protocols myself and so don't consider myself well-versed in what is possible and what is not, but my inclination is to think that this is probably overly restrictive.  Of course, if people come up with protocols that work within that guideline, then that's of course great.\n\nI think what the transaction sponsor model is trying to do is make CPFP cheaper/more efficient in situations where a protocol is unable to bring endogenous fees to a transaction, compared with using anyone-can-spend outputs.  However, in order to be workable, Jeremy had proposed a number of policy rules on top of the consensus change, which were needed in order to make sponsors useful as a CPFP/RBF alternative. From his [mailing list post](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018179.html):\n\n> In this BIP, we only care to ensure a subset of behavior sufficient to replace CPFP and RBF for fee\n> bumping.\n> \n> Thus we restrict the mempool policy such that:\n> \n> 1. No Transaction with a Sponsor Vector may have any child spends; and\n> 1. No Transaction with a Sponsor Vector may have any unconfirmed parents; and\n> 1. The Sponsor Vector must have exactly 1 entry; and\n> 1. The Sponsor Vector's entry must be present in the mempool; and\n> 1. Every Transaction may have exactly 1 sponsor in the mempool; except\n> 1. Transactions with a Sponsor Vector may not be sponsored.\n> \n> \n> The mempool treats ancestors and descendants limits as follows:\n> \n> 1. Sponsors are counted as children transactions for descendants; but\n> 1. Sponsoring transactions are exempted from any limits saturated at the time of submission.\n> \n> This ensures that within a given package, every child transaction may have a sponsor, but that the\n> mempool prefers to not accept new true children while there are parents that can be cleared.\n> \n> To prevent garbage sponsors, we also require that:\n> \n> 1. The Sponsor's feerate must be greater than the Sponsored's ancestor fee rate\n> \n> We allow one Sponsor to replace another subject to normal replacement policies, they are treated as\n> conflicts.\n\nLooking at this now, this seems extremely similar to the rule set for v3 (TRUC!) children[^size] -- an opt-in policy to make RBF work better, while still allowing for CPFP.  In Jeremy's original post, he suggested that:\n\n[^size]: If I'm not mistaken, Jeremy's original proposal didn't seem to include a bound on the size of a sponsor transaction, something which is part of the TRUC/v3 proposal -- without that, RBF pinning is still possible in a situation where someone creates a large sponsor transaction that is low feerate (but still above the feerate of the parent), making it difficult to replace with another higher feerate sponsor transaction.\n\n> What is wanted is a minimal mechanism that allows arbitrary unconnected third parties to attach\nfees to an arbitrary transaction. The set of rules given tightly bounds how much extra work the\nmempool might have to do to account for the new sponsors in the worst case, while providing a \"it\nalways works\" API for end users that is not subject to traditional issues around pinning.\n\nWhat I argue instead is that the *policy changes*, not the *consensus changes* are what allow us to avoid the \"traditional issues around pinning\" -- and the v3/TRUC proposal is an example of this.\n\nSo given that the policy changes are what is helpful here, the question becomes: is it worth changing the consensus model in order to save ~52 vbytes for protocols that rely on exogenous-fee-CPFP in order to fund transaction fees?\n\nExogenous-fee-CPFP is already still less efficient than paying a miner out of band to mine a given transaction, so if the concern is the miner-centralization-issue, then we should really abandon such protocols in favor of endogenous-fee-single-tx schemes.  Given that we're willing to tolerate some level of blockchain-inefficiency to make such protocols work, my personal view is that tradeoff to save those ~52vbytes is not worth it, and at a minimum, I'd suggest that the community first deploy exogenous-fee-CPFP protocols using existing methodologies (like anyone-can-spend outputs) to demonstrate utility and adoption before we seriously consider changing the consensus model.  \n\nAnd even if somehow such protocols gained enough adoption that shaving a few bytes to make them more efficient catches on, I'd still argue that we should not opt existing transactions into this behavior, because I believe there will always be unintended policy side effects from allowing arbitrary third parties to attach to the transaction graph, and I think good soft-fork design should compel us to avoid causing any potential harm to existing use cases/users when rolling out new features.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 95,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}