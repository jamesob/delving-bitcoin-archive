{
  "id": 1873,
  "name": "",
  "username": "roconnor-blockstream",
  "avatar_template": "/user_avatar/delvingbitcoin.org/roconnor-blockstream/{size}/427_2.png",
  "created_at": "2024-03-13T14:44:09.341Z",
  "cooked": "<p>Based on your description, I can make some high-level comparisons with Simplicity design choices.</p>\n<p>One feature of Simplicity is \u201cpruning\u201d.  Simplicity programs are committed via a Merkle Tree structure and unexecuted branches are required to be trimmed when the program is revealed.  This is kinda the opposite of the if statement that evaluates both branches that is described in Chia Lisp.  Simplicity\u2019s pruning has potential privacy benefits as well as potential for reducing on chain data.</p>\n<p>Chia Lisp and Simplicity both appear to support \u201cdelegation\u201d, which lets you attach new code in controlled ways at redemption time. In Chia Lisp you would add quoted code as an input, and in Simplicity there is a special combinator for attaching code at a particular location at redemption time.  In Simplicity the hash of this attached code would typically require to be signed.  I\u2019m not sure how it works in Chia Lisp.</p>\n<p>Unfortunately, as I have found out, delegation generally wreaks havoc on softforking in new opcodes (by opcode I just mean some primitive, or intrinsic or jet-like thing).  If unallocated opcodes are treated as op-success and users can attach new code at redemption time, then that new code could contain an unallocated opcode, whose op-successedness will just succeed and bypass all other checks that are supposed to run.</p>\n<p>Chia Lisp solutions seems to take a NOP approach where softforked opcodes must return nil and the computational content is all in whether the opcode fails or not.  I suppose this approach could also be done in Simplicity by only allowing softforks of jets that return Simplicity\u2019s equivalent of nil.</p>\n<p>There are also several other more minor design differences.  Simplicity\u2019s implementation has no \u201crun-time\u201d allocation.  The maximum memory use is computed upfront from the structure of the program and allocated before evaluation begins.  An alternative implementation could just reuse a pool of maximum sized allocations which is currently arbitrarily defined to be 5 Megabits or about 650 Kilobytes.</p>\n<p>And, of course, this upfront computation of costs and maximum memory use is only possible because Simplicity has no general recursion (though you can somewhat fake it using the delegation mechanism).  Another consequence is types in Simplicity programs are always of statically bounded size.</p>",
  "post_number": 6,
  "post_type": 1,
  "updated_at": "2024-03-13T14:44:09.341Z",
  "reply_count": 1,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 7,
  "readers_count": 6,
  "score": 6.4,
  "yours": false,
  "topic_id": 636,
  "topic_slug": "chia-lisp-for-bitcoiners",
  "topic_title": "Chia Lisp For Bitcoiners",
  "topic_html_title": "Chia Lisp For Bitcoiners",
  "category_id": 7,
  "display_username": "",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Based on your description, I can make some high-level comparisons with Simplicity design choices.\n\nOne feature of Simplicity is \"pruning\".  Simplicity programs are committed via a Merkle Tree structure and unexecuted branches are required to be trimmed when the program is revealed.  This is kinda the opposite of the if statement that evaluates both branches that is described in Chia Lisp.  Simplicity's pruning has potential privacy benefits as well as potential for reducing on chain data.\n\nChia Lisp and Simplicity both appear to support \"delegation\", which lets you attach new code in controlled ways at redemption time. In Chia Lisp you would add quoted code as an input, and in Simplicity there is a special combinator for attaching code at a particular location at redemption time.  In Simplicity the hash of this attached code would typically require to be signed.  I'm not sure how it works in Chia Lisp.\n\nUnfortunately, as I have found out, delegation generally wreaks havoc on softforking in new opcodes (by opcode I just mean some primitive, or intrinsic or jet-like thing).  If unallocated opcodes are treated as op-success and users can attach new code at redemption time, then that new code could contain an unallocated opcode, whose op-successedness will just succeed and bypass all other checks that are supposed to run.\n\nChia Lisp solutions seems to take a NOP approach where softforked opcodes must return nil and the computational content is all in whether the opcode fails or not.  I suppose this approach could also be done in Simplicity by only allowing softforks of jets that return Simplicity's equivalent of nil.\n\nThere are also several other more minor design differences.  Simplicity's implementation has no \"run-time\" allocation.  The maximum memory use is computed upfront from the structure of the program and allocated before evaluation begins.  An alternative implementation could just reuse a pool of maximum sized allocations which is currently arbitrarily defined to be 5 Megabits or about 650 Kilobytes.\n\nAnd, of course, this upfront computation of costs and maximum memory use is only possible because Simplicity has no general recursion (though you can somewhat fake it using the delegation mechanism).  Another consequence is types in Simplicity programs are always of statically bounded size.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 351,
  "hidden": false,
  "trust_level": 0,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}