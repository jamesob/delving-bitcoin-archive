{
  "id": 1883,
  "name": "ZmnSCPxj jxPCSnmZ",
  "username": "ZmnSCPxj",
  "avatar_template": "/letter_avatar_proxy/v4/letter/z/ee7513/{size}.png",
  "created_at": "2024-03-14T06:06:29.190Z",
  "cooked": "<p>Looking into this more \u2014 it seems that practical accumulators with O(1) witness sizes tend to require trapdoors.  In other words, you have some party that knows of the trapdoor and is able to forge commitments.  I am unaware of any cryptographic accumulator with O(1) witness size that is trapdoorless, they seem to require O(log N) witness size (which in a all-N-unilaterally-exit case leads to O(N log N) exit).</p>\n<p>In particular, as noted, it turns out trees, including <code>CTV</code>-trees, have O(N) total data, and an all-N-unilaterally-exit using <code>CTV</code> trees is actually O(N), because mipmaps are awesome.</p>\n<p>Note that just because there is a trapdoor does <em><strong>not</strong></em> mean that the party-with-trapdoor must absolutely be some <em><strong>single</strong></em> trusted party.  With the magic of multiparty computation it may be possible to create a party-with-trapdoor that is actually the N-of-N of all participants, such that no one participant actually knows the trapdoor.  See <code>OP_EVICT</code> for an example.</p>\n<p>(ROLL-YOUR-OWN-CRYPTO-WARNING) For the case of unilateral exit rather than eviction as with <code>OP_EVICT</code>, the trapdoor may be a simple sum of N pubkeys from all participants (as in <code>OP_EVICT</code>) \u2014 you need to protect against key cancellation attacks as well, such as requiring proof of knowledge of private key of each pubkey share.  Suppose there are public keys <code>point[0]</code> to <code>point[n-1]</code>, the trapdoor being the corresponding sum of private keys (shards of which are known by the participants, but no one participant knows the entire trapdoor).  To commit to a particular <code>(point[i], value[i])</code>, then the signers <code>point[0]..point[i-1]</code> and <code>point[i+1]..point[n-1]</code> \u2014 i.e. all the signers <em><strong>except</strong></em> <code>point[i]</code> \u2014 construct a MuSig2 signature committing to <code>(point[i], value[i])</code>.  More specifically, the owner of <code>(point[i], value[i])</code> gets MuSig2 partial signatures and stores each partial signature with the corresponding <code>point[all except i]</code> from that participant.  Then the accumulator is the sum of <code>point[0]</code> to <code>point[n-1]</code>.</p>\n<p>To delete from the accumulator, you show <code>(point[i], value[i])</code> you commit to, then subtract <code>point[i]</code> from the accumulator amount.  The owner of <code>(point[i], value[i])</code> then sums up all the partial signatures to generate a full MuSig2 signature, which it presents as witness that <code>(point[i], value[i])</code> was committed in the accumulator.  The next accumulator is then the current accumulator minus <code>point[i]</code>.  The other owners of <code>(point[j[, value[j])</code> where <code>i != j</code> then remove the partial signature from <code>point[i]</code> from their storage, so that when they exit later, their own witness sums up to the correct value.(we would need a variant of Schnorr signing which does not commit to the signing public key \u2014 ROLL-YOUR-OWN-CRYPTO-WARNING).  Note that the last exiter cannot present a witness though \u2014 maybe every such construct could use a publicized shared private key and amount to be used as the \u201clast exiter\u201d (so that the last <em>real</em> exiter is technically always the second-to-the-last exiter), which miners can then MEVil to get as fee.</p>\n<p>But basically yes, the drawback of trapdoored O(1) accumulators can possibly be worked around with multiparty computation.  <em><strong>The problem is that the setup of a trapdoored-but-non-custodial/trust-minimized requires everyone to be online simultaneously to generate an N-of-N \u201ctrusted\u201d party which is really the consensus of every participant</strong></em>.  The advantage of <code>CTV</code>-trees and non-trapdoored accumulators is that they can be set up without requiring trust and thus without requiring building a consensus N-of-N.</p>",
  "post_number": 10,
  "post_type": 1,
  "updated_at": "2024-03-14T06:07:31.136Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 1,
  "reads": 5,
  "readers_count": 4,
  "score": 6.0,
  "yours": false,
  "topic_id": 664,
  "topic_slug": "unilateral-exit",
  "topic_title": "Unilateral Exit",
  "topic_html_title": "Unilateral Exit",
  "category_id": 7,
  "display_username": "ZmnSCPxj jxPCSnmZ",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Looking into this more --- it seems that practical accumulators with O(1) witness sizes tend to require trapdoors.  In other words, you have some party that knows of the trapdoor and is able to forge commitments.  I am unaware of any cryptographic accumulator with O(1) witness size that is trapdoorless, they seem to require O(log N) witness size (which in a all-N-unilaterally-exit case leads to O(N log N) exit).\n\nIn particular, as noted, it turns out trees, including `CTV`-trees, have O(N) total data, and an all-N-unilaterally-exit using `CTV` trees is actually O(N), because mipmaps are awesome.\n\nNote that just because there is a trapdoor does ***not*** mean that the party-with-trapdoor must absolutely be some ***single*** trusted party.  With the magic of multiparty computation it may be possible to create a party-with-trapdoor that is actually the N-of-N of all participants, such that no one participant actually knows the trapdoor.  See `OP_EVICT` for an example.\n\n(ROLL-YOUR-OWN-CRYPTO-WARNING) For the case of unilateral exit rather than eviction as with `OP_EVICT`, the trapdoor may be a simple sum of N pubkeys from all participants (as in `OP_EVICT`) --- you need to protect against key cancellation attacks as well, such as requiring proof of knowledge of private key of each pubkey share.  Suppose there are public keys `point[0]` to `point[n-1]`, the trapdoor being the corresponding sum of private keys (shards of which are known by the participants, but no one participant knows the entire trapdoor).  To commit to a particular `(point[i], value[i])`, then the signers `point[0]..point[i-1]` and `point[i+1]..point[n-1]` --- i.e. all the signers ***except*** `point[i]` --- construct a MuSig2 signature committing to `(point[i], value[i])`.  More specifically, the owner of `(point[i], value[i])` gets MuSig2 partial signatures and stores each partial signature with the corresponding `point[all except i]` from that participant.  Then the accumulator is the sum of `point[0]` to `point[n-1]`.\n\nTo delete from the accumulator, you show `(point[i], value[i])` you commit to, then subtract `point[i]` from the accumulator amount.  The owner of `(point[i], value[i])` then sums up all the partial signatures to generate a full MuSig2 signature, which it presents as witness that `(point[i], value[i])` was committed in the accumulator.  The next accumulator is then the current accumulator minus `point[i]`.  The other owners of `(point[j[, value[j])` where `i != j` then remove the partial signature from `point[i]` from their storage, so that when they exit later, their own witness sums up to the correct value.(we would need a variant of Schnorr signing which does not commit to the signing public key --- ROLL-YOUR-OWN-CRYPTO-WARNING).  Note that the last exiter cannot present a witness though --- maybe every such construct could use a publicized shared private key and amount to be used as the \"last exiter\" (so that the last *real* exiter is technically always the second-to-the-last exiter), which miners can then MEVil to get as fee.\n\nBut basically yes, the drawback of trapdoored O(1) accumulators can possibly be worked around with multiparty computation.  ***The problem is that the setup of a trapdoored-but-non-custodial/trust-minimized requires everyone to be online simultaneously to generate an N-of-N \"trusted\" party which is really the consensus of every participant***.  The advantage of `CTV`-trees and non-trapdoored accumulators is that they can be set up without requiring trust and thus without requiring building a consensus N-of-N.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 104,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}