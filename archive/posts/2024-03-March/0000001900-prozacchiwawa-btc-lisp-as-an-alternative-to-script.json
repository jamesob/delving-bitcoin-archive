{
  "id": 1900,
  "name": "arty",
  "username": "prozacchiwawa",
  "avatar_template": "/user_avatar/delvingbitcoin.org/prozacchiwawa/{size}/431_2.png",
  "created_at": "2024-03-14T23:03:34.690Z",
  "cooked": "<p>Source maps can be a good start, but there are a few things about clvm and similar compilation targets that may need at least one more step.  In javascript, the vast majority of code the vm executes comes from a source file, is read once and ultimately referenced by address.  Doing that, it\u2019s easy to centralize the information needed to map a specific statement (however the vm stores that internally) to a souce map reference.  You wouldn\u2019t have source map info for the function that results from calling the Function constructor.  At least in chialisp, there is a lot of code that passes on or modifies the environment as a normal clvm value (a lot like calling a function that results from the Function constructor in javascript).</p>\n<p>If care is not taken, it can be difficult or expensive to determine whether some clvm value passed to apply matches a function from the original clvm code.  Really the difficulty boils down to these specifics:</p>\n<ul>\n<li>Determine as well as possible the heritage of values passed to apply to recover their relationship to specific parts of the input clvm expression.</li>\n<li>No statements means no high level sequencing outside of either functions or individual forms.</li>\n<li>Very compact structure means that individual subexpression can have the same clvm representation, which means that a simple 1-1 mapping of literal values in apply isn\u2019t sufficient.</li>\n<li>Javascript environments are mutable hashes with names that have inferrable mappings.  clvm only has numeric environment references, and they only take place after a full apply.  A system with as much power as dwarf is likely needed to fully recover variable assignments in every context.</li>\n</ul>",
  "post_number": 5,
  "post_type": 1,
  "updated_at": "2024-03-14T23:03:34.690Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 5,
  "readers_count": 4,
  "score": 1.0,
  "yours": false,
  "topic_id": 682,
  "topic_slug": "btc-lisp-as-an-alternative-to-script",
  "topic_title": "BTC Lisp as an alternative to Script",
  "topic_html_title": "BTC Lisp as an alternative to Script",
  "category_id": 7,
  "display_username": "arty",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Source maps can be a good start, but there are a few things about clvm and similar compilation targets that may need at least one more step.  In javascript, the vast majority of code the vm executes comes from a source file, is read once and ultimately referenced by address.  Doing that, it's easy to centralize the information needed to map a specific statement (however the vm stores that internally) to a souce map reference.  You wouldn't have source map info for the function that results from calling the Function constructor.  At least in chialisp, there is a lot of code that passes on or modifies the environment as a normal clvm value (a lot like calling a function that results from the Function constructor in javascript).  \n\nIf care is not taken, it can be difficult or expensive to determine whether some clvm value passed to apply matches a function from the original clvm code.  Really the difficulty boils down to these specifics:\n\n- Determine as well as possible the heritage of values passed to apply to recover their relationship to specific parts of the input clvm expression.\n- No statements means no high level sequencing outside of either functions or individual forms.\n- Very compact structure means that individual subexpression can have the same clvm representation, which means that a simple 1-1 mapping of literal values in apply isn't sufficient.\n- Javascript environments are mutable hashes with names that have inferrable mappings.  clvm only has numeric environment references, and they only take place after a full apply.  A system with as much power as dwarf is likely needed to fully recover variable assignments in every context.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 353,
  "hidden": false,
  "trust_level": 0,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}