{
  "id": 2049,
  "name": "David A. Harding",
  "username": "harding",
  "avatar_template": "/user_avatar/delvingbitcoin.org/harding/{size}/6_2.png",
  "created_at": "2024-03-26T21:38:40.495Z",
  "cooked": "<p>(Replying out of order)</p>\n<aside class=\"quote no-group\" data-username=\"sdaftuar\" data-post=\"6\" data-topic=\"696\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/letter_avatar_proxy/v4/letter/s/0ea827/48.png\" class=\"avatar\"> sdaftuar:</div>\n<blockquote>\n<p>Could you elaborate on what the soft fork proposals are that would allow scripts to verify SPV proofs, which you mention here?</p>\n</blockquote>\n</aside>\n<p>I made the assumption (perhaps incorrectly?) that anything that enables <code>OP_CAT</code> or an equivalent allows verifying a merkle proof in conjunction with existing opcodes (namely <code>OP_SHA256</code>/<code>OP_HASH256</code>).  Similarly, those functions also allow verifying proof of work and header chains.  With OP_IF, I think you could be accommodate any consensus-compatible shape of the partial merkle branch.</p>\n<p>If you want to implement something like \u201cmy transaction expires at height 1,234,567\u201d, you require a partial merkle branch that commits to both your transaction and a coinbase transaction with a BIP34 commitment of less than 1,234,567.</p>\n<p>Proposals that enable <code>OP_CAT</code> or an equivalent include:</p>\n<ul>\n<li><a href=\"https://github.com/bitcoin-inquisition/binana/blob/a1d1daab524007819aca70132e0dd97e0e8caf51/2024/BIN-2024-0001.md\">BIN24-1</a></li>\n<li><a href=\"https://github.com/BlockstreamResearch/simplicity\">Simplicity</a></li>\n<li><a href=\"https://delvingbitcoin.org/t/btc-lisp-as-an-alternative-to-script/682\">BTC Lisp</a></li>\n<li>Elements-style <a href=\"https://github.com/ElementsProject/elements/blob/2d298f7e3f76bc6c19d9550af4fd1ef48cf0b2a6/doc/tapscript_opcodes.md#new-opcodes-for-additional-functionality\">streaming SHA</a> opcodes</li>\n<li><a href=\"https://merkle.fun/\">MATT</a></li>\n</ul>\n<aside class=\"quote no-group\" data-username=\"sdaftuar\" data-post=\"6\" data-topic=\"696\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/letter_avatar_proxy/v4/letter/s/0ea827/48.png\" class=\"avatar\"> sdaftuar:</div>\n<blockquote>\n<p>If we were to let an arbitrary 3rd party on the network attach to the transaction graph of any relayed transaction, I think we\u2019d open up all sorts of DoS concerns with mempool policy.</p>\n</blockquote>\n</aside>\n<p>Any time I create an output paying someone I don\u2019t trust, doesn\u2019t that have the same problem?  Similarly, any time I receive an output in a batched transaction that also pays other people\u2014people I didn\u2019t choose to be in a relationship with\u2014doesn\u2019t that also create the same problem?  I think it\u2019s already the case that typical users can be significantly affected by transaction graph dependencies that they have no control over.</p>\n<p>I\u2019m not opposed to an opt-in flag, but that has the downside of making blockchain analysis easier, so I\u2019d love to avoid it if possible.  If it\u2019s possible to make cluster mempool safe for always-allowed sponsorship, I think that would also address the existing problems described above.</p>\n<aside class=\"quote no-group quote-modified\" data-username=\"sdaftuar\" data-post=\"6\" data-topic=\"696\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/letter_avatar_proxy/v4/letter/s/0ea827/48.png\" class=\"avatar\"> sdaftuar:</div>\n<blockquote>\n<p>many of the underlying issues that [fee sponsors] tries to solve require work at the policy layer that could just as readily be done without transaction sponsorship</p>\n</blockquote>\n</aside>\n<p>I don\u2019t understand this point.  Let me quickly quote what I believe is the entire text you previously wrote about this:</p>\n<blockquote>\n<p>the fee bumping improvement that this proposal aims at is\nreally coming from the policy change, rather than the consensus change. But\nif policy changes are the direction we\u2019re going to solve these problems, we\ncould instead just propose new policy rules for the existing types of\ntransaction chaining that we have, rather than couple them to a new\ntransaction type.</p>\n</blockquote>\n<p>It seems to me like the problem you\u2019re attempting to solve here is transaction pinning.  That\u2019s a problem created by policy, so it makes sense to me that we can solve it by policy alone.</p>\n<p>But there\u2019s another problem which has come to my attention more recently, which is the high cost of exogenous fee bumping compared to paying miners out of band.  When the cost difference is too high, users might be incentivized to work with large miners directly, undermining Bitcoin\u2019s decentralization.</p>\n<p>Peter Todd has wielded that argument as a weapon against v3 policy and ephemeral anchors, which I think is unfair: those policies improve the current state of using Bitcoin for a large number of users, so I think we should pursue them (and thank you for all of your work on them!).  But I find his fundamental argument worth thinking about.</p>\n<p>That\u2019s where I think sponsors are interesting.  Whereas ephemeral anchors cost ~11 vbytes for the anchor output and ~41 vbytes for the spend, this improved sponsor proposal is only ~0.5 vbytes.  It\u2019s almost the same as the 0 vbytes used when paying a miner out of band or when using RBF under ideal circumstances.  It gives us all of the advantages of exogenous fees (for contract protocols and also for regular fee bumping) without it\u2019s major long-term downside of potentially worsening decentralization.</p>\n<p>I don\u2019t think it\u2019s possible to achieve that efficiency benefit using policy only, at least not if we stick with a UTXO model.  Any policy we create that boosts the priority of transaction A using funds from transaction B must be rooted in the consensus rules, otherwise miners will claim the value from B without mining A.  But, if I\u2019m missing something, I would love to learn more!</p>",
  "post_number": 7,
  "post_type": 1,
  "updated_at": "2024-03-26T21:43:43.587Z",
  "reply_count": 1,
  "reply_to_post_number": 6,
  "quote_count": 1,
  "incoming_link_count": 0,
  "reads": 7,
  "readers_count": 6,
  "score": 6.4,
  "yours": false,
  "topic_id": 696,
  "topic_slug": "improving-transaction-sponsor-blockspace-efficiency",
  "topic_title": "Improving transaction sponsor blockspace efficiency",
  "topic_html_title": "Improving transaction sponsor blockspace efficiency",
  "category_id": 7,
  "display_username": "David A. Harding",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "(Replying out of order)\n\n[quote=\"sdaftuar, post:6, topic:696\"]\nCould you elaborate on what the soft fork proposals are that would allow scripts to verify SPV proofs, which you mention here?\n[/quote]\n\nI made the assumption (perhaps incorrectly?) that anything that enables `OP_CAT` or an equivalent allows verifying a merkle proof in conjunction with existing opcodes (namely `OP_SHA256`/`OP_HASH256`).  Similarly, those functions also allow verifying proof of work and header chains.  With OP_IF, I think you could be accommodate any consensus-compatible shape of the partial merkle branch.\n\nIf you want to implement something like \"my transaction expires at height 1,234,567\", you require a partial merkle branch that commits to both your transaction and a coinbase transaction with a BIP34 commitment of less than 1,234,567.\n\nProposals that enable `OP_CAT` or an equivalent include:\n\n- [BIN24-1](https://github.com/bitcoin-inquisition/binana/blob/a1d1daab524007819aca70132e0dd97e0e8caf51/2024/BIN-2024-0001.md)\n- [Simplicity](https://github.com/BlockstreamResearch/simplicity)\n- [BTC Lisp](https://delvingbitcoin.org/t/btc-lisp-as-an-alternative-to-script/682)\n- Elements-style [streaming SHA](https://github.com/ElementsProject/elements/blob/2d298f7e3f76bc6c19d9550af4fd1ef48cf0b2a6/doc/tapscript_opcodes.md#new-opcodes-for-additional-functionality) opcodes\n- [MATT](https://merkle.fun/)\n\n[quote=\"sdaftuar, post:6, topic:696\"]\nIf we were to let an arbitrary 3rd party on the network attach to the transaction graph of any relayed transaction, I think we\u2019d open up all sorts of DoS concerns with mempool policy.\n[/quote]\n\nAny time I create an output paying someone I don't trust, doesn't that have the same problem?  Similarly, any time I receive an output in a batched transaction that also pays other people---people I didn't choose to be in a relationship with---doesn't that also create the same problem?  I think it's already the case that typical users can be significantly affected by transaction graph dependencies that they have no control over.\n\nI'm not opposed to an opt-in flag, but that has the downside of making blockchain analysis easier, so I'd love to avoid it if possible.  If it's possible to make cluster mempool safe for always-allowed sponsorship, I think that would also address the existing problems described above.\n\n[quote=\"sdaftuar, post:6, topic:696\"]\nmany of the underlying issues that [fee sponsors] tries to solve require work at the policy layer that could just as readily be done without transaction sponsorship\n[/quote]\n\nI don't understand this point.  Let me quickly quote what I believe is the entire text you previously wrote about this:\n\n> the fee bumping improvement that this proposal aims at is\nreally coming from the policy change, rather than the consensus change. But\nif policy changes are the direction we're going to solve these problems, we\ncould instead just propose new policy rules for the existing types of\ntransaction chaining that we have, rather than couple them to a new\ntransaction type.\n\nIt seems to me like the problem you're attempting to solve here is transaction pinning.  That's a problem created by policy, so it makes sense to me that we can solve it by policy alone.\n\nBut there's another problem which has come to my attention more recently, which is the high cost of exogenous fee bumping compared to paying miners out of band.  When the cost difference is too high, users might be incentivized to work with large miners directly, undermining Bitcoin's decentralization.\n\nPeter Todd has wielded that argument as a weapon against v3 policy and ephemeral anchors, which I think is unfair: those policies improve the current state of using Bitcoin for a large number of users, so I think we should pursue them (and thank you for all of your work on them!).  But I find his fundamental argument worth thinking about.\n\nThat's where I think sponsors are interesting.  Whereas ephemeral anchors cost ~11 vbytes for the anchor output and ~41 vbytes for the spend, this improved sponsor proposal is only ~0.5 vbytes.  It's almost the same as the 0 vbytes used when paying a miner out of band or when using RBF under ideal circumstances.  It gives us all of the advantages of exogenous fees (for contract protocols and also for regular fee bumping) without it's major long-term downside of potentially worsening decentralization.\n\nI don't think it's possible to achieve that efficiency benefit using policy only, at least not if we stick with a UTXO model.  Any policy we create that boosts the priority of transaction A using funds from transaction B must be rooted in the consensus rules, otherwise miners will claim the value from B without mining A.  But, if I'm missing something, I would love to learn more!",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 6,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": "Github link was replaced with a permanent link",
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}