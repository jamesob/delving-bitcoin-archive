{
  "id": 2271,
  "name": "Bob McElrath",
  "username": "mcelrath",
  "avatar_template": "/user_avatar/delvingbitcoin.org/mcelrath/{size}/521_2.png",
  "created_at": "2024-04-18T13:31:55.182Z",
  "cooked": "<p>As a means to synchronize the mempool in a fragmented mempool world, this does not (and cannot) accomplish that goal. When miners are taking fees out of band, they will not relay the txs they\u2019ve been paid for out of band, nor will they advertise them in weak blocks, as this allows other miners to snipe the fees they\u2019ve been paid out of band. This causes block validation times to go up for everyone else as they retrieve the missing transactions. Weak block relay is too little, too late, and cannot solve the problem.</p>\n<p>The only viable path is to incentivize these miners so that it\u2019s not in their best interest to mine txs out of band but instead should participate in a decentralized mining pool for the other benefits it offers (lower variance, hashrate derivatives, outsourced tx selection to individual miners). This what Braidpool intends to accomplish.</p>\n<p>Another problem with this proposal is that it interferes with the \u201cfirst seen\u201d rule of the mempool. When constructing a block in the face of conflicting transactions, the mempool accepts the \u201cfirst seen\u201d of conflicting transactions. This is not censorship resistant broadcast, and weak blocks (alone) is also not censorship resistant. Putting a weak PoW on a blob of transactions alone does not give me any consensus on which txs came first, and timestamps can be manipulated. Seeing a weak block and retrieving txs in it does not give me a solution to resolve conflicting txs between two weak blocks.</p>\n<p>This leads to putting a consensus mechanism on the weak blocks, which provides a time ordering and conflict resolution mechanism on the contained txs. The simplest way to do this is just to extend Nakamoto consensus to a DAG and follow the \u201cmost PoW\u201d rule. <a href=\"https://eprint.iacr.org/2022/1494.pdf\" rel=\"noopener nofollow ugc\">DAGKnight</a> is a reasonable solution and I believe <a href=\"https://rawgit.com/mcelrath/braidcoin/master/Braid%2BExamples.html\" rel=\"noopener nofollow ugc\">my Braid proposal is equivalent</a>. It\u2019s very simple to add a committed header field pointing to the most recently seen \u201ctip\u201d weak blocks, which forms a DAG structure. The DAG can be partial ordered in linear time using known algorithms (\u201cMost Recent Common Ancestor\u201d) that are only ~100 lines of code. Once a DAG consensus protocol is present, a decentralized mining pool can enforce that a block must contain only transactions already broadcast in its ancestor weak-blocks.</p>\n<p>Note that the existence of a decentralized mining pool cannot stop centralized pools from accepting txs out of band. There is no protocol way to do that. The only way to do that is to make it economically nonviable to do so.</p>\n<p>For further reading, you might be interested in my <a href=\"https://github.com/braidpool/braidpool/blob/cd5c7d4b610c3894794766d83ee1991cf2a753b4/docs/general_considerations.md\" rel=\"noopener nofollow ugc\">discussion of weak blocks</a> or the <a href=\"https://github.com/braidpool/braidpool/blob/cd5c7d4b610c3894794766d83ee1991cf2a753b4/docs/overview.md\" rel=\"noopener nofollow ugc\">Overview to get an idea how a decentralized mining pool could be attractive enough to overtake centralized pools (and tx withholding/OOB)</a> and there\u2019s the <a href=\"https://github.com/braidpool/braidpool/blob/cd5c7d4b610c3894794766d83ee1991cf2a753b4/docs/braidpool_spec.md\" rel=\"noopener nofollow ugc\">WIP Spec which we\u2019d be happy to receive further feedback on</a>.</p>\n<p>Cheers,\n\u2013 Bob</p>",
  "post_number": 7,
  "post_type": 1,
  "updated_at": "2024-04-18T13:36:59.726Z",
  "reply_count": 1,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 1,
  "reads": 11,
  "readers_count": 10,
  "score": 12.2,
  "yours": false,
  "topic_id": 805,
  "topic_slug": "second-look-at-weak-blocks",
  "topic_title": "Second Look at Weak Blocks",
  "topic_html_title": "Second Look at Weak Blocks",
  "category_id": 8,
  "display_username": "Bob McElrath",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "As a means to synchronize the mempool in a fragmented mempool world, this does not (and cannot) accomplish that goal. When miners are taking fees out of band, they will not relay the txs they've been paid for out of band, nor will they advertise them in weak blocks, as this allows other miners to snipe the fees they've been paid out of band. This causes block validation times to go up for everyone else as they retrieve the missing transactions. Weak block relay is too little, too late, and cannot solve the problem.\n\nThe only viable path is to incentivize these miners so that it's not in their best interest to mine txs out of band but instead should participate in a decentralized mining pool for the other benefits it offers (lower variance, hashrate derivatives, outsourced tx selection to individual miners). This what Braidpool intends to accomplish.\n\nAnother problem with this proposal is that it interferes with the \"first seen\" rule of the mempool. When constructing a block in the face of conflicting transactions, the mempool accepts the \"first seen\" of conflicting transactions. This is not censorship resistant broadcast, and weak blocks (alone) is also not censorship resistant. Putting a weak PoW on a blob of transactions alone does not give me any consensus on which txs came first, and timestamps can be manipulated. Seeing a weak block and retrieving txs in it does not give me a solution to resolve conflicting txs between two weak blocks.\n\nThis leads to putting a consensus mechanism on the weak blocks, which provides a time ordering and conflict resolution mechanism on the contained txs. The simplest way to do this is just to extend Nakamoto consensus to a DAG and follow the \"most PoW\" rule. [DAGKnight](https://eprint.iacr.org/2022/1494.pdf) is a reasonable solution and I believe [my Braid proposal is equivalent](https://rawgit.com/mcelrath/braidcoin/master/Braid%2BExamples.html). It's very simple to add a committed header field pointing to the most recently seen \"tip\" weak blocks, which forms a DAG structure. The DAG can be partial ordered in linear time using known algorithms (\"Most Recent Common Ancestor\") that are only ~100 lines of code. Once a DAG consensus protocol is present, a decentralized mining pool can enforce that a block must contain only transactions already broadcast in its ancestor weak-blocks.\n\nNote that the existence of a decentralized mining pool cannot stop centralized pools from accepting txs out of band. There is no protocol way to do that. The only way to do that is to make it economically nonviable to do so.\n\nFor further reading, you might be interested in my [discussion of weak blocks](https://github.com/braidpool/braidpool/blob/cd5c7d4b610c3894794766d83ee1991cf2a753b4/docs/general_considerations.md) or the [Overview to get an idea how a decentralized mining pool could be attractive enough to overtake centralized pools (and tx withholding/OOB)](https://github.com/braidpool/braidpool/blob/cd5c7d4b610c3894794766d83ee1991cf2a753b4/docs/overview.md) and there's the [WIP Spec which we'd be happy to receive further feedback on](https://github.com/braidpool/braidpool/blob/cd5c7d4b610c3894794766d83ee1991cf2a753b4/docs/braidpool_spec.md).\n\nCheers,\n-- Bob",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 406,
  "hidden": false,
  "trust_level": 0,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": "Github link was replaced with a permanent link",
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}