{
  "id": 2217,
  "name": "Suhas Daftuar",
  "username": "sdaftuar",
  "avatar_template": "/letter_avatar_proxy/v4/letter/s/0ea827/{size}.png",
  "created_at": "2024-04-12T17:46:06.036Z",
  "cooked": "<p>In <a href=\"https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393\" class=\"inline-onebox\">An overview of the cluster mempool proposal</a>, I wrote up a description of a new mempool design.  As that proposal would change which transactions make it into the mempool under certain circumstances, it raises questions around what effects those changes to relay policy might have on the network, should the proposal be widely adopted.</p>\n<p>I attempted to gain some insights into this by simulating the mempool using the current design in Bitcoin Core on data from 2023, and comparing that to a simulation of my prototype cluster mempool implementation (<a href=\"https://github.com/bitcoin/bitcoin/pull/28676\" class=\"inline-onebox\">[WIP] Cluster mempool implementation by sdaftuar \u00b7 Pull Request #28676 \u00b7 bitcoin/bitcoin \u00b7 GitHub</a>) on that same data.  In this post, I\u2019ll summarize my findings.</p>\n<h1><a name=\"methodology-1\" class=\"anchor\" href=\"#methodology-1\"></a>Methodology</h1>\n<h2><a name=\"background-2\" class=\"anchor\" href=\"#background-2\"></a>Background</h2>\n<p>I have a patchset to Bitcoin Core that does two things:</p>\n<ol>\n<li>Datalogging: a node running with datalogging enabled will record every block, transaction, header, compact block (etc) received over the network along with a timestamp, and write it to disk.</li>\n<li>Simulation: when running in simulation mode, the networking code is disabled, and for the given target date range, the node will read stored data and play it back through validation (via the <code>ProcessNewBlock</code> and <code>ProcessTransaction</code> hooks in Bitcoin Core).  This allows for studying the effect of changes to the mempool or consensus logic on historical blocks and transactions.</li>\n</ol>\n<p>My datalogger has been (mostly) running for the past 10 years or so, so I have a lot of historical data that my logging node has seen. Note that there is nothing canonical about my data; when I run my simulations, I am just taking one node\u2019s view of the network into account when doing analysis.  However, I believe the data I have should be representative of what other nodes may see as well.</p>\n<h2><a name=\"additional-code-changes-for-this-study-3\" class=\"anchor\" href=\"#additional-code-changes-for-this-study-3\"></a>Additional code changes for this study</h2>\n<p>I patched my cluster mempool prototype implementation with the simulation code described above, and did the same with a recent commit from Bitcoin Core\u2019s master branch.  In addition, I made a couple of additional changes to the code:</p>\n<ol>\n<li>Comparing the effects on mining: in both simulations, I inserted a call to <code>CreateNewBlock()</code> just before each actual block received over the network is delivered by the simulation system. This allows for comparing block templates that would be generated by each implementation, sampled at consistent points in time (which happen to line up with when actual blocks were relayed on the network).</li>\n<li>Simulating the effect of a cluster size limit on user behavior: in just the cluster mempool simulation, I modified the transaction processing logic to store transactions that were rejected due to a cluster size limit being hit, and then to try to reprocess all such stored transactions after each block is delivered.  (more discussion on this below)</li>\n</ol>\n<h2><a name=\"configuration-4\" class=\"anchor\" href=\"#configuration-4\"></a>Configuration</h2>\n<ol>\n<li>I ran both simulations with <code>-debug=mempool</code> and <code>-debug=mempoolrej</code>, so that I had logging for every transaction\u2019s acceptance or rejection from the mempool.</li>\n<li>I also ran both simulations with <code>-maxmempool=20000</code>, to effectively unlimit the mempool size so that mempool trimming would not be triggered. This reduced the noice in comparing differences between the simulations, as otherwise we\u2019d have small differences from slightly different mempool minimum fee values that occur because the memory layout/usage of the two implementations differ.</li>\n<li>The cluster mempool implementation was run with cluster mempool limits of <strong>100 transactions/101 kvb</strong> transaction size.  (Note also that the cluster mempool implementation has no limits on ancestor or descendant counts or sizes.)</li>\n</ol>\n<p>Both simulations were run on all the data I recorded in 2023, from Jan 1 to  December 31.</p>\n<p>Note that I\u2019m presenting statistics from my last run of the cluster mempool simulation, but it took me a few tries to get it right (I had some bugs to fix along the way).</p>\n<h1><a name=\"results-5\" class=\"anchor\" href=\"#results-5\"></a>Results</h1>\n<h2><a name=\"overall-transactions-accepted-6\" class=\"anchor\" href=\"#overall-transactions-accepted-6\"></a>Overall transactions accepted</h2>\n<ol>\n<li>Cluster mempool: <strong>151,579,643</strong></li>\n<li>Baseline: <strong>151,561,522 (~0.01% fewer txs)</strong></li>\n</ol>\n<p>There are a couple of reasons we see different transactions accepted in each simulation:</p>\n<ul>\n<li>The cluster mempool logic rejects transactions that would create clusters that are too large, but it is more lax than the baseline logic which imposes a limit on ancestor/descendant counts. In 2023, those ancestor/descendant limits caused over 46k txs to be rejected at some point (note that they may have been later accepted in the simulation if they were rebroadcast). Meanwhile, only ~14k transactions were rejected due to a cluster size limit being hit, in the cluster mempool simulation (more on this below).</li>\n<li>The RBF rules enforced in the two simulations are different, but this turned out to produce a negligible effect on the aggregate acceptance numbers here. I\u2019ll discuss the RBF differences in more detail below.</li>\n</ul>\n<p>In the aggregate, the absolute differences in accepted transactions is negligible. However, this high level analysis doesn\u2019t answer the question of whether there might be some use cases that are meaningfully affected, which gets lost in the big picture.</p>\n<h2><a name=\"effect-of-retrying-cluster-size-rejected-transactions-7\" class=\"anchor\" href=\"#effect-of-retrying-cluster-size-rejected-transactions-7\"></a>Effect of retrying cluster-size-rejected transactions</h2>\n<p>In a cluster mempool world, we might expect users to respond to a transaction being rejected due to a cluster size limit in a couple of different ways. One is that they might reconstruct their transaction by changing inputs, to try to avoid creating too large of a cluster.  However another possibility is that users might just wait and try to rebroadcast their transaction later, after other transactions already in the cluster are confirmed.</p>\n<p>(This is the same as what I expect users might do today, should they hit an ancestor or descendant size limit.)</p>\n<p>We don\u2019t have a good way to simulate users choosing to reconstruct their transactions in the face of a rejection, but by retrying transactions that were rejected due to cluster size limits, we can model the effectiveness of the wait-and-rebroadcast approach.  In particular, we can estimate that transactions which were eventually accepted to the mempool in the simulation would have been minimally affected by a cluster size limit last year, because being accepted to the mempool means that relay would have been successful prior to the transaction being selected by a miner last year.</p>\n<p>With that in mind, here are the numbers for cluster size rejections and eventual mempool acceptance on retry:</p>\n<ul>\n<li>Total transactions accepted to cluster mempool in 2023: \t\t<strong>151,579,643</strong></li>\n<li>Number of transactions rejected due to cluster limit: \t\t\t<strong>14,358</strong></li>\n<li>Number of these accepted during reprocessing after a block: \t<strong>10,122 (70%)</strong></li>\n</ul>\n<p>So a very small percentage of overall transactions were rejected due to a cluster size limit, and of those, 70% would have been ultimately accepted to the mempool.  That gives us a bound of at most 30% of transactions that would have been rejected and not ultimately accepted (note: I didn\u2019t verify that these 30% were all mined, so this is an upper bound).</p>\n<h2><a name=\"economic-significance-of-mempool-differences-8\" class=\"anchor\" href=\"#economic-significance-of-mempool-differences-8\"></a>Economic significance of mempool differences</h2>\n<p>While we\u2019ve seen that the number of transactions affected by the cluster mempool change is very small, the question remains whether those transactions might be economically significant to the network (and miners who would potentially be missing out on the ability to include them, in a cluster mempool world).</p>\n<p>To get a sense of this, we can look at differences in block fees, as determined from running <code>CreateNewBlock()</code> at the same points in time in both simulations, and looking at the distribution of the differences in total fees.</p>\n<h3><a name=\"percentage-fee-differences-9\" class=\"anchor\" href=\"#percentage-fee-differences-9\"></a>Percentage fee differences</h3>\n<p>This graph shows the percentage fee difference between the blocks produced by the cluster mempool simulation and the baseline simulation. Each datapoint (x, y) is (block number, (cluster_fees - baseline_fees) / cluster_fees)).</p>\n<p><strong><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/1X/4ff6794658a3fb48b4e38066cfd7437819571f0f.jpeg\" data-download-href=\"https://delvingbitcoin.org/uploads/default/4ff6794658a3fb48b4e38066cfd7437819571f0f\" title=\"|744px;x540px;\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/1X/4ff6794658a3fb48b4e38066cfd7437819571f0f_2_689x499.jpeg\" alt=\"|744px;x540px;\" data-base62-sha1=\"bpnMPTYbRrQJInwE8ff5VAou40L\" width=\"689\" height=\"499\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/1X/4ff6794658a3fb48b4e38066cfd7437819571f0f_2_689x499.jpeg, https://delvingbitcoin.org/uploads/default/optimized/1X/4ff6794658a3fb48b4e38066cfd7437819571f0f_2_1033x748.jpeg 1.5x, https://delvingbitcoin.org/uploads/default/optimized/1X/4ff6794658a3fb48b4e38066cfd7437819571f0f_2_1378x998.jpeg 2x\" data-dominant-color=\"E6EDF1\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">|744px;x540px;</span><span class=\"informations\">2048\u00d71486 210 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></strong></p>\n<h3><a name=\"absolute-fee-differences-10\" class=\"anchor\" href=\"#absolute-fee-differences-10\"></a>Absolute fee differences</h3>\n<p>This graph shows the absolute difference in fees (same data as shown above, but the y-values are not normalized by the block fees in the cluster mempool blocks):</p>\n<p><strong><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/1X/53f0617ae2b27754788d46052aeba7560bc2d8b8.jpeg\" data-download-href=\"https://delvingbitcoin.org/uploads/default/53f0617ae2b27754788d46052aeba7560bc2d8b8\" title=\"|746px;x540px;\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/1X/53f0617ae2b27754788d46052aeba7560bc2d8b8_2_690x499.jpeg\" alt=\"|746px;x540px;\" data-base62-sha1=\"bYyDTB83rFZgP8puPwiNOajGFa8\" width=\"690\" height=\"499\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/1X/53f0617ae2b27754788d46052aeba7560bc2d8b8_2_690x499.jpeg, https://delvingbitcoin.org/uploads/default/optimized/1X/53f0617ae2b27754788d46052aeba7560bc2d8b8_2_1035x748.jpeg 1.5x, https://delvingbitcoin.org/uploads/default/optimized/1X/53f0617ae2b27754788d46052aeba7560bc2d8b8_2_1380x998.jpeg 2x\" data-dominant-color=\"F5F7F9\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">|746px;x540px;</span><span class=\"informations\">2048\u00d71483 161 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></strong></p>\n<p>(Note: the x-axis is again the block number, just as in the prior graph, but for some reason it rendered as the block height rather than starting at 0.)</p>\n<h3><a name=\"histogram-of-fee-differences-11\" class=\"anchor\" href=\"#histogram-of-fee-differences-11\"></a>Histogram of fee differences</h3>\n<p>Just to give a sense of how often one implementation outperformed the other, I produced a histogram of the fee differences. I discarded the 0 values to avoid skewing the histogram with values where the implementations tied.</p>\n<p><strong><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/1X/0b2e8369deb731e6ae7092bb526943d997a396a4.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/0b2e8369deb731e6ae7092bb526943d997a396a4\" title=\"|702px;x508px;\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/1X/0b2e8369deb731e6ae7092bb526943d997a396a4_2_690x499.png\" alt=\"|702px;x508px;\" data-base62-sha1=\"1AUUcIoRXf4tBowW7cgs9sEqHPK\" width=\"690\" height=\"499\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/1X/0b2e8369deb731e6ae7092bb526943d997a396a4_2_690x499.png, https://delvingbitcoin.org/uploads/default/optimized/1X/0b2e8369deb731e6ae7092bb526943d997a396a4_2_1035x748.png 1.5x, https://delvingbitcoin.org/uploads/default/optimized/1X/0b2e8369deb731e6ae7092bb526943d997a396a4_2_1380x998.png 2x\" data-dominant-color=\"E2EBEF\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">|702px;x508px;</span><span class=\"informations\">2048\u00d71482 147 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></strong></p>\n<p>The buckets here are in increments of 500k sats.</p>\n<h3><a name=\"statistics-12\" class=\"anchor\" href=\"#statistics-12\"></a>Statistics</h3>\n<ul>\n<li>Average fee difference (cluster - baseline): \t\t\t<strong>153,615 sats</strong></li>\n<li>Percentage of blocks where cluster was better: \t\t<strong>72.8%</strong></li>\n<li>Percentage of blocks where baseline was better: \t\t<strong>8.4%</strong></li>\n<li>Maximum amount cluster was better by: \t\t\t\t<strong>18,246,422 sats</strong></li>\n<li>Maximum amount baseline was better by: \t\t\t<strong>10,299,305 sats</strong></li>\n</ul>\n<h3><a name=\"discussion-13\" class=\"anchor\" href=\"#discussion-13\"></a>Discussion</h3>\n<p>Note that these graphs overstate the benefit of cluster mempool. This is for a few reasons:</p>\n<ul>\n<li>If there\u2019s a sort order that is more optimal than what miners were doing in practice last year, this analysis will show persistent differences until the transactions that caused the difference were mined.</li>\n<li>This also conflates two effects: the choice of what to accept to the mempool, and the sort order of what is in the mempool. Cluster mempool gives us differences in both. Of course, we can\u2019t easily tease these apart because it\u2019s not practical to do a more optimal sorting using the legacy mempool.</li>\n<li>Over longer time spans, the differences in sort order don\u2019t matter, as essentially all the same transactions eventually get mined.</li>\n</ul>\n<p>However, if we\u2019re trying to answer the question of whether cluster mempool might have a significant negative impact on fees collected in blocks, then it seems to me that there is no evidence of this in the data.  While it may be inconclusive as to whether cluster mempool is materially <em>better</em> than baseline based on network activity in 2023, it strikes me as very unlikely that cluster mempool is materially <em>worse</em>.</p>\n<h2><a name=\"rbf-changes-14\" class=\"anchor\" href=\"#rbf-changes-14\"></a>RBF changes</h2>\n<p>As a reminder, the cluster mempool RBF rules are centered around whether the <a href=\"https://delvingbitcoin.org/t/mempool-incentive-compatibility/553/1\">feerate diagram of the mempool would improve</a> after the replacement takes place, while Bitcoin Core\u2019s existing RBF rules are roughly what is described in BIP 125 and <a href=\"https://github.com/bitcoin/bitcoin/blob/0de63b8b46eff5cda85b4950062703324ba65a80/doc/policy/mempool-replacements.md\">documented here</a>.</p>\n<p>Unlike BIP 125, the proposed RBF rule is focused on the <em>result</em> of a replacement.  A tx can be better in theory than in practice: maybe it \u201cshould\u201d be accepted based on a theoretical understanding of what should be good for the mempool, but if the resulting feerate diagram is worse for any reason (say, because the linearization algorithm is not optimal), then we\u2019ll reject the replacement.</p>\n<p>So, we should wonder:</p>\n<ul>\n<li>Do any quirks arise from doing things this way?</li>\n<li>Does the number of RBFs successfully processed materially change?</li>\n<li>Are there transactions that are rejected in cluster mempool which \u201cshould\u201d be accepted?</li>\n<li>Are use cases impacted from users (ab-)using the old rules?</li>\n</ul>\n<h3><a name=\"aggregate-effects-15\" class=\"anchor\" href=\"#aggregate-effects-15\"></a>Aggregate effects</h3>\n<p>To start, we can note the number of total RBF replacements in each simulation:</p>\n<ul>\n<li>Cluster mempool: <strong>3,642,009</strong></li>\n<li>Baseline: <strong>3,641,885</strong></li>\n</ul>\n<p>These numbers are nearly identical in aggregate, and the cluster mempool branch was able to process slightly more transactions than the baseline.  Certain rules are not enforced in the cluster mempool model, which serve to restrict the number of txs accepted by the baseline model:</p>\n<ul>\n<li>Rule against adding new unconfirmed parents (532 txs rejected for this in baseline)</li>\n<li>Descendant chain limit can be more restrictive than cluster size limit</li>\n</ul>\n<p>However, my primary focus in analyzing this data was to try to characterize the replacements which would have been rejected by cluster mempool, but accepted under BIP 125.</p>\n<h3><a name=\"cluster-mempool-rbf-rejections-16\" class=\"anchor\" href=\"#cluster-mempool-rbf-rejections-16\"></a>Cluster mempool RBF rejections</h3>\n<p>Why are some replacememnts rejected only by the cluster mempool rules?  There are four reasons that we might reject a replacement in the proposed RBF policy:</p>\n<ol>\n<li><strong>Too many direct conflicts</strong>. In my current implementation, there is a limit of 100 direct conflicts that a replacement can have (which bounds the number of clusters that might need to be re-linearized to 100). This is more lax than BIP 125\u2019s rule about the number of conflicts a transaction can have.</li>\n<li><strong>Tx fee must exceed that of conflicts and be able to pay for own relay</strong>. This anti-DoS rule is the same as what appears in BIP 125.</li>\n<li><strong>Cluster size limit would be exceeded</strong>. We calculate the size of clusters if the replacement succeeds, and if a cluster would be too big, then we reject the replacement.</li>\n<li><strong>Feerate diagram does not improve</strong>.  This captures the entirety of our new incentive compatibility rule.</li>\n</ol>\n<p>Reasons 2 and 4 were the primary reasons we saw RBF attempts rejected in the cluster mempool simulation; since rule 2 is the same as we have currently, I wanted to characterize all the reasons we might see a replacement that passes the BIP 125 rules yet would fail the feerate diagram check.</p>\n<p>Fewer than 60 replacement attempts (out of the ~150M accepted transactions last year) fell into this category, and almost all could be characterized as fitting into one of these two scenarios:</p>\n<ol>\n<li>\n<p><strong>Merging parents</strong> \u2013 a transaction conflicted with two or more other transactions which had low fee parents, and the replacement transaction spent all those low fee parents, resulting in a worse mining score than a conflict.</p>\n</li>\n<li>\n<p><strong>Higher feerate child</strong> \u2013 a transaction conflicted with a tx that had a higher feerate child than the replacement transaction.**</p>\n</li>\n</ol>\n<p>I\u2019ll explain each in turn, with an actual example from last year.</p>\n<h4><a name=\"merging-parents-17\" class=\"anchor\" href=\"#merging-parents-17\"></a>Merging parents</h4>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/1X/f805f7b44aa8739e986fed4e0aa6520b14a5630d.jpeg\" data-download-href=\"https://delvingbitcoin.org/uploads/default/f805f7b44aa8739e986fed4e0aa6520b14a5630d\" title=\"Merging parents example\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/1X/f805f7b44aa8739e986fed4e0aa6520b14a5630d_2_690x343.jpeg\" alt=\"Merging parents example\" data-base62-sha1=\"zo7chOQC9XuhJXfK28LwN3vNIgR\" width=\"690\" height=\"343\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/1X/f805f7b44aa8739e986fed4e0aa6520b14a5630d_2_690x343.jpeg, https://delvingbitcoin.org/uploads/default/optimized/1X/f805f7b44aa8739e986fed4e0aa6520b14a5630d_2_1035x514.jpeg 1.5x, https://delvingbitcoin.org/uploads/default/optimized/1X/f805f7b44aa8739e986fed4e0aa6520b14a5630d_2_1380x686.jpeg 2x\" data-dominant-color=\"F3EDF0\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">Merging parents example</span><span class=\"informations\">2520\u00d71254 244 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>Here, the blue transaction is a replacement that would conflict with the two red transactions.  We can see that its parents are the union of the parents of the two transactions already in the mempool, and that as a result is mining score (57.3 sat/vb) is actually less than that of one of the conflicts (61.4 sat/vb), despite the replacement having a higher feerate and higher fee than the transactions it would replace.</p>\n<p>In this example, the BIP 125 rules are permitting a replacement that may be making the mempool worse off, by replacing a transaction with a higher mining score with one that has a lower mining score.</p>\n<h4><a name=\"higher-feerate-child-18\" class=\"anchor\" href=\"#higher-feerate-child-18\"></a>Higher feerate child</h4>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/1X/e1d7c185a91add21c77b6114623b50f6726634b9.jpeg\" data-download-href=\"https://delvingbitcoin.org/uploads/default/e1d7c185a91add21c77b6114623b50f6726634b9\" title=\"Higher feerate child\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/1X/e1d7c185a91add21c77b6114623b50f6726634b9_2_690x273.jpeg\" alt=\"Higher feerate child\" data-base62-sha1=\"wdTGwlbsbE1LLo6GcUMHbfw3kpj\" width=\"690\" height=\"273\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/1X/e1d7c185a91add21c77b6114623b50f6726634b9_2_690x273.jpeg, https://delvingbitcoin.org/uploads/default/optimized/1X/e1d7c185a91add21c77b6114623b50f6726634b9_2_1035x409.jpeg 1.5x, https://delvingbitcoin.org/uploads/default/optimized/1X/e1d7c185a91add21c77b6114623b50f6726634b9_2_1380x546.jpeg 2x\" data-dominant-color=\"F5F2F4\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">Higher feerate child</span><span class=\"informations\">2040\u00d7810 121 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>In this example, the blue transaction would replace both the red transactions, but it only directly conflicts with the parent.  Because BIP 125 only requires that a replacement transaction have a higher feerate than its direct conflicts, and the feerate rules of BIP 125 are satisfied, even though the replacement has a lower feerate than the child transaction that it would replace.</p>\n<p>In fact, the child has a higher mining score than the incoming blue transaction (10.6 vs 9.0 sats/vb), so again the BIP 125 rules here are permitting a replacement that may be making the mempool worse.</p>\n<p>It\u2019s tempting to think at this point that the new RBF rules are always just better than BIP 125.  However, there is a caveat to this that is worth flagging.</p>\n<h4><a name=\"replacements-can-also-be-rejected-due-to-suboptimal-linearizations-19\" class=\"anchor\" href=\"#replacements-can-also-be-rejected-due-to-suboptimal-linearizations-19\"></a>Replacements can also be rejected due to suboptimal linearizations</h4>\n<p>Because optimal linearizations are currently only known to be computationally feasible when working on small clusters, we fall back to using heuristics like the ancestor feerate algorithm when linearizing large clusters. As a non-optimal sorting algorithm for clusters, it\u2019s possible that we might have some examples of clusters that would improve if we were using an optimal sort, but actually get worse when using a non-optimal sort.</p>\n<p>And indeed in some of my cluster mempool simulations, I occasionally encountered examples like this.  Typically the situation would be that a replacement is being attempted where the new transaction has the exact same size and parents as an existing transaction, but with a higher fee.  In such situations, it\u2019s obvious that if we simply placed the new transaction in the same spot as the old one, that the mempool would be strictly better.</p>\n<p>However, due to quirks in the ancestor feerate algorithm, sometimes we wouldn\u2019t find a strictly better linearization even in such obvious cases, and thus the new RBF logic would reject the replacement.  These examples are interesting to think about, because:</p>\n<ul>\n<li>This type of situation will always be possible if we allow for non-optimal cluster linearizations, ie, if we permit cluster sizes to be too big to optimally sort.</li>\n<li>Even though such transactions \u201cought\u201d to be accepted, they really are (inadvertently) making the mempool worse in some way, by triggering flaws in our linearization code. This highlights that under the existing BIP 125 rules, we are also allowing such replacements which, under the hood, result in worse behavior than we expect.</li>\n<li>Obviously, we\u2019d still like to eliminate all these cases as much as possible, as it\u2019s more optimal for everyone (users and miners) if this doesn\u2019t happen.</li>\n</ul>\n<p>In practice, we have linearization techniques (learned from seeing these examples) which will eliminate the specific type of failure that I observed from happening again.  However, as a theoretical point, it\u2019s worth noting that these examples will always exist.  So if new use cases emerge that are triggering this behavior, then we may want to put in additional work to try to tweak our algorithms to improve linearizations in those cases.</p>\n<h4><a name=\"rbf-summary-20\" class=\"anchor\" href=\"#rbf-summary-20\"></a>RBF summary</h4>\n<p>Overall, the RBF differences between cluster mempool and existing policy were minimal.  Where they differed, the proposed new RBF rules were largely protecting the mempool against replacements which were not incentive compatible \u2013 a good change.  Yet it\u2019s important to also be aware that in theory, we could see replacements prevented that in an ideal world would be accepted, because sometimes seemingly good replacements can trigger suboptimal behavior, which was previously undetected (by BIP 125 policy) but would be detected and prevented in the new rules.</p>\n<h1><a name=\"summary-21\" class=\"anchor\" href=\"#summary-21\"></a>Summary</h1>\n<p>It seems to me that with cluster size limits of 100 transactions / 101 kvb, and with new RBF rules designed to prevent the mempool feerate diagram from ever worsening, that we wouldn\u2019t really be affecting existing use cases on the network very much, based on last year\u2019s data. An extremely small percentage of transactions would have exercised the new behavior; in the case of transactions which would exceed the new cluster size limits, 70% would have been able to be resubmitted later without affecting when they were ultimately mined.</p>\n<p>In the case of RBF, the effect of the rule change is small and beneficial \u2013 perhaps the ideal type of change!</p>\n<p>And finally, it seems that block construction is unlikely to be any worse, and in my estimation, is actually likely to be better (but this is hard to say definitively).</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2024-04-12T17:51:25.548Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 10,
  "readers_count": 9,
  "score": 47.0,
  "yours": false,
  "topic_id": 794,
  "topic_slug": "research-into-the-effects-of-a-cluster-size-limited-mempool-in-2023",
  "topic_title": "Research into the effects of a cluster size limited mempool in 2023",
  "topic_html_title": "Research into the effects of a cluster size limited mempool in 2023",
  "category_id": 7,
  "display_username": "Suhas Daftuar",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "In https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393, I wrote up a description of a new mempool design.  As that proposal would change which transactions make it into the mempool under certain circumstances, it raises questions around what effects those changes to relay policy might have on the network, should the proposal be widely adopted.\n\nI attempted to gain some insights into this by simulating the mempool using the current design in Bitcoin Core on data from 2023, and comparing that to a simulation of my prototype cluster mempool implementation (https://github.com/bitcoin/bitcoin/pull/28676) on that same data.  In this post, I'll summarize my findings.\n\n# Methodology\n\n## Background\nI have a patchset to Bitcoin Core that does two things:\n1) Datalogging: a node running with datalogging enabled will record every block, transaction, header, compact block (etc) received over the network along with a timestamp, and write it to disk.\n2) Simulation: when running in simulation mode, the networking code is disabled, and for the given target date range, the node will read stored data and play it back through validation (via the `ProcessNewBlock` and `ProcessTransaction` hooks in Bitcoin Core).  This allows for studying the effect of changes to the mempool or consensus logic on historical blocks and transactions.\n\nMy datalogger has been (mostly) running for the past 10 years or so, so I have a lot of historical data that my logging node has seen. Note that there is nothing canonical about my data; when I run my simulations, I am just taking one node's view of the network into account when doing analysis.  However, I believe the data I have should be representative of what other nodes may see as well.\n\n## Additional code changes for this study\nI patched my cluster mempool prototype implementation with the simulation code described above, and did the same with a recent commit from Bitcoin Core's master branch.  In addition, I made a couple of additional changes to the code:\n\n1. Comparing the effects on mining: in both simulations, I inserted a call to `CreateNewBlock()` just before each actual block received over the network is delivered by the simulation system. This allows for comparing block templates that would be generated by each implementation, sampled at consistent points in time (which happen to line up with when actual blocks were relayed on the network).\n2. Simulating the effect of a cluster size limit on user behavior: in just the cluster mempool simulation, I modified the transaction processing logic to store transactions that were rejected due to a cluster size limit being hit, and then to try to reprocess all such stored transactions after each block is delivered.  (more discussion on this below)\n\n## Configuration\n\n1. I ran both simulations with `-debug=mempool` and `-debug=mempoolrej`, so that I had logging for every transaction's acceptance or rejection from the mempool.\n2. I also ran both simulations with `-maxmempool=20000`, to effectively unlimit the mempool size so that mempool trimming would not be triggered. This reduced the noice in comparing differences between the simulations, as otherwise we'd have small differences from slightly different mempool minimum fee values that occur because the memory layout/usage of the two implementations differ.\n3. The cluster mempool implementation was run with cluster mempool limits of **100 transactions/101 kvb** transaction size.  (Note also that the cluster mempool implementation has no limits on ancestor or descendant counts or sizes.)\n\nBoth simulations were run on all the data I recorded in 2023, from Jan 1 to  December 31.\n\nNote that I'm presenting statistics from my last run of the cluster mempool simulation, but it took me a few tries to get it right (I had some bugs to fix along the way).\n\n# Results\n\n## Overall transactions accepted\n\n1. Cluster mempool: **151,579,643**\n2. Baseline: **151,561,522 (~0.01% fewer txs)**\n\nThere are a couple of reasons we see different transactions accepted in each simulation:\n * The cluster mempool logic rejects transactions that would create clusters that are too large, but it is more lax than the baseline logic which imposes a limit on ancestor/descendant counts. In 2023, those ancestor/descendant limits caused over 46k txs to be rejected at some point (note that they may have been later accepted in the simulation if they were rebroadcast). Meanwhile, only ~14k transactions were rejected due to a cluster size limit being hit, in the cluster mempool simulation (more on this below).\n* The RBF rules enforced in the two simulations are different, but this turned out to produce a negligible effect on the aggregate acceptance numbers here. I'll discuss the RBF differences in more detail below.\n\nIn the aggregate, the absolute differences in accepted transactions is negligible. However, this high level analysis doesn't answer the question of whether there might be some use cases that are meaningfully affected, which gets lost in the big picture.\n\n## Effect of retrying cluster-size-rejected transactions\n\nIn a cluster mempool world, we might expect users to respond to a transaction being rejected due to a cluster size limit in a couple of different ways. One is that they might reconstruct their transaction by changing inputs, to try to avoid creating too large of a cluster.  However another possibility is that users might just wait and try to rebroadcast their transaction later, after other transactions already in the cluster are confirmed.\n\n(This is the same as what I expect users might do today, should they hit an ancestor or descendant size limit.)\n\nWe don't have a good way to simulate users choosing to reconstruct their transactions in the face of a rejection, but by retrying transactions that were rejected due to cluster size limits, we can model the effectiveness of the wait-and-rebroadcast approach.  In particular, we can estimate that transactions which were eventually accepted to the mempool in the simulation would have been minimally affected by a cluster size limit last year, because being accepted to the mempool means that relay would have been successful prior to the transaction being selected by a miner last year.\n\nWith that in mind, here are the numbers for cluster size rejections and eventual mempool acceptance on retry:\n\n * Total transactions accepted to cluster mempool in 2023: \t\t**151,579,643**\n * Number of transactions rejected due to cluster limit: \t\t\t**14,358**\n  * Number of these accepted during reprocessing after a block: \t**10,122 (70%)**\n\nSo a very small percentage of overall transactions were rejected due to a cluster size limit, and of those, 70% would have been ultimately accepted to the mempool.  That gives us a bound of at most 30% of transactions that would have been rejected and not ultimately accepted (note: I didn\u2019t verify that these 30% were all mined, so this is an upper bound).\n\n## Economic significance of mempool differences\n\nWhile we've seen that the number of transactions affected by the cluster mempool change is very small, the question remains whether those transactions might be economically significant to the network (and miners who would potentially be missing out on the ability to include them, in a cluster mempool world).\n\nTo get a sense of this, we can look at differences in block fees, as determined from running `CreateNewBlock()` at the same points in time in both simulations, and looking at the distribution of the differences in total fees.\n\n### Percentage fee differences\n\nThis graph shows the percentage fee difference between the blocks produced by the cluster mempool simulation and the baseline simulation. Each datapoint (x, y) is (block number, (cluster_fees - baseline_fees) / cluster_fees)).\n\n**![|744px;x540px;](upload://bpnMPTYbRrQJInwE8ff5VAou40L.jpeg)**\n\n### Absolute fee differences\n\nThis graph shows the absolute difference in fees (same data as shown above, but the y-values are not normalized by the block fees in the cluster mempool blocks):\n\n**![|746px;x540px;](upload://bYyDTB83rFZgP8puPwiNOajGFa8.jpeg)**\n\n(Note: the x-axis is again the block number, just as in the prior graph, but for some reason it rendered as the block height rather than starting at 0.)\n\n### Histogram of fee differences\n\nJust to give a sense of how often one implementation outperformed the other, I produced a histogram of the fee differences. I discarded the 0 values to avoid skewing the histogram with values where the implementations tied.\n\n**![|702px;x508px;](upload://1AUUcIoRXf4tBowW7cgs9sEqHPK.png)**\n\nThe buckets here are in increments of 500k sats.\n\n### Statistics\n\n * Average fee difference (cluster - baseline): \t\t\t**153,615 sats**\n * Percentage of blocks where cluster was better: \t\t**72.8%**\n * Percentage of blocks where baseline was better: \t\t**8.4%**\n * Maximum amount cluster was better by: \t\t\t\t**18,246,422 sats**\n * Maximum amount baseline was better by: \t\t\t**10,299,305 sats**\n\n### Discussion\n\nNote that these graphs overstate the benefit of cluster mempool. This is for a few reasons:\n\n* If there\u2019s a sort order that is more optimal than what miners were doing in practice last year, this analysis will show persistent differences until the transactions that caused the difference were mined.\n* This also conflates two effects: the choice of what to accept to the mempool, and the sort order of what is in the mempool. Cluster mempool gives us differences in both. Of course, we can\u2019t easily tease these apart because it\u2019s not practical to do a more optimal sorting using the legacy mempool.\n* Over longer time spans, the differences in sort order don't matter, as essentially all the same transactions eventually get mined.\n\nHowever, if we're trying to answer the question of whether cluster mempool might have a significant negative impact on fees collected in blocks, then it seems to me that there is no evidence of this in the data.  While it may be inconclusive as to whether cluster mempool is materially *better* than baseline based on network activity in 2023, it strikes me as very unlikely that cluster mempool is materially *worse*.\n\n## RBF changes\n\nAs a reminder, the cluster mempool RBF rules are centered around whether the [feerate diagram of the mempool would improve](https://delvingbitcoin.org/t/mempool-incentive-compatibility/553/1) after the replacement takes place, while Bitcoin Core's existing RBF rules are roughly what is described in BIP 125 and [documented here](https://github.com/bitcoin/bitcoin/blob/0de63b8b46eff5cda85b4950062703324ba65a80/doc/policy/mempool-replacements.md).\n\nUnlike BIP 125, the proposed RBF rule is focused on the *result* of a replacement.  A tx can be better in theory than in practice: maybe it \"should\" be accepted based on a theoretical understanding of what should be good for the mempool, but if the resulting feerate diagram is worse for any reason (say, because the linearization algorithm is not optimal), then we\u2019ll reject the replacement.\n\nSo, we should wonder: \n  * Do any quirks arise from doing things this way?\n  * Does the number of RBFs successfully processed materially change?\n  * Are there transactions that are rejected in cluster mempool which \u201cshould\u201d be accepted?\n  * Are use cases impacted from users (ab-)using the old rules?\n\n### Aggregate effects\n\nTo start, we can note the number of total RBF replacements in each simulation:\n\n* Cluster mempool: **3,642,009**\n* Baseline: **3,641,885**\n\nThese numbers are nearly identical in aggregate, and the cluster mempool branch was able to process slightly more transactions than the baseline.  Certain rules are not enforced in the cluster mempool model, which serve to restrict the number of txs accepted by the baseline model:\n\n * Rule against adding new unconfirmed parents (532 txs rejected for this in baseline)\n * Descendant chain limit can be more restrictive than cluster size limit\n\nHowever, my primary focus in analyzing this data was to try to characterize the replacements which would have been rejected by cluster mempool, but accepted under BIP 125.\n\n### Cluster mempool RBF rejections\n\nWhy are some replacememnts rejected only by the cluster mempool rules?  There are four reasons that we might reject a replacement in the proposed RBF policy:\n\n1. **Too many direct conflicts**. In my current implementation, there is a limit of 100 direct conflicts that a replacement can have (which bounds the number of clusters that might need to be re-linearized to 100). This is more lax than BIP 125's rule about the number of conflicts a transaction can have.  \n2.  **Tx fee must exceed that of conflicts and be able to pay for own relay**. This anti-DoS rule is the same as what appears in BIP 125.\n3.  **Cluster size limit would be exceeded**. We calculate the size of clusters if the replacement succeeds, and if a cluster would be too big, then we reject the replacement.\n4. **Feerate diagram does not improve**.  This captures the entirety of our new incentive compatibility rule.\n\nReasons 2 and 4 were the primary reasons we saw RBF attempts rejected in the cluster mempool simulation; since rule 2 is the same as we have currently, I wanted to characterize all the reasons we might see a replacement that passes the BIP 125 rules yet would fail the feerate diagram check.\n\nFewer than 60 replacement attempts (out of the ~150M accepted transactions last year) fell into this category, and almost all could be characterized as fitting into one of these two scenarios:\n\n1. **Merging parents** \u2013 a transaction conflicted with two or more other transactions which had low fee parents, and the replacement transaction spent all those low fee parents, resulting in a worse mining score than a conflict.\n\n2. **Higher feerate child** \u2013 a transaction conflicted with a tx that had a higher feerate child than the replacement transaction.**\n\nI'll explain each in turn, with an actual example from last year.\n\n#### Merging parents\n\n![Merging parents example|690x343](upload://zo7chOQC9XuhJXfK28LwN3vNIgR.jpeg)\n\nHere, the blue transaction is a replacement that would conflict with the two red transactions.  We can see that its parents are the union of the parents of the two transactions already in the mempool, and that as a result is mining score (57.3 sat/vb) is actually less than that of one of the conflicts (61.4 sat/vb), despite the replacement having a higher feerate and higher fee than the transactions it would replace.\n\nIn this example, the BIP 125 rules are permitting a replacement that may be making the mempool worse off, by replacing a transaction with a higher mining score with one that has a lower mining score.\n\n#### Higher feerate child\n\n![Higher feerate child|690x273](upload://wdTGwlbsbE1LLo6GcUMHbfw3kpj.jpeg)\n\nIn this example, the blue transaction would replace both the red transactions, but it only directly conflicts with the parent.  Because BIP 125 only requires that a replacement transaction have a higher feerate than its direct conflicts, and the feerate rules of BIP 125 are satisfied, even though the replacement has a lower feerate than the child transaction that it would replace.  \n\nIn fact, the child has a higher mining score than the incoming blue transaction (10.6 vs 9.0 sats/vb), so again the BIP 125 rules here are permitting a replacement that may be making the mempool worse.\n\nIt's tempting to think at this point that the new RBF rules are always just better than BIP 125.  However, there is a caveat to this that is worth flagging.\n\n#### Replacements can also be rejected due to suboptimal linearizations\n\nBecause optimal linearizations are currently only known to be computationally feasible when working on small clusters, we fall back to using heuristics like the ancestor feerate algorithm when linearizing large clusters. As a non-optimal sorting algorithm for clusters, it's possible that we might have some examples of clusters that would improve if we were using an optimal sort, but actually get worse when using a non-optimal sort.\n\nAnd indeed in some of my cluster mempool simulations, I occasionally encountered examples like this.  Typically the situation would be that a replacement is being attempted where the new transaction has the exact same size and parents as an existing transaction, but with a higher fee.  In such situations, it's obvious that if we simply placed the new transaction in the same spot as the old one, that the mempool would be strictly better.\n\nHowever, due to quirks in the ancestor feerate algorithm, sometimes we wouldn't find a strictly better linearization even in such obvious cases, and thus the new RBF logic would reject the replacement.  These examples are interesting to think about, because:\n \n * This type of situation will always be possible if we allow for non-optimal cluster linearizations, ie, if we permit cluster sizes to be too big to optimally sort.\n * Even though such transactions \"ought\" to be accepted, they really are (inadvertently) making the mempool worse in some way, by triggering flaws in our linearization code. This highlights that under the existing BIP 125 rules, we are also allowing such replacements which, under the hood, result in worse behavior than we expect. \n * Obviously, we'd still like to eliminate all these cases as much as possible, as it's more optimal for everyone (users and miners) if this doesn't happen.\n\nIn practice, we have linearization techniques (learned from seeing these examples) which will eliminate the specific type of failure that I observed from happening again.  However, as a theoretical point, it's worth noting that these examples will always exist.  So if new use cases emerge that are triggering this behavior, then we may want to put in additional work to try to tweak our algorithms to improve linearizations in those cases.\n\n#### RBF summary\n\nOverall, the RBF differences between cluster mempool and existing policy were minimal.  Where they differed, the proposed new RBF rules were largely protecting the mempool against replacements which were not incentive compatible -- a good change.  Yet it's important to also be aware that in theory, we could see replacements prevented that in an ideal world would be accepted, because sometimes seemingly good replacements can trigger suboptimal behavior, which was previously undetected (by BIP 125 policy) but would be detected and prevented in the new rules.\n\n# Summary\n\nIt seems to me that with cluster size limits of 100 transactions / 101 kvb, and with new RBF rules designed to prevent the mempool feerate diagram from ever worsening, that we wouldn't really be affecting existing use cases on the network very much, based on last year's data. An extremely small percentage of transactions would have exercised the new behavior; in the case of transactions which would exceed the new cluster size limits, 70% would have been able to be resubmitted later without affecting when they were ultimately mined.\n\nIn the case of RBF, the effect of the rule change is small and beneficial -- perhaps the ideal type of change!\n\nAnd finally, it seems that block construction is unlikely to be any worse, and in my estimation, is actually likely to be better (but this is hard to say definitively).",
  "actions_summary": [
    {
      "id": 2,
      "count": 3
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 95,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": "downloaded local copies of images",
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 3
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 3,
  "current_user_used_main_reaction": false
}