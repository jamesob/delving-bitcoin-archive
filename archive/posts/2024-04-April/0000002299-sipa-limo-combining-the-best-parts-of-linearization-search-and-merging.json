{
  "id": 2299,
  "name": "Pieter Wuille",
  "username": "sipa",
  "avatar_template": "/user_avatar/delvingbitcoin.org/sipa/{size}/1100_2.png",
  "created_at": "2024-04-23T02:43:58.324Z",
  "cooked": "<h1><a name=\"limo-linearization-through-incremental-merging-of-optimizations-1\" class=\"anchor\" href=\"#limo-linearization-through-incremental-merging-of-optimizations-1\"></a>LIMO: Linearization through Incremental Merging of Optimizations</h1>\n<div data-theme-toc=\"true\"> </div>\n<h2><a name=\"h-1-introduction-2\" class=\"anchor\" href=\"#h-1-introduction-2\"></a>1. Introduction</h2>\n<p>Consider the linearization algorithm as suggested in <a href=\"https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303\">How To Linearize Your Cluster</a>, excluding the approach from Section 1.2 (Bottleneck Splitting). In broad lines:</p>\n<ul>\n<li>While transactions remain in the cluster:\n<ul>\n<li>Use a computationally-bounded search algorithm which pre-splits on the best remaining ancestor set to find a good topologically valid set of transactions in what remains of the cluster.</li>\n<li>Output the transactions of that topologically valid set as the next linearized transactions.</li>\n<li>Remove the set from the cluster and repeat.</li>\n</ul>\n</li>\n</ul>\n<p>One might expect that this algorithm will always produce a linearization which is (by the convex-hull <a href=\"https://delvingbitcoin.org/t/cluster-mempool-definitions-theory/202#linearizations-and-chunks-3\">feerate diagram</a> metric) at least as good as straight up picking the best ancestor sets of what remains, as this is just additionally doing search on top. It turns out this is <strong>not the case</strong>. In fact, it may (rarely) be strictly worse.</p>\n<p>Consider the following example cluster:</p>\n<pre data-code-height=\"234\" data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">graph BT\n  T0[\"B: 11\"];\n  T1[\"C: 7\"];\n  T2[\"D: 10\"];\n  T3[\"E: 7\"];\n  T4[\"A: 1\"];\n  T0 --&gt; T4;\n  T2 --&gt; T1 --&gt; T4;\n  T3 --&gt; T4;\n</code></pre>\n<p><strong>Ancestor-set based linearization.</strong> The consecutive remaining best ancestor sets are AB (6), CD (8.5), and E (7), and the resulting [A,B,C,D,E] linearization is in fact optimal, chunked as [ABCD (7.25), E (7)].</p>\n<p><strong>Computationally-bounded search.</strong> However, ACDE (6.25) has higher feerate than AB (but worse than ABCD), and thus a (very) bounded search might end up with ACDE as first set to include. The resulting [A,C,D,E,B] linearization, chunked as [ACDEB (7.2)], is not optimal, and strictly worse than [A,B,C,D,E].</p>\n<p>It is not a very satisfactory situation that an algorithm that performs strictly more work can end up with a worse solution.</p>\n<h2><a name=\"h-2-incremental-merging-3\" class=\"anchor\" href=\"#h-2-incremental-merging-3\"></a>2. Incremental merging</h2>\n<p>Of course, we have a good algorithm for combining the best parts of two linearizations already: <a href=\"https://delvingbitcoin.org/t/merging-incomparable-linearizations/209\">merging</a>.</p>\n<p>With that, it is possible to compute two separate linearizations, one using just ancestor sets, and one using bounded search, and then merging the two. But that has downsides too; either:</p>\n<ul>\n<li>We only perform the optimal ancestor set finding once, as part of the ancestor linearization, but then the bounded search cannot take advantage of this information, as it\u2019s only available during the merge at the very end.</li>\n<li>We perform the search for optimal ancestor sets twice (once inside the ancestor linearization, and once inside the pre-splitting during search), meaning duplicate work.</li>\n</ul>\n<p>Overall, it feels like using merging to address this comes \u201ctoo late\u201d. Ideally, we would incorporate the findings of ancestor sort as input to the search. This can be accomplished by turning the overall linearization algorithm into a improvement algorithm:</p>\n<ul>\n<li>Start with an initial linearization <span class=\"math\">L</span>, e.g. the ancestor-based linearization.</li>\n<li>While transactions remain in <span class=\"math\">L</span>:\n<ul>\n<li>Use bounded search to find a high-feerate topologically valid subset <span class=\"math\">S</span> of what remains of <span class=\"math\">L</span>.</li>\n<li>Perform an optimization step that reorders <span class=\"math\">L</span> without worsening it, and such that the initial part of its diagram is at least as good as the diagram of <span class=\"math\">L[S]</span>.</li>\n<li>Output the highest-feerate prefix of <span class=\"math\">L</span> and continue with what remains.</li>\n</ul>\n</li>\n</ul>\n<p><strong>Definition.</strong> The notation <span class=\"math\">L \\triangleleft S</span>, for a linearization <span class=\"math\">L</span> of graph <span class=\"math\">G</span> and set <span class=\"math\">S</span> is used to mean <span class=\"math\">L[S] + L[G \\setminus S]</span>, i.e. <span class=\"math\">L</span> but with the subset <span class=\"math\">S</span> moved to the front.</p>\n<p>The optimization step above can then be written as <span class=\"math\">\\operatorname{merge}(L, L \\triangleleft S)</span>. This is a strict improvement over the existing linearization algorithm, which can be seen as switching to <span class=\"math\">L \\triangleleft S</span> directly. In addition to guaranteeing a result that is as good as the combinations of prefixes of found subsets, the optimization step also guarantees a result that is as good as the initial linearization. And contrary to the merge-at-the-end strategy, the subset searches get to take advantage of the quality of the initial linearization too, as that affects what remains in <span class=\"math\">L</span> (and more, see below).</p>\n<h2><a name=\"h-3-single-set-improvement-steps-4\" class=\"anchor\" href=\"#h-3-single-set-improvement-steps-4\"></a>3. Single-set improvement steps</h2>\n<p>The approach above requires performing a <span class=\"math\">\\operatorname{merge}</span> operation for every search step, which can be up to cubic in complexity, as <span class=\"math\">\\operatorname{merge}</span> may take up to <span class=\"math\">\\mathcal{O}(n^2)</span> time, and we may need to run it up to <span class=\"math\">n</span> times. This would make the overall operation potentially significantly slower than just merging once at the end.</p>\n<p>To address that, observe that the <a href=\"https://delvingbitcoin.org/t/merging-incomparable-linearizations/209#prefix-intersection-merging-5\">merging algorithm</a> itself works by incrementally moving high-feerate subsets to the front. If instead of performing a full merge in every step, we just determine what the first to-be-moved subset would be for the resulting merge, and output that before continuing with what remains of the linearization, we are back to quadratic complexity.</p>\n<p>The result is the LIMO algorithm:</p>\n<p><strong>Definition.</strong> <span class=\"math\">\\Pi(L)</span> denotes the highest-feerate prefix of <span class=\"math\">L</span> (i.e, its first chunk).</p>\n<ul>\n<li>Given an initial linearization <span class=\"math\">L</span>:\n<ul>\n<li>While there are transactions left in <span class=\"math\">L</span>:\n<ul>\n<li>Let <span class=\"math\">l = \\Pi(L)</span>.</li>\n<li>Find a high-feerate topologically-valid subset <span class=\"math\">S</span> of the transactions in <span class=\"math\">L</span> (search).</li>\n<li>Let <span class=\"math\">s = \\Pi(L[S])</span>.</li>\n<li>Let <span class=\"math\">b = s</span> if <span class=\"math\">\\operatorname{feerate}(s) &gt; \\operatorname{feerate}(l)</span>; <span class=\"math\">b = \\Pi(L[l] \\triangleleft s)</span> otherwise.</li>\n<li>Append <span class=\"math\">L[b]</span> to output linearization.</li>\n<li>Remove <span class=\"math\">b</span> from <span class=\"math\">L</span> and repeat.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>As long as the consecutive <span class=\"math\">S</span> sets do not degrade in quality, the resulting linearization will be as good as all its combined prefixes.</p>\n<p>For every search step an initial guess <span class=\"math\">l</span> is known: the highest-feerate prefix of what remains of the initial linearization. This <span class=\"math\">l</span> can be used as the initial <span class=\"math\">\\operatorname{best}</span> inside the <a href=\"https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303\">search algorithm</a> (instead of <span class=\"math\">\\varnothing</span>), which may allow earlier pruning of work queue items whose <span class=\"math\">\\operatorname{pot}</span> isn\u2019t better (see <a href=\"https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303#h-22-potential-set-bounding-7\">Section 2.2</a>), and can reduce the initial size of <span class=\"math\">\\operatorname{imp}</span> (see <a href=\"https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303#h-23-best-bounding-of-potentials-8\">Section 2.3</a>).</p>\n<h2><a name=\"h-4-improving-existing-linearizations-5\" class=\"anchor\" href=\"#h-4-improving-existing-linearizations-5\"></a>4. Improving existing linearizations</h2>\n<p>So far, we have considered LIMO as a replacement for a \u201ccold-start\u201d linearizations, for clusters which do not have a linearization already, or for merging as a linearization retry with an existing one. It could however also be used to improve existing linearizations, by passing in that existing linearization as initial <span class=\"math\">L</span>, rather than an ancestor-based linearization.</p>\n<p>In that setting, it would be useful if the algorithm could merge in two distinct <span class=\"math\">S</span> sets in every iteration, e.g. one found through ancestor-set linearization and one through search, effectively moving the ancestor-set logic into the algorithm itself rather than using it as an input.</p>\n<p>It gets more complicated to have two sets if we want to guarantee a result that\u2019s as good as both, and as good as the initial linearization, but this appears to work (no proof, just a lot of fuzzing\u2026). Let\u2019s call it Double LIMO:</p>\n<ul>\n<li>Given an initial linearization <span class=\"math\">L</span>\n<ul>\n<li>While there are transactions left in <span class=\"math\">L</span>:\n<ul>\n<li>Set <span class=\"math\">b = \\Pi(L)</span>.</li>\n<li>Find high-feerate topologically-valid subsets <span class=\"math\">S_1</span> and <span class=\"math\">S_2</span> of the transactions in <span class=\"math\">L</span>:\n<ul>\n<li><span class=\"math\">S_1</span> could be the best ancestor set in what remains of <span class=\"math\">L</span>.</li>\n<li><span class=\"math\">S_2</span> could be the result of a computationally bounded search in <span class=\"math\">L</span>, using <span class=\"math\">b</span> as a starting point. This search can be delayed until after the <span class=\"math\">S = S_1</span> iteration below, which may provide a better <span class=\"math\">b</span>.</li>\n</ul>\n</li>\n<li>For <span class=\"math\">S \\in \\{S_1, S_2, S_1 \\cap S_2\\}</span>:\n<ul>\n<li>Let <span class=\"math\">s = \\Pi(L[S] \\triangleleft b)</span> (during the first iteration it holds that <span class=\"math\">L[S] \\triangleleft b = L[S]</span>).</li>\n<li>Set <span class=\"math\">b = s</span> if <span class=\"math\">\\operatorname{feerate}(s) &gt; \\operatorname{feerate}(b)</span>; <span class=\"math\">b = \\Pi(L[b] \\triangleleft s)</span> otherwise.</li>\n</ul>\n</li>\n<li>Append <span class=\"math\">L[b]</span> to output linearization.</li>\n<li>Remove <span class=\"math\">b</span> from <span class=\"math\">L</span> and repeat.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>It appears this algorithm even generalizes to higher numbers. E.g. Triple LIMO would involve three subsets and <span class=\"math\">S</span> would loop over their 7 non-empty intersections <span class=\"math\">\\{S_1, S_2, S_1 \\cap S_2, S_3, S_1 \\cap S_3, S_2 \\cap S_3, S_1 \\cap S_2 \\cap S_3\\}</span>.</p>\n<p>Double LIMO can be used in cluster update situations:</p>\n<ul>\n<li>Start with an existing linearzation <span class=\"math\">L</span> for a cluster.</li>\n<li>With a new transaction/package coming it, remove from <span class=\"math\">L</span> the conflicts and append (at the end) the replacements, leaving the order otherwise the same.</li>\n<li><a href=\"https://delvingbitcoin.org/t/linearization-post-processing-o-n-2-fancy-chunking/201\">Post-process</a> <span class=\"math\">L</span>.</li>\n<li>Perform Double LIMO on <span class=\"math\">L</span> (with <span class=\"math\">S_1 =</span> best ancestor set, <span class=\"math\">S_2 =</span> bounded search result).</li>\n<li>Maybe post-process again?</li>\n</ul>\n<p>The result will be at least as good as ancestor sort, at least as good as the combination of prefixes found by bounded search, and at least as good as the result of post-processing the remainder of the original linearization after replacements, all while letting the ancestor sort and bounded search operate on the best state so far.</p>\n<h2><a name=\"acknowledgements-6\" class=\"anchor\" href=\"#acknowledgements-6\"></a>Acknowledgements</h2>\n<p>Thanks to <a class=\"mention\" href=\"/u/ajtowns\">@ajtowns</a> for the notational suggestions.</p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 9,
  "updated_at": "2024-04-24T14:47:07.313Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 118,
  "reads": 54,
  "readers_count": 53,
  "score": 665.8,
  "yours": false,
  "topic_id": 825,
  "topic_slug": "limo-combining-the-best-parts-of-linearization-search-and-merging",
  "topic_title": "LIMO: combining the best parts of linearization search and merging",
  "topic_html_title": "LIMO: combining the best parts of linearization search and merging",
  "category_id": 8,
  "display_username": "Pieter Wuille",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 18,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "# LIMO: Linearization through Incremental Merging of Optimizations\n\n<div data-theme-toc=\"true\"> </div>\n\n## 1. Introduction\n\nConsider the linearization algorithm as suggested in [How To Linearize Your Cluster](https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303), excluding the approach from Section 1.2 (Bottleneck Splitting). In broad lines:\n* While transactions remain in the cluster:\n  * Use a computationally-bounded search algorithm which pre-splits on the best remaining ancestor set to find a good topologically valid set of transactions in what remains of the cluster.\n  * Output the transactions of that topologically valid set as the next linearized transactions.\n  * Remove the set from the cluster and repeat.\n\nOne might expect that this algorithm will always produce a linearization which is (by the convex-hull [feerate diagram](https://delvingbitcoin.org/t/cluster-mempool-definitions-theory/202#linearizations-and-chunks-3) metric) at least as good as straight up picking the best ancestor sets of what remains, as this is just additionally doing search on top. It turns out this is **not the case**. In fact, it may (rarely) be strictly worse.\n\nConsider the following example cluster:\n\n```mermaid height=234,auto\ngraph BT\n  T0[\"B: 11\"];\n  T1[\"C: 7\"];\n  T2[\"D: 10\"];\n  T3[\"E: 7\"];\n  T4[\"A: 1\"];\n  T0 --> T4;\n  T2 --> T1 --> T4;\n  T3 --> T4;\n```\n\n**Ancestor-set based linearization.** The consecutive remaining best ancestor sets are AB (6), CD (8.5), and E (7), and the resulting [A,B,C,D,E] linearization is in fact optimal, chunked as [ABCD (7.25), E (7)].\n\n**Computationally-bounded search.** However, ACDE (6.25) has higher feerate than AB (but worse than ABCD), and thus a (very) bounded search might end up with ACDE as first set to include. The resulting [A,C,D,E,B] linearization, chunked as [ACDEB (7.2)], is not optimal, and strictly worse than [A,B,C,D,E].\n\nIt is not a very satisfactory situation that an algorithm that performs strictly more work can end up with a worse solution.\n\n## 2. Incremental merging\n\nOf course, we have a good algorithm for combining the best parts of two linearizations already: [merging](https://delvingbitcoin.org/t/merging-incomparable-linearizations/209).\n\nWith that, it is possible to compute two separate linearizations, one using just ancestor sets, and one using bounded search, and then merging the two. But that has downsides too; either:\n* We only perform the optimal ancestor set finding once, as part of the ancestor linearization, but then the bounded search cannot take advantage of this information, as it's only available during the merge at the very end.\n* We perform the search for optimal ancestor sets twice (once inside the ancestor linearization, and once inside the pre-splitting during search), meaning duplicate work.\n\nOverall, it feels like using merging to address this comes \"too late\". Ideally, we would incorporate the findings of ancestor sort as input to the search. This can be accomplished by turning the overall linearization algorithm into a improvement algorithm:\n* Start with an initial linearization $L$, e.g. the ancestor-based linearization.\n* While transactions remain in $L$:\n  * Use bounded search to find a high-feerate topologically valid subset $S$ of what remains of $L$.\n  * Perform an optimization step that reorders $L$ without worsening it, and such that the initial part of its diagram is at least as good as the diagram of $L[S]$.\n  * Output the highest-feerate prefix of $L$ and continue with what remains.\n\n**Definition.** The notation $L \\triangleleft S$, for a linearization $L$ of graph $G$ and set $S$ is used to mean $L[S] + L[G \\setminus S]$, i.e. $L$ but with the subset $S$ moved to the front.\n\nThe optimization step above can then be written as $\\operatorname{merge}(L, L \\triangleleft S)$. This is a strict improvement over the existing linearization algorithm, which can be seen as switching to $L \\triangleleft S$ directly. In addition to guaranteeing a result that is as good as the combinations of prefixes of found subsets, the optimization step also guarantees a result that is as good as the initial linearization. And contrary to the merge-at-the-end strategy, the subset searches get to take advantage of the quality of the initial linearization too, as that affects what remains in $L$ (and more, see below).\n\n## 3. Single-set improvement steps\n\nThe approach above requires performing a $\\operatorname{merge}$ operation for every search step, which can be up to cubic in complexity, as $\\operatorname{merge}$ may take up to $\\mathcal{O}(n^2)$ time, and we may need to run it up to $n$ times. This would make the overall operation potentially significantly slower than just merging once at the end.\n\nTo address that, observe that the [merging algorithm](https://delvingbitcoin.org/t/merging-incomparable-linearizations/209#prefix-intersection-merging-5) itself works by incrementally moving high-feerate subsets to the front. If instead of performing a full merge in every step, we just determine what the first to-be-moved subset would be for the resulting merge, and output that before continuing with what remains of the linearization, we are back to quadratic complexity.\n\nThe result is the LIMO algorithm:\n\n**Definition.** $\\Pi(L)$ denotes the highest-feerate prefix of $L$ (i.e, its first chunk).\n\n* Given an initial linearization $L$:\n  * While there are transactions left in $L$:\n    * Let $l = \\Pi(L)$.\n    * Find a high-feerate topologically-valid subset $S$ of the transactions in $L$ (search).\n    * Let $s = \\Pi(L[S])$.\n    * Let $b = s$ if $\\operatorname{feerate}(s) > \\operatorname{feerate}(l)$; $b = \\Pi(L[l] \\triangleleft s)$ otherwise.\n    * Append $L[b]$ to output linearization.\n    * Remove $b$ from $L$ and repeat.\n\nAs long as the consecutive $S$ sets do not degrade in quality, the resulting linearization will be as good as all its combined prefixes.\n\nFor every search step an initial guess $l$ is known: the highest-feerate prefix of what remains of the initial linearization. This $l$ can be used as the initial $\\operatorname{best}$ inside the [search algorithm](https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303) (instead of $\\varnothing$), which may allow earlier pruning of work queue items whose $\\operatorname{pot}$ isn't better (see [Section 2.2](https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303#h-22-potential-set-bounding-7)), and can reduce the initial size of $\\operatorname{imp}$ (see [Section 2.3](https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303#h-23-best-bounding-of-potentials-8)).\n\n## 4. Improving existing linearizations\n\nSo far, we have considered LIMO as a replacement for a \"cold-start\" linearizations, for clusters which do not have a linearization already, or for merging as a linearization retry with an existing one. It could however also be used to improve existing linearizations, by passing in that existing linearization as initial $L$, rather than an ancestor-based linearization.\n\nIn that setting, it would be useful if the algorithm could merge in two distinct $S$ sets in every iteration, e.g. one found through ancestor-set linearization and one through search, effectively moving the ancestor-set logic into the algorithm itself rather than using it as an input.\n\nIt gets more complicated to have two sets if we want to guarantee a result that's as good as both, and as good as the initial linearization, but this appears to work (no proof, just a lot of fuzzing...). Let's call it Double LIMO:\n\n* Given an initial linearization $L$\n  * While there are transactions left in $L$:\n    * Set $b = \\Pi(L)$.\n    * Find high-feerate topologically-valid subsets $S_1$ and $S_2$ of the transactions in $L$:\n      * $S_1$ could be the best ancestor set in what remains of $L$.\n      * $S_2$ could be the result of a computationally bounded search in $L$, using $b$ as a starting point. This search can be delayed until after the $S = S_1$ iteration below, which may provide a better $b$.\n    * For $S \\in \\{S_1, S_2, S_1 \\cap S_2\\}$:\n      * Let $s = \\Pi(L[S] \\triangleleft b)$ (during the first iteration it holds that $L[S] \\triangleleft b = L[S]$).\n      * Set $b = s$ if $\\operatorname{feerate}(s) > \\operatorname{feerate}(b)$; $b = \\Pi(L[b] \\triangleleft s)$ otherwise.\n    * Append $L[b]$ to output linearization.\n    * Remove $b$ from $L$ and repeat.\n\nIt appears this algorithm even generalizes to higher numbers. E.g. Triple LIMO would involve three subsets and $S$ would loop over their 7 non-empty intersections $\\{S_1, S_2, S_1 \\cap S_2, S_3, S_1 \\cap S_3, S_2 \\cap S_3, S_1 \\cap S_2 \\cap S_3\\}$.\n\nDouble LIMO can be used in cluster update situations:\n* Start with an existing linearzation $L$ for a cluster.\n* With a new transaction/package coming it, remove from $L$ the conflicts and append (at the end) the replacements, leaving the order otherwise the same.\n* [Post-process](https://delvingbitcoin.org/t/linearization-post-processing-o-n-2-fancy-chunking/201) $L$.\n* Perform Double LIMO on $L$ (with $S_1 =$ best ancestor set, $S_2 =$ bounded search result).\n* Maybe post-process again?\n\nThe result will be at least as good as ancestor sort, at least as good as the combination of prefixes found by bounded search, and at least as good as the result of post-processing the remainder of the original linearization after replacements, all while letting the ancestor sort and bounded search operate on the best state so far.\n\n## Acknowledgements\n\nThanks to @ajtowns for the notational suggestions.",
  "actions_summary": [
    {
      "id": 2,
      "count": 3
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 96,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "<a name=\"limo-linearization-through-incremental-merging-of-optimizations-1\" class=\"anchor\" href=\"#limo-linearization-through-incremental-merging-of-optimizations-1\"></a>LIMO: Linearization through Incremental Merging of Optimizations\n \n<a name=\"h-1-introduction-2\" class=\"anchor\" href=\"#h-1-introduction-2\"></a>1. Introduction\nConsider the linearization algorithm as suggested in <a href=\"https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303\">How To Linearize Your Cluster</a>, excluding the approach from Section 1.2 (Bottleneck Splitting). In broad lines: \n\nWhile transactions remain in the cluster:\n\nUse a co&hellip;",
  "truncated": true,
  "post_url": "/t/limo-combining-the-best-parts-of-linearization-search-and-merging/825/1",
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 3
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 3,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}