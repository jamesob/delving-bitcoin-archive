{
  "id": 2317,
  "name": "Tadge Dryja",
  "username": "adiabat",
  "avatar_template": "/user_avatar/delvingbitcoin.org/adiabat/{size}/532_2.png",
  "created_at": "2024-04-24T03:12:24.329Z",
  "cooked": "<p>Exploding Keys</p>\n<p>TLDR: Public keys that commit to a set of outputs.  If the key is spent to those outputs, no signature or witness is needed.</p>\n<p>Motivation: Exploding keys gets you basically the same functionality as <code>op_ctv</code> but done in a somewhat clever way that saves a few bytes.  I came up with this a while ago but kept thinking there was a way to make this better / more powerful / really compelling.  Maybe that\u2019s not going to happen, and I want to write up all the things that would be really cool but don\u2019t work.  On it\u2019s own it\u2019s kind of fun though and maybe will give people some ideas, or could be a tool for bitcoin covenants.</p>\n<p>For the example transactions, assume that public keys are used like in taproot outputs, rather than public key hashes.</p>\n<p>The example tx has 1 input and 3 outputs.</p>\n<pre><code class=\"lang-auto\">\nInput 0:\ntxid:idx (points to prev PkScript KeyQ, 9 BTC)\nno sigscript\nno witness\n\nOutput 0:\nKeyA, 2 BTC\n\nOutput 1:\nKeyB, 3 BTC\n\nOutput 2:\nKeyC, 4 BTC\n</code></pre>\n<p>Normally you\u2019d look at this and say, well there\u2019s no witness, so no deal, fail the tx.  But with the exploding keys soft fork (guess you\u2019d need to use a new segwit version or some other tag to keep the fork soft) you perform an additional check if the tx has no witnesses:</p>\n<p>For each output, use the presented key as an \u201cinner key\u201d and commit in the amount of BTC taproot style (BIP 341).  Store the keys for the next step.</p>\n<pre><code class=\"lang-auto\">KeyA' = KeyA + hash(2, KeyA)*G\nKeyB' = KeyB + hash(3, KeyB)*G\nKeyC' = KeyC + hash(4, KeyC)*G\n</code></pre>\n<p>Next, take the key aggregation function in BIP 327, KeyAgg(), and feed it all the tweaked keys.  (I think you don\u2019t want to run KeySort() first and keep it in the order seen in the tx).</p>\n<pre><code class=\"lang-auto\">KeyW = KeyAgg(KeyA', KeyB', KeyC')\n</code></pre>\n<p>Then check if <code>KeyW == KeyQ</code> seen in the input.  If they\u2019re equal then the input passes the validation checks despite having an empty witness.  (You still need to check that the amounts work - in this example they do with 0 fee)</p>\n<p>I think this works in that if you\u2019re given a <code>KeyQ</code>, there\u2019s no way to come up with a set of keys that aggregates to it other than the one initially used to construct <code>KeyQ</code> itself.  If there were, that would be a problem / collision for BIP 327 aggregation.  Similarly, given a tweaked key like <code>KeyA'</code>, there should be no way to come up with a different inner key and tweak value, because that would be a problem for BIP 341 tweaking.</p>\n<p>To construct an exploding key, you go through the same sequence as verification: start with the keys and amounts you want to explode to, then tweak, then aggregate the tweaked keys.  The resulting key is an explodable key which you can send coins to.  What\u2019s nice is that private key holders A, B, and C can still interact to sign with the explodable key to send it somewhere else.  If they can\u2019t interact though, any party with the knowledge of the output set (which is not just A, B, and C, after all there is no signature needed) can explode the key into the 3 components.  This could be useful for a shared UTXO where multiple parties all claim a portion of the total coins - they can cooperate to sign or press the explode button to leave.</p>\n<p>Just like <code>op_ctv</code>, this works recursively \u2013 <code>KeyA</code> can itself be an exploding key.</p>\n<p>So that\u2019s it.  It gives the basic functionality of <code>op_ctv</code>, while saving a few bytes of witness data.  On it\u2019s own it\u2019s maybe not all that compelling, but I wanted to put it out there as maybe it could be a useful primitive as part of a more complex covenant construction.</p>\n<p>Don\u2019t have time today but I do want to write a bit in a day or two about some things that would be really cool if exploding keys could do them, but they can\u2019t and maybe nothing can <img src=\"https://delvingbitcoin.org/images/emoji/twitter/slight_smile.png?v=12\" title=\":slight_smile:\" class=\"emoji\" alt=\":slight_smile:\" loading=\"lazy\" width=\"20\" height=\"20\"></p>\n<p>Thanks to sipa &amp; real-or-random who I discussed this with a while ago and helped with feedback.  (Also I may have forgotten their feedback, rendering this construction insecure, in which case, that\u2019s on me not them <img src=\"https://delvingbitcoin.org/images/emoji/twitter/slight_smile.png?v=12\" title=\":slight_smile:\" class=\"emoji\" alt=\":slight_smile:\" loading=\"lazy\" width=\"20\" height=\"20\"> )</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2024-04-24T03:12:24.329Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 48,
  "reads": 26,
  "readers_count": 25,
  "score": 365.2,
  "yours": false,
  "topic_id": 832,
  "topic_slug": "exploding-keys-covenant-construction",
  "topic_title": "Exploding Keys - Covenant construction",
  "topic_html_title": "Exploding Keys - Covenant construction",
  "category_id": 7,
  "display_username": "Tadge Dryja",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Exploding Keys\n\nTLDR: Public keys that commit to a set of outputs.  If the key is spent to those outputs, no signature or witness is needed.\n\nMotivation: Exploding keys gets you basically the same functionality as `op_ctv` but done in a somewhat clever way that saves a few bytes.  I came up with this a while ago but kept thinking there was a way to make this better / more powerful / really compelling.  Maybe that's not going to happen, and I want to write up all the things that would be really cool but don't work.  On it's own it's kind of fun though and maybe will give people some ideas, or could be a tool for bitcoin covenants.\n\nFor the example transactions, assume that public keys are used like in taproot outputs, rather than public key hashes.\n\nThe example tx has 1 input and 3 outputs.\n\n```\n\nInput 0:\ntxid:idx (points to prev PkScript KeyQ, 9 BTC)\nno sigscript\nno witness\n\nOutput 0:\nKeyA, 2 BTC\n\nOutput 1:\nKeyB, 3 BTC\n\nOutput 2:\nKeyC, 4 BTC\n```\n\nNormally you'd look at this and say, well there's no witness, so no deal, fail the tx.  But with the exploding keys soft fork (guess you'd need to use a new segwit version or some other tag to keep the fork soft) you perform an additional check if the tx has no witnesses:\n\nFor each output, use the presented key as an \"inner key\" and commit in the amount of BTC taproot style (BIP 341).  Store the keys for the next step.\n\n```\nKeyA' = KeyA + hash(2, KeyA)*G\nKeyB' = KeyB + hash(3, KeyB)*G\nKeyC' = KeyC + hash(4, KeyC)*G\n```\nNext, take the key aggregation function in BIP 327, KeyAgg(), and feed it all the tweaked keys.  (I think you don't want to run KeySort() first and keep it in the order seen in the tx).\n```\nKeyW = KeyAgg(KeyA', KeyB', KeyC')\n```\nThen check if `KeyW == KeyQ` seen in the input.  If they're equal then the input passes the validation checks despite having an empty witness.  (You still need to check that the amounts work - in this example they do with 0 fee)\n\nI think this works in that if you're given a `KeyQ`, there's no way to come up with a set of keys that aggregates to it other than the one initially used to construct `KeyQ` itself.  If there were, that would be a problem / collision for BIP 327 aggregation.  Similarly, given a tweaked key like `KeyA'`, there should be no way to come up with a different inner key and tweak value, because that would be a problem for BIP 341 tweaking.\n\nTo construct an exploding key, you go through the same sequence as verification: start with the keys and amounts you want to explode to, then tweak, then aggregate the tweaked keys.  The resulting key is an explodable key which you can send coins to.  What's nice is that private key holders A, B, and C can still interact to sign with the explodable key to send it somewhere else.  If they can't interact though, any party with the knowledge of the output set (which is not just A, B, and C, after all there is no signature needed) can explode the key into the 3 components.  This could be useful for a shared UTXO where multiple parties all claim a portion of the total coins - they can cooperate to sign or press the explode button to leave.\n\nJust like `op_ctv`, this works recursively -- `KeyA` can itself be an exploding key.\n\nSo that's it.  It gives the basic functionality of `op_ctv`, while saving a few bytes of witness data.  On it's own it's maybe not all that compelling, but I wanted to put it out there as maybe it could be a useful primitive as part of a more complex covenant construction.\n\nDon't have time today but I do want to write a bit in a day or two about some things that would be really cool if exploding keys could do them, but they can't and maybe nothing can :)\n\nThanks to sipa & real-or-random who I discussed this with a while ago and helped with feedback.  (Also I may have forgotten their feedback, rendering this construction insecure, in which case, that's on me not them :) )",
  "actions_summary": [
    {
      "id": 2,
      "count": 6
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 414,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 6
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 6,
  "current_user_used_main_reaction": false
}