{
  "id": 2288,
  "name": "",
  "username": "dgpv",
  "avatar_template": "/user_avatar/delvingbitcoin.org/dgpv/{size}/75_2.png",
  "created_at": "2024-04-19T21:48:52.027Z",
  "cooked": "<p>After I had a closer look at the <a href=\"https://delvingbitcoin.org/t/basic-vault-prototype-using-op-cat/576/16\">Basic vault prototype using OP_CAT</a> and discovered some problems with the implementation, I was wondering if modelling this covenant using some model checker would have helped to uncover these problems.</p>\n<p>I have also wanted to try to model some simple contract using <a href=\"https://alloytools.org/\">Alloy</a> and see how its visualization capabilities can help with analyzing transaction inter-relations, and if Alloy syntax is suitable to model covenant-based contracts.</p>\n<p>The resulting specification is here: <a href=\"https://gist.github.com/dgpv/514134c9727653b64d675d7513f983dd\" class=\"inline-onebox\">Alloy specification for simple vault covenant-enforced contract \u00b7 GitHub</a></p>\n<p>The spec is commented with good detail, so please look at the comments there if interested.</p>\n<p>If you find a problem in the spec, or have questions, please do not hesitate to comment here. I tried to make a model that is sufficient for analysis of this particular contract, but I could have missed something, of course.</p>\n<p><code>simple_vault.als</code> is the spec, and <code>simple_vault.thm</code> is the \u201ctheme\u201d for the Alloy visualizer to make the results easy to examine.</p>\n<p>The specified model demonstrates the need for the covenant script to explicitly check input index, and also for the software handling the covenant to never lock the funds at the output with index other than 0.</p>\n<p>The model also demonstrates that there is no need to enforce the number of inputs and outputs of the current transaction, only number of outputs in the previous transaction in the \u2018complete_withdrawal\u2019 case.</p>\n<p>When the covenant does not enforce the number of inputs and outputs, the \u2018cancel\u2019 case does not need its own covenant. The \u2018trigger\u2019 and \u2018cancel\u2019 cases can be handled by the same covenant. If the transaction that spends the covenant via \u2018trigger_or_cancel\u2019 case does not have exactly two outputs, it is effectively a \u2018cancel\u2019 transaction: withdrawal cannot be done with it, because the \u2018complete_withdrawal\u2019 case expects previous transaction to have exactly two outputs.</p>\n<p>What became apparent is the importance for the model to reflect the underlying mechanics of the covenant. For the covenant implemented using Elements introspection opcodes, and for the covenant implemented using just <code>OP_CAT</code>, the required checks are different for the \u2018trigger withdrawal\u2019 covenant case - for the \u2018rich introspection\u2019 covenant, the \u2018trigger withdrawal\u2019 does not strictly need to enforce the current input index to be fixed. For <code>OP_CAT</code> covenant, it must be fixed.</p>\n<p>This is because with the <code>OP_CAT</code> covenant, the current input index and the inputs/outputs buffers that are hashed to build the signature hash are not synchronized. In Elements, these can be synchronized with <code>OP_PUSHINPUTINDEX</code> and explicit introspection opcodes that allow access to arbitrary inputs or outputs. Allowing arbitrary input index in the <code>OP_CAT</code> covenant would be too cumbersome, if at all possible, so the best way to synchronize is to just force all indexes to be 0.</p>\n<p>This aspect of making model reflect the particulars of the underlying covenant-enforcing mechanism is something that have to be kept in mind when modelling such contracts. Failure to reflect these details in the model can result in missing the important checks, that can lead to vulnerabilities in the contract.</p>\n<p>Because the temporal structure of the contract is very simple, I decided to ignore the timelock aspect of the contract at all, which allowed to work only with the structure of the transactions. Although Alloy 6 has ability to model temporal progress, limiting the model to only structural analysis makes it simpler and makes checking faster.</p>\n<p>In my opinion, Alloy syntax is more intuitive and makes the spec easier to comprehend on a basic level to wider audience, in comparison with syntax of TLA+. But to actually check the correctness of the spec, you still need a thorough understanding of the mechanisms employed by Alloy behind this syntax, so in that aspect it is not that different from TLA+.</p>\n<p>The visualization features for Alloy are neat, and with the right settings for the visualizer theme, the transaction structure becomes visible and demonstrative.</p>\n<p>As an example, here is a counterexample for the <code>contract_holds</code> predicate that happens if you remove the <code>i.index = 0</code> in <code>trigger_or_cancel_cov</code> predicate and run the <code>vault</code> check in Alloy:</p>\n<p><img src=\"https://delvingbitcoin.org/uploads/default/original/1X/499bc649a1575ed761a09607befc0a4e61e997ca.png\" alt=\"counterexample_1\" data-base62-sha1=\"avaBftAp8ZA1O0FqJFazqYeIHl8\" width=\"465\" height=\"348\"></p>\n<p>If you remove <code>no_2output_envault</code> predicate from the <code>vault</code> check, you will get this counterexample:</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/1X/f95e31567f2810b31b75faa0dc9c87d3fe771253.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/f95e31567f2810b31b75faa0dc9c87d3fe771253\" title=\"counterexample_2\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/1X/f95e31567f2810b31b75faa0dc9c87d3fe771253_2_690x314.png\" alt=\"counterexample_2\" data-base62-sha1=\"zA0HdKOL2gnwMyA00zN4mtY6quT\" width=\"690\" height=\"314\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/1X/f95e31567f2810b31b75faa0dc9c87d3fe771253_2_690x314.png, https://delvingbitcoin.org/uploads/default/original/1X/f95e31567f2810b31b75faa0dc9c87d3fe771253.png 1.5x, https://delvingbitcoin.org/uploads/default/original/1X/f95e31567f2810b31b75faa0dc9c87d3fe771253.png 2x\" data-dominant-color=\"CFE7D0\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">counterexample_2</span><span class=\"informations\">764\u00d7348 27.3 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>I would recommend to use SAT4J solver in Alloy to explore the various instances of the model, and install <a href=\"https://github.com/arminbiere/lingeling\">Plingeling</a> (and choose it in the options) to actually check the model, because Plingeling will be much faster, but SAT4J allows to generate new instances with one click, to explore possible transaction structures.</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2024-04-20T08:16:21.910Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 3,
  "reads": 9,
  "readers_count": 8,
  "score": 16.6,
  "yours": false,
  "topic_id": 819,
  "topic_slug": "analyzing-simple-vault-covenant-with-alloy",
  "topic_title": "Analyzing simple vault covenant with Alloy",
  "topic_html_title": "Analyzing simple vault covenant with Alloy",
  "category_id": 7,
  "display_username": "",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 4,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": "",
  "bookmarked": false,
  "raw": "After I had a closer look at the [Basic vault prototype using OP_CAT](https://delvingbitcoin.org/t/basic-vault-prototype-using-op-cat/576/16) and discovered some problems with the implementation, I was wondering if modelling this covenant using some model checker would have helped to uncover these problems.\n\nI have also wanted to try to model some simple contract using [Alloy](https://alloytools.org/) and see how its visualization capabilities can help with analyzing transaction inter-relations, and if Alloy syntax is suitable to model covenant-based contracts.\n\nThe resulting specification is here: https://gist.github.com/dgpv/514134c9727653b64d675d7513f983dd\n\nThe spec is commented with good detail, so please look at the comments there if interested.\n\nIf you find a problem in the spec, or have questions, please do not hesitate to comment here. I tried to make a model that is sufficient for analysis of this particular contract, but I could have missed something, of course.\n\n`simple_vault.als` is the spec, and `simple_vault.thm` is the \"theme\" for the Alloy visualizer to make the results easy to examine.\n\nThe specified model demonstrates the need for the covenant script to explicitly check input index, and also for the software handling the covenant to never lock the funds at the output with index other than 0.\n\nThe model also demonstrates that there is no need to enforce the number of inputs and outputs of the current transaction, only number of outputs in the previous transaction in the 'complete_withdrawal' case.\n\nWhen the covenant does not enforce the number of inputs and outputs, the 'cancel' case does not need its own covenant. The 'trigger' and 'cancel' cases can be handled by the same covenant. If the transaction that spends the covenant via 'trigger_or_cancel' case does not have exactly two outputs, it is effectively a 'cancel' transaction: withdrawal cannot be done with it, because the 'complete_withdrawal' case expects previous transaction to have exactly two outputs.\n\nWhat became apparent is the importance for the model to reflect the underlying mechanics of the covenant. For the covenant implemented using Elements introspection opcodes, and for the covenant implemented using just `OP_CAT`, the required checks are different for the 'trigger withdrawal' covenant case - for the 'rich introspection' covenant, the 'trigger withdrawal' does not strictly need to enforce the current input index to be fixed. For `OP_CAT` covenant, it must be fixed. \n\nThis is because with the `OP_CAT` covenant, the current input index and the inputs/outputs buffers that are hashed to build the signature hash are not synchronized. In Elements, these can be synchronized with `OP_PUSHINPUTINDEX` and explicit introspection opcodes that allow access to arbitrary inputs or outputs. Allowing arbitrary input index in the `OP_CAT` covenant would be too cumbersome, if at all possible, so the best way to synchronize is to just force all indexes to be 0.\n\nThis aspect of making model reflect the particulars of the underlying covenant-enforcing mechanism is something that have to be kept in mind when modelling such contracts. Failure to reflect these details in the model can result in missing the important checks, that can lead to vulnerabilities in the contract.\n\nBecause the temporal structure of the contract is very simple, I decided to ignore the timelock aspect of the contract at all, which allowed to work only with the structure of the transactions. Although Alloy 6 has ability to model temporal progress, limiting the model to only structural analysis makes it simpler and makes checking faster.\n\nIn my opinion, Alloy syntax is more intuitive and makes the spec easier to comprehend on a basic level to wider audience, in comparison with syntax of TLA+. But to actually check the correctness of the spec, you still need a thorough understanding of the mechanisms employed by Alloy behind this syntax, so in that aspect it is not that different from TLA+.  \n\nThe visualization features for Alloy are neat, and with the right settings for the visualizer theme, the transaction structure becomes visible and demonstrative.\n\nAs an example, here is a counterexample for the `contract_holds` predicate that happens if you remove the `i.index = 0` in `trigger_or_cancel_cov` predicate and run the `vault` check in Alloy: \n\n![counterexample_1|465x348](upload://avaBftAp8ZA1O0FqJFazqYeIHl8.png)\n\nIf you remove `no_2output_envault` predicate from the `vault` check, you will get this counterexample:\n\n![counterexample_2|690x314](upload://zA0HdKOL2gnwMyA00zN4mtY6quT.png)\n\nI would recommend to use SAT4J solver in Alloy to explore the various instances of the model, and install [Plingeling](https://github.com/arminbiere/lingeling) (and choose it in the options) to actually check the model, because Plingeling will be much faster, but SAT4J allows to generate new instances with one click, to explore possible transaction structures.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 85,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}