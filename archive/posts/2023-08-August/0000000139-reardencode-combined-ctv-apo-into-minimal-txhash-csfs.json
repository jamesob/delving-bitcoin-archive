{
  "id": 139,
  "name": "Brandon Black",
  "username": "reardencode",
  "avatar_template": "/user_avatar/delvingbitcoin.org/reardencode/{size}/27_2.png",
  "created_at": "2023-08-27T13:37:10.961Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"jamesob\" data-post=\"4\" data-topic=\"60\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/jamesob/48/271_2.png\" class=\"avatar\"> jamesob:</div>\n<blockquote>\n<p>I agree here that there\u2019s little practical difference between softforking to add a new opcode and softforking to enable new argument-based behavior. Clients still need to update, fork still needs to be deployed, and code savings on the Core side are pretty minor I think.</p>\n</blockquote>\n</aside>\n<p>That\u2019s a good point. Since we have both Tapscript versions and quite a few upgradable opcodes, optimizing for avoiding using extra ops in upgrades is not a good general goal. In this case, it seems like defining an op <code>OP_TEMPLATEHASH</code> which takes a only numeric mode arg from the stack would make more sense than upgradable <code>OP_TXHASH</code>.</p>\n<aside class=\"quote no-group\" data-username=\"jamesob\" data-post=\"4\" data-topic=\"60\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/jamesob/48/271_2.png\" class=\"avatar\"> jamesob:</div>\n<blockquote>\n<p>I think it would be really unfortunate if we got to the point where we were using CAT and rolling SHA opcodes to slice and dice txn components into tailor made hashes.</p>\n</blockquote>\n</aside>\n<p>I couldn\u2019t agree more. We don\u2019t want to have mile-long difficult to reason about scripts. We want to have concrete verification functionality that can be composed to do useful things.</p>\n<aside class=\"quote no-group\" data-username=\"jamesob\" data-post=\"4\" data-topic=\"60\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/jamesob/48/271_2.png\" class=\"avatar\"> jamesob:</div>\n<blockquote>\n<p>I think it would be helpful to have some kind of listing of uses that having CSFS enables (e.g. key delegation, although to be honest I can\u2019t explain this use much deeper than just saying \u201ckey delegation\u201d; something-something federations maybe?). Because if the only use for CSFS that we can think of here is allowing a unification of BIP 118 and 119, I\u2019d say it\u2019s more expeditious just to activate the two together as written.</p>\n</blockquote>\n</aside>\n<p>Key delegation looks like this:</p>\n<pre><code class=\"lang-auto\">Lock: OP_2DUP OP_DROP &lt;csfs_pubkey&gt; OP_CSFSV OP_CHECKSIG\nUnlock: &lt;csfs_signature&gt; &lt;cs_pubkey&gt; &lt;cs_signature&gt;\n</code></pre>\n<p>More usefully one might do:</p>\n<pre><code class=\"lang-auto\">Lock: &lt;csfs_pubkey&gt; OP_SWAP OP_IF OP_TOALTSTACK OP_OVER OP_FROMALTSTACK OP_CSFSV OP_ENDIF OP_CHECKSIG\nUnlock0: OP_0 &lt;csfs_signature&gt; \nUnlock1: OP_1 &lt;csfs_signature&gt; &lt;cs_pubkey&gt; &lt;cs_signature&gt; \n</code></pre>\n<p>I\u2019d have to do some digging to learn about other usecases for CSFS.</p>\n<hr>\n<p>Thanks for your thoughts!</p>",
  "post_number": 5,
  "post_type": 1,
  "posts_count": 9,
  "updated_at": "2023-08-27T13:37:10.961Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 1,
  "incoming_link_count": 1,
  "reads": 40,
  "readers_count": 39,
  "score": 13.0,
  "yours": false,
  "topic_id": 60,
  "topic_slug": "combined-ctv-apo-into-minimal-txhash-csfs",
  "topic_title": "Combined CTV/APO into minimal TXHASH+CSFS",
  "topic_html_title": "Combined CTV/APO into minimal TXHASH+CSFS",
  "category_id": 7,
  "display_username": "Brandon Black",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"jamesob, post:4, topic:60\"]\nI agree here that there\u2019s little practical difference between softforking to add a new opcode and softforking to enable new argument-based behavior. Clients still need to update, fork still needs to be deployed, and code savings on the Core side are pretty minor I think.\n[/quote]\n\nThat's a good point. Since we have both Tapscript versions and quite a few upgradable opcodes, optimizing for avoiding using extra ops in upgrades is not a good general goal. In this case, it seems like defining an op `OP_TEMPLATEHASH` which takes a only numeric mode arg from the stack would make more sense than upgradable `OP_TXHASH`.\n\n[quote=\"jamesob, post:4, topic:60\"]\nI think it would be really unfortunate if we got to the point where we were using CAT and rolling SHA opcodes to slice and dice txn components into tailor made hashes.\n[/quote]\n\nI couldn't agree more. We don't want to have mile-long difficult to reason about scripts. We want to have concrete verification functionality that can be composed to do useful things.\n\n[quote=\"jamesob, post:4, topic:60\"]\nI think it would be helpful to have some kind of listing of uses that having CSFS enables (e.g. key delegation, although to be honest I can\u2019t explain this use much deeper than just saying \u201ckey delegation\u201d; something-something federations maybe?). Because if the only use for CSFS that we can think of here is allowing a unification of BIP 118 and 119, I\u2019d say it\u2019s more expeditious just to activate the two together as written.\n[/quote]\n\nKey delegation looks like this:\n```\nLock: OP_2DUP OP_DROP <csfs_pubkey> OP_CSFSV OP_CHECKSIG\nUnlock: <csfs_signature> <cs_pubkey> <cs_signature>\n```\n\nMore usefully one might do:\n```\nLock: <csfs_pubkey> OP_SWAP OP_IF OP_TOALTSTACK OP_OVER OP_FROMALTSTACK OP_CSFSV OP_ENDIF OP_CHECKSIG\nUnlock0: OP_0 <csfs_signature> \nUnlock1: OP_1 <csfs_signature> <cs_pubkey> <cs_signature> \n```\n\nI'd have to do some digging to learn about other usecases for CSFS.\n\n--------------------------------\n\nThanks for your thoughts!",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 30,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "That\u2019s a good point. Since we have both Tapscript versions and quite a few upgradable opcodes, optimizing for avoiding using extra ops in upgrades is not a good general goal. In this case, it seems like defining an op OP_TEMPLATEHASH which takes a only numeric mode arg from the stack would make mor&hellip;",
  "truncated": true,
  "post_url": "/t/combined-ctv-apo-into-minimal-txhash-csfs/60/5",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}