{
  "id": 134,
  "name": "Gregory Sanders",
  "username": "instagibbs",
  "avatar_template": "/user_avatar/delvingbitcoin.org/instagibbs/{size}/28_2.png",
  "created_at": "2023-08-24T14:42:57.655Z",
  "cooked": "<p>The original TXHASH mail says:</p>\n<blockquote>\n<p>For similar reasons, TXHASH is not amenable to extending the set of txflags<br>\nat a later date.  In theory, one could have TXHASH abort-with-success when<br>\nencountering an unknown set of flags.  However, this would make analyzing<br>\ntapscript much more difficult. Tapscripts would then be able to abort with<br>\nsuccess or failure depending on the order script fragments are assembled<br>\nand executed, and getting the order incorrect would be catastrophic.  This<br>\nbehavior is manifestly different from the current batch of OP_SUCCESS<br>\nopcodes that abort-with-success just by their mere presence, whether they<br>\nwould be executed or not.</p>\n<p>I believe the difficulties with upgrading TXHASH can be mitigated by<br>\ndesigning a robust set of TXHASH flags from the start.  For example having<br>\nbits to control whether (1) the version is covered; (2) the locktime is<br>\ncovered; (3) txids are covered; (4) sequence numbers are covered; (5) input<br>\namounts are covered; (6) input scriptpubkeys are covered; (7) number of<br>\ninputs is covered; (8) output amounts are covered; (9) output scriptpubkeys<br>\nare covered; (10) number of outputs is covered; (11) the tapbranch is<br>\ncovered; (12) the tapleaf is covered; (13) the opseparator value is<br>\ncovered; (14) whether all, one, or no inputs are covered; (15) whether all,<br>\none or no outputs are covered; (16) whether the one input position is<br>\ncovered; (17) whether the one output position is covered; (18) whether the<br>\nsighash flags are covered or not (note: whether or not the sighash flags<br>\nare or are not covered must itself be covered).  Possibly specifying which<br>\ninput or output position is covered in the single case and whether the<br>\nposition is relative to the input\u2019s position or is an absolute position.</p>\n<p>That all said, even if other txhash flag modes are needed in the future,<br>\nadding TXHASH2 always remains an option.</p>\n</blockquote>\n<p>I think adding upgrade hooks, as he says, is pretty fraught, vs \u201cjust use another opcode\u201d. Currently if someone reorders it, it just becomes trivially true do the hash type has to be committed to in the output to avoid \u201canyonecanspend\u201d style behavior.</p>\n<p>I hadn\u2019t read this in a while, and the closing part was interesting:</p>\n<blockquote>\n<p>The usual way of building a covenant, which we will call \u201c*additive *<br>\n<em>covenants</em>\u201d, is to push all the parts of the transaction data you would<br>\nlike to fix onto the stack, hash it all together, and verify the resulting<br>\nhash matches a fixed value.  Another way of building covenants, which we<br>\nwill call \u201c<em>subtractive covenants</em>\u201d, is to push all the parts of the<br>\ntransaction data you would like to remain free onto the stack.  Then use<br>\nrolling SHA256 opcodes starting from a fixed midstate that commits to a<br>\nprefix of the transaction hash data. The free parts are hashed into that<br>\nmidstate.  Finally, the resulting hash value is verified to match a value<br>\nreturned by TXHASH.  The ability to nicely build subtractive covenants<br>\ndepends on the details of how the TXHASH hash value is constructed,<br>\nsomething that I\u2019m told CTV has given consideration to.</p>\n</blockquote>",
  "post_number": 2,
  "post_type": 1,
  "updated_at": "2023-08-24T14:44:22.779Z",
  "reply_count": 2,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 18,
  "reads": 16,
  "readers_count": 15,
  "score": 93.2,
  "yours": false,
  "topic_id": 60,
  "topic_slug": "combined-ctv-apo-into-minimal-txhash-csfs",
  "topic_title": "Combined CTV/APO into minimal TXHASH+CSFS",
  "topic_html_title": "Combined CTV/APO into minimal TXHASH+CSFS",
  "category_id": 7,
  "display_username": "Gregory Sanders",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "The original TXHASH mail says:\n\n> \n> For similar reasons, TXHASH is not amenable to extending the set of txflags\n> at a later date.  In theory, one could have TXHASH abort-with-success when\n> encountering an unknown set of flags.  However, this would make analyzing\n> tapscript much more difficult. Tapscripts would then be able to abort with\n> success or failure depending on the order script fragments are assembled\n> and executed, and getting the order incorrect would be catastrophic.  This\n> behavior is manifestly different from the current batch of OP_SUCCESS\n> opcodes that abort-with-success just by their mere presence, whether they\n> would be executed or not.\n> \n> I believe the difficulties with upgrading TXHASH can be mitigated by\n> designing a robust set of TXHASH flags from the start.  For example having\n> bits to control whether (1) the version is covered; (2) the locktime is\n> covered; (3) txids are covered; (4) sequence numbers are covered; (5) input\n> amounts are covered; (6) input scriptpubkeys are covered; (7) number of\n> inputs is covered; (8) output amounts are covered; (9) output scriptpubkeys\n> are covered; (10) number of outputs is covered; (11) the tapbranch is\n> covered; (12) the tapleaf is covered; (13) the opseparator value is\n> covered; (14) whether all, one, or no inputs are covered; (15) whether all,\n> one or no outputs are covered; (16) whether the one input position is\n> covered; (17) whether the one output position is covered; (18) whether the\n> sighash flags are covered or not (note: whether or not the sighash flags\n> are or are not covered must itself be covered).  Possibly specifying which\n> input or output position is covered in the single case and whether the\n> position is relative to the input's position or is an absolute position.\n> \n> That all said, even if other txhash flag modes are needed in the future,\n> adding TXHASH2 always remains an option.\n\n\nI think adding upgrade hooks, as he says, is pretty fraught, vs \"just use another opcode\". Currently if someone reorders it, it just becomes trivially true do the hash type has to be committed to in the output to avoid \"anyonecanspend\" style behavior.\n\nI hadn't read this in a while, and the closing part was interesting:\n\n> The usual way of building a covenant, which we will call \"*additive *\n> *covenants*\", is to push all the parts of the transaction data you would\n> like to fix onto the stack, hash it all together, and verify the resulting\n> hash matches a fixed value.  Another way of building covenants, which we\n> will call \"*subtractive covenants*\", is to push all the parts of the\n> transaction data you would like to remain free onto the stack.  Then use\n> rolling SHA256 opcodes starting from a fixed midstate that commits to a\n> prefix of the transaction hash data. The free parts are hashed into that\n> midstate.  Finally, the resulting hash value is verified to match a value\n> returned by TXHASH.  The ability to nicely build subtractive covenants\n> depends on the details of how the TXHASH hash value is constructed,\n> something that I'm told CTV has given consideration to.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 31,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}