{
  "id": 3698,
  "name": "Eric Voskuil",
  "username": "evoskuil",
  "avatar_template": "/user_avatar/delvingbitcoin.org/evoskuil/{size}/391_2.png",
  "created_at": "2024-12-03T02:51:12.878Z",
  "cooked": "<p>I\u2019ve been trying to find a good way to show this with data. I think that our construction of the ElecrumX address index table along with our point compression is a pretty good proxy (both are optional). These are not ordered but in combination impose the same number and type of table reads/writes as a utxo store population would under assume valid.</p>\n<p>The address index requires the mapping of the sha256 hash of every output to the surrogate key of the output. This is comparable to the write of the output to the utxo store (the surrogate key allows direct recovery of the corresponding output, with navigation to its spending input).</p>\n<p>We don\u2019t do deletes, but the spend of the output can be approximated by the search of each input in the point hash table, and write of an entry to that table in the case that it\u2019s missing. This optional search compresses out redundant point hashes, saving about 50GB (making the fully-indexed store materially smaller than the Core store).</p>\n<p>Point compression is neutral on total sync time, because the resulting table is so much smaller (similar to the reduction caused by removing spent outputs in a utxo table). The address index adds about 30 minutes to a 1 hour sync. This is on a machine that takes Core 15 hours to sync under assume valid.</p>\n<p>I think this makes the case as closely as possible that lack of utxo store population (reads/writes) is not what powers milestone sync, it\u2019s the lack of imposition of total block ordering by a utxo store.</p>\n<p>However, one might also consider the extraordinary amount of non-optional indexing. BN always indexes all transactions by hash, all confirmed txs to their containing block, all outputs to their spending input(s), all inputs to their point hash (optionally compressible), all headers by hash, and all headers to their associated txs (if associated). Each of these is a hash table.</p>",
  "post_number": 40,
  "post_type": 1,
  "updated_at": "2024-12-03T03:32:11.727Z",
  "reply_count": 0,
  "reply_to_post_number": 37,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 5,
  "readers_count": 4,
  "score": 1.0,
  "yours": false,
  "topic_id": 1222,
  "topic_slug": "libbitcoin-for-core-people",
  "topic_title": "Libbitcoin for Core people",
  "topic_html_title": "Libbitcoin for Core people",
  "category_id": 8,
  "display_username": "Eric Voskuil",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 3,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "reply_to_user": {
    "username": "evoskuil",
    "name": "Eric Voskuil",
    "avatar_template": "/user_avatar/delvingbitcoin.org/evoskuil/{size}/391_2.png"
  },
  "bookmarked": false,
  "raw": "I've been trying to find a good way to show this with data. I think that our construction of the ElecrumX address index table along with our point compression is a pretty good proxy (both are optional). These are not ordered but in combination impose the same number and type of table reads/writes as a utxo store population would under assume valid.\n\nThe address index requires the mapping of the sha256 hash of every output to the surrogate key of the output. This is comparable to the write of the output to the utxo store (the surrogate key allows direct recovery of the corresponding output, with navigation to its spending input).\n\nWe don't do deletes, but the spend of the output can be approximated by the search of each input in the point hash table, and write of an entry to that table in the case that it's missing. This optional search compresses out redundant point hashes, saving about 50GB (making the fully-indexed store materially smaller than the Core store).\n\nPoint compression is neutral on total sync time, because the resulting table is so much smaller (similar to the reduction caused by removing spent outputs in a utxo table). The address index adds about 30 minutes to a 1 hour sync. This is on a machine that takes Core 15 hours to sync under assume valid.\n\nI think this makes the case as closely as possible that lack of utxo store population (reads/writes) is not what powers milestone sync, it's the lack of imposition of total block ordering by a utxo store.\n\nHowever, one might also consider the extraordinary amount of non-optional indexing. BN always indexes all transactions by hash, all confirmed txs to their containing block, all outputs to their spending input(s), all inputs to their point hash (optionally compressible), all headers by hash, and all headers to their associated txs (if associated). Each of these is a hash table.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 324,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}