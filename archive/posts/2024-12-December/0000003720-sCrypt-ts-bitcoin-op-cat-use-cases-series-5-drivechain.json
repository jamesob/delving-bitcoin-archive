{
  "id": 3720,
  "name": "sCrypt",
  "username": "sCrypt-ts",
  "avatar_template": "/user_avatar/delvingbitcoin.org/scrypt-ts/{size}/746_2.png",
  "created_at": "2024-12-06T08:04:01.558Z",
  "cooked": "<h1><a name=\"p-3720-bitcoin-op_cat-use-cases-series-5-drivechain-1\" class=\"anchor\" href=\"#p-3720-bitcoin-op_cat-use-cases-series-5-drivechain-1\"></a>Bitcoin OP_CAT Use Cases Series <span class=\"hashtag-raw\">#5:</span> Drivechain</h1>\n<h2><a name=\"p-3720-hashrate-escrows-without-bip300-2\" class=\"anchor\" href=\"#p-3720-hashrate-escrows-without-bip300-2\"></a>Hashrate Escrows Without BIP300</h2>\n<p>We have created a smart contract that operates similarly to the hashrate escrow mechanism in Bitcoin\u2019s Drivechain proposal. However, instead of requiring a substantial protocol upgrade like <a href=\"https://en.bitcoin.it/wiki/BIP_0300\" rel=\"noopener nofollow ugc\">BIP300</a>, it leverages general smart contract functionality to establish a sidechain covenant using OP_CAT.</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/1X/f6ba01f1612cfdc2166d2b1b5a611a27be73c51e.jpeg\" data-download-href=\"https://delvingbitcoin.org/uploads/default/f6ba01f1612cfdc2166d2b1b5a611a27be73c51e\" title=\"\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/1X/f6ba01f1612cfdc2166d2b1b5a611a27be73c51e_2_690x394.jpeg\" alt=\"\" data-base62-sha1=\"zcDYAaSuq2l1Y53EDTb6JyMTZoi\" width=\"690\" height=\"394\" role=\"presentation\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/1X/f6ba01f1612cfdc2166d2b1b5a611a27be73c51e_2_690x394.jpeg, https://delvingbitcoin.org/uploads/default/original/1X/f6ba01f1612cfdc2166d2b1b5a611a27be73c51e.jpeg 1.5x, https://delvingbitcoin.org/uploads/default/original/1X/f6ba01f1612cfdc2166d2b1b5a611a27be73c51e.jpeg 2x\" data-dominant-color=\"75715C\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\"></span><span class=\"informations\">700\u00d7400 85.1 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<h1><a name=\"p-3720-drivechain-3\" class=\"anchor\" href=\"#p-3720-drivechain-3\"></a>Drivechain</h1>\n<p>Drivechain in Bitcoin are a mechanism for implementing <strong>sidechains</strong>, which are independent blockchains pegged to Bitcoin. They allow users to transfer BTC between the Bitcoin mainchain and sidechains, enabling new features or experimental technologies without altering the mainchain. Drivechain use a two-way peg system and rely on Bitcoin miners to enforce transfers.</p>\n<p><strong>Peg-In: Transferring to a Sidechain</strong></p>\n<ul>\n<li>Users initiate a transaction that locks their bitcoins in a special output on the main Bitcoin chain.</li>\n<li>This action generates an equivalent amount of tokens on the chosen sidechain, permitting users to transact under the sidechain\u2019s distinct rules and features.</li>\n</ul>\n<p><strong>Peg-Out: Returning to the Mainchain</strong></p>\n<ul>\n<li>To move assets back, users execute a transaction on the sidechain that effectively burns the sidechain tokens.</li>\n<li>A corresponding withdrawal request is then submitted to the mainchain, to be voted on by miners as detailed below.</li>\n</ul>\n<h1><a name=\"p-3720-bip300-hashrate-escrow-4\" class=\"anchor\" href=\"#p-3720-bip300-hashrate-escrow-4\"></a>BIP300: Hashrate Escrow</h1>\n<p>The Drivechain proposal for Bitcoin is encapsulated in two Bitcoin Improvement Proposals: <a href=\"https://en.bitcoin.it/wiki/BIP_0300\" rel=\"noopener nofollow ugc\">BIP300</a> for Hashrate Escrows and <a href=\"https://en.bitcoin.it/wiki/BIP_0301\" rel=\"noopener nofollow ugc\">BIP301</a> for Blind Merged Mining. We focus on the former since involves opcode change.</p>\n<p>In the Drivechain proposal BIP300, <strong>miner voting</strong> is a critical mechanism that governs the approval of withdrawals (peg-outs) from the sidechain back to the main Bitcoin blockchain. Transactions are not signed using cryptographic keys. Instead, they are \u201csigned/voted\u201d by the collective hashpower over time: hashrate-secured escrow. This process functions like a large multisignature arrangement, requiring something akin to 1500 out of 3000 \u201csignatures,\u201d with each mined block representing one signature.</p>\n<p>Here\u2019s how miner voting operates in our hashrate escrow contract:</p>\n<h2><a name=\"p-3720-h-1-withdrawal-request-creation-5\" class=\"anchor\" href=\"#p-3720-h-1-withdrawal-request-creation-5\"></a><strong>1. Withdrawal Request Creation</strong></h2>\n<p>A user on the sidechain burns their sidechain tokens to initiate a withdrawal request to the main Bitcoin chain.</p>\n<h2><a name=\"p-3720-h-2-miner-voting-period-6\" class=\"anchor\" href=\"#p-3720-h-2-miner-voting-period-6\"></a><strong>2. Miner Voting Period</strong></h2>\n<ul>\n<li>The withdrawal request is submitted to Bitcoin miners, who vote on its validity.</li>\n<li>This voting process typically spans <strong>3 to 6 months</strong>, allowing ample time for miners to evaluate the request.</li>\n</ul>\n<h2><a name=\"p-3720-h-3-voting-process-7\" class=\"anchor\" href=\"#p-3720-h-3-voting-process-7\"></a><strong>3. Voting Process</strong></h2>\n<ul>\n<li>Miners include a signal in the blocks they mine, either <strong>approving</strong> or <strong>rejecting</strong> the withdrawal request.</li>\n<li>Signals are embedded in block headers or auxiliary data fields, making them visible on the Bitcoin blockchain.</li>\n</ul>\n<h2><a name=\"p-3720-h-4-consensus-threshold-8\" class=\"anchor\" href=\"#p-3720-h-4-consensus-threshold-8\"></a><strong>4. Consensus Threshold</strong></h2>\n<ul>\n<li>For a withdrawal to be approved, a majority of miners (usually defined as a percentage of the total hashrate, like 51%) must vote in favor of the request during the voting period.</li>\n<li>If the required threshold is not met, the withdrawal is denied.</li>\n</ul>\n<h1><a name=\"p-3720-overview-9\" class=\"anchor\" href=\"#p-3720-overview-9\"></a>Overview</h1>\n<p>Our hashrate escrow of the drivechain implementation features:</p>\n<ul>\n<li><strong>Operator Control</strong>: Using m-of-n signatures from trusted operators.</li>\n<li><strong>Miner Voting</strong>: Decentralized consensus for withdrawals.</li>\n<li><strong>Dynamic State Updates</strong>: The smart contract contains state data that contains values such as vote count and timestamps for voting periods.</li>\n</ul>\n<p>The contract includes four primary methods: <code>lock</code>, <code>initWithdrawal</code>, <code>vote</code>, and <code>finishWithdrawal</code>.</p>\n<p><strong>Operator-Controlled State Management</strong></p>\n<ul>\n<li>A group of operators (m-of-n configuration) manage the state transitions.</li>\n<li>The operators are responsible for initializing withdrawal proposals.</li>\n<li>Their actions are validated through a multisig, ensuring no single party can unilaterally control the funds.</li>\n</ul>\n<p><strong>Miner Voting</strong></p>\n<ul>\n<li>Miners vote on withdrawal proposals via coinbase transactions.</li>\n<li>Voting is based on a two-thirds majority rule, ensuring wide miner participation and decentralized decision-making.</li>\n</ul>\n<p><strong>Dynamic Contract State</strong></p>\n<ul>\n<li>The smart contract contains state data that contains values such as vote count and timestamps for voting periods.</li>\n<li>Each state transition is hashed and stored in an unspendable OP_RETURN output. Transaction introspection allows us to read this value in the transaction that follows.</li>\n</ul>\n<p>The contract operates through the following phases:</p>\n<ol>\n<li><strong>Lock</strong>: Funds are bridged into the drive chain.</li>\n<li><strong>InitWithdrawal</strong>: Operators propose withdrawals.</li>\n<li><strong>Vote</strong>: Miners vote to approve or reject proposals.</li>\n<li><strong>FinishWithdrawal</strong>: Approved withdrawals are executed or state resets for unapproved proposals.</li>\n</ol>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/1X/d78ad1976b0cb003abe17d133a02bf4b2aa97a15.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/d78ad1976b0cb003abe17d133a02bf4b2aa97a15\" title=\"\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/1X/d78ad1976b0cb003abe17d133a02bf4b2aa97a15_2_690x226.png\" alt=\"\" data-base62-sha1=\"uKM4zYzYYlpFYIml5rsCJOScyzj\" width=\"690\" height=\"226\" role=\"presentation\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/1X/d78ad1976b0cb003abe17d133a02bf4b2aa97a15_2_690x226.png, https://delvingbitcoin.org/uploads/default/original/1X/d78ad1976b0cb003abe17d133a02bf4b2aa97a15.png 1.5x, https://delvingbitcoin.org/uploads/default/original/1X/d78ad1976b0cb003abe17d133a02bf4b2aa97a15.png 2x\" data-dominant-color=\"D8E8D5\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\"></span><span class=\"informations\">700\u00d7229 25.7 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>Transaction diagram depicting a call to the lock() method</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/1X/9ac7d5f6f8164e7375894e2c6be29a8f34a622c3.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/9ac7d5f6f8164e7375894e2c6be29a8f34a622c3\" title=\"\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/1X/9ac7d5f6f8164e7375894e2c6be29a8f34a622c3_2_690x347.png\" alt=\"\" data-base62-sha1=\"m5fFX8Hnpnx7ts0pRzYq1Y2KiVZ\" width=\"690\" height=\"347\" role=\"presentation\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/1X/9ac7d5f6f8164e7375894e2c6be29a8f34a622c3_2_690x347.png, https://delvingbitcoin.org/uploads/default/original/1X/9ac7d5f6f8164e7375894e2c6be29a8f34a622c3.png 1.5x, https://delvingbitcoin.org/uploads/default/original/1X/9ac7d5f6f8164e7375894e2c6be29a8f34a622c3.png 2x\" data-dominant-color=\"E4EFE4\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\"></span><span class=\"informations\">700\u00d7352 25 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>Transaction diagram depicting a call to the vote() method</p>\n<h1><a name=\"p-3720-implementation-10\" class=\"anchor\" href=\"#p-3720-implementation-10\"></a>Implementation</h1>\n<h2><a name=\"p-3720-state-representation-11\" class=\"anchor\" href=\"#p-3720-state-representation-11\"></a>State Representation</h2>\n<p>The contract state includes:</p>\n<ul>\n<li><code>startPeriod</code>: Block height of the last update.</li>\n<li><code>voteCnt</code>: Miner votes for the current withdrawal.</li>\n<li><code>payoutAmt</code>: BTC amount to withdraw.</li>\n<li><code>payoutSPK</code>: ScriptPubKey of the withdrawal output.</li>\n</ul>\n<p>These values are hashed and enforced to be stored within an unspendable OP_RETURN output by the contract, using <a href=\"https://scryptplatform.medium.com/bitcoin-op-cat-use-cases-series-4-recursive-covenants-6a3127a24af4\" rel=\"noopener nofollow ugc\">recursive covenants</a>.</p>\n<h2><a name=\"p-3720-locking-extra-funds-12\" class=\"anchor\" href=\"#p-3720-locking-extra-funds-12\"></a>Locking Extra Funds</h2>\n<p>The <code>lock</code> method validates and bridges BTC to the covenant. It ensures the bridged amount exceeds 10,000 satoshis and verifies state consistency.</p>\n<pre data-code-wrap=\"ts\"><code class=\"lang-ts\">@method()\npublic lock(\n    shPreimage: SHPreimage,\n    prevTx: DriveChainTx,\n    amtBridged: bigint,\n    spentAmountsSuffix: ByteString,\n    feePrevout: ByteString\n) {\n    this.checkContractContext(shPreimage, prevTx, feePrevout)\n\n    // Check passed spent amounts info is valid.\n    assert(\n        shPreimage.hashSpentAmounts ==\n        sha256(\n            DriveChain.padAmt(prevTx.contractOutputAmount) +\n            DriveChain.padAmt(amtBridged) +\n            spentAmountsSuffix\n        )\n    )\n\n    // Check bridged amount is sufficient.\n    assert(amtBridged &gt; 10000n)\n\n    // Ensure state transition is reflected in outputs.\n    const hashOutputs = sha256(\n        DriveChain.padAmt(prevTx.contractOutputAmount + amtBridged) +\n        prevTx.contractOutputSPK +\n        DriveChain.getStateOut(prevTx.stateHash)\n    )\n    assert(hashOutputs == shPreimage.hashOutputs)\n}\n</code></pre>\n<h2><a name=\"p-3720-initializing-a-withdrawal-13\" class=\"anchor\" href=\"#p-3720-initializing-a-withdrawal-13\"></a>Initializing a Withdrawal</h2>\n<p>Operators propose withdrawals by providing signatures and specifying payout details. The contract validates these signatures, ensures sufficient time has passed since the last proposal, and updates the state.</p>\n<pre data-code-wrap=\"ts\"><code class=\"lang-ts\">@method()\npublic initWithdrawal(\n    shPreimage: SHPreimage,\n    prevTx: DriveChainTx,\n    operatorSigs: FixedArray&lt;Sig, 3&gt;,\n    operatorPubKeys: FixedArray&lt;PubKey, 5&gt;,\n    currentState: DriveChainState,\n    nLockTimeInt: bigint,\n    payoutAmt: bigint,\n    payoutSPK: ByteString,\n    feePrevout: ByteString\n) {\n    this.checkContractContext(shPreimage, prevTx, feePrevout);\n\n    // Verify the provided state matches the stored hash\n    assert(DriveChain.getStateHash(currentState) == prevTx.stateHash);\n\n    // Validate operator signatures and keys\n    assert(this.checkMultiSig(operatorSigs, operatorPubKeys));\n\n    // Ensure withdrawal period requirements are met\n    assert(nLockTimeInt &gt;= currentState.startPeriod + 2088n);\n\n    // Update state with new payout details\n    const newState: DriveChainState = {\n        startPeriod: nLockTimeInt,\n        voteCnt: 0n,\n        payoutAmt: payoutAmt,\n        payoutSPK: payoutSPK,\n    };\n\n    // Ensure state transition is reflected in outputs\n    const hashOutputs = sha256(\n        DriveChain.padAmt(prevTx.contractOutputAmount) +\n        prevTx.contractOutputSPK +\n        DriveChain.getStateOut(DriveChain.getStateHash(newState))\n    );\n    assert(hashOutputs == shPreimage.hashOutputs);\n}\n</code></pre>\n<h2><a name=\"p-3720-voting-on-withdrawal-14\" class=\"anchor\" href=\"#p-3720-voting-on-withdrawal-14\"></a>Voting on Withdrawal</h2>\n<p>Miners vote by using a coinbase transaction. Their votes affect the <code>voteCnt</code> positively or negatively, and the contract enforces single-use votes.</p>\n<pre data-code-wrap=\"ts\"><code class=\"lang-ts\">@method()\npublic vote(\n    shPreimage: SHPreimage,\n    prevTx: DriveChainTx,\n    coinbaseTx: CoinbaseTx,\n    currentState: DriveChainState,\n    agree: boolean,\n    feePrevout: ByteString,\n    changeOut: ByteString\n) {\n    this.checkContractContextVote(\n        shPreimage,\n        prevTx,\n        coinbaseTx,\n        feePrevout\n    )\n\n    // Check passed state.\n    assert(DriveChain.getStateHash(currentState) == prevTx.stateHash)\n\n    // Check block height in coinbase tx is greater than start period.\n    assert(coinbaseTx.blockHeight &gt; currentState.startPeriod)\n\n    // Adjust vote count.\n    // Implements 66% agree-voting threshold.\n    if (agree) {\n        currentState.voteCnt += 1n\n    } else {\n        currentState.voteCnt -= 2n\n    }\n\n    // Ensure state transition is reflected in outputs.\n    const hashOutputs = sha256(\n        DriveChain.padAmt(prevTx.contractOutputAmount) +\n        prevTx.contractOutputSPK +\n        DriveChain.getStateOut(DriveChain.getStateHash(currentState)) +\n        changeOut\n    )\n    assert(hashOutputs == shPreimage.hashOutputs)\n}\n</code></pre>\n<h2><a name=\"p-3720-finalizing-a-withdrawal-15\" class=\"anchor\" href=\"#p-3720-finalizing-a-withdrawal-15\"></a>Finalizing a Withdrawal</h2>\n<p>Once the voting period ends, withdrawals are finalized if the <code>voteCnt</code> reaches the threshold. The payout amount is sent, and the state is reset for future proposals.</p>\n<pre data-code-wrap=\"ts\"><code class=\"lang-ts\">@method()\npublic finishWithdrawal(\n    shPreimage: SHPreimage,\n    prevTx: DriveChainTx,\n    nLockTimeInt: bigint,\n    currentState: DriveChainState,\n    feePrevout: ByteString\n) {\n    this.checkContractContext(shPreimage, prevTx, feePrevout)\n    \n    // Check passed state.\n    assert(DriveChain.getStateHash(currentState) == prevTx.stateHash)\n    // Check passed nLockTime int value.\n    assert(shPreimage.nLockTime == DriveChain.padTime(nLockTimeInt))\n    // This method can only be called at least 2016 blocks after startPeriod.\n    assert(nLockTimeInt &gt;= currentState.startPeriod + 2016n)\n    // Check votes were made.\n    assert(currentState.voteCnt &gt; 0n)\n    // Construct payout output.\n    const payoutOut =\n        DriveChain.padAmt(currentState.payoutAmt) + currentState.payoutSPK\n    // Update state; reset vote count, payout amt and set new start preiod.\n    const newState: DriveChainState = {\n        startPeriod: nLockTimeInt,\n        voteCnt: 0n,\n        payoutAmt: 0n,\n        payoutSPK: toByteString(''),\n    }\n    // Ensure state transition is reflected in outputs.\n    const hashOutputs = sha256(\n        DriveChain.padAmt(prevTx.contractOutputAmount) +\n        prevTx.contractOutputSPK +\n        DriveChain.getStateOut(DriveChain.getStateHash(newState)) +\n        payoutOut\n    )\n    assert(hashOutputs == shPreimage.hashOutputs)\n}\n</code></pre>\n<p>The full code of the smart contract can be found <a href=\"https://github.com/sCrypt-Inc/cat-contracts/blob/master/src/contracts/driveChain.ts\" rel=\"noopener nofollow ugc\">on GitHub</a>.</p>\n<h1><a name=\"p-3720-acknowledgement-16\" class=\"anchor\" href=\"#p-3720-acknowledgement-16\"></a>Acknowledgement</h1>\n<p>Our implementation draws inspiration from <a href=\"https://github.com/mr-zwets/upgraded-SHA-gate\" rel=\"noopener nofollow ugc\">the SHA-gate contract</a> designed for Bitcoin Cash. Our work adapts the mechanics of the SHA-gate contract to BTC with OP_CAT re-enabled.</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2024-12-06T08:09:05.517Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 19,
  "reads": 10,
  "readers_count": 9,
  "score": 96.8,
  "yours": false,
  "topic_id": 1307,
  "topic_slug": "bitcoin-op-cat-use-cases-series-5-drivechain",
  "topic_title": "Bitcoin OP_CAT Use Cases Series #5: Drivechain",
  "topic_html_title": "Bitcoin OP_CAT Use Cases Series #5: Drivechain",
  "category_id": 8,
  "display_username": "sCrypt",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": "",
  "bookmarked": false,
  "raw": "# Bitcoin OP_CAT Use Cases Series #5: Drivechain\n\n## Hashrate Escrows Without BIP300\n\nWe have created a smart contract that operates similarly to the hashrate escrow mechanism in Bitcoin\u2019s Drivechain proposal. However, instead of requiring a substantial protocol upgrade like [BIP300](https://en.bitcoin.it/wiki/BIP_0300), it leverages general smart contract functionality to establish a sidechain covenant using OP_CAT.\n\n![|700x400](upload://zcDYAaSuq2l1Y53EDTb6JyMTZoi.jpeg)\n\n# Drivechain\n\nDrivechain in Bitcoin are a mechanism for implementing **sidechains**, which are independent blockchains pegged to Bitcoin. They allow users to transfer BTC between the Bitcoin mainchain and sidechains, enabling new features or experimental technologies without altering the mainchain. Drivechain use a two-way peg system and rely on Bitcoin miners to enforce transfers.\n\n**Peg-In: Transferring to a Sidechain**\n\n* Users initiate a transaction that locks their bitcoins in a special output on the main Bitcoin chain.\n* This action generates an equivalent amount of tokens on the chosen sidechain, permitting users to transact under the sidechain\u2019s distinct rules and features.\n\n**Peg-Out: Returning to the Mainchain**\n\n* To move assets back, users execute a transaction on the sidechain that effectively burns the sidechain tokens.\n* A corresponding withdrawal request is then submitted to the mainchain, to be voted on by miners as detailed below.\n\n# BIP300: Hashrate Escrow\n\nThe Drivechain proposal for Bitcoin is encapsulated in two Bitcoin Improvement Proposals: [BIP300](https://en.bitcoin.it/wiki/BIP_0300) for Hashrate Escrows and [BIP301](https://en.bitcoin.it/wiki/BIP_0301) for Blind Merged Mining. We focus on the former since involves opcode change.\n\nIn the Drivechain proposal BIP300, **miner voting** is a critical mechanism that governs the approval of withdrawals (peg-outs) from the sidechain back to the main Bitcoin blockchain. Transactions are not signed using cryptographic keys. Instead, they are \u201csigned/voted\u201d by the collective hashpower over time: hashrate-secured escrow. This process functions like a large multisignature arrangement, requiring something akin to 1500 out of 3000 \u201csignatures,\u201d with each mined block representing one signature.\n\nHere\u2019s how miner voting operates in our hashrate escrow contract:\n\n## **1. Withdrawal Request Creation**\n\nA user on the sidechain burns their sidechain tokens to initiate a withdrawal request to the main Bitcoin chain.\n\n## **2. Miner Voting Period**\n\n* The withdrawal request is submitted to Bitcoin miners, who vote on its validity.\n* This voting process typically spans **3 to 6 months**, allowing ample time for miners to evaluate the request.\n\n## **3. Voting Process**\n\n* Miners include a signal in the blocks they mine, either **approving** or **rejecting** the withdrawal request.\n* Signals are embedded in block headers or auxiliary data fields, making them visible on the Bitcoin blockchain.\n\n## **4. Consensus Threshold**\n\n* For a withdrawal to be approved, a majority of miners (usually defined as a percentage of the total hashrate, like 51%) must vote in favor of the request during the voting period.\n* If the required threshold is not met, the withdrawal is denied.\n\n# Overview\n\nOur hashrate escrow of the drivechain implementation features:\n\n* **Operator Control**: Using m-of-n signatures from trusted operators.\n* **Miner Voting**: Decentralized consensus for withdrawals.\n* **Dynamic State Updates**: The smart contract contains state data that contains values such as vote count and timestamps for voting periods.\n\nThe contract includes four primary methods: `lock`, `initWithdrawal`, `vote`, and `finishWithdrawal`.\n\n**Operator-Controlled State Management**\n\n* A group of operators (m-of-n configuration) manage the state transitions.\n* The operators are responsible for initializing withdrawal proposals.\n* Their actions are validated through a multisig, ensuring no single party can unilaterally control the funds.\n\n**Miner Voting**\n\n* Miners vote on withdrawal proposals via coinbase transactions.\n* Voting is based on a two-thirds majority rule, ensuring wide miner participation and decentralized decision-making.\n\n**Dynamic Contract State**\n\n* The smart contract contains state data that contains values such as vote count and timestamps for voting periods.\n* Each state transition is hashed and stored in an unspendable OP_RETURN output. Transaction introspection allows us to read this value in the transaction that follows.\n\nThe contract operates through the following phases:\n\n1. **Lock**: Funds are bridged into the drive chain.\n2. **InitWithdrawal**: Operators propose withdrawals.\n3. **Vote**: Miners vote to approve or reject proposals.\n4. **FinishWithdrawal**: Approved withdrawals are executed or state resets for unapproved proposals.\n\n![|700x230](upload://uKM4zYzYYlpFYIml5rsCJOScyzj.png)\n\nTransaction diagram depicting a call to the lock() method\n\n![|700x353](upload://m5fFX8Hnpnx7ts0pRzYq1Y2KiVZ.png)\n\nTransaction diagram depicting a call to the vote() method\n\n# Implementation\n\n## State Representation\n\nThe contract state includes:\n\n* `startPeriod`: Block height of the last update.\n* `voteCnt`: Miner votes for the current withdrawal.\n* `payoutAmt`: BTC amount to withdraw.\n* `payoutSPK`: ScriptPubKey of the withdrawal output.\n\nThese values are hashed and enforced to be stored within an unspendable OP_RETURN output by the contract, using [recursive covenants](https://scryptplatform.medium.com/bitcoin-op-cat-use-cases-series-4-recursive-covenants-6a3127a24af4).\n\n## Locking Extra Funds\n\nThe `lock` method validates and bridges BTC to the covenant. It ensures the bridged amount exceeds 10,000 satoshis and verifies state consistency.\n\n```ts\n@method()\npublic lock(\n    shPreimage: SHPreimage,\n    prevTx: DriveChainTx,\n    amtBridged: bigint,\n    spentAmountsSuffix: ByteString,\n    feePrevout: ByteString\n) {\n    this.checkContractContext(shPreimage, prevTx, feePrevout)\n\n    // Check passed spent amounts info is valid.\n    assert(\n        shPreimage.hashSpentAmounts ==\n        sha256(\n            DriveChain.padAmt(prevTx.contractOutputAmount) +\n            DriveChain.padAmt(amtBridged) +\n            spentAmountsSuffix\n        )\n    )\n\n    // Check bridged amount is sufficient.\n    assert(amtBridged > 10000n)\n\n    // Ensure state transition is reflected in outputs.\n    const hashOutputs = sha256(\n        DriveChain.padAmt(prevTx.contractOutputAmount + amtBridged) +\n        prevTx.contractOutputSPK +\n        DriveChain.getStateOut(prevTx.stateHash)\n    )\n    assert(hashOutputs == shPreimage.hashOutputs)\n}\n```\n\n## Initializing a Withdrawal\n\nOperators propose withdrawals by providing signatures and specifying payout details. The contract validates these signatures, ensures sufficient time has passed since the last proposal, and updates the state.\n\n```ts\n@method()\npublic initWithdrawal(\n    shPreimage: SHPreimage,\n    prevTx: DriveChainTx,\n    operatorSigs: FixedArray<Sig, 3>,\n    operatorPubKeys: FixedArray<PubKey, 5>,\n    currentState: DriveChainState,\n    nLockTimeInt: bigint,\n    payoutAmt: bigint,\n    payoutSPK: ByteString,\n    feePrevout: ByteString\n) {\n    this.checkContractContext(shPreimage, prevTx, feePrevout);\n\n    // Verify the provided state matches the stored hash\n    assert(DriveChain.getStateHash(currentState) == prevTx.stateHash);\n\n    // Validate operator signatures and keys\n    assert(this.checkMultiSig(operatorSigs, operatorPubKeys));\n\n    // Ensure withdrawal period requirements are met\n    assert(nLockTimeInt >= currentState.startPeriod + 2088n);\n\n    // Update state with new payout details\n    const newState: DriveChainState = {\n        startPeriod: nLockTimeInt,\n        voteCnt: 0n,\n        payoutAmt: payoutAmt,\n        payoutSPK: payoutSPK,\n    };\n\n    // Ensure state transition is reflected in outputs\n    const hashOutputs = sha256(\n        DriveChain.padAmt(prevTx.contractOutputAmount) +\n        prevTx.contractOutputSPK +\n        DriveChain.getStateOut(DriveChain.getStateHash(newState))\n    );\n    assert(hashOutputs == shPreimage.hashOutputs);\n}\n```\n\n## Voting on Withdrawal\n\nMiners vote by using a coinbase transaction. Their votes affect the `voteCnt` positively or negatively, and the contract enforces single-use votes.\n\n```ts\n@method()\npublic vote(\n    shPreimage: SHPreimage,\n    prevTx: DriveChainTx,\n    coinbaseTx: CoinbaseTx,\n    currentState: DriveChainState,\n    agree: boolean,\n    feePrevout: ByteString,\n    changeOut: ByteString\n) {\n    this.checkContractContextVote(\n        shPreimage,\n        prevTx,\n        coinbaseTx,\n        feePrevout\n    )\n\n    // Check passed state.\n    assert(DriveChain.getStateHash(currentState) == prevTx.stateHash)\n\n    // Check block height in coinbase tx is greater than start period.\n    assert(coinbaseTx.blockHeight > currentState.startPeriod)\n\n    // Adjust vote count.\n    // Implements 66% agree-voting threshold.\n    if (agree) {\n        currentState.voteCnt += 1n\n    } else {\n        currentState.voteCnt -= 2n\n    }\n\n    // Ensure state transition is reflected in outputs.\n    const hashOutputs = sha256(\n        DriveChain.padAmt(prevTx.contractOutputAmount) +\n        prevTx.contractOutputSPK +\n        DriveChain.getStateOut(DriveChain.getStateHash(currentState)) +\n        changeOut\n    )\n    assert(hashOutputs == shPreimage.hashOutputs)\n}\n```\n\n## Finalizing a Withdrawal\n\nOnce the voting period ends, withdrawals are finalized if the `voteCnt` reaches the threshold. The payout amount is sent, and the state is reset for future proposals.\n\n```ts\n@method()\npublic finishWithdrawal(\n    shPreimage: SHPreimage,\n    prevTx: DriveChainTx,\n    nLockTimeInt: bigint,\n    currentState: DriveChainState,\n    feePrevout: ByteString\n) {\n    this.checkContractContext(shPreimage, prevTx, feePrevout)\n    \n    // Check passed state.\n    assert(DriveChain.getStateHash(currentState) == prevTx.stateHash)\n    // Check passed nLockTime int value.\n    assert(shPreimage.nLockTime == DriveChain.padTime(nLockTimeInt))\n    // This method can only be called at least 2016 blocks after startPeriod.\n    assert(nLockTimeInt >= currentState.startPeriod + 2016n)\n    // Check votes were made.\n    assert(currentState.voteCnt > 0n)\n    // Construct payout output.\n    const payoutOut =\n        DriveChain.padAmt(currentState.payoutAmt) + currentState.payoutSPK\n    // Update state; reset vote count, payout amt and set new start preiod.\n    const newState: DriveChainState = {\n        startPeriod: nLockTimeInt,\n        voteCnt: 0n,\n        payoutAmt: 0n,\n        payoutSPK: toByteString(''),\n    }\n    // Ensure state transition is reflected in outputs.\n    const hashOutputs = sha256(\n        DriveChain.padAmt(prevTx.contractOutputAmount) +\n        prevTx.contractOutputSPK +\n        DriveChain.getStateOut(DriveChain.getStateHash(newState)) +\n        payoutOut\n    )\n    assert(hashOutputs == shPreimage.hashOutputs)\n}\n```\nThe full code of the smart contract can be found [on GitHub](https://github.com/sCrypt-Inc/cat-contracts/blob/master/src/contracts/driveChain.ts).\n\n# Acknowledgement\n\nOur implementation draws inspiration from [the SHA-gate contract](https://github.com/mr-zwets/upgraded-SHA-gate) designed for Bitcoin Cash. Our work adapts the mechanics of the SHA-gate contract to BTC with OP_CAT re-enabled.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 477,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": "downloaded local copies of images",
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}