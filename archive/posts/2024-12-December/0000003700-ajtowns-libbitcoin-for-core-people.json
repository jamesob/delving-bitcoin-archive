{
  "id": 3700,
  "name": "Anthony Towns",
  "username": "ajtowns",
  "avatar_template": "/user_avatar/delvingbitcoin.org/ajtowns/{size}/417_2.png",
  "created_at": "2024-12-03T04:45:30.120Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"sipa\" data-post=\"36\" data-topic=\"1222\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/sipa/48/102_2.png\" class=\"avatar\"> sipa:</div>\n<blockquote>\n<p>When script validation is enabled, this isn\u2019t possible because the state required to run script validation is pretty much the entire spending transaction, not just a small piece of UTXO data.</p>\n</blockquote>\n</aside>\n<p>I think you can do the same optimisation even in that case, if you augment the spending block with its corresponding revNNN.dat data. You can\u2019t authenticate the revNNN.dat, so still need to track negative entries, and in addition also need to check that the rev data was correct (compare it to the utxo when you find a match), and need to be able handle falling back to in-order processing (in case you\u2019re given bad rev data which says a tx is invalid, you need to recheck when you get the actual utxo data, if it\u2019s different).</p>\n<p>(I was thinking of that technique in the context of taking an assumeutxo set and validating the chain both forwards and backwards simultaneously, to avoid the need to maintaining two utxo sets, provided you didn\u2019t care about optimising for the case where the assumeutxo point was actually invalid)</p>",
  "post_number": 41,
  "post_type": 1,
  "updated_at": "2024-12-03T04:45:30.120Z",
  "reply_count": 0,
  "reply_to_post_number": 36,
  "quote_count": 1,
  "incoming_link_count": 1,
  "reads": 8,
  "readers_count": 7,
  "score": 6.4,
  "yours": false,
  "topic_id": 1222,
  "topic_slug": "libbitcoin-for-core-people",
  "topic_title": "Libbitcoin for Core people",
  "topic_html_title": "Libbitcoin for Core people",
  "category_id": 8,
  "display_username": "Anthony Towns",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"sipa, post:36, topic:1222\"]\nWhen script validation is enabled, this isn\u2019t possible because the state required to run script validation is pretty much the entire spending transaction, not just a small piece of UTXO data.\n[/quote]\n\nI think you can do the same optimisation even in that case, if you augment the spending block with its corresponding revNNN.dat data. You can't authenticate the revNNN.dat, so still need to track negative entries, and in addition also need to check that the rev data was correct (compare it to the utxo when you find a match), and need to be able handle falling back to in-order processing (in case you're given bad rev data which says a tx is invalid, you need to recheck when you get the actual utxo data, if it's different).\n\n(I was thinking of that technique in the context of taking an assumeutxo set and validating the chain both forwards and backwards simultaneously, to avoid the need to maintaining two utxo sets, provided you didn't care about optimising for the case where the assumeutxo point was actually invalid)",
  "actions_summary": [],
  "moderator": true,
  "admin": true,
  "staff": true,
  "user_id": 3,
  "hidden": false,
  "trust_level": 4,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}