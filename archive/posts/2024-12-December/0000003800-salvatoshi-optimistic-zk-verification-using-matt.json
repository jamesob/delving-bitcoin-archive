{
  "id": 3800,
  "name": "salvatoshi",
  "username": "salvatoshi",
  "avatar_template": "/user_avatar/delvingbitcoin.org/salvatoshi/{size}/72_2.png",
  "created_at": "2024-12-16T13:09:21.674Z",
  "cooked": "<p>In MATT, <code>OP_CAT</code> is only used for the purpose of creating vector commitments, as that enables checking Merkle proofs; other opcodes like <a href=\"https://github.com/bitcoin/bips/pull/1699\" rel=\"noopener nofollow ugc\"><code>OP_PAIRCOMMIT</code>/<code>VECTORCOMMIT</code></a> would do the job, too.</p>\n<p>About the need for a covenant: it is used in order to execute a protocol as an arbitrary state machine across multiple UTXOs, where each \u2018transition\u2019 can do some computation on the <em>state</em> committed in it (if any), and dynamically compute the state for the \u2018next step\u2019 (which corresponds to a different node in the state machine of the protocol). Fraud proofs for any computation are a use case. Notably, no presigned transaction is needed for such protocols, as all the possible futures are directly preprogrammed in Script thanks to the covenant.</p>\n<p>I sketched the fraud proofs in the <a href=\"https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com/\" rel=\"noopener nofollow ugc\">initial post about MATT</a> (starting from <em>Commitments to computation and fraud challenges</em>), with a toy example <a href=\"https://gnusha.org/pi/bitcoindev/CAMhCMoEONv3jriBU3qwm0pt75iF_sgra1H2Z4rOF8u+e7hs_cw@mail.gmail.com/\" rel=\"noopener nofollow ugc\">here</a>. There\u2019s also a <a href=\"https://github.com/Merkleize/pymatt/blob/55c9239288ae9b4900a251bfe5d8fc0f99308491/matt/hub/fraud.py\" rel=\"noopener nofollow ugc\">python implementation</a> of the bisection protocol, which contains a formal description in the comments.</p>\n<p>I collect all the resources related to MATT at <a href=\"https://merkle.fun\" rel=\"noopener nofollow ugc\">https://merkle.fun</a>, if you\u2019re interested to go more in-depth on any of these topics, or check the existing code. Please don\u2019t hesitate to reach out if you have any question.</p>",
  "post_number": 3,
  "post_type": 1,
  "updated_at": "2024-12-16T13:14:25.104Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 10,
  "readers_count": 9,
  "score": 2.0,
  "yours": false,
  "topic_id": 1050,
  "topic_slug": "optimistic-zk-verification-using-matt",
  "topic_title": "Optimistic ZK verification using MATT",
  "topic_html_title": "Optimistic ZK verification using MATT",
  "category_id": 7,
  "display_username": "salvatoshi",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "In MATT, `OP_CAT` is only used for the purpose of creating vector commitments, as that enables checking Merkle proofs; other opcodes like [`OP_PAIRCOMMIT`/`VECTORCOMMIT`](https://github.com/bitcoin/bips/pull/1699) would do the job, too.\n\nAbout the need for a covenant: it is used in order to execute a protocol as an arbitrary state machine across multiple UTXOs, where each 'transition' can do some computation on the *state* committed in it (if any), and dynamically compute the state for the 'next step' (which corresponds to a different node in the state machine of the protocol). Fraud proofs for any computation are a use case. Notably, no presigned transaction is needed for such protocols, as all the possible futures are directly preprogrammed in Script thanks to the covenant.\n\nI sketched the fraud proofs in the [initial post about MATT](https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com/) (starting from *Commitments to computation and fraud challenges*), with a toy example [here](https://gnusha.org/pi/bitcoindev/CAMhCMoEONv3jriBU3qwm0pt75iF_sgra1H2Z4rOF8u+e7hs_cw@mail.gmail.com/). There's also a [python implementation](https://github.com/Merkleize/pymatt/blob/55c9239288ae9b4900a251bfe5d8fc0f99308491/matt/hub/fraud.py) of the bisection protocol, which contains a formal description in the comments.\n\nI collect all the resources related to MATT at https://merkle.fun, if you're interested to go more in-depth on any of these topics, or check the existing code. Please don't hesitate to reach out if you have any question.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 81,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": "Github link was replaced with a permanent link",
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}