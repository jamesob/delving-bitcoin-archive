{
  "id": 3844,
  "name": "Zawy",
  "username": "zawy",
  "avatar_template": "/user_avatar/delvingbitcoin.org/zawy/{size}/750_2.png",
  "created_at": "2024-12-22T14:35:54.185Z",
  "cooked": "<p>I was helping Bob McElrath on his difficulty algorithm for Braidpool and found a remarkable difficulty algorithm that doesn\u2019t use timestamps, hashrate, or latency. Its goal is to be the fastest-possible consensus. Hashrate and latency independently create a wider DAG when they go up.  But when you\u2019re doing making it as fast as possible, hashrate * latency precisely cancels time units. You can simply set difficulty to target the DAG width.</p>\n<p>Bob\u2019s simple way of getting consensus is when the DAG width = 1 so that all nodes can agree what state the system was in. Width = 1 occurs when a block is the only child of the previous generation of blocks and the only parent of the next generation. This occurs when he\u2019s the only block mined in 1 latency period after he sends it, and not block is mined in 1 latency period after everyone has received it.</p>\n<p>But how do we measure DAG width? You just count your parents and target a fixed number of parents. This is an extremely simple idea compared to other DAG schemes that have to examine and think about a large tree of blocks.</p>\n<p>What the best number of parents? It turns out 2 gives the fastest consensus (i.e. the fastest time between 2 blocks at DAG width=1). When you target 2.000, the StdDev of number of parents is 1.000.  But wait, there\u2019s more. Consensus is achieved in exactly 2.71828x the latency, where latency is defined as the delay for all nodes in receiving a block. It\u2019s 2x faster if you define latency as the median.  Another interesting thing is that the ratio of total blocks to the consensus blocks is also 2.7182. Maybe someone could do the math to explain why.</p>\n<p>Here\u2019s the DAA:</p>\n<p>D = D_parents * (1 + parents/100 - 2/100)</p>\n<p>if parents average &gt; 2 in past 100 blocks, D goes up, and vice versa.</p>\n<p>Here\u2019s the command line output of my simulator below.</p>\n<pre><code class=\"lang-auto\">\nUser chose to use 'a' as the exact latency between every peer.\n\n=====   User selected parent-count DAA. =====\nx = x_parents_hmean * ( 1 + desired_parents/n - num_parents_measured\n\nmedian a\tL\tparents desired\t\tn\t\tblocks\n1.00\t\t1.0\t\t2\t\t\t\t500\t\t50000\n             Mean  StdDev\nx:           0.995 0.030 (Try to get smallest SD/mean for a given Nb*n.)\nsolvetime:   1.006 1.008\nNb/Nc:       2.694 0.059 \nnum_parents: 2.004 1.007\nNc blocks: 18561\nTime/Nc/a: 2.712 (The speed of consensus as a multiple of latency.)\n</code></pre>\n<p><a href=\"https://github.com/zawy12/difficulty-algorithms/blob/22f17c23784a0db47237e92ec9e5e2a8d2bccc8c/DAG_braidpool_simulator.py\" rel=\"noopener nofollow ugc\">DAG simulator by counting parents</a></p>\n<p><strong>Equivalence to Avalanche Speed and Efficiency:</strong>\nBasically, fees in both systems dictate how much \u201cwaste\u201d you can spend on making it distributed and secure. Avalanche is so proud the number of messages/node doesn\u2019t go up any as the number of nodes increases, but the network-wide waste in sending each other messages linearly goes up.  Peers are basically \u201cmining each other\u201d with messages to get consensus. I don\u2019t say mining here lightly. It\u2019s very much the same level of waste for the same reasons with the same inefficiency. Network bandwidth is precious and expensive. PoW does local hashing to remove the need for network messaging. Fees determine how much waste either system has and fees =&gt; waste is the source of security and decentralization.</p>\n<ul>\n<li>Avalanche &lt;=&gt; PoW</li>\n<li>messages = hashes</li>\n<li>more nodes = more hashing</li>\n<li>stake = CAPEX in mining equipment</li>\n<li>fast = this DAG</li>\n</ul>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 21,
  "updated_at": "2025-01-04T08:11:01.617Z",
  "reply_count": 1,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 214,
  "reads": 58,
  "readers_count": 57,
  "score": 1086.6,
  "yours": false,
  "topic_id": 1331,
  "topic_slug": "fastest-possible-pow-via-simple-dag",
  "topic_title": "Fastest-possible PoW via Simple DAG",
  "topic_html_title": "Fastest-possible PoW via Simple DAG",
  "category_id": 7,
  "display_username": "Zawy",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 7,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "I was helping Bob McElrath on his difficulty algorithm for Braidpool and found a remarkable difficulty algorithm that doesn't use timestamps, hashrate, or latency. Its goal is to be the fastest-possible consensus. Hashrate and latency independently create a wider DAG when they go up.  But when you're doing making it as fast as possible, hashrate * latency precisely cancels time units. You can simply set difficulty to target the DAG width. \n\nBob's simple way of getting consensus is when the DAG width = 1 so that all nodes can agree what state the system was in. Width = 1 occurs when a block is the only child of the previous generation of blocks and the only parent of the next generation. This occurs when he's the only block mined in 1 latency period after he sends it, and not block is mined in 1 latency period after everyone has received it.  \n\nBut how do we measure DAG width? You just count your parents and target a fixed number of parents. This is an extremely simple idea compared to other DAG schemes that have to examine and think about a large tree of blocks. \n\nWhat the best number of parents? It turns out 2 gives the fastest consensus (i.e. the fastest time between 2 blocks at DAG width=1). When you target 2.000, the StdDev of number of parents is 1.000.  But wait, there's more. Consensus is achieved in exactly 2.71828x the latency, where latency is defined as the delay for all nodes in receiving a block. It's 2x faster if you define latency as the median.  Another interesting thing is that the ratio of total blocks to the consensus blocks is also 2.7182. Maybe someone could do the math to explain why.  \n\nHere's the DAA:\n\nD = D_parents * (1 + parents/100 - 2/100)\n\nif parents average > 2 in past 100 blocks, D goes up, and vice versa.\n\nHere's the command line output of my simulator below.\n```\n\nUser chose to use 'a' as the exact latency between every peer.\n\n=====   User selected parent-count DAA. =====\nx = x_parents_hmean * ( 1 + desired_parents/n - num_parents_measured\n\nmedian a\tL\tparents desired\t\tn\t\tblocks\n1.00\t\t1.0\t\t2\t\t\t\t500\t\t50000\n             Mean  StdDev\nx:           0.995 0.030 (Try to get smallest SD/mean for a given Nb*n.)\nsolvetime:   1.006 1.008\nNb/Nc:       2.694 0.059 \nnum_parents: 2.004 1.007\nNc blocks: 18561\nTime/Nc/a: 2.712 (The speed of consensus as a multiple of latency.)\n```\n\n[DAG simulator by counting parents](https://github.com/zawy12/difficulty-algorithms/blob/22f17c23784a0db47237e92ec9e5e2a8d2bccc8c/DAG_braidpool_simulator.py)\n\n**Equivalence to Avalanche Speed and Efficiency:** \nBasically, fees in both systems dictate how much \"waste\" you can spend on making it distributed and secure. Avalanche is so proud the number of messages/node doesn't go up any as the number of nodes increases, but the network-wide waste in sending each other messages linearly goes up.  Peers are basically \"mining each other\" with messages to get consensus. I don't say mining here lightly. It's very much the same level of waste for the same reasons with the same inefficiency. Network bandwidth is precious and expensive. PoW does local hashing to remove the need for network messaging. Fees determine how much waste either system has and fees => waste is the source of security and decentralization.\n\n* Avalanche <=> PoW\n* messages = hashes\n* more nodes = more hashing\n* stake = CAPEX in mining equipment\n* fast = this DAG",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 502,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "I was helping Bob McElrath on his difficulty algorithm for Braidpool and found a remarkable difficulty algorithm that doesn\u2019t use timestamps, hashrate, or latency. Its goal is to be the fastest-possible consensus. Hashrate and latency independently create a wider DAG when they go up.  But when you\u2019r&hellip;",
  "truncated": true,
  "post_url": "/t/fastest-possible-pow-via-simple-dag/1331/1",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}