{
  "id": 3755,
  "name": "lorban",
  "username": "lorbax",
  "avatar_template": "/user_avatar/delvingbitcoin.org/lorbax/{size}/797_2.png",
  "created_at": "2024-12-10T09:32:38.687Z",
  "cooked": "<blockquote>\n<p>This seems worse than block withholding, because such a miner could run a way with ~100% of the block reward with ~0% of the PoW.</p>\n</blockquote>\n<p>If a miner is providing ~0% of the PoW, then he would get ~0% of blocks subsidy and ~0% of the block fees, because the fee-based score is calculated on top of the difficulty based score. Suppose that a slice contains the shares from ther <span class=\"math\">k_1</span>-th to the <span class=\"math\">k_2</span>-th. Suppose also that the fee and the difficulty score of the <span class=\"math\">i</span>-th share are <span class=\"math\">f_i</span> and <span class=\"math\">\\bar d_i</span>. Then\n<span class=\"math\"> score_f(i) = \\frac{\\bar d_i f_i}{\\sum_{j=k_1}^{k_2}\\bar d_j f_j}</span>. If <span class=\"math\">\\bar d_i \\approx 0</span> then this <span class=\"math\">score_f(i) \\approx 0</span>.</p>\n<p>The easiest architecture is that each pool run its JDS. In this case, the JDS validates each share. In the SRI, the JDS runs a light mempool just for faster recognition of the transactions. If there is some unknown transaction during validating the shares, then it will be asked to the miner through \u201cPovideMissingTransactions\u201d message, as for Sv2 protocol.</p>\n<blockquote>\n<p>For coinbase-only templates the JDS doesn\u2019t know the transactions and can\u2019t verify anything.</p>\n</blockquote>\n<p>I understand that \u201ccoinbase-only templates\u201d is a share with just the coinbase transaction, so it is an \u201cempty weak block\u201d. But then you refer at the transactions, so there is more than one. I do not understand, can you explain?</p>\n<blockquote>\n<p><em>Perhaps a simpler solution</em> is to cap the fees for all slices to whatever fees were in the found block.</p>\n</blockquote>\n<p>This reflects the state of the mempool when the blocks is found. If a share is produced in a moment in which the MMEF (mempool maximum extractible fees) is much less then the fee found in the block, then the share is devalued, even though the miner is very good at maximizing fees. This is not fair IMO.</p>\n<blockquote>\n<p>It\u2019s also unclear how, in the random sample verification protocol, you would distinguish a malicious miner from a malicious pool making such templates for themselves (and \u2018accidentally\u2019 approving them).</p>\n</blockquote>\n<p>I don\u2019t quite understand what you mean. Perhaps is worth pointing out that one of the main concerns is when the pool is also a miner, so there are some incentives for the pool to pay more for the fees it produced. Since a shares are public and those which are not valid can be spotted easily, one possible way the pool can cheat is by reordering shares by putting them in a slice with reference job that a a lower fee. But it is not trivial, because the job of the share must be compatible with the reference job, and fixing it involves timestamps or pointers, but this is outside the scope of the article.</p>",
  "post_number": 42,
  "post_type": 1,
  "updated_at": "2024-12-10T09:32:38.687Z",
  "reply_count": 0,
  "reply_to_post_number": 41,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 5,
  "readers_count": 4,
  "score": 1.0,
  "yours": false,
  "topic_id": 1099,
  "topic_slug": "pplns-with-job-declaration",
  "topic_title": "PPLNS with job declaration",
  "topic_html_title": "PPLNS with job declaration",
  "category_id": 7,
  "display_username": "lorban",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "reply_to_user": {
    "username": "sjors",
    "name": "Sjors Provoost",
    "avatar_template": "/user_avatar/delvingbitcoin.org/sjors/{size}/59_2.png"
  },
  "bookmarked": false,
  "raw": "> This seems worse than block withholding, because such a miner could run a way with ~100% of the block reward with ~0% of the PoW.\n\nIf a miner is providing ~0% of the PoW, then he would get ~0% of blocks subsidy and ~0% of the block fees, because the fee-based score is calculated on top of the difficulty based score. Suppose that a slice contains the shares from ther $k_1$-th to the $k_2$-th. Suppose also that the fee and the difficulty score of the $i$-th share are $f_i$ and $\\bar d_i$. Then\n$ score_f(i) = \\frac{\\bar d_i f_i}{\\sum_{j=k_1}^{k_2}\\bar d_j f_j}$. If $\\bar d_i \\approx 0$ then this $score_f(i) \\approx 0$.\n\nThe easiest architecture is that each pool run its JDS. In this case, the JDS validates each share. In the SRI, the JDS runs a light mempool just for faster recognition of the transactions. If there is some unknown transaction during validating the shares, then it will be asked to the miner through \"PovideMissingTransactions\" message, as for Sv2 protocol.\n\n> For coinbase-only templates the JDS doesn\u2019t know the transactions and can\u2019t verify anything.\n\nI understand that \"coinbase-only templates\" is a share with just the coinbase transaction, so it is an \"empty weak block\". But then you refer at the transactions, so there is more than one. I do not understand, can you explain?\n\n> *Perhaps a simpler solution* is to cap the fees for all slices to whatever fees were in the found block.\n\nThis reflects the state of the mempool when the blocks is found. If a share is produced in a moment in which the MMEF (mempool maximum extractible fees) is much less then the fee found in the block, then the share is devalued, even though the miner is very good at maximizing fees. This is not fair IMO.\n\n> It\u2019s also unclear how, in the random sample verification protocol, you would distinguish a malicious miner from a malicious pool making such templates for themselves (and \u2018accidentally\u2019 approving them).\n\nI don't quite understand what you mean. Perhaps is worth pointing out that one of the main concerns is when the pool is also a miner, so there are some incentives for the pool to pay more for the fees it produced. Since a shares are public and those which are not valid can be spotted easily, one possible way the pool can cheat is by reordering shares by putting them in a slice with reference job that a a lower fee. But it is not trivial, because the job of the share must be compatible with the reference job, and fixing it involves timestamps or pointers, but this is outside the scope of the article.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 527,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}