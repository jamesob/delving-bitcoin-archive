{
  "id": 702,
  "name": "Murch",
  "username": "murch",
  "avatar_template": "/user_avatar/delvingbitcoin.org/murch/{size}/139_2.png",
  "created_at": "2023-12-10T15:22:28.041Z",
  "cooked": "<aside class=\"quote no-group quote-modified\" data-username=\"sipa\" data-post=\"1\" data-topic=\"202\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/sipa/48/102_2.png\" class=\"avatar\"> sipa:</div>\n<blockquote>\n<p><em><strong>Definition</strong></em>. A <strong>chunking</strong> C = (c_1, c_2, \\ldots, c_n)C=(c1,c2,\u2026,cn)C = (c_1, c_2, \\ldots, c_n) for a given graph <em>G</em> is a list of sets of transactions (called <strong>chunks</strong>) of <em>G</em> such that:</p>\n<ul>\n<li>The chunks c_icic_i form a partition of <em>G</em> (no overlap, and their union contains all elements).</li>\n<li>Every prefix of chunks is topological (\\cup_{i=1}^{k} c_i\u222aki=1ci\\cup_{i=1}^{k} c_i for k=1 \\ldots nk=1\u2026nk=1 \\ldots n are topological subsets of GGG). Thus, a transaction\u2019s parent can appear in the same chunk as the transaction itself or in an earlier chunk, but not in a later chunk.</li>\n<li>The feerates of the sets are monotonically decreasing. Thus, the consecutive prefices of chunks form the highest, second-highest, \u2026 feerate topological prefices.</li>\n</ul>\n</blockquote>\n</aside>\n<p>I assume you are defining it on a graph so that you can have a chunking across multiple clusters, but\nit seems to me that this definition would only require that the topology is valid at the chunk borders and would not require the transactions to be topological <em>within the chunks</em>. I think it would be correct if you said \u201cevery prefix of the chunking is topological\u201d instead of \u201cevery prefix of chunks is topological\u201d.</p>\n<aside class=\"quote no-group quote-modified\" data-username=\"sipa\" data-post=\"1\" data-topic=\"202\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/sipa/48/102_2.png\" class=\"avatar\"> sipa:</div>\n<blockquote>\n<p><em><strong>Theorem</strong></em>. The <strong>corresponding chunking is a valid chunking, and is <a href=\"https://en.wikipedia.org/wiki/Uniqueness_theorem\">unique</a></strong>. The same chunking is obtained regardless of what order of merge operations is used. Thus, we can talk about <em>the</em> corresponding chunking \\operatorname{chunks}(L)chunks(L)\\operatorname{chunks}(L) of a linearization LLL. [no proof yet]</p>\n</blockquote>\n</aside>\n<aside class=\"quote no-group\" data-username=\"sipa\" data-post=\"1\" data-topic=\"202\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/sipa/48/102_2.png\" class=\"avatar\"> sipa:</div>\n<blockquote>\n<p>For other values it linearly interpolates between those points.</p>\n</blockquote>\n</aside>\n<p>Would it perhaps be sufficient that a feerate diagram has exactly one \u201cconvex hull\u201d for a geometric proof? E.g. if we draw all transactions separately in the feerate diagram instead of their chunks, could we use the approach you use in the <em>gathering theorem</em> to show that all possible subgroupings will always be below the convex hull?</p>\n<aside class=\"quote no-group\" data-username=\"sipa\" data-post=\"1\" data-topic=\"202\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/sipa/48/102_2.png\" class=\"avatar\"> sipa:</div>\n<blockquote>\n<p><em><strong>Theorem</strong></em>. The <strong>chunk reordering theorem</strong>: reordering a linearization with changes restricted to a single chunk results leaves it at least as good.</p>\n</blockquote>\n</aside>\n<p>Should this perhaps be restricted to topologically valid reorderings?</p>\n<aside class=\"quote no-group quote-modified\" data-username=\"sipa\" data-post=\"1\" data-topic=\"202\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/sipa/48/102_2.png\" class=\"avatar\"> sipa:</div>\n<blockquote>\n<p>Let e_j = c_j \\cap Sej=cj\u2229Se_j = c_j \\cap S for j=1 \\ldots nj=1\u2026nj=1 \\ldots n, the SSS transactions in chunk iii of LLL. Note that this is distinct from d_jdjd_j because e_jeje_j follows the chunk boundaries of LLL, while d_jdjd_j follows the boundaries of L[S]L[S]L[S].</p>\n</blockquote>\n</aside>\n<p>This should be \u201cin chunk <em>j</em> of <em>L</em>\u201d.</p>\n<aside class=\"quote no-group quote-modified\" data-username=\"sipa\" data-post=\"1\" data-topic=\"202\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/sipa/48/102_2.png\" class=\"avatar\"> sipa:</div>\n<blockquote>\n<p>Let \\zeta_j = \\cup_{i=j+1}^{n} e_i\u03b6j=\u222ani=j+1ei\\zeta_j = \\cup_{i=j+1}^{n} e_i for j = 1 \\ldots nj=1\u2026nj = 1 \\ldots n, the SSS transactions <em>after</em> the first jjj chunks of LLL.</p>\n</blockquote>\n</aside>\n<p>Maybe \u201call remaining transactions of <em>S</em> <em>after</em> the first <em>j</em> chunks of <em>L</em>\u201d would be clearer.</p>\n<aside class=\"quote no-group quote-modified\" data-username=\"sipa\" data-post=\"1\" data-topic=\"202\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/sipa/48/102_2.png\" class=\"avatar\"> sipa:</div>\n<blockquote>\n<p>Let SSS be the highest-feerate subset of GGG. If there are multiple, choose an arbitrary but consistent to order them.</p>\n</blockquote>\n</aside>\n<p>\u201cchoose an arbitrary but consistent <strong>way/approach/method/criteria/something</strong> to order them\u201d?</p>\n<aside class=\"quote no-group\" data-username=\"sipa\" data-post=\"1\" data-topic=\"202\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/sipa/48/102_2.png\" class=\"avatar\"> sipa:</div>\n<blockquote>\n<p><em><strong>Theorem</strong></em>. <strong>In an optimal linearization/chunking, the corresponding chunks have connected components whose feerate is all the same</strong>. This is trivially true if the chunks are all connected. <em><strong>Proof</strong></em> If not, the chunks could be split in two, which would improve the diagram.</p>\n</blockquote>\n</aside>\n<p>Linebreak missing before the Proof.</p>\n<p>I find that phrasing a bit confusing. What do you mean with \u201chave connected components whose feerate is all the same\u201d? I assume you are referring to the optimal linearization consisting only of chunks that cannot be split further by reordering, i.e. that any valid reordering would not lead to a different chunking, but the \u201chave connected components whose feerate is all the same\u201d makes me think that you are postulating that there are two chunks with the same feerate.</p>",
  "post_number": 2,
  "post_type": 1,
  "updated_at": "2023-12-10T15:26:45.964Z",
  "reply_count": 1,
  "reply_to_post_number": null,
  "quote_count": 1,
  "incoming_link_count": 0,
  "reads": 4,
  "readers_count": 3,
  "score": 5.8,
  "yours": false,
  "topic_id": 202,
  "topic_slug": "cluster-mempool-definitions-theory",
  "topic_title": "Cluster mempool definitions & theory",
  "topic_html_title": "Cluster mempool definitions &amp; theory",
  "category_id": 9,
  "display_username": "Murch",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": "",
  "bookmarked": false,
  "raw": "[quote=\"sipa, post:1, topic:202\"]\n***Definition***. A **chunking** C = (c_1, c_2, \\ldots, c_n)C=(c1,c2,\u2026,cn)C = (c_1, c_2, \\ldots, c_n) for a given graph *G* is a list of sets of transactions (called **chunks**) of *G* such that:\n\n* The chunks c_icic_i form a partition of *G* (no overlap, and their union contains all elements).\n* Every prefix of chunks is topological (\\cup_{i=1}^{k} c_i\u222aki=1ci\\cup_{i=1}^{k} c_i for k=1 \\ldots nk=1\u2026nk=1 \\ldots n are topological subsets of GGG). Thus, a transaction\u2019s parent can appear in the same chunk as the transaction itself or in an earlier chunk, but not in a later chunk.\n* The feerates of the sets are monotonically decreasing. Thus, the consecutive prefices of chunks form the highest, second-highest, \u2026 feerate topological prefices.\n[/quote]\n\n I assume you are defining it on a graph so that you can have a chunking across multiple clusters, but \nit seems to me that this definition would only require that the topology is valid at the chunk borders and would not require the transactions to be topological _within the chunks_. I think it would be correct if you said \"every prefix of the chunking is topological\" instead of \"every prefix of chunks is topological\".\n\n[quote=\"sipa, post:1, topic:202\"]\n***Theorem***. The **corresponding chunking is a valid chunking, and is [unique](https://en.wikipedia.org/wiki/Uniqueness_theorem)**. The same chunking is obtained regardless of what order of merge operations is used. Thus, we can talk about *the* corresponding chunking \\operatorname{chunks}(L)chunks(L)\\operatorname{chunks}(L) of a linearization LLL. [no proof yet]\n[/quote]\n\n[quote=\"sipa, post:1, topic:202\"]\nFor other values it linearly interpolates between those points.\n[/quote]\n\nWould it perhaps be sufficient that a feerate diagram has exactly one \"convex hull\" for a geometric proof? E.g. if we draw all transactions separately in the feerate diagram instead of their chunks, could we use the approach you use in the _gathering theorem_ to show that all possible subgroupings will always be below the convex hull?\n\n[quote=\"sipa, post:1, topic:202\"]\n***Theorem***. The **chunk reordering theorem**: reordering a linearization with changes restricted to a single chunk results leaves it at least as good.\n[/quote]\n\nShould this perhaps be restricted to topologically valid reorderings?\n\n[quote=\"sipa, post:1, topic:202\"]\nLet e_j = c_j \\cap Sej=cj\u2229Se_j = c_j \\cap S for j=1 \\ldots nj=1\u2026nj=1 \\ldots n, the SSS transactions in chunk iii of LLL. Note that this is distinct from d_jdjd_j because e_jeje_j follows the chunk boundaries of LLL, while d_jdjd_j follows the boundaries of L[S]L[S]L[S].\n[/quote]\n\nThis should be \"in chunk _j_ of _L_\".\n\n[quote=\"sipa, post:1, topic:202\"]\nLet \\zeta_j = \\cup_{i=j+1}^{n} e_i\u03b6j=\u222ani=j+1ei\\zeta_j = \\cup_{i=j+1}^{n} e_i for j = 1 \\ldots nj=1\u2026nj = 1 \\ldots n, the SSS transactions *after* the first jjj chunks of LLL.\n[/quote]\n\nMaybe \"all remaining transactions of _S_ *after* the first _j_ chunks of _L_\" would be clearer.\n\n[quote=\"sipa, post:1, topic:202\"]\nLet SSS be the highest-feerate subset of GGG. If there are multiple, choose an arbitrary but consistent to order them.\n[/quote]\n\n\"choose an arbitrary but consistent **way/approach/method/criteria/something** to order them\"?\n\n[quote=\"sipa, post:1, topic:202\"]\n***Theorem***. **In an optimal linearization/chunking, the corresponding chunks have connected components whose feerate is all the same**. This is trivially true if the chunks are all connected. ***Proof*** If not, the chunks could be split in two, which would improve the diagram.\n[/quote]\n\nLinebreak missing before the Proof.\n\nI find that phrasing a bit confusing. What do you mean with \"have connected components whose feerate is all the same\"? I assume you are referring to the optimal linearization consisting only of chunks that cannot be split further by reordering, i.e. that any valid reordering would not lead to a different chunking, but the \"have connected components whose feerate is all the same\" makes me think that you are postulating that there are two chunks with the same feerate.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 58,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}