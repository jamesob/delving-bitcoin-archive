{
  "id": 672,
  "name": "Rusty Russell",
  "username": "rustyrussell",
  "avatar_template": "/user_avatar/delvingbitcoin.org/rustyrussell/{size}/154_2.png",
  "created_at": "2023-12-06T20:01:08.859Z",
  "cooked": "<p>This is, in fact, what gossip_timestamp_filter does:</p>\n<pre><code class=\"lang-auto\">1. type: 265 (`gossip_timestamp_filter`) (`gossip_queries`)\n2. data:\n    * [`chain_hash`:`chain_hash`]\n    * [`u32`:`first_timestamp`]\n    * [`u32`:`timestamp_range`]\n</code></pre>\n<p>The \u201ctimestamp\u201d for channel_announcement is defined as \" the <code>timestamp</code> of a corresponding <code>channel_update</code>.\" (rather than \u201call corresponding channel_update\u201d which is what you specified).</p>\n<p>It turns out, however, that everyone uses \u201cnone\u201d, \u201call\u201d or \u201crecent\u201d, where recent is 10 minutes ago (CLN), now (LND and Eclair), 1 hour ago (LDK).  To avoid scanning the entire gossip_store (or keeping more metadata), we now keep a single \u201cfirst record with timestamp &gt; 2 hours ago\u201d offset and scan from there, unless they set first_update to 0.  This basically turns the field into a trinary.</p>\n<p>But this is <em>still</em> not what a single-peer-gossiper wants!  The timestamp of the record is a very rough guide to \u201chave you seen this before\u201d.  A better guide is when the <em>peer</em> received the gossip: presumably it started streaming it within 60 seconds.  It\u2019s also much easier for us to implement: for speed we can keep the received timestamps at every ~1MB of gossip store, since they will be monotonic.</p>",
  "post_number": 5,
  "post_type": 1,
  "updated_at": "2023-12-06T20:01:08.859Z",
  "reply_count": 0,
  "reply_to_post_number": 4,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 4,
  "readers_count": 3,
  "score": 0.8,
  "yours": false,
  "topic_id": 251,
  "topic_slug": "quick-peer-gossip-catchup-protocol",
  "topic_title": "Quick peer gossip catchup protocol",
  "topic_html_title": "Quick peer gossip catchup protocol",
  "category_id": 7,
  "display_username": "Rusty Russell",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "reply_to_user": {
    "username": "cdecker",
    "name": "Christian Decker",
    "avatar_template": "/user_avatar/delvingbitcoin.org/cdecker/{size}/99_2.png"
  },
  "bookmarked": false,
  "raw": "This is, in fact, what gossip_timestamp_filter does:\n\n```\n1. type: 265 (`gossip_timestamp_filter`) (`gossip_queries`)\n2. data:\n    * [`chain_hash`:`chain_hash`]\n    * [`u32`:`first_timestamp`]\n    * [`u32`:`timestamp_range`]\n```\n\nThe \"timestamp\" for channel_announcement is defined as \" the `timestamp` of a corresponding `channel_update`.\" (rather than \"all corresponding channel_update\" which is what you specified).\n\nIt turns out, however, that everyone uses \"none\", \"all\" or \"recent\", where recent is 10 minutes ago (CLN), now (LND and Eclair), 1 hour ago (LDK).  To avoid scanning the entire gossip_store (or keeping more metadata), we now keep a single \"first record with timestamp > 2 hours ago\" offset and scan from there, unless they set first_update to 0.  This basically turns the field into a trinary.\n\nBut this is *still* not what a single-peer-gossiper wants!  The timestamp of the record is a very rough guide to \"have you seen this before\".  A better guide is when the *peer* received the gossip: presumably it started streaming it within 60 seconds.  It's also much easier for us to implement: for speed we can keep the received timestamps at every ~1MB of gossip store, since they will be monotonic.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 137,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}