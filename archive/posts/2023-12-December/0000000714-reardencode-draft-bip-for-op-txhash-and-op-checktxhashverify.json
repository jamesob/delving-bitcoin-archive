{
  "id": 714,
  "name": "Brandon Black",
  "username": "reardencode",
  "avatar_template": "/user_avatar/delvingbitcoin.org/reardencode/{size}/27_2.png",
  "created_at": "2023-12-11T21:58:40.254Z",
  "cooked": "<p>Copying some bits of our chat on Telegram to this more accessible place:</p>\n<h3><a name=\"does-non-verify-txhash-make-sense-without-csfs-or-cat-too-1\" class=\"anchor\" href=\"#does-non-verify-txhash-make-sense-without-csfs-or-cat-too-1\"></a>Does non-verify TXHASH make sense without CSFS or CAT too?</h3>\n<p>Yes, it can be used to validate equality between specific fields of the transaction (e.g. two input amounts are equal, or input and output scriptpubkey are equal).</p>\n<p>Also, CSFS (obviously?) composes beautifully with TXHASH, and CAT plus TXHASH opens up an extremely broad design space.</p>\n<h3><a name=\"why-are-input-values-in-txfs_special_template-not-in-ctv-2\" class=\"anchor\" href=\"#why-are-input-values-in-txfs_special_template-not-in-ctv-2\"></a>Why are input values in <code>TXFS_SPECIAL_TEMPLATE</code> (not in CTV)?</h3>\n<p>With CTV, the lack of input values allows protocol designers to awkwardly add fees via a specifically sized UTXO at spend time. With TXHASH, a more customized TxFieldSelector can be chosen to enable adding fees.</p>\n<p>Including the values in this template mode helps remove the footgun of a specific hash being only usable with a specific UTXO size, and more clearly sets this template mode to hash everything possible that doesn\u2019t lead to a hash cycle.</p>\n<h3><a name=\"on-the-difference-between-adding-csfs-and-adding-apo-style-keys-3\" class=\"anchor\" href=\"#on-the-difference-between-adding-csfs-and-adding-apo-style-keys-3\"></a>On the difference between adding CSFS and adding APO-style keys</h3>\n<p>There really isn\u2019t much difference. APO keys end up being 1-byte larger than taproot x-only keys, which is the same as the 1 extra opcode for TXHASH+CSFS. One benefit of APO-style keys is they would work with CHECKSIGADD as well.</p>\n<p>In either case, we should consider whether adding \u201cmagic\u201d keys for the Taproot internal key and/or external key makes sense (APO proposes &lt;1&gt; to represent the internal key); or whether opcodes to put those keys on the stack makes more sense (i.e. <code>OP_INTERNAL_KEY</code> and/or <code>OP_EXTERNAL_KEY</code>).</p>\n<p><strong>edit</strong>: Thinking more about this:</p>\n<p><code>OP_TXHASH</code> + <code>OP_CHECKSIGFROMSTACK</code> does open up some interesting possibilities in scripts compared to adding APO-style keys.</p>\n<p>For example, a script requiring signatures from 2 keys on the same hash:</p>\n<pre><code class=\"lang-auto\">&lt;sig&gt; &lt;sig&gt; &lt;txfieldselector&gt;\nOP_TXHASH OP_TUCK &lt;pubkey&gt; OP_CSFSV &lt;pubkey&gt; OP_CSFS\n</code></pre>\n<p>Also, I think OP_CHECKSIGADD can be emulated without undue pain. For 2-of-3, one of these <code>&lt;sig&gt; &lt;txfieldselector&gt;</code> pairs should be a pair of empties:</p>\n<pre><code class=\"lang-auto\">&lt;sig&gt; &lt;txfieldselector&gt; &lt;sig&gt; &lt;txfieldselector&gt; &lt;sig&gt; &lt;txfieldselector&gt;\nOP_TXHASH &lt;pubkey&gt; OP_CSFS OP_TOALTSTACK OP_TXHASH &lt;pubkey&gt; OP_CSFS OP_FROMALTSTACK OP_ADD OP_TOALTSTACK &lt;pubkey&gt; OP_CSFS OP_FROMALTSTACK OP_ADD 2 OP_EQUAL\n</code></pre>\n<p>This is ugly, but only 1 vByte more than <code>OP_CHECKSIGADD</code> per key.</p>\n<h2><a name=\"additional-comments-4\" class=\"anchor\" href=\"#additional-comments-4\"></a>Additional comments</h2>\n<ul>\n<li>It seems like it might be worthwhile to pick a default mode for <code>TXFS_INPUTS</code> and <code>TXFS_OUTPUTS</code> (<code>TXFS_INOUT_NUMBER|TXFS_INOUT_SELECTION_ALL</code>?) where bytes 3 and 4 are not required. This makes the logic a tiny bit fiddly: if both inputs and outputs are selected either both or neither can use the default mode.</li>\n<li>It might be worth adding to the BIP some discussion of why committing to the control block is chosen over committing to the tapleaf_hash. At first I thought we might need both, but upon reflection the control block commitment implicitly commits to the leaf hash via BIP341\u2019s script validation rules.</li>\n</ul>\n<p><strong>edit</strong>: Hmm, I think that if this TxFieldSelector mechanism is to be potentially useful in a future introspection opcode, it\u2019ll need some way to select the current input\u2019s script code. Could repurpose <code>TXFS_CONTROL</code>, but might be worth adding discussion of this to the BIP.</p>",
  "post_number": 12,
  "post_type": 1,
  "updated_at": "2023-12-12T05:26:10.583Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 62,
  "reads": 11,
  "readers_count": 10,
  "score": 312.2,
  "yours": false,
  "topic_id": 121,
  "topic_slug": "draft-bip-for-op-txhash-and-op-checktxhashverify",
  "topic_title": "Draft BIP for OP_TXHASH and OP_CHECKTXHASHVERIFY",
  "topic_html_title": "Draft BIP for OP_TXHASH and OP_CHECKTXHASHVERIFY",
  "category_id": 7,
  "display_username": "Brandon Black",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 4,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Copying some bits of our chat on Telegram to this more accessible place:\n\n### Does non-verify TXHASH make sense without CSFS or CAT too?\n\nYes, it can be used to validate equality between specific fields of the transaction (e.g. two input amounts are equal, or input and output scriptpubkey are equal).\n\nAlso, CSFS (obviously?) composes beautifully with TXHASH, and CAT plus TXHASH opens up an extremely broad design space.\n\n### Why are input values in `TXFS_SPECIAL_TEMPLATE` (not in CTV)?\n\nWith CTV, the lack of input values allows protocol designers to awkwardly add fees via a specifically sized UTXO at spend time. With TXHASH, a more customized TxFieldSelector can be chosen to enable adding fees.\n\nIncluding the values in this template mode helps remove the footgun of a specific hash being only usable with a specific UTXO size, and more clearly sets this template mode to hash everything possible that doesn't lead to a hash cycle.\n\n### On the difference between adding CSFS and adding APO-style keys\n\nThere really isn't much difference. APO keys end up being 1-byte larger than taproot x-only keys, which is the same as the 1 extra opcode for TXHASH+CSFS. One benefit of APO-style keys is they would work with CHECKSIGADD as well.\n\nIn either case, we should consider whether adding \"magic\" keys for the Taproot internal key and/or external key makes sense (APO proposes <1> to represent the internal key); or whether opcodes to put those keys on the stack makes more sense (i.e. `OP_INTERNAL_KEY` and/or `OP_EXTERNAL_KEY`).\n\n**edit**: Thinking more about this:\n\n`OP_TXHASH` + `OP_CHECKSIGFROMSTACK` does open up some interesting possibilities in scripts compared to adding APO-style keys.\n\nFor example, a script requiring signatures from 2 keys on the same hash:\n\n```\n<sig> <sig> <txfieldselector>\nOP_TXHASH OP_TUCK <pubkey> OP_CSFSV <pubkey> OP_CSFS\n```\n\nAlso, I think OP_CHECKSIGADD can be emulated without undue pain. For 2-of-3, one of these `<sig> <txfieldselector>` pairs should be a pair of empties:\n```\n<sig> <txfieldselector> <sig> <txfieldselector> <sig> <txfieldselector>\nOP_TXHASH <pubkey> OP_CSFS OP_TOALTSTACK OP_TXHASH <pubkey> OP_CSFS OP_FROMALTSTACK OP_ADD OP_TOALTSTACK <pubkey> OP_CSFS OP_FROMALTSTACK OP_ADD 2 OP_EQUAL\n```\nThis is ugly, but only 1 vByte more than `OP_CHECKSIGADD` per key.\n\n## Additional comments\n\n* It seems like it might be worthwhile to pick a default mode for `TXFS_INPUTS` and `TXFS_OUTPUTS` (`TXFS_INOUT_NUMBER|TXFS_INOUT_SELECTION_ALL`?) where bytes 3 and 4 are not required. This makes the logic a tiny bit fiddly: if both inputs and outputs are selected either both or neither can use the default mode.\n* It might be worth adding to the BIP some discussion of why committing to the control block is chosen over committing to the tapleaf_hash. At first I thought we might need both, but upon reflection the control block commitment implicitly commits to the leaf hash via BIP341\u2019s script validation rules.\n\n**edit**: Hmm, I think that if this TxFieldSelector mechanism is to be potentially useful in a future introspection opcode, it'll need some way to select the current input's script code. Could repurpose `TXFS_CONTROL`, but might be worth adding discussion of this to the BIP.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 30,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}