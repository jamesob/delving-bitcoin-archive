{
  "id": 707,
  "name": "Anthony Towns",
  "username": "ajtowns",
  "avatar_template": "/user_avatar/delvingbitcoin.org/ajtowns/{size}/3_2.png",
  "created_at": "2023-12-11T01:16:32.565Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"sipa\" data-post=\"5\" data-topic=\"202\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/sipa/48/102_2.png\" class=\"avatar\"> sipa:</div>\n<blockquote>\n<p>I don\u2019t think there is an objective reason to want the smallest ones first.</p>\n</blockquote>\n</aside>\n<p>Oh, actually, I think you want the smallest ones last, if anything? (Or is my guess for getting mildly better performance out of greedy knapsack selection off the mark?)</p>\n<p>Is this about optimising for the last few transactions in a block, or choosing a canonical ordering so there\u2019s less uncertainty/ambiguity, or something else?</p>\n<p>You can\u2019t get a strictly unique \u201cperfect\u201d linearisation, since if you have txs A, B, C, C spending A and B, and A,B having equal fee and size, but lower feerate than C, then [ABC] and [BAC] are equally good linearisations. You could break the tie by resorting to your arbitrary order <span class=\"math\">R_2</span>, of course, but that\u2019s still picking a winner arbitrarily\u2026</p>\n<p>Your definition of <span class=\"math\">opt</span> seems weird? Shouldn\u2019t that just be <span class=\"math\">\\operatorname{opt}(G) = L_G + \\operatorname{opt}(G \\setminus S_G)</span> where <span class=\"math\">S_G</span> is the highest-feerate subset of <span class=\"math\">G</span> and <span class=\"math\">L_G</span> is the first valid linearisation of <span class=\"math\">S_G</span>?</p>\n<p>I would have proven the uniqueness claim non-constructively: set  <span class=\"math\">f(L) = |\\{L_2 | L \\ge L2\\}|</span>. Pick a linearisation <span class=\"math\">L_x</span> where <span class=\"math\">f(L_x) \\ge f(L)</span> for all <span class=\"math\">L</span>. If this value equals the count of all linearisations, then <span class=\"math\">L_x \\ge L</span> for all <span class=\"math\">L</span>, so <span class=\"math\">L_x</span> is an optimal linearisation. If it\u2019s not the case, then there is some <span class=\"math\">L_y</span> where <span class=\"math\">L_x \\not\\ge L_y</span>, so calculate <span class=\"math\">L_z = \\operatorname{merge}(L_x, L_y)</span> which gives us <span class=\"math\">L_z \\ge L_x</span> but also <span class=\"math\">L_z \\ge L_y</span>. But for any <span class=\"math\">L</span> where <span class=\"math\">L_x \\ge L</span>, <span class=\"math\">L_z \\ge L</span> by transitivity,  so <span class=\"math\">f(L_z) \\gt f(L_x)</span> which contradicts our choice of <span class=\"math\">L_x</span>.</p>",
  "post_number": 6,
  "post_type": 1,
  "updated_at": "2023-12-11T01:16:32.565Z",
  "reply_count": 1,
  "reply_to_post_number": 5,
  "quote_count": 1,
  "incoming_link_count": 0,
  "reads": 9,
  "readers_count": 8,
  "score": 6.8,
  "yours": false,
  "topic_id": 202,
  "topic_slug": "cluster-mempool-definitions-theory",
  "topic_title": "Cluster mempool definitions & theory",
  "topic_html_title": "Cluster mempool definitions &amp; theory",
  "category_id": 9,
  "display_username": "Anthony Towns",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"sipa, post:5, topic:202\"]\nI don\u2019t think there is an objective reason to want the smallest ones first.\n[/quote]\n\nOh, actually, I think you want the smallest ones last, if anything? (Or is my guess for getting mildly better performance out of greedy knapsack selection off the mark?)\n\nIs this about optimising for the last few transactions in a block, or choosing a canonical ordering so there's less uncertainty/ambiguity, or something else?\n\nYou can't get a strictly unique \"perfect\" linearisation, since if you have txs A, B, C, C spending A and B, and A,B having equal fee and size, but lower feerate than C, then [ABC] and [BAC] are equally good linearisations. You could break the tie by resorting to your arbitrary order $R_2$, of course, but that's still picking a winner arbitrarily...\n\nYour definition of $opt$ seems weird? Shouldn't that just be $\\operatorname{opt}(G) = L_G + \\operatorname{opt}(G \\setminus S_G)$ where $S_G$ is the highest-feerate subset of $G$ and $L_G$ is the first valid linearisation of $S_G$?\n\nI would have proven the uniqueness claim non-constructively: set  $f(L) = |\\{L_2 | L \\ge L2\\}|$. Pick a linearisation $L_x$ where $f(L_x) \\ge f(L)$ for all $L$. If this value equals the count of all linearisations, then $L_x \\ge L$ for all $L$, so $L_x$ is an optimal linearisation. If it's not the case, then there is some $L_y$ where $L_x \\not\\ge L_y$, so calculate $L_z = \\operatorname{merge}(L_x, L_y)$ which gives us $L_z \\ge L_x$ but also $L_z \\ge L_y$. But for any $L$ where $L_x \\ge L$, $L_z \\ge L$ by transitivity,  so $f(L_z) \\gt f(L_x)$ which contradicts our choice of $L_x$.",
  "actions_summary": [],
  "moderator": true,
  "admin": true,
  "staff": true,
  "user_id": 3,
  "hidden": false,
  "trust_level": 4,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}