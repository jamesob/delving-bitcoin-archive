{
  "id": 839,
  "name": "salvatoshi",
  "username": "salvatoshi",
  "avatar_template": "/user_avatar/delvingbitcoin.org/salvatoshi/{size}/72_2.png",
  "created_at": "2023-12-20T13:21:04.756Z",
  "cooked": "<p>A little postscript to detail how the fraud proofs needed in the protocol might look like, as I had time to brainstorm it a bit more.</p>\n<p>The only fraud-sensitive statement that is more complicated is Ingrid\u2019s statement:</p>\n<p>\u201cI\u2019m withdrawing for users <span class=\"math\">S = \\left\\{s_0, s_1, \\dots, s_{k - 1}\\right\\}</span>, whose total balance is <span class=\"math\">T</span>\u201d, where each <span class=\"math\">s_i</span> is the index of a user within the vector commitment of all the <code>user:balance</code> pairs. That\u2019s because this is a statement about multiple leaves of the Merkle tree simultaneously, as it is a statement about their sum.</p>\n<p>Script itself can compute <span class=\"math\">root_S</span>, the root of the Merkle tree of the vector <span class=\"math\">S</span>, so that this <span class=\"math\">root_S</span> can be passed around in the next UTXOs.</p>\n<p>Using MATT generic fraud proof protocols as a blackbox, we could use a fraud proof on the following computation:</p>\n<div class=\"math\">\n\\sum_{i=1}^k  \\operatorname{balance}(s_i)\n</div>\n<p>This is a computation with <code>k</code> steps, so it would require about <span class=\"math\">2\\log k</span> transactions to resolve.</p>\n<p>However, we can make an ad-hoc fraud proof protocol that requires less rounds:</p>\n<ol>\n<li>Ingrid claims \u201cI\u2019m withdrawing for users <span class=\"math\">S = \\left\\{s_0, s_1, \\dots, s_{k - 1}\\right\\}</span>, whose total balance is <span class=\"math\">T</span>\u201d.</li>\n<li>Anyone who spots that <span class=\"math\">T</span> is wrong challenges Ingrid. \u201cNo, $T is wrong\u201d.</li>\n<li>Ingrid now has to reveal on-chain the individual balances of <span class=\"math\">S</span>: \u201cHere is the list of user:balance in <span class=\"math\">S</span>: <span class=\"math\">[(s_0, b_0), \\dots, (s_k, b_k)]</span>\u201d. The Script is only valid if the provided indices are the same (recomputing <span class=\"math\">root_S</span>, which must match), and the sum of the balances is <span class=\"math\">T</span>. The new <span class=\"math\">root_S'</span> of the user:balance pairs is computed, and it is verified if indeed <span class=\"math\">T = \\sum_{i=0}^k b_i)</span>.</li>\n<li>If Ingrid lied, at least 1 of the balances (say <span class=\"math\">b_t</span> was wrong, and it can be exposed with two Merkle proofs (one to show the balance Ingrid claimed for <span class=\"math\">s_t</span>, and the other to show the real balance of user <span class=\"math\">s_t</span>).</li>\n</ol>\n<p>Therefore, in case Ingrid lies, just 3 transactions are enough to expose the fraud.</p>\n<p>As usual, only (1) is expected to happen in practice, and (2-4) only happens in case of fraud (or claims of fraud). That\u2019s why (1) and (3) are separated; publishing the list of users and balances is significantly more expensive than only the user indices (a few bytes for each user).</p>\n<p>In this version, step (3) would benefit from 64-bit arithmetic (although it is not too hard to simulate it with OP_CAT).</p>\n<hr>\n<p>Note that if the size of <span class=\"math\">S</span> is large (which might make sense in practice, since all the users want to get out anyway), then representing <span class=\"math\">S</span> as an <span class=\"math\">n</span>-bit bitmap is way more efficient for very large <span class=\"math\">S</span>, and the <span class=\"math\">O(\\log n)</span>-size fraud proof protocol is probably much more efficient in terms of bytes (as it does not require to post on-chain all the user balances).</p>\n<p>Of course, multiple version of the protocol might co-exist in different tapleaves.</p>",
  "post_number": 4,
  "post_type": 1,
  "updated_at": "2023-12-20T13:25:42.864Z",
  "reply_count": 0,
  "reply_to_post_number": 3,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 6,
  "readers_count": 5,
  "score": 1.2,
  "yours": false,
  "topic_id": 297,
  "topic_slug": "aggregate-delegated-exit-for-l2-pools",
  "topic_title": "Aggregate delegated exit for L2 pools",
  "topic_html_title": "Aggregate delegated exit for L2 pools",
  "category_id": 7,
  "display_username": "salvatoshi",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "reply_to_user": {
    "username": "salvatoshi",
    "name": "salvatoshi",
    "avatar_template": "/user_avatar/delvingbitcoin.org/salvatoshi/{size}/72_2.png"
  },
  "bookmarked": false,
  "raw": "A little postscript to detail how the fraud proofs needed in the protocol might look like, as I had time to brainstorm it a bit more.\n\nThe only fraud-sensitive statement that is more complicated is Ingrid's statement:\n\n\"I'm withdrawing for users $S = \\left\\{s_0, s_1, \\dots, s_{k - 1}\\right\\}$, whose total balance is $T$\", where each $s_i$ is the index of a user within the vector commitment of all the `user:balance` pairs. That's because this is a statement about multiple leaves of the Merkle tree simultaneously, as it is a statement about their sum.\n\nScript itself can compute $root_S$, the root of the Merkle tree of the vector $S$, so that this $root_S$ can be passed around in the next UTXOs.\n\nUsing MATT generic fraud proof protocols as a blackbox, we could use a fraud proof on the following computation:\n\n$$\n\\sum_{i=1}^k  \\operatorname{balance}(s_i)\n$$\n\nThis is a computation with `k` steps, so it would require about $2\\log k$ transactions to resolve.\n\nHowever, we can make an ad-hoc fraud proof protocol that requires less rounds:\n\n1) Ingrid claims \"I'm withdrawing for users $S = \\left\\{s_0, s_1, \\dots, s_{k - 1}\\right\\}$, whose total balance is $T$\".\n2) Anyone who spots that $T$ is wrong challenges Ingrid. \"No, $T is wrong\".\n3) Ingrid now has to reveal on-chain the individual balances of $S$: \"Here is the list of user:balance in $S$: $[(s_0, b_0), \\dots, (s_k, b_k)]$\". The Script is only valid if the provided indices are the same (recomputing $root_S$, which must match), and the sum of the balances is $T$. The new $root_S'$ of the user:balance pairs is computed, and it is verified if indeed $T = \\sum_{i=0}^k b_i)$.\n4) If Ingrid lied, at least 1 of the balances (say $b_t$ was wrong, and it can be exposed with two Merkle proofs (one to show the balance Ingrid claimed for $s_t$, and the other to show the real balance of user $s_t$).\n\nTherefore, in case Ingrid lies, just 3 transactions are enough to expose the fraud.\n\nAs usual, only (1) is expected to happen in practice, and (2-4) only happens in case of fraud (or claims of fraud). That's why (1) and (3) are separated; publishing the list of users and balances is significantly more expensive than only the user indices (a few bytes for each user).\n\nIn this version, step (3) would benefit from 64-bit arithmetic (although it is not too hard to simulate it with OP_CAT).\n\n---\n\nNote that if the size of $S$ is large (which might make sense in practice, since all the users want to get out anyway), then representing $S$ as an $n$-bit bitmap is way more efficient for very large $S$, and the $O(\\log n)$-size fraud proof protocol is probably much more efficient in terms of bytes (as it does not require to post on-chain all the user balances).\n\nOf course, multiple version of the protocol might co-exist in different tapleaves.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 81,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}