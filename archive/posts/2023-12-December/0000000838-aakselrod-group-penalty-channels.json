{
  "id": 838,
  "name": "Alex Akselrod",
  "username": "aakselrod",
  "avatar_template": "/user_avatar/delvingbitcoin.org/aakselrod/{size}/57_2.png",
  "created_at": "2023-12-20T05:29:17.014Z",
  "cooked": "<h1><a name=\"group-penalty-channels-1\" class=\"anchor\" href=\"#group-penalty-channels-1\"></a>Group Penalty Channels</h1>\n<p>With few <a href=\"https://delvingbitcoin.org/t/aggregate-delegated-exit-for-l2-pools/297\">exceptions</a>, <a href=\"https://nakamotoinstitute.org/static/docs/scalable-funding-of-bitcoin-micropayment-channel-networks.pdf\" rel=\"noopener nofollow ugc\">proposed</a> <a href=\"https://blockstream.com/eltoo.pdf\" rel=\"noopener nofollow ugc\">multi</a>-<a href=\"https://github.com/JohnLaw2/ln-factory-optimized\" rel=\"noopener nofollow ugc\">party</a> <a href=\"https://www.arkpill.me/deep-dive\" rel=\"noopener nofollow ugc\">channel</a> <a href=\"https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-August/021897.html\" rel=\"noopener nofollow ugc\">structures</a> all assume a requirement for unilateral, non-interactive, individual exit to layer 1, which is most of what takes up block space. <a href=\"https://en.bitcoin.it/wiki/Payment_channels\" rel=\"noopener nofollow ugc\">Payment channels</a> have been designed this way from the beginning. I have some ideas in the design space where this is not a requirement, including unions, co-ops, family budgets, or any other group or event where the money belongs to the organization and not individual members.</p>\n<p>I\u2019m interested in designing a structure where group members would know and trust each other enough to work together, preventing Sybil attacks from anonymous/pseudonymous participants. Budget decisions should be made together, democratically, delegating smaller budgets to subgroups. Subgroups can be groups of stakeholders with differing priorities such as customers, co-owners, or workers organized by department. Liquidity providers can help cross trust boundaries with other groups or channel types. Spending policies can be mutually enforced by group members using <a href=\"https://eprint.iacr.org/2020/852\" rel=\"noopener nofollow ugc\">threshold</a> <a href=\"https://eprint.iacr.org/2022/550\" rel=\"noopener nofollow ugc\">signatures</a>. Thresholds should be configured to minimize delegation of trust, and place more trust in the larger group than smaller subgroups.</p>\n<p>The current design below takes advantage of off-chain pre-signed transactions as a substitute for covenants, but could potentially be more efficient with on-chain covenants. In addition, covenants would still be useful for nesting channels based on individual exit within group penalty channels.</p>\n<p>Thanks to Jennifer Akselrod, Carl Dong, Tadge Dryja, Brian Groll, Johan Halseth, Jonathan Harvey-Buschel, Joost Jager, Jordi Montes, and James O\u2019Beirne for review and discussion of the ideas here.</p>\n<h2><a name=\"on-chain-time-decay-threshold-tdt-output-2\" class=\"anchor\" href=\"#on-chain-time-decay-threshold-tdt-output-2\"></a>On-chain Time-Decay Threshold (TDT) output</h2>\n<p>The first building block for group penalty channels is the TDT output. When a transaction containing such an output is confirmed, the resulting UTXO starts a timer to agree on funds distribution. The output is a P2TR with the internal key being the maximum required threshold (not necessarily 100%) for full consensus for an immediate spend of the output. Each tapleaf is another redemption option: the longer the CSV delay, the lower the threshold to spend. Disaster recovery tapleaves can have threshold options lower than 50%, but a very long CSV delay.</p>\n<pre data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">---\ntitle: Example On-chain Time Decay Threshold (TDT) Output PkScript\n---\ngraph BT\nsubgraph PkScript\ndirection LR\nOutRoot(OP_1)\nQ(\"\ud83d\udd12Q\")\nend\nsubgraph Key\ndirection LR\nNofN(\"\ud83d\udd12mConsensus/n\")\nplus{+}\nT(\"\ud83d\udd00T\")\nend\nKey--&gt;Q\nGenMult{* G}--&gt;T\nsubgraph TapTweak[\"#\ufe0f\u20e3TapTweak\"]\ndirection LR\ntaggedHash1(\"TaggedHash(\")\ntapTweakStr1(\"#quot;TapTweak#quot;,\")\nNofN2(\"\ud83d\udd12mConsensus/n,\")\nscript_root(\"#\ufe0f\u20e3script_root)\")\nend\nTapTweak--&gt;GenMult\nsubgraph TapTree[\"Time Decay Threshold (TDT) TapTree\"]\ntlDisaster(\"\ud83c\udf41tlDisaster\")--&gt;script_root\nDisaster--&gt;tlDisaster\nsubgraph Disaster\nmDisaster/n(\"\ud83d\udd12mDisaster/n\")\nOP_CDDS(OP_CHECKSIG)\ndDisaster(\"\u23f2\ufe0fdDisaster\")\nOP_CSVDD(OP_CHECKSEQUENCEVERIFY)\nOP_DDD(OP_DROP)\nend\nend\n</code></pre>\n<p>m<em>Case</em> is the threshold in each case, and d<em>Case</em> is delay. For this example, m<em>Consensus</em> should be <em>floor</em>(50%+1) to ensure a democratic decision, and m<em>Disaster</em> might be 20% and d<em>Disaster</em> a long time period in case a majority of the group is permanently unavailable.</p>\n<h2><a name=\"revocable-off-chain-time-decay-threhold-rtdt-output-3\" class=\"anchor\" href=\"#revocable-off-chain-time-decay-threhold-rtdt-output-3\"></a>Revocable Off-Chain Time Decay Threhold (RTDT) Output</h2>\n<p>The next building block is the single-group RTDT output. Off-chain transactions can contain such outputs for the top-level group or any subgroup. This is, again, a P2TR output. These outputs can be used to nest replaceable transactions, allowing allocation of money between subgroups.</p>\n<p>To commit to a state where the output is valid, the group co-signs a transaction spending the output using the <code>tlCommit</code> script path, redeemable after a CSV revocation delay. Then the group co-signs the transaction containing the output.</p>\n<p>To revoke the current state, the group co-signs a key path spend to a transaction which has a TDT output for the group itself and/or its larger parent group. This creates a \u201cgroup penalty\u201d: the entire balance of the revoked output goes to the group to democratically decide what to do with, should the revoked state be confirmed. The penalty TDT output can be customized, e.g. the larger group\u2019s script leaves may have lower CSV delays than the subgroup\u2019s.</p>\n<pre data-code-height=\"287\" data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">---\ntitle: Example Revocable Off-Chain Time Decay Threshold (RTDT) Output PkScript for Group\n---\ngraph BT\nsubgraph PkScript\ndirection LR\nOutRoot(OP_1)\nQ(\"\ud83d\udd12Q\")\nend\nsubgraph Key\ndirection LR\nNofN(\"\ud83d\udd12mConsensus/n\")\nplus{+}\nT(\"\ud83d\udd00T\")\nend\nKey--&gt;Q\nGenMult{* G}--&gt;T\nsubgraph TapTweak[\"#\ufe0f\u20e3TapTweak\"]\ndirection LR\ntaggedHash1(\"TaggedHash(\")\ntapTweakStr1(\"#quot;TapTweak#quot;,\")\nNofN2(\"\ud83d\udd12mConsensus/n,\")\nscript_root(\"#\ufe0f\u20e3script_root)\")\nend\nTapTweak--&gt;GenMult\nsubgraph TapTree[\"Revocable Time Decay Threshold (RTDT) TapTree\"]\ntbRTDT(\"#\ufe0f\u20e3tbRTDT\")--&gt;script_root\ntlCommit(\"\ud83c\udf41tlCommit\")--&gt;tbRTDT\ntlDisaster(\"\ud83c\udf41tlDisaster\")--&gt;tbRTDT\nCommit--&gt;tlCommit\nDisaster--&gt;tlDisaster\nsubgraph Commit\nAB/2+1(\"\ud83d\udd12mConsensus/n\")\nOP_CSLG(OP_CHECKSIG)\ndRevoke(\"\u23f2\ufe0fdRevoke\")\nOP_CSVLG(OP_CHECKSEQUENCEVERIFY)\nOP_DLG(OP_DROP)\nend\nsubgraph Disaster\nmDisaster/n(\"\ud83d\udd12mDisaster/n\")\nOP_CSDD(OP_CHECKSIG)\ndDisaster(\"\u23f2\ufe0fdDisaster\")\nOP_CSVDD(OP_CHECKSEQUENCEVERIFY)\nOP_DDD(OP_DROP)\nend\nend\n</code></pre>\n<h2><a name=\"dual-group-modified-taproot-channelshttpsgithubcomlightningboltspull995-4\" class=\"anchor\" href=\"#dual-group-modified-taproot-channelshttpsgithubcomlightningboltspull995-4\"></a>Dual-group modified <a href=\"https://github.com/lightning/bolts/pull/995\" rel=\"noopener nofollow ugc\">Taproot channels</a></h2>\n<p>It\u2019s possible to use TDT outputs in a channel between two groups. In this case, the internal key of any funding or commitment output is a NUMS point, so the output must be spent using the script path. Each threshold key can be checked separately, avoiding potential issues with nesting (e.g. FROST in MuSig2). As such nesting is further developed, we could optimize by using the key path for multisig with no delay. Instead of internal revocation keys, pre-signed revocation transactions with TDT outputs are used.</p>\n<p>There are several differences in commitment transaction outputs, depending on their purpose:</p>\n<ul>\n<li>A to_local tapleaf for the local delay key, consisting of the local group\u2019s threshold for committing to the state, redeemable after a CSV delay. Before signing the parent commitment transaction, the group should sign a second-level transaction spending the output with this tapleaf, having a local TDT output, and distribute it to each group member for storage until revocation.</li>\n<li>A revocation tapleaf checks two threshold signatures, one from each group, without a CSV delay. On revocation, a second-level transaction spending the output with that tapleaf is signed by the local party, having a penalty TDT output to the remote party. Unlike revealing a private key used as the taproot internal key, this guarantees that the remote party can redeem the TDT output even in case of breach during disaster. If the remote party is using a threshold key, they should counter-sign the transaction as quickly as possible and each group member should keep a copy until channel closure. This revocation mechanism uses more storage per state, but the data is shared among the group and partially prunable.</li>\n<li>An HTLC success tapleaf for a payment preimage and both threshold keys, unchanged. However, the second-level HTLC also uses a NUMS point for the output\u2019s taproot internal key, and has a separate revocation tapleaf for which a spend is signed at revocation.</li>\n<li>An HTLC timeout tapleaf for both threshold keys and a CLTV delay, unchanged. However, the second-level HTLC also uses a NUMS point for the output\u2019s taproot internal key, and has a separate revocation tapleaf for which a spend is signed at revocation.</li>\n</ul>\n<p>The to_remote output in such a channel would be a TDT output for the remote party.</p>\n<p>This type of channel may be on-chain between two mutually-distrusting groups, or nested in a transaction which is a child of an RTDT, allowing payments between subgroups. One potential setup for an on-chain channel is to create it between two top-level groups, and then delegate to subgroups from each side to do the liquidity provision, knowing the penalty from any dispute will always go to the larger groups that control the on-chain output.</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2023-12-20T05:29:17.014Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 7,
  "reads": 4,
  "readers_count": 3,
  "score": 25.8,
  "yours": false,
  "topic_id": 309,
  "topic_slug": "group-penalty-channels",
  "topic_title": "Group Penalty Channels",
  "topic_html_title": "Group Penalty Channels",
  "category_id": 7,
  "display_username": "Alex Akselrod",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "# Group Penalty Channels\n\nWith few [exceptions](https://delvingbitcoin.org/t/aggregate-delegated-exit-for-l2-pools/297), [proposed](https://nakamotoinstitute.org/static/docs/scalable-funding-of-bitcoin-micropayment-channel-networks.pdf) [multi](https://blockstream.com/eltoo.pdf)-[party](https://github.com/JohnLaw2/ln-factory-optimized) [channel](https://www.arkpill.me/deep-dive) [structures](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-August/021897.html) all assume a requirement for unilateral, non-interactive, individual exit to layer 1, which is most of what takes up block space. [Payment channels](https://en.bitcoin.it/wiki/Payment_channels) have been designed this way from the beginning. I have some ideas in the design space where this is not a requirement, including unions, co-ops, family budgets, or any other group or event where the money belongs to the organization and not individual members.\n\nI'm interested in designing a structure where group members would know and trust each other enough to work together, preventing Sybil attacks from anonymous/pseudonymous participants. Budget decisions should be made together, democratically, delegating smaller budgets to subgroups. Subgroups can be groups of stakeholders with differing priorities such as customers, co-owners, or workers organized by department. Liquidity providers can help cross trust boundaries with other groups or channel types. Spending policies can be mutually enforced by group members using [threshold](https://eprint.iacr.org/2020/852) [signatures](https://eprint.iacr.org/2022/550). Thresholds should be configured to minimize delegation of trust, and place more trust in the larger group than smaller subgroups.\n\nThe current design below takes advantage of off-chain pre-signed transactions as a substitute for covenants, but could potentially be more efficient with on-chain covenants. In addition, covenants would still be useful for nesting channels based on individual exit within group penalty channels.\n\nThanks to Jennifer Akselrod, Carl Dong, Tadge Dryja, Brian Groll, Johan Halseth, Jonathan Harvey-Buschel, Joost Jager, Jordi Montes, and James O'Beirne for review and discussion of the ideas here.\n\n## On-chain Time-Decay Threshold (TDT) output\n\nThe first building block for group penalty channels is the TDT output. When a transaction containing such an output is confirmed, the resulting UTXO starts a timer to agree on funds distribution. The output is a P2TR with the internal key being the maximum required threshold (not necessarily 100%) for full consensus for an immediate spend of the output. Each tapleaf is another redemption option: the longer the CSV delay, the lower the threshold to spend. Disaster recovery tapleaves can have threshold options lower than 50%, but a very long CSV delay.\n\n```mermaid\n---\ntitle: Example On-chain Time Decay Threshold (TDT) Output PkScript\n---\ngraph BT\nsubgraph PkScript\ndirection LR\nOutRoot(OP_1)\nQ(\"\ud83d\udd12Q\")\nend\nsubgraph Key\ndirection LR\nNofN(\"\ud83d\udd12mConsensus/n\")\nplus{+}\nT(\"\ud83d\udd00T\")\nend\nKey-->Q\nGenMult{* G}-->T\nsubgraph TapTweak[\"#\ufe0f\u20e3TapTweak\"]\ndirection LR\ntaggedHash1(\"TaggedHash(\")\ntapTweakStr1(\"#quot;TapTweak#quot;,\")\nNofN2(\"\ud83d\udd12mConsensus/n,\")\nscript_root(\"#\ufe0f\u20e3script_root)\")\nend\nTapTweak-->GenMult\nsubgraph TapTree[\"Time Decay Threshold (TDT) TapTree\"]\ntlDisaster(\"\ud83c\udf41tlDisaster\")-->script_root\nDisaster-->tlDisaster\nsubgraph Disaster\nmDisaster/n(\"\ud83d\udd12mDisaster/n\")\nOP_CDDS(OP_CHECKSIG)\ndDisaster(\"\u23f2\ufe0fdDisaster\")\nOP_CSVDD(OP_CHECKSEQUENCEVERIFY)\nOP_DDD(OP_DROP)\nend\nend\n```\n\nm*Case* is the threshold in each case, and d*Case* is delay. For this example, m*Consensus* should be *floor*(50%+1) to ensure a democratic decision, and m*Disaster* might be 20% and d*Disaster* a long time period in case a majority of the group is permanently unavailable.\n\n## Revocable Off-Chain Time Decay Threhold (RTDT) Output\n\nThe next building block is the single-group RTDT output. Off-chain transactions can contain such outputs for the top-level group or any subgroup. This is, again, a P2TR output. These outputs can be used to nest replaceable transactions, allowing allocation of money between subgroups.\n\nTo commit to a state where the output is valid, the group co-signs a transaction spending the output using the `tlCommit` script path, redeemable after a CSV revocation delay. Then the group co-signs the transaction containing the output.\n\nTo revoke the current state, the group co-signs a key path spend to a transaction which has a TDT output for the group itself and/or its larger parent group. This creates a \"group penalty\": the entire balance of the revoked output goes to the group to democratically decide what to do with, should the revoked state be confirmed. The penalty TDT output can be customized, e.g. the larger group's script leaves may have lower CSV delays than the subgroup's.\n\n```mermaid height=287,auto\n---\ntitle: Example Revocable Off-Chain Time Decay Threshold (RTDT) Output PkScript for Group\n---\ngraph BT\nsubgraph PkScript\ndirection LR\nOutRoot(OP_1)\nQ(\"\ud83d\udd12Q\")\nend\nsubgraph Key\ndirection LR\nNofN(\"\ud83d\udd12mConsensus/n\")\nplus{+}\nT(\"\ud83d\udd00T\")\nend\nKey-->Q\nGenMult{* G}-->T\nsubgraph TapTweak[\"#\ufe0f\u20e3TapTweak\"]\ndirection LR\ntaggedHash1(\"TaggedHash(\")\ntapTweakStr1(\"#quot;TapTweak#quot;,\")\nNofN2(\"\ud83d\udd12mConsensus/n,\")\nscript_root(\"#\ufe0f\u20e3script_root)\")\nend\nTapTweak-->GenMult\nsubgraph TapTree[\"Revocable Time Decay Threshold (RTDT) TapTree\"]\ntbRTDT(\"#\ufe0f\u20e3tbRTDT\")-->script_root\ntlCommit(\"\ud83c\udf41tlCommit\")-->tbRTDT\ntlDisaster(\"\ud83c\udf41tlDisaster\")-->tbRTDT\nCommit-->tlCommit\nDisaster-->tlDisaster\nsubgraph Commit\nAB/2+1(\"\ud83d\udd12mConsensus/n\")\nOP_CSLG(OP_CHECKSIG)\ndRevoke(\"\u23f2\ufe0fdRevoke\")\nOP_CSVLG(OP_CHECKSEQUENCEVERIFY)\nOP_DLG(OP_DROP)\nend\nsubgraph Disaster\nmDisaster/n(\"\ud83d\udd12mDisaster/n\")\nOP_CSDD(OP_CHECKSIG)\ndDisaster(\"\u23f2\ufe0fdDisaster\")\nOP_CSVDD(OP_CHECKSEQUENCEVERIFY)\nOP_DDD(OP_DROP)\nend\nend\n```\n\n## Dual-group modified [Taproot channels](https://github.com/lightning/bolts/pull/995)\n\nIt's possible to use TDT outputs in a channel between two groups. In this case, the internal key of any funding or commitment output is a NUMS point, so the output must be spent using the script path. Each threshold key can be checked separately, avoiding potential issues with nesting (e.g. FROST in MuSig2). As such nesting is further developed, we could optimize by using the key path for multisig with no delay. Instead of internal revocation keys, pre-signed revocation transactions with TDT outputs are used.\n\nThere are several differences in commitment transaction outputs, depending on their purpose:\n  - A to_local tapleaf for the local delay key, consisting of the local group's threshold for committing to the state, redeemable after a CSV delay. Before signing the parent commitment transaction, the group should sign a second-level transaction spending the output with this tapleaf, having a local TDT output, and distribute it to each group member for storage until revocation.\n  - A revocation tapleaf checks two threshold signatures, one from each group, without a CSV delay. On revocation, a second-level transaction spending the output with that tapleaf is signed by the local party, having a penalty TDT output to the remote party. Unlike revealing a private key used as the taproot internal key, this guarantees that the remote party can redeem the TDT output even in case of breach during disaster. If the remote party is using a threshold key, they should counter-sign the transaction as quickly as possible and each group member should keep a copy until channel closure. This revocation mechanism uses more storage per state, but the data is shared among the group and partially prunable.\n  - An HTLC success tapleaf for a payment preimage and both threshold keys, unchanged. However, the second-level HTLC also uses a NUMS point for the output's taproot internal key, and has a separate revocation tapleaf for which a spend is signed at revocation.\n  - An HTLC timeout tapleaf for both threshold keys and a CLTV delay, unchanged. However, the second-level HTLC also uses a NUMS point for the output's taproot internal key, and has a separate revocation tapleaf for which a spend is signed at revocation.\n\nThe to_remote output in such a channel would be a TDT output for the remote party.\n\nThis type of channel may be on-chain between two mutually-distrusting groups, or nested in a transaction which is a child of an RTDT, allowing payments between subgroups. One potential setup for an on-chain channel is to create it between two top-level groups, and then delegate to subgroups from each side to do the liquidity provision, knowing the penalty from any dispute will always go to the larger groups that control the on-chain output.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 69,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}