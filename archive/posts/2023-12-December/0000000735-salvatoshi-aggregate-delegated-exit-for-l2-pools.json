{
  "id": 735,
  "name": "salvatoshi",
  "username": "salvatoshi",
  "avatar_template": "/user_avatar/delvingbitcoin.org/salvatoshi/{size}/72_2.png",
  "created_at": "2023-12-16T08:08:35.030Z",
  "cooked": "<p>It\u2019s often been claimed that \u201ccovenants don\u2019t solve the L2 exit problem\u201d because it\u2019s always not economical to exit a layer 2 system for a user whose balance is too low to cover for the fees.</p>\n<p>In this post, I will argue that fraud proofs might provide an interesting solution to this problem.</p>\n<p><strong>TL;DR:</strong> a withdrawal protocol based on fraud proofs can allow many parties that are individually <em>too poor</em> to withdraw their balance from a pooled UTXO to cooperate off-chain and perform a single, larger withdrawal.</p>\n<h2><a name=\"intro-fraud-proofs-1\" class=\"anchor\" href=\"#intro-fraud-proofs-1\"></a>Intro: fraud proofs</h2>\n<p>Readers who are familiar with the concept of fraud proofs can safely skip this section.</p>\n<p>The idea of <em>fraud proofs</em> is to replace a (possibly expensive) computation in a smart contract with just a claim that a computation would give a certain result.</p>\n<p>As long as the interested parties in a smart contracts have a way of disproving fraudulent claims - and a protocol that punishes any fraud attempt, then frauds (and fraud proofs) are never expected to end up on chain.</p>\n<p>The saving generally comes not only from avoiding an expensive operation in Script, but also by <em>not</em> putting the entire witness data that the computation would need: a commitment to it is generally sufficient, as long as the counterparties are able to independently compute the correct data themselves.</p>\n<p>The trade-off of using protocols based on fraud proofs (optimistic protocols) in comparison to a full on-chain validation of the contract transition are:</p>\n<ul>\n<li>fraud proofs require a challenge period, in comparison to direct computations that are confirmed in a single transaction; moreover, some capital lockup is generally needed during the challenge period;</li>\n<li>fraud proof protocols rely on the assumption that miners are not actively censoring the transactions of the challenger.</li>\n</ul>\n<p>The most commonly used optimistic protocol in bitcoin today is in fact a Lightning channel: the \u201cjustice transaction\u201d is a fraud proof.</p>\n<p><strong>Remark</strong>. While <a>MATT</a> admits a generic fraud proof protocol for arbitrary computations (that scales logarithmically on its computational cost), there are many special cases for which the fraud proof protocol is a lot simpler. Fraud proofs on statements about the leaves of a Merkle tree (for example \u201cif I change the <span class=\"math\">i</span>-th leaf of the Merkle tree with root <span class=\"math\">R</span>, the root of the new Merkle tree is <span class=\"math\">R'</span>\u201d have fairly straightforward fraud proof protocols).</p>\n<h2><a name=\"the-optimistic-pool-setting-2\" class=\"anchor\" href=\"#the-optimistic-pool-setting-2\"></a>The optimistic pool setting</h2>\n<p>Imagine a layer 2 system where a single UTXO stores the state as a list of <code>user:balance</code> for <span class=\"math\">n</span> users (where <code>user</code> is a public key, and <code>balance</code> is an amount in satoshis), and the operator (or a Musig2 of all the participants) publishes new states according to some rules.</p>\n<p>An important assumption in what follows is that <em>all the users completely know the state of the contract - that is, each user\u2019s balance</em>.</p>\n<p>If the operator messes up (for example, fraud is proven, or the operator becomes unresponsive and does not publish the next state), then the UTXO can be spent towards an <em>unwinding</em> state, where the only action allowed is getting your money out of the pool.</p>\n<p>There are multiple constructions that might fit this model (rollups, coinpools, etc.). In the following, we only focus on the <em>unwinding</em> stage of such constructions: something went wrong, and all the users have to withdraw their coins.</p>\n<h2><a name=\"the-unwind-contract-3\" class=\"anchor\" href=\"#the-unwind-contract-3\"></a>The \u201cUnwind\u201d contract</h2>\n<p>Once the panic button is pressed, the pool is in the Unwind contract (a UTXO with a covenant): the only allowed action is \u201cTTMAR\u201d (Take The Money And Run). This UTXO contains a vector commitment of all the <code>user:balance</code> pairs; that is, the root of the Merkle tree of the vector.</p>\n<p>High value users can exit directly and instantly by proving their balances (with a Merkle proof) \u2013 but low value users can\u2019t, as even publishing the Merkle proof is more expensive than their balance!</p>\n<h2><a name=\"optimistic-withdrawal-4\" class=\"anchor\" href=\"#optimistic-withdrawal-4\"></a>Optimistic withdrawal</h2>\n<p>If the Merkle proof is large, one can think of a cheaper way: withdraw with a fraud proof.</p>\n<p>User Will who is withdrawing claims \u201cmy balance is X, and the remaining pool is Unwind(all-users-minus-Will)\u201d; he additionally attaches 1 \u20bf as a bond, and the money is locked for the challenge period. If he lied, whoever proves the fraud can take <span class=\"math\">(1+X)/2</span> \u20bf (half of Will\u2019s money), while <span class=\"math\">(1+X)/2</span> \u20bf is burned. Otherwise, at the end of the challenge period, Will can take out his money, and his bond, and produce the output Unwind(all-users-minus-Will)</p>\n<p>This optimistic withdrawal might be cheaper as it does not require a Merkle proof, lowering the balance threshold for which withdrawals are economically feasible.</p>\n<p>However, users who want to withdraw their 10000 sats are still out of luck.</p>\n<h2><a name=\"optimistic-aggregated-withdrawal-5\" class=\"anchor\" href=\"#optimistic-aggregated-withdrawal-5\"></a>Optimistic aggregated withdrawal</h2>\n<p>The idea is to generalize the optimistic withdrawal to an arbitrary subset of pool users, and add an intermediary Ingrid.</p>\n<p>A set <span class=\"math\">S</span> of users of users wants to delegate to Ingrid the right to withdraw their \u201caggregate balance\u201d. Each of them signs a delegation message with their pubkey in the pool saying \u201cI authorize Ingrid to withdraw my balance\u201d.</p>\n<p>Ingrid then spends the Unwind UTXO, claiming \u201cI\u2019m authorized to withdraw a total of X on behalf of the users in <span class=\"math\">S</span> = {s_0, s_1, \u2026, s_k}; the new state will be Unwind(all users, except the ones in <span class=\"math\">S</span>)\u201d (note: only the <em>index</em> of each user in <span class=\"math\">S</span> is posted); the output also contains the Merkle root of all the delegations, and is timelocked to allow fraud proofs, and Ingrid also posts a juicy 10 \u20bf bond.</p>\n<p>If Ingrid is lying about the total aggregate balance of <span class=\"math\">S</span>, or about the new state of the contract (with the updated Merkle root), any user in the system can challenge Ingrid: since they know the full state of the system, a fraud proof protocol on the Merkle tree of the UTXO state will allow to expose the lie. upon winning the challenge, they will 5 \u20bf from Ingrid\u2019s bond and burn the other 5 \u20bf; the withdrawal attempt is reversed.</p>\n<p>Any user in <span class=\"math\">S</span> can challenge Ingrid if they didn\u2019t sign a delegation (but they also have to put a bond, and if Ingrid proves they <em>did</em> sign a delegation, Ingrid pockets half of their bond).</p>\n<p>If there is no challenge, Ingrid takes the money of all the users in <span class=\"math\">S</span>, and gets back her bond.</p>\n<p>Ingrid then can (custodially) return the funds in some other way - on lightning, on Liquid, in fiat, etc.</p>\n<h3><a name=\"properties-6\" class=\"anchor\" href=\"#properties-6\"></a>Properties</h3>\n<p>Summing up, the properties of the system are such that:</p>\n<ul>\n<li>the intermediary can be chosen at any time <em>after</em> the Unwind utxo is created; users can cooperate at any time with other users to find an intermediary who still didn\u2019t withdraw (and they have an incentive to do so);</li>\n<li>the cost for Ingrid to claim the money is (almost) constant (except for the list of indices that grows with the user indices, that is pretty small anyway);</li>\n<li>any unsuccessful fraud loses money;</li>\n<li>any set of users with sufficient aggregate balance can withdraw using the optimistic approach.</li>\n</ul>\n<h2><a name=\"improvements-7\" class=\"anchor\" href=\"#improvements-7\"></a>Improvements</h2>\n<h3><a name=\"non-custodial-ingrid-8\" class=\"anchor\" href=\"#non-custodial-ingrid-8\"></a>Non-custodial Ingrid</h3>\n<p>For simplicity, we said that Ingrid \u201ccustodially\u201d helps <span class=\"math\">S</span> above, but one can build on top of this scheme: for example, the delegation could already specify some other UTXO(s) where the money has to go to once the challenge period is over \u2013 maybe a new pool with a different operators agreed upon by the users in <span class=\"math\">S</span>).</p>\n<p>OP_CHECKTEMPLATEVERIFY or OP_TXHASH would provide an efficient to pre-program the future of the coins after the aggregated withdrawal.</p>\n<h3><a name=\"constant-withdrawal-cost-open-problem-9\" class=\"anchor\" href=\"#constant-withdrawal-cost-open-problem-9\"></a>Constant withdrawal cost? (open problem)</h3>\n<p>In the above, the index of each user who is withdrawing is part of the initial aggregate withdrawal message. While that doesn\u2019t require too many bytes, it still make the transaction size increase linearly with the number of users withdrawing.</p>\n<p>For a pool with <span class=\"math\">n</span> users, one could use 1 bit per user (listing for each of the n users whether they are in <span class=\"math\">S</span> or not), so the total cost of withdrawing is fixed at <span class=\"math\">n + O(1)</span> bits; this might be good enough in practice.</p>\n<p>It would be great to find a protocol with constant cost independent on <span class=\"math\">n</span> or <span class=\"math\">|S|</span>.</p>\n<h3><a name=\"parallel-optimistic-withdrawals-open-problem-10\" class=\"anchor\" href=\"#parallel-optimistic-withdrawals-open-problem-10\"></a>Parallel optimistic withdrawals? (open problem)</h3>\n<p>With an opcode like OP_CHECKCONTRACTVERIFY that allows cross-input introspection, the optimistic withdrawal protocol (and possible challenge protocol) could be performed on a separate UTXO instead of spending the pool UTXO; only at maturity (after the challenge period is over), both UTXOs could be spent together. However, it\u2019s not clear if there is a clean/easy way to make one withdrawal not interfere with other ones happening in parallel.</p>\n<h1><a name=\"script-requirements-11\" class=\"anchor\" href=\"#script-requirements-11\"></a>Script requirements</h1>\n<ul>\n<li>MATT (e.g. OP_CHECKCONTRACTVERIFY + OP_CAT)</li>\n<li>Amount introspection (equality checks should be enough)</li>\n</ul>\n<p><strong>Nice-to-have</strong>s:</p>\n<ul>\n<li>OP_CHECKSIGFROMSTACK to sign delegations (there are <a href=\"https://gist.github.com/bigspider/041ebd0842c0dcc74d8af087c1783b63#pre-signed-state-update-utxos\" rel=\"noopener nofollow ugc\">workarounds</a> to do it without, but it\u2019s just awkward)</li>\n<li>64 bit arithmetic</li>\n</ul>\n<h1><a name=\"conclusions-12\" class=\"anchor\" href=\"#conclusions-12\"></a>Conclusions</h1>\n<p>There are many details to figure out, but the approach seems sound to me. I look forward to your comments.</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2023-12-16T14:11:01.540Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 90,
  "reads": 8,
  "readers_count": 7,
  "score": 451.6,
  "yours": false,
  "topic_id": 297,
  "topic_slug": "aggregate-delegated-exit-for-l2-pools",
  "topic_title": "Aggregate delegated exit for L2 pools",
  "topic_html_title": "Aggregate delegated exit for L2 pools",
  "category_id": 7,
  "display_username": "salvatoshi",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "It's often been claimed that \"covenants don't solve the L2 exit problem\" because it's always not economical to exit a layer 2 system for a user whose balance is too low to cover for the fees.\n\nIn this post, I will argue that fraud proofs might provide an interesting solution to this problem.\n\n**TL;DR:** a withdrawal protocol based on fraud proofs can allow many parties that are individually _too poor_ to withdraw their balance from a pooled UTXO to cooperate off-chain and perform a single, larger withdrawal.\n\n## Intro: fraud proofs\n\nReaders who are familiar with the concept of fraud proofs can safely skip this section.\n\nThe idea of *fraud proofs* is to replace a (possibly expensive) computation in a smart contract with just a claim that a computation would give a certain result.\n\nAs long as the interested parties in a smart contracts have a way of disproving fraudulent claims - and a protocol that punishes any fraud attempt, then frauds (and fraud proofs) are never expected to end up on chain.\n\nThe saving generally comes not only from avoiding an expensive operation in Script, but also by *not* putting the entire witness data that the computation would need: a commitment to it is generally sufficient, as long as the counterparties are able to independently compute the correct data themselves.\n\nThe trade-off of using protocols based on fraud proofs (optimistic protocols) in comparison to a full on-chain validation of the contract transition are:\n- fraud proofs require a challenge period, in comparison to direct computations that are confirmed in a single transaction; moreover, some capital lockup is generally needed during the challenge period;\n- fraud proof protocols rely on the assumption that miners are not actively censoring the transactions of the challenger.\n\nThe most commonly used optimistic protocol in bitcoin today is in fact a Lightning channel: the \"justice transaction\" is a fraud proof. \n\n**Remark**. While [MATT](merkle.fun) admits a generic fraud proof protocol for arbitrary computations (that scales logarithmically on its computational cost), there are many special cases for which the fraud proof protocol is a lot simpler. Fraud proofs on statements about the leaves of a Merkle tree (for example \"if I change the $i$-th leaf of the Merkle tree with root $R$, the root of the new Merkle tree is $R'$\" have fairly straightforward fraud proof protocols).\n\n## The optimistic pool setting\n\nImagine a layer 2 system where a single UTXO stores the state as a list of `user:balance` for $n$ users (where `user` is a public key, and `balance` is an amount in satoshis), and the operator (or a Musig2 of all the participants) publishes new states according to some rules.\n\nAn important assumption in what follows is that _all the users completely know the state of the contract - that is, each user's balance_.\n\nIf the operator messes up (for example, fraud is proven, or the operator becomes unresponsive and does not publish the next state), then the UTXO can be spent towards an _unwinding_ state, where the only action allowed is getting your money out of the pool.\n\nThere are multiple constructions that might fit this model (rollups, coinpools, etc.). In the following, we only focus on the _unwinding_ stage of such constructions: something went wrong, and all the users have to withdraw their coins.\n\n## The \"Unwind\" contract\n\nOnce the panic button is pressed, the pool is in the Unwind contract (a UTXO with a covenant): the only allowed action is \"TTMAR\" (Take The Money And Run). This UTXO contains a vector commitment of all the `user:balance` pairs; that is, the root of the Merkle tree of the vector.\n\nHigh value users can exit directly and instantly by proving their balances (with a Merkle proof) \u2013 but low value users can't, as even publishing the Merkle proof is more expensive than their balance!\n\n## Optimistic withdrawal\n\nIf the Merkle proof is large, one can think of a cheaper way: withdraw with a fraud proof.\n\nUser Will who is withdrawing claims \"my balance is X, and the remaining pool is Unwind(all-users-minus-Will)\"; he additionally attaches 1 \u20bf as a bond, and the money is locked for the challenge period. If he lied, whoever proves the fraud can take $(1+X)/2$ \u20bf (half of Will's money), while $(1+X)/2$ \u20bf is burned. Otherwise, at the end of the challenge period, Will can take out his money, and his bond, and produce the output Unwind(all-users-minus-Will)\n\nThis optimistic withdrawal might be cheaper as it does not require a Merkle proof, lowering the balance threshold for which withdrawals are economically feasible.\n\nHowever, users who want to withdraw their 10000 sats are still out of luck.\n\n## Optimistic aggregated withdrawal\n\nThe idea is to generalize the optimistic withdrawal to an arbitrary subset of pool users, and add an intermediary Ingrid.\n\nA set $S$ of users of users wants to delegate to Ingrid the right to withdraw their \"aggregate balance\". Each of them signs a delegation message with their pubkey in the pool saying \"I authorize Ingrid to withdraw my balance\".\n\nIngrid then spends the Unwind UTXO, claiming \"I'm authorized to withdraw a total of X on behalf of the users in $S$ = {s_0, s_1, ..., s_k}; the new state will be Unwind(all users, except the ones in $S$)\" (note: only the _index_ of each user in $S$ is posted); the output also contains the Merkle root of all the delegations, and is timelocked to allow fraud proofs, and Ingrid also posts a juicy 10 \u20bf bond.\n\nIf Ingrid is lying about the total aggregate balance of $S$, or about the new state of the contract (with the updated Merkle root), any user in the system can challenge Ingrid: since they know the full state of the system, a fraud proof protocol on the Merkle tree of the UTXO state will allow to expose the lie. upon winning the challenge, they will 5 \u20bf from Ingrid's bond and burn the other 5 \u20bf; the withdrawal attempt is reversed.\n\nAny user in $S$ can challenge Ingrid if they didn't sign a delegation (but they also have to put a bond, and if Ingrid proves they _did_ sign a delegation, Ingrid pockets half of their bond).\n\nIf there is no challenge, Ingrid takes the money of all the users in $S$, and gets back her bond.\n\nIngrid then can (custodially) return the funds in some other way - on lightning, on Liquid, in fiat, etc.\n\n### Properties\n\nSumming up, the properties of the system are such that:\n- the intermediary can be chosen at any time _after_ the Unwind utxo is created; users can cooperate at any time with other users to find an intermediary who still didn't withdraw (and they have an incentive to do so);\n- the cost for Ingrid to claim the money is (almost) constant (except for the list of indices that grows with the user indices, that is pretty small anyway);\n- any unsuccessful fraud loses money;\n- any set of users with sufficient aggregate balance can withdraw using the optimistic approach.\n\n## Improvements\n\n### Non-custodial Ingrid\nFor simplicity, we said that Ingrid \"custodially\" helps $S$ above, but one can build on top of this scheme: for example, the delegation could already specify some other UTXO(s) where the money has to go to once the challenge period is over \u2013 maybe a new pool with a different operators agreed upon by the users in $S$).\n\nOP_CHECKTEMPLATEVERIFY or OP_TXHASH would provide an efficient to pre-program the future of the coins after the aggregated withdrawal.\n\n### Constant withdrawal cost? (open problem)\n\nIn the above, the index of each user who is withdrawing is part of the initial aggregate withdrawal message. While that doesn't require too many bytes, it still make the transaction size increase linearly with the number of users withdrawing.\n\nFor a pool with $n$ users, one could use 1 bit per user (listing for each of the n users whether they are in $S$ or not), so the total cost of withdrawing is fixed at $n + O(1)$ bits; this might be good enough in practice.\n\nIt would be great to find a protocol with constant cost independent on $n$ or $|S|$.\n\n### Parallel optimistic withdrawals? (open problem)\n\nWith an opcode like OP_CHECKCONTRACTVERIFY that allows cross-input introspection, the optimistic withdrawal protocol (and possible challenge protocol) could be performed on a separate UTXO instead of spending the pool UTXO; only at maturity (after the challenge period is over), both UTXOs could be spent together. However, it's not clear if there is a clean/easy way to make one withdrawal not interfere with other ones happening in parallel.\n\n# Script requirements\n- MATT (e.g. OP_CHECKCONTRACTVERIFY + OP_CAT)\n- Amount introspection (equality checks should be enough)\n\n**Nice-to-have**s:\n- OP_CHECKSIGFROMSTACK to sign delegations (there are [workarounds](https://gist.github.com/bigspider/041ebd0842c0dcc74d8af087c1783b63#pre-signed-state-update-utxos) to do it without, but it's just awkward)\n- 64 bit arithmetic\n\n# Conclusions\n\nThere are many details to figure out, but the approach seems sound to me. I look forward to your comments.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 81,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}