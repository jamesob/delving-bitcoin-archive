{
  "id": 789,
  "name": "salvatoshi",
  "username": "salvatoshi",
  "avatar_template": "/user_avatar/delvingbitcoin.org/salvatoshi/{size}/72_2.png",
  "created_at": "2023-12-19T12:46:39.300Z",
  "cooked": "<p>With miniscript on taproot in core, and support coming soon in hardware signers, we will start seeing wallets exploring the new possibilities.</p>\n<p>One thing that will probably be useful for certain use cases and that doesn\u2019t have clear specs to day is: how to create spending policies with unspendable keys?</p>\n<p>That\u2019s particularly important in taproot, as one might desire to create a wallet that can only be spent using the script paths; for example, because all the spending conditions require a timelock, or not expressible as a musig/FROST keypath.</p>\n<p>It\u2019s easy to create a specific unspendable keys or xpubs; for example: <code>xpub661MyMwAqRbcEYS8w7XLSVeEsBXy79zSzH1J8vCdxAZningWLdN3zgtU6QgnecKFpJFPpdzxKrwoaZoV44qAJewsc4kX9vGaCaBExuvJH57</code>, constructed by taking the NUMS point suggested in <a href=\"https://github.com/bitcoin/bips/blob/9c57fac1a71d20f693607c2490dec9011c205ab5/bip-0341.mediawiki\" rel=\"noopener nofollow ugc\">BIP-0341</a> and attaching a chaincode made of 32 <code>0</code> bytes.</p>\n<p>However, there are desirable properties that it\u2019s not trivial to achieve:</p>\n<ol>\n<li>unspendable keys should be indistinguishable from a random key for an external observer;</li>\n<li>in a descriptor with the range operator (like the <a href=\"https://github.com/bitcoin/bips/pull/1389\" rel=\"noopener nofollow ugc\">wallet policies</a> compatible with most known wallet account formats), each change/address_index combination must generate a different unspendable pubkey , and they should not be relatable to each other (in order to avoid fingerprinting);</li>\n<li>the fact that a certain key is unspendable should be easy to detect with full knowledge of the descriptor;</li>\n<li>additional entropy needed for this key should be avoided or minimized.</li>\n</ol>\n<p>Properties (3) and (4) help providing a better user experience when using such spending policies with a hardware signing devices, where minimizing what\u2019s shown on-screen is important. For security reasons, any entropy that is part of the descriptor/wallet policy <em>must</em> be inspected by the user when they register the policy on the device, and compared with their backup. A worse user experience does in fact result in worse security in practice, especially with less experienced users - as they tend to skip the paranoid security steps.</p>\n<p>A key observation is that the unspendable pubkey <em>cannot</em> depend on information that is not in the descriptor itself (including private <em>or</em> public key material generated from the seed of the participants): that would make watch-only wallets impossible.</p>\n<p>It\u2019s unclear to me if there is any interesting use case for unspendable keys outside of the taproot keypath, but some of the solutions below might work for that as well.</p>\n<p>I\u2019ve been brainstorming some of the possible approaches, which I list below.</p>\n<h1><a name=\"solutions-1\" class=\"anchor\" href=\"#solutions-1\"></a>Solutions</h1>\n<h2><a name=\"s0-use-a-fixed-unspendable-xpub-2\" class=\"anchor\" href=\"#s0-use-a-fixed-unspendable-xpub-2\"></a>(s0) Use a fixed unspendable xpub</h2>\n<p>Just use <code>xpub661MyMwAqRbcEYS8w7XLSVeEsBXy79zSzH1J8vCdxAZningWLdN3zgtU6QgnecKFpJFPpdzxKrwoaZoV44qAJewsc4kX9vGaCaBExuvJH57</code> above.</p>\n<p>This is easy, but of course it only satisfies (3) and (4) and is giving up on (2) and (3)</p>\n<h2><a name=\"s1-use-a-root-xpub-with-unspendable-pubkey-and-random-chaincode-3\" class=\"anchor\" href=\"#s1-use-a-root-xpub-with-unspendable-pubkey-and-random-chaincode-3\"></a>(s1) Use a root xpub with unspendable pubkey and random chaincode</h2>\n<p>Instead of using the above xpub, on could generate a random unspendable xpub by using a random chaincode instead of a fixed constant.</p>\n<p>As long as the xpub is followed by a <code>/*</code> in the descriptor (as it\u2019s common in today\u2019s wallets that use <code>xpub/&lt;0;1&gt;/*</code>), this satisfies (1) and (2). It also satisfies (3), since the compressed public key of the root descriptor is fixed.</p>\n<p>It is not ideal for (4), as the additional entropy must be part of the backup, and be part of the information inspected on the hardware signer screen during registration of the wallet policy.</p>\n<h2><a name=\"s2-bip-0341-approach-h-rg-4\" class=\"anchor\" href=\"#s2-bip-0341-approach-h-rg-4\"></a>(s2) BIP-0341 approach: <code>H + r*G</code></h2>\n<p><a href=\"https://github.com/bitcoin/bips/blob/9c57fac1a71d20f693607c2490dec9011c205ab5/bip-0341.mediawiki\" rel=\"noopener nofollow ugc\">BIP-0341</a> suggests using a pubkey generated as <code>H + r*G</code>, where <code>H = lift_x(0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0)</code> is the NUMS point mentioned above, and <code>r</code> is a random number in <code>0..n-1</code> where <code>n</code> is the curve order.</p>\n<p>One can imagine a KEY expression <code>unspend(r)</code> (with a fixed chaincode so it can be used in further derivations).</p>\n<p>Of course, since <code>r</code> is chosen from a rather large set, this has the same properties as the previous approach: (1), (2) and (3), not optimal for (4).</p>\n<h2><a name=\"s3-entropy-from-the-taptree-keypath-only-5\" class=\"anchor\" href=\"#s3-entropy-from-the-taptree-keypath-only-5\"></a>(s3) Entropy from the taptree (keypath only)</h2>\n<p>Based on an idea from Antoine Poinsot: define a new fragment, say <code>tree(TREE)</code> (taptree only, without keypath), where the keypath is computed as a NUMS point with the previous approach, where <code>r</code> is the hash of the taptree.</p>\n<p>This is ideal w.r.t goals (2), (3) and (4). Fingerprinting is not ideal, as the fact that there is no keypath is revealed at spending time.</p>\n<p>One slight caveat compared to the approaches based on generating a provably unspendable xpub is that descriptors using the new fragment are not interoperable with wallets that didn\u2019t implement the new fragment type.</p>\n<h2><a name=\"s4-recycle-the-entropy-of-the-descriptor-6\" class=\"anchor\" href=\"#s4-recycle-the-entropy-of-the-descriptor-6\"></a>(s4) Recycle the entropy of the descriptor</h2>\n<p>As the \u201centropy\u201d of the unspendable key must be public to anyone that knows the descriptor, one approach could be to use the entropy in the descriptor itself to generate the unspendable pubkey.</p>\n<p>A typical descriptor used in wallets today contains a number of xpubs, followed by <code>/&lt;M;N&gt;/*</code> (that is, usually <code>/0/*</code> for receive addresses, or <code>/1/*</code> for change addresses.</p>\n<p>One could generate an unspendable xpub as follows:</p>\n<ul>\n<li>generate the pubkey as <code>H + r*G</code> above, where <code>r</code> is the SHA256 of the concatenation of all the compressed pubkeys in the descriptor that have a <code>/&lt;M;N&gt;/*</code>, in some canonical order (e.g. left-to-right in the descriptor)</li>\n<li>choose a fixed chaincode, like all zeros.</li>\n</ul>\n<p>EDIT: perhaps simpler:</p>\n<ul>\n<li>use the fixed unspendable pubkey</li>\n<li>use <code>r</code> for the chaincode.</li>\n</ul>\n<p>The KEY expression could be modified to allow a special marker that represents this special unspendable xpub, say <code>_</code>.</p>\n<p>For example, a taproot descriptor for a wallet with a single leaf that is an old-style multisig would be:</p>\n<pre><code class=\"lang-plaintext\">tr(_/&lt;0;1&gt;/*,multi_a(xpub1/&lt;0;1&gt;/*,xpub2/&lt;0;1&gt;/*)\n</code></pre>\n<p>(which can be more succinctly represented as <code>tr(_/**,multi_a(@0/**,@1/**))</code> as a descriptor template for wallet policies)</p>\n<p>The <code>_</code> could easily be converted to the actual pubkey if the descriptor needs to be imported in software that doesn\u2019t understand <code>_</code>.</p>\n<p>This approach would generate the same unspendable xpub for both a descriptor, but also the corresponding <a href=\"https://github.com/bitcoin/bips/pull/1389\" rel=\"noopener nofollow ugc\">wallet policy</a> (when a compatible wallet policy exists).</p>\n<p>All the properties (1-4) above are satisfied.</p>\n<p>TBD:</p>\n<ul>\n<li>Should more than one <code>_</code> be allowed in the descriptor? Should the same xpub generated every time? Or should it only be allowed in the taproot keypath?</li>\n<li>Probably <code>_</code> not followed by <code>/&lt;0;1&gt;/*</code> should be disallowed.</li>\n<li>Is there any simpler way to get all 4 properties?</li>\n</ul>\n<h1><a name=\"conclusions-7\" class=\"anchor\" href=\"#conclusions-7\"></a>Conclusions</h1>\n<p>Among the approaches that do not change any standard, (s1) is probably the most practical today: it\u2019s straightforward for hardware signers to detect such xpubs. The UX is a bit worse, but not by a lot \u2013 as there is anyway plenty of other information that the user has to inspect anyway.</p>\n<p>Among the forward-looking approaches that do require a syntax addition to descriptors, (s4) seems ideal in the spirit, but it feels a bit dirty and unsatisfactory when applied to descriptors. The scheme is much cleaner in the context of wallet policies, since they already separate the <em>descriptor template</em> from the xpubs, and are designed as a much more restricted language.</p>\n<p>Implementing this only for wallet policies might also be an option if they become a more widely adopted standard to backup descriptor-based wallets, but that is probably premature today.</p>\n<p>I look forward to your ideas and any cleaner approaches that I might have missed.</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2023-12-19T13:29:37.600Z",
  "reply_count": 1,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 25,
  "reads": 8,
  "readers_count": 7,
  "score": 146.6,
  "yours": false,
  "topic_id": 304,
  "topic_slug": "unspendable-keys-in-descriptors",
  "topic_title": "Unspendable keys in descriptors",
  "topic_html_title": "Unspendable keys in descriptors",
  "category_id": 8,
  "display_username": "salvatoshi",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 4,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "With miniscript on taproot in core, and support coming soon in hardware signers, we will start seeing wallets exploring the new possibilities.\n\nOne thing that will probably be useful for certain use cases and that doesn't have clear specs to day is: how to create spending policies with unspendable keys?\n\nThat's particularly important in taproot, as one might desire to create a wallet that can only be spent using the script paths; for example, because all the spending conditions require a timelock, or not expressible as a musig/FROST keypath.\n\nIt's easy to create a specific unspendable keys or xpubs; for example: `xpub661MyMwAqRbcEYS8w7XLSVeEsBXy79zSzH1J8vCdxAZningWLdN3zgtU6QgnecKFpJFPpdzxKrwoaZoV44qAJewsc4kX9vGaCaBExuvJH57`, constructed by taking the NUMS point suggested in [BIP-0341](https://github.com/bitcoin/bips/blob/9c57fac1a71d20f693607c2490dec9011c205ab5/bip-0341.mediawiki) and attaching a chaincode made of 32 `0` bytes.\n\nHowever, there are desirable properties that it's not trivial to achieve:\n\n1. unspendable keys should be indistinguishable from a random key for an external observer;\n2. in a descriptor with the range operator (like the [wallet policies](https://github.com/bitcoin/bips/pull/1389) compatible with most known wallet account formats), each change/address_index combination must generate a different unspendable pubkey , and they should not be relatable to each other (in order to avoid fingerprinting);\n3. the fact that a certain key is unspendable should be easy to detect with full knowledge of the descriptor;\n4. additional entropy needed for this key should be avoided or minimized.\n\nProperties (3) and (4) help providing a better user experience when using such spending policies with a hardware signing devices, where minimizing what's shown on-screen is important. For security reasons, any entropy that is part of the descriptor/wallet policy _must_ be inspected by the user when they register the policy on the device, and compared with their backup. A worse user experience does in fact result in worse security in practice, especially with less experienced users - as they tend to skip the paranoid security steps.\n\nA key observation is that the unspendable pubkey _cannot_ depend on information that is not in the descriptor itself (including private _or_ public key material generated from the seed of the participants): that would make watch-only wallets impossible.\n\nIt's unclear to me if there is any interesting use case for unspendable keys outside of the taproot keypath, but some of the solutions below might work for that as well.\n\nI've been brainstorming some of the possible approaches, which I list below.\n\n# Solutions\n## (s0) Use a fixed unspendable xpub\nJust use `xpub661MyMwAqRbcEYS8w7XLSVeEsBXy79zSzH1J8vCdxAZningWLdN3zgtU6QgnecKFpJFPpdzxKrwoaZoV44qAJewsc4kX9vGaCaBExuvJH57` above.\n\nThis is easy, but of course it only satisfies (3) and (4) and is giving up on (2) and (3)\n\n## (s1) Use a root xpub with unspendable pubkey and random chaincode\n\nInstead of using the above xpub, on could generate a random unspendable xpub by using a random chaincode instead of a fixed constant.\n\nAs long as the xpub is followed by a `/*` in the descriptor (as it's common in today's wallets that use `xpub/<0;1>/*`), this satisfies (1) and (2). It also satisfies (3), since the compressed public key of the root descriptor is fixed.\n\nIt is not ideal for (4), as the additional entropy must be part of the backup, and be part of the information inspected on the hardware signer screen during registration of the wallet policy.\n \n\n## (s2) BIP-0341 approach: `H + r*G`\n\n[BIP-0341](https://github.com/bitcoin/bips/blob/9c57fac1a71d20f693607c2490dec9011c205ab5/bip-0341.mediawiki) suggests using a pubkey generated as `H + r*G`, where `H = lift_x(0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0)` is the NUMS point mentioned above, and `r` is a random number in `0..n-1` where `n` is the curve order.\n\nOne can imagine a KEY expression `unspend(r)` (with a fixed chaincode so it can be used in further derivations).\n\nOf course, since `r` is chosen from a rather large set, this has the same properties as the previous approach: (1), (2) and (3), not optimal for (4).\n\n## (s3) Entropy from the taptree (keypath only)\n\nBased on an idea from Antoine Poinsot: define a new fragment, say `tree(TREE)` (taptree only, without keypath), where the keypath is computed as a NUMS point with the previous approach, where `r` is the hash of the taptree.\n\nThis is ideal w.r.t goals (2), (3) and (4). Fingerprinting is not ideal, as the fact that there is no keypath is revealed at spending time.\n\nOne slight caveat compared to the approaches based on generating a provably unspendable xpub is that descriptors using the new fragment are not interoperable with wallets that didn't implement the new fragment type.\n\n## (s4) Recycle the entropy of the descriptor\n\nAs the \"entropy\" of the unspendable key must be public to anyone that knows the descriptor, one approach could be to use the entropy in the descriptor itself to generate the unspendable pubkey.\n\nA typical descriptor used in wallets today contains a number of xpubs, followed by `/<M;N>/*` (that is, usually `/0/*` for receive addresses, or `/1/*` for change addresses.\n\nOne could generate an unspendable xpub as follows:\n- generate the pubkey as `H + r*G` above, where `r` is the SHA256 of the concatenation of all the compressed pubkeys in the descriptor that have a `/<M;N>/*`, in some canonical order (e.g. left-to-right in the descriptor)\n- choose a fixed chaincode, like all zeros.\n\nEDIT: perhaps simpler:\n- use the fixed unspendable pubkey \n- use `r` for the chaincode.\n\nThe KEY expression could be modified to allow a special marker that represents this special unspendable xpub, say `_`.\n\nFor example, a taproot descriptor for a wallet with a single leaf that is an old-style multisig would be:\n\n```text\ntr(_/<0;1>/*,multi_a(xpub1/<0;1>/*,xpub2/<0;1>/*)\n```\n\n(which can be more succinctly represented as `tr(_/**,multi_a(@0/**,@1/**))` as a descriptor template for wallet policies)\n\nThe `_` could easily be converted to the actual pubkey if the descriptor needs to be imported in software that doesn't understand `_`.\n\nThis approach would generate the same unspendable xpub for both a descriptor, but also the corresponding [wallet policy](https://github.com/bitcoin/bips/pull/1389) (when a compatible wallet policy exists).\n\nAll the properties (1-4) above are satisfied.\n\nTBD:\n- Should more than one `_` be allowed in the descriptor? Should the same xpub generated every time? Or should it only be allowed in the taproot keypath?\n- Probably `_` not followed by `/<0;1>/*` should be disallowed.\n- Is there any simpler way to get all 4 properties?\n\n# Conclusions\n\nAmong the approaches that do not change any standard, (s1) is probably the most practical today: it's straightforward for hardware signers to detect such xpubs. The UX is a bit worse, but not by a lot \u2013 as there is anyway plenty of other information that the user has to inspect anyway.\n\nAmong the forward-looking approaches that do require a syntax addition to descriptors, (s4) seems ideal in the spirit, but it feels a bit dirty and unsatisfactory when applied to descriptors. The scheme is much cleaner in the context of wallet policies, since they already separate the *descriptor template* from the xpubs, and are designed as a much more restricted language.\n\nImplementing this only for wallet policies might also be an option if they become a more widely adopted standard to backup descriptor-based wallets, but that is probably premature today.\n\nI look forward to your ideas and any cleaner approaches that I might have missed.",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 81,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}