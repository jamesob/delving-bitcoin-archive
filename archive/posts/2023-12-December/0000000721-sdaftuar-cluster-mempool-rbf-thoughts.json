{
  "id": 721,
  "name": "Suhas Daftuar",
  "username": "sdaftuar",
  "avatar_template": "/letter_avatar_proxy/v4/letter/s/0ea827/{size}.png",
  "created_at": "2023-12-12T21:34:10.366Z",
  "cooked": "<p>(Not sure where else to put this, but wanted to log this somewhere)</p>\n<p>I was thinking about <a href=\"https://github.com/bitcoin/bitcoin/pull/28984\" class=\"inline-onebox\">Cluster size 2 package rbf by instagibbs \u00b7 Pull Request #28984 \u00b7 bitcoin/bitcoin \u00b7 GitHub</a>, and realized just now that the RBF rules there for the cluster-size-2 case has the same sort of problem that I brought up here, with regard to the RBF heuristic not quite lining up with the feerate diagram test that we\u2019d like to use in the future.</p>\n<p><strong>Issue 1: The feerate diagram might not improve using the rules described in <span class=\"hashtag-raw\">#28984</span>.</strong></p>\n<p>This is similar to the example posted above. Imagine the starting mempool is:</p>\n<pre data-code-height=\"146\" data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">graph TD;\n    A[Tx A: sz 2, fee 4.5]--&gt;B[Tx B: sz 1, fee 5];\n</code></pre>\n<p>And we want to process a package (C, D) that would make the mempool look like this:</p>\n<pre data-code-height=\"146\" data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">graph TD;\n    A[Tx A: sz 2, fee 4.5]\n    C[Tx C: 1]--&gt;D[Tx D: 6];\n</code></pre>\n<p>Imagine specifically that D conflicts with B.</p>\n<p>Using the heuristic in the PR, we\u2019d say the package feerate of (C, D) is 3.5, which is greater than the ancestor feerate of B (9.5/3), and the total fee of (C, D) is 7, which is more than 5.</p>\n<p>However the feerate diagram does not strictly improve:</p>\n<p><img src=\"https://delvingbitcoin.org/uploads/default/original/1X/a2d23cd7b1b1b0ffa0c5c4eda9acc438b1dc11ee.png\" alt=\"Figure_1\" data-base62-sha1=\"nenMvioTTKmlkFRJ7LEYUDDiJC6\" width=\"640\" height=\"480\"></p>\n<p><strong>Issue 2: The rules proposed in <span class=\"hashtag-raw\">#28984</span> might be satisfied when validating a package (A, B), but might fail to successfully relay if A is valid in a peer\u2019s mempool and then B is evaluated using legacy RBF rules (as a singleton RBF).</strong></p>\n<p>Consider the same situation as above, but with feerates such that the package would pass validation rules (this could be accomplished by raising the fee for tx D sufficiently high).</p>\n<p>Now suppose that tx C would relay to our peers, because it has a high enough feerate that it passes the mempool min fee and minrelayfee.  Then using submitpackage (or package relay) to get (C, D) to our own node might still result in tx D failing to propagate, because once tx C propagates, then attempts to relay D will trigger the old RBF rules, which (in particular) prohibit an RBF that introduces a new unconfirmed parent.</p>\n<p>So it would seem that to make package RBF of (C, D) useful, users would need to ensure that C would not relay on its own (eg by making its feerate below the minrelayfee).</p>\n<p><strong>Issue 3: In the new cluster mempool world, the feerate diagram might be satisfied for a transaction package (A, B), but fail to relay successfully if A is valid in a peer\u2019s mempool and then B\u2019s RBF attempt is validated using feerate diagram rules (which can fail because the starting diagram for a peer might include tx A).</strong></p>\n<p>It turns out that the feerate diagram test might not be strictly improved if we are able to break up a transaction package into its parts.</p>\n<p>Consider this starting mempool, all transactions are the same size:</p>\n<pre data-code-height=\"146\" data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">graph TD;\n    A[Tx A: fee 1]--&gt;B[Tx B: fee 5]\n</code></pre>\n<p>And we are considering a new package (C, D) where D conflicts with B, which would bring the mempool to this:</p>\n<pre data-code-height=\"146\" data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">graph TD;\n    A[Tx A: fee 1]\n    C[Tx C: fee 3]--&gt;D[Tx D: fee 4]\n</code></pre>\n<p>This would pass the feerate diagram check if (C, D) is evaluated as a package against the starting mempool:</p>\n<p><img src=\"https://delvingbitcoin.org/uploads/default/original/1X/385aa59067fd105498639cbd96e3865d0a9a6370.png\" alt=\"Figure_2\" data-base62-sha1=\"82wWMpFJD6mZpkh0coQ0TnZMBb2\" width=\"640\" height=\"480\"></p>\n<p>However, if tx C were to relay on its own (it has no conflicts, so this is plausible), then the feerate diagram check for tx D versus a starting mempool of (A, B, C) would fail:</p>\n<p>[EDIT: just realized the total fee didn\u2019t go up, which is perhaps not a great example.]</p>\n<p><img src=\"https://delvingbitcoin.org/uploads/default/original/1X/8f4413a0eabb3d3ea44d40e74c2dcdfc79f80b71.png\" alt=\"Figure_3\" data-base62-sha1=\"kro8aVIGTnPqLnqTEPnS6UXB3P3\" width=\"640\" height=\"480\"></p>",
  "post_number": 23,
  "post_type": 1,
  "updated_at": "2023-12-12T21:56:07.748Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 5,
  "reads": 6,
  "readers_count": 5,
  "score": 26.2,
  "yours": false,
  "topic_id": 156,
  "topic_slug": "cluster-mempool-rbf-thoughts",
  "topic_title": "Cluster Mempool RBF Thoughts",
  "topic_html_title": "Cluster Mempool RBF Thoughts",
  "category_id": 9,
  "display_username": "Suhas Daftuar",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 3,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "(Not sure where else to put this, but wanted to log this somewhere)\n\nI was thinking about https://github.com/bitcoin/bitcoin/pull/28984, and realized just now that the RBF rules there for the cluster-size-2 case has the same sort of problem that I brought up here, with regard to the RBF heuristic not quite lining up with the feerate diagram test that we'd like to use in the future.\n\n**Issue 1: The feerate diagram might not improve using the rules described in #28984.**\n\nThis is similar to the example posted above. Imagine the starting mempool is:\n```mermaid height=146,auto\ngraph TD;\n    A[Tx A: sz 2, fee 4.5]-->B[Tx B: sz 1, fee 5];\n```\nAnd we want to process a package (C, D) that would make the mempool look like this:\n\n```mermaid height=146,auto\ngraph TD;\n    A[Tx A: sz 2, fee 4.5]\n    C[Tx C: 1]-->D[Tx D: 6];\n```\nImagine specifically that D conflicts with B.\n\nUsing the heuristic in the PR, we'd say the package feerate of (C, D) is 3.5, which is greater than the ancestor feerate of B (9.5/3), and the total fee of (C, D) is 7, which is more than 5.\n\nHowever the feerate diagram does not strictly improve:\n\n![Figure_1|640x480](upload://nenMvioTTKmlkFRJ7LEYUDDiJC6.png)\n\n**Issue 2: The rules proposed in #28984 might be satisfied when validating a package (A, B), but might fail to successfully relay if A is valid in a peer's mempool and then B is evaluated using legacy RBF rules (as a singleton RBF).**\n\nConsider the same situation as above, but with feerates such that the package would pass validation rules (this could be accomplished by raising the fee for tx D sufficiently high).  \n\nNow suppose that tx C would relay to our peers, because it has a high enough feerate that it passes the mempool min fee and minrelayfee.  Then using submitpackage (or package relay) to get (C, D) to our own node might still result in tx D failing to propagate, because once tx C propagates, then attempts to relay D will trigger the old RBF rules, which (in particular) prohibit an RBF that introduces a new unconfirmed parent.\n\nSo it would seem that to make package RBF of (C, D) useful, users would need to ensure that C would not relay on its own (eg by making its feerate below the minrelayfee).\n\n**Issue 3: In the new cluster mempool world, the feerate diagram might be satisfied for a transaction package (A, B), but fail to relay successfully if A is valid in a peer's mempool and then B's RBF attempt is validated using feerate diagram rules (which can fail because the starting diagram for a peer might include tx A).**\n\nIt turns out that the feerate diagram test might not be strictly improved if we are able to break up a transaction package into its parts.\n\nConsider this starting mempool, all transactions are the same size:\n\n```mermaid height=146,auto\ngraph TD;\n    A[Tx A: fee 1]-->B[Tx B: fee 5]\n```\n\nAnd we are considering a new package (C, D) where D conflicts with B, which would bring the mempool to this:\n\n```mermaid height=146,auto\ngraph TD;\n    A[Tx A: fee 1]\n    C[Tx C: fee 3]-->D[Tx D: fee 4]\n```\n\nThis would pass the feerate diagram check if (C, D) is evaluated as a package against the starting mempool:\n\n![Figure_2|640x480](upload://82wWMpFJD6mZpkh0coQ0TnZMBb2.png)\n\nHowever, if tx C were to relay on its own (it has no conflicts, so this is plausible), then the feerate diagram check for tx D versus a starting mempool of (A, B, C) would fail:\n\n[EDIT: just realized the total fee didn't go up, which is perhaps not a great example.]\n\n![Figure_3|640x480](upload://kro8aVIGTnPqLnqTEPnS6UXB3P3.png)",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 95,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}