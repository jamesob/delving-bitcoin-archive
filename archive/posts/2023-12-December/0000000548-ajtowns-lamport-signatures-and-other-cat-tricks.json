{
  "id": 548,
  "name": "Anthony Towns",
  "username": "ajtowns",
  "avatar_template": "/user_avatar/delvingbitcoin.org/ajtowns/{size}/3_2.png",
  "created_at": "2023-12-03T07:39:02.642Z",
  "cooked": "<p>This requires separate pushes of <code>0</code> or <code>1</code> for each level of each merkle tree to decide what branch you want. I don\u2019t think you can do better than that with just CAT, but if you had <code>DIVMOD</code> (takes <code>s1, s2</code> from the stack, pushes <code>int(s1/s2)</code> then <code>s1%s2</code> onto the stack; cf elements\u2019 <code>OP_DIV64</code>) you could provide a leaf number, and execute something like:</p>\n<p><code>ROT ROT 2 DIVMOD 2SWAP ROT IF SWAP ENDIF CAT HASH160</code></p>\n<p>to combine a path towards the root (starting stack is: <code>[path, n, hash]</code>). It\u2019s 6B more script per level, vs 2 bytes less witness data per level, so unlikely to be interesting unless you\u2019re running into stack size limits, or also adding a looping construct</p>\n<p>You could also consider an <code>OP_STR_LESSTHAN</code> that compares two byte vectors, and code it as <code>STR_LESSTHAN NOTIF SWAP ENDIF CAT HASH160</code>, and construct the merkle tree with an implicit order.</p>\n<p>I think your script\u2019s idea is:</p>\n<ul>\n<li>to create a single-use pubkey, you generate 20 byte commitments.</li>\n<li>for each byte commitment, you create a merkle tree where the leaves are \u201cnonce ++ byte\u201d</li>\n<li>the single-use pubkey is then the hash of the concatenation of its commitment roots</li>\n</ul>\n<p>To verify a signature, you then:</p>\n<ul>\n<li>for each byte of the message hash, you reveal the path to the nth commitment for the pubkey</li>\n<li>you combine the commitment roots to produce the single use pubkey</li>\n<li>you check the pubkey is what you expect</li>\n<li>you\u2019re left with the msg hash on the stack, which you might then verify by constructing a signature verification with R=P=G, or could compare directly with the result of <code>&lt;x&gt; TXHASH HASH160</code> or similar.</li>\n</ul>\n<p>There\u2019s a couple of stack optimisations you could do (you\u2019ve got a TOALT immediately followed by a FROMALT, eg), but I don\u2019t think there\u2019s much else to be done, without some sort of looping construct.</p>",
  "post_number": 2,
  "post_type": 1,
  "updated_at": "2023-12-03T07:39:02.642Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 2,
  "readers_count": 1,
  "score": 0.2,
  "yours": false,
  "topic_id": 236,
  "topic_slug": "lamport-signatures-and-other-cat-tricks",
  "topic_title": "Lamport signatures and other CAT tricks",
  "topic_html_title": "Lamport signatures and other CAT tricks",
  "category_id": 7,
  "display_username": "Anthony Towns",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "This requires separate pushes of `0` or `1` for each level of each merkle tree to decide what branch you want. I don't think you can do better than that with just CAT, but if you had `DIVMOD` (takes `s1, s2` from the stack, pushes `int(s1/s2)` then `s1%s2` onto the stack; cf elements' `OP_DIV64`) you could provide a leaf number, and execute something like:\n\n  `ROT ROT 2 DIVMOD 2SWAP ROT IF SWAP ENDIF CAT HASH160`\n\nto combine a path towards the root (starting stack is: `[path, n, hash]`). It's 6B more script per level, vs 2 bytes less witness data per level, so unlikely to be interesting unless you're running into stack size limits, or also adding a looping construct\n\nYou could also consider an `OP_STR_LESSTHAN` that compares two byte vectors, and code it as `STR_LESSTHAN NOTIF SWAP ENDIF CAT HASH160`, and construct the merkle tree with an implicit order.\n\nI think your script's idea is:\n * to create a single-use pubkey, you generate 20 byte commitments.\n * for each byte commitment, you create a merkle tree where the leaves are \"nonce ++ byte\"\n * the single-use pubkey is then the hash of the concatenation of its commitment roots\n\nTo verify a signature, you then:\n * for each byte of the message hash, you reveal the path to the nth commitment for the pubkey\n * you combine the commitment roots to produce the single use pubkey\n * you check the pubkey is what you expect\n * you're left with the msg hash on the stack, which you might then verify by constructing a signature verification with R=P=G, or could compare directly with the result of `<x> TXHASH HASH160` or similar.\n\nThere's a couple of stack optimisations you could do (you've got a TOALT immediately followed by a FROMALT, eg), but I don't think there's much else to be done, without some sort of looping construct.",
  "actions_summary": [],
  "moderator": true,
  "admin": true,
  "staff": true,
  "user_id": 3,
  "hidden": false,
  "trust_level": 4,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "heart",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}