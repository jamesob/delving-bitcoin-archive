{
  "id": 788,
  "name": "Pieter Wuille",
  "username": "sipa",
  "avatar_template": "/user_avatar/delvingbitcoin.org/sipa/{size}/102_2.png",
  "created_at": "2023-12-18T20:55:14.448Z",
  "cooked": "<h1><a name=\"how-to-linearize-your-cluster-1\" class=\"anchor\" href=\"#how-to-linearize-your-cluster-1\"></a>How to linearize your cluster</h1>\n<p>Most transaction clusters are small. At least today, the majority consist of just a single transaction, and those which aren\u2019t usually have no more than a few transactions.  We plan to set the cluster size limit so that even at the limit, the ancestor-set based linearization algorithm completes in a reasonable time. Yet, most clusters will be smaller, and better algorithms can be used.</p>\n<p>Here I build up an algorithm that eventually finds the optimal linearization. It can be run with a computation limit, in which case it\u2019ll find something at least as good as ancestor-set based linearization.</p>\n<div data-theme-toc=\"true\"> </div>\n<h2><a name=\"h-1-linearization-overall-2\" class=\"anchor\" href=\"#h-1-linearization-overall-2\"></a>1. Linearization overall</h2>\n<p>The most high-level description for pretty much any cluster linearization algorithm is:</p>\n<ul>\n<li>While there are remaining transactions:\n<ul>\n<li>Find a high-feerate subset of the remaining transactions in the cluster (or ideally, the highest-feerate)</li>\n<li>Sort that subset according to some topologically valid order (doesn\u2019t matter which one, so e.g. sorting by number of unconfirmed ancestors suffices), append those transactions to the output, and remove them from the cluster.</li>\n<li>Continue with the remainder of the cluster.</li>\n</ul>\n</li>\n<li>Optionally run a post-processing algorithm on the output, like <a href=\"https://delvingbitcoin.org/t/linearization-post-processing-o-n-2-fancy-chunking/201/8\">this one</a>.</li>\n</ul>\n<p>Almost all the complexity (both in the computational sense and the implementation complexity sense) is in the \u201cfind high-feerate subset\u201d algorithm. If we instantiate that with \u201cpick highest-feerate ancestor set\u201d, we get ancestor-set based linearization. The next section will go into finding better subsets, but first there are a few high-level improvements possible to the overall algorithm.</p>\n<p>In practice of course transactions aren\u2019t removed from the cluster, but instead of set of remaining transactions is kept, and all operations (connectivity checks, ancestor sets, descendant sets, \u2026) only care about the part of the cluster that remains. For readability we drop the <span class=\"math\">_G</span> index to <span class=\"math\">\\operatorname{anc}()</span> and <span class=\"math\">\\operatorname{desc}()</span>; it is always implicitly the part of the cluster that remains.</p>\n<h3><a name=\"h-11-splitting-in-connected-components-3\" class=\"anchor\" href=\"#h-11-splitting-in-connected-components-3\"></a>1.1 Splitting in connected components</h3>\n<p>A cluster is (by definition) always connected, but it need not remain connected once some subset of transactions have been included. For example:</p>\n<pre data-code-height=\"234\" data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">graph BT\n  A[\"A: 5\"];\n  B[\"B: 1 \"] --&gt; A;\n  C[\"C: 4\"] --&gt; B;\n  D[\"D: 2\"] --&gt; A;\n  E[\"E: 3\"] --&gt; D;\n</code></pre>\n<p>The highest-feerate subset is [A], but once that is included the cluster breaks apart into two components.</p>\n<p>Whenever the remainder of the cluster consists of multiple components, it is possible to run the linearization algorithm recursively on those components separately, and then merge them (by chunking  and merge-sorting the chunks).</p>\n<h3><a name=\"h-12-bottleneck-splitting-4\" class=\"anchor\" href=\"#h-12-bottleneck-splitting-4\"></a>1.2 Bottleneck splitting</h3>\n<p>Given a cluster <span class=\"math\">G</span>, define the set of its bottlenecks as</p>\n<div class=\"math\">\nB = \\bigcap_{x \\in S} \\operatorname{anc}_G(x) \\cup \\operatorname{desc}_G(x) \n</div>\n<p>These are the transactions that are either a descendant or an ancestor of every other transaction in the cluster. These transactions must be included in a fixed order, and by doing so, they partition the set into separate groups that can be linearized separately. For example</p>\n<pre data-code-height=\"167\" data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">graph RL\n  A;\n  B --&gt; A;\n  C --&gt; B; C --&gt; D;\n  D --&gt; A;\n  E --&gt; D;\n \n  F --&gt; C; F --&gt; E;\n  G --&gt; F;\n  H --&gt; F;\n  I --&gt; G; I --&gt; H;\n</code></pre>\n<p>In this example, A, F, and I are bottleneck transactions. If there is a single root which everything descends from, or a single leaf that descends from everything, these will necessarily be bottlenecks, but the concept is more general and can include inner transactions too, like F above.</p>\n<p>Bottleneck splitting consists of computing bottlenecks, and then linearizing the parts between them separately, and then combining them by concatenation. In a way, bottleneck splitting is the serial analogue of the parallel connected-component splitting. Here it would amount to invoking linearization recursively for BCDE and GH, and then outputting [A] + lin(BCDE) + [F] + lin(GH) + [I].</p>\n<p>I\u2019m not convinced bottleneck splitting is worth it as an optimization, as it only seems to help with clusters that are already relatively easy to linearize by what follows.</p>\n<h2><a name=\"h-2-finding-high-feerate-subsets-5\" class=\"anchor\" href=\"#h-2-finding-high-feerate-subsets-5\"></a>2. Finding high-feerate subsets</h2>\n<p>The bulk of the work is in the internal algorithm to find high-feerate subsets (or ideally, <em>the</em> highest-feerate subset). I conjecture that finding the highest-feerate subset is an NP-hard problem, so we\u2019re very likely limited to small (remainders of) clusters, or approximations.</p>\n<h3><a name=\"h-21-searching-6\" class=\"anchor\" href=\"#h-21-searching-6\"></a>2.1 Searching</h3>\n<p>Overall, the search for high-feerate subsets of a given (remainder of a) cluster <span class=\"math\">G</span> follows an approach where a set of work items is maintained, each of which corresponds to some definitely-included transactions, some definitely-excluded transactions, and some undecided transactions. Then a processing loop follows which in every iteration \u201csplits\u201d one work item in two: one where the transaction becomes included, and one where the transaction becomes excluded.</p>\n<ul>\n<li>Let <span class=\"math\">W = \\{(\\emptyset,\\emptyset)\\}</span>, the set of work items, initialized with a single element <span class=\"math\">(\\emptyset,\\emptyset)</span>.\n<ul>\n<li>Each work item <span class=\"math\">(inc,exc)</span> consists of two non-overlapping sets; <span class=\"math\">inc</span> represents transactions that have to be included, and <span class=\"math\">exc</span> represents transactions that cannot be included. Transactions that are not in either are undecided. <span class=\"math\">inc</span> always includes its own ancestors <span class=\"math\">(\\operatorname{anc}(inc)=inc)</span>, while <span class=\"math\">exc</span> always includes its own descendants <span class=\"math\">(\\operatorname{desc}(exc)=exc).</span></li>\n<li>The initial item <span class=\"math\">(\\emptyset,\\emptyset)</span> represents \u201ceverything undecided\u201d.</li>\n</ul>\n</li>\n<li>Set <span class=\"math\">best = \\emptyset</span>, the best subset seen so far.</li>\n<li>While <span class=\"math\">W</span> is non-empty and computation limit is not reached:\n<ul>\n<li>Take some work item <span class=\"math\">(inc, exc)</span> out of <span class=\"math\">W</span>.</li>\n<li>Find a transaction <span class=\"math\">t</span> not in <span class=\"math\">inc</span> and not in <span class=\"math\">exc</span> (an undecided one).</li>\n<li>Let <span class=\"math\">work_{add} = (inc \\cup \\operatorname{anc}(t), exc)</span>, the work item for <span class=\"math\">t</span> being included.</li>\n<li>Let <span class=\"math\">work_{del} = (inc, exc \\cup \\operatorname{desc}(t))</span>, the work item for <span class=\"math\">t</span> being excluded.</li>\n<li>For each <span class=\"math\">(inc_{new}, exc_{new}) \\in \\{work_{add}, work_{del}\\}</span>:\n<ul>\n<li>If <span class=\"math\">\\operatorname{feerate}(inc_{new}) &gt; \\operatorname{feerate}(best)</span> (or <span class=\"math\">best = \\emptyset</span>): set <span class=\"math\">best = inc_{new}</span>.</li>\n<li>If there are undecided transactions left corresponding to <span class=\"math\">(inc_{new}, exc_{new})</span>:\n<ul>\n<li>Add <span class=\"math\">(inc_{new}, exc_{new})</span> to <span class=\"math\">W</span>.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Return <span class=\"math\">best</span></li>\n</ul>\n<p>Regardless of the choice of element to take out of <span class=\"math\">W</span>, or the choice of undecided transaction <span class=\"math\">t</span> within it, this will iterate over all valid topological subsets of <span class=\"math\">G</span>, and thus put in <span class=\"math\">best</span> the actual best subset.</p>\n<p>It would be possible to restrict the choice of undecided transaction to only consider ones that share ancestry with <span class=\"math\">inc</span> (if non-empty). Doing so will make the algorithm only consider <em>connected</em> subsets, and we know at least one connected highest-feerate subset always exists. This would result in a moderate speedup as it reduces the search space, but interferes with a much more important improvement later.</p>\n<h3><a name=\"h-22-bounding-through-potential-sets-7\" class=\"anchor\" href=\"#h-22-bounding-through-potential-sets-7\"></a>2.2 Bounding through potential sets</h3>\n<p>To avoid iterating over literally every topological subset, we can compute a conservative upper bound on how good (the evolution of) each work item can get. If that is not better than <span class=\"math\">best</span>, the item can be discarded.</p>\n<p>This conservative upper bound is the <em>potential set</em> <span class=\"math\">pot</span>, which we will compute for every work item. For a given work item <span class=\"math\">(inc, exc)</span>, <span class=\"math\">pot</span> is the highest-feerate set among <em>all</em> sets (not just topologically valid ones) that are compatible with <span class=\"math\">inc</span> and <span class=\"math\">exc</span>: <span class=\"math\">inc \\subset pot</span> and <span class=\"math\">exc \\cap pot = \\emptyset</span>. This is easy to compute:</p>\n<ul>\n<li>Initialize <span class=\"math\">pot = inc</span>.</li>\n<li>For each <span class=\"math\">u</span> not in <span class=\"math\">pot</span> or <span class=\"math\">exc</span>, in decreasing individual feerate order:\n<ul>\n<li>If <span class=\"math\">\\operatorname{feerate}(u) &gt; \\operatorname{feerate}(pot)</span>: set <span class=\"math\">pot = pot \\cup \\{u\\}</span>.</li>\n<li>Otherwise, stop iterating.</li>\n</ul>\n</li>\n</ul>\n<p>Observe that all elements of <span class=\"math\">(pot \\setminus inc)</span> have a strictly higher feerate than <span class=\"math\">pot</span> itself (it\u2019s true for the last one added, and all previously-added ones have an even higher feerate), and all undecided elements not in <span class=\"math\">pot</span> have a feerate not exceeding <span class=\"math\">pot</span> (if they did, they\u2019d have been included). Thus, adding any other undecided transactions to <span class=\"math\">pot</span>, or removing any non-<span class=\"math\">inc</span> transactions from it, or any combination thereof, decreases its feerate. Therefore, it must be a maximum.</p>\n<p>Incorporating this into the search algorithm we get:</p>\n<ul>\n<li>Let <span class=\"math\">W = \\{(\\emptyset,\\emptyset)\\}</span>.</li>\n<li>Set <span class=\"math\">best = \\emptyset</span>.</li>\n<li>While <span class=\"math\">W</span> is non-empty and computation limit is not reached:\n<ul>\n<li>Take some work item <span class=\"math\">(inc, exc)</span> out of <span class=\"math\">W</span>.</li>\n<li>Set <span class=\"math\">pot = inc</span>.</li>\n<li>For each <span class=\"math\">u</span> not in <span class=\"math\">pot</span> or <span class=\"math\">exc</span>, in decreasing individual feerate order:\n<ul>\n<li>If <span class=\"math\">\\operatorname{feerate}(u) &gt; \\operatorname{feerate}(pot)</span>: set <span class=\"math\">pot = pot \\cup \\{u\\}</span>.</li>\n<li>Otherwise, stop iterating.</li>\n</ul>\n</li>\n<li>If <span class=\"math\">\\operatorname{feerate}(pot) &gt; \\operatorname{feerate}(best)</span> or <span class=\"math\">best = \\emptyset</span>:\n<ul>\n<li>Find a transaction <span class=\"math\">t</span> not in <span class=\"math\">inc</span> and not in <span class=\"math\">exc</span> to split on.</li>\n<li>Let <span class=\"math\">work_{add} = (inc \\cup \\operatorname{anc}(t), exc)</span>.</li>\n<li>Let <span class=\"math\">work_{del} = (inc, exc \\cup \\operatorname{desc}(t))</span>.</li>\n</ul>\n</li>\n<li>For each <span class=\"math\">(inc_{new}, exc_{new}) \\in \\{work_{add}, work_{del}\\}</span>:\n<ul>\n<li>If <span class=\"math\">\\operatorname{feerate}(inc_{new}) &gt; \\operatorname{feerate}(best)</span> or <span class=\"math\">best = \\emptyset</span>: set <span class=\"math\">best = inc_{new}</span>.</li>\n<li>If there are undecided transactions left (not in <span class=\"math\">inc_{new}</span> or <span class=\"math\">exc_{new}</span>):\n<ul>\n<li>Add <span class=\"math\">(inc_{new}, exc_{new})</span> to <span class=\"math\">W</span>.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Return <span class=\"math\">best</span></li>\n</ul>\n<p>This change helps the average case, but not the worst case, as it\u2019s always possible that the optimal subset is only found in the last iteration. However, it\u2019s a necessary preparation for the next improvement, which very much does improve the worst case.</p>\n<h3><a name=\"h-23-jumping-ahead-8\" class=\"anchor\" href=\"#h-23-jumping-ahead-8\"></a>2.3 Jumping ahead</h3>\n<p>The potential set, as introduced in the previous section, has an important property: its non-<span class=\"math\">inc</span> transactions each have a higher feerate than the highest-feerate set possible (compatible with the work item\u2019s <span class=\"math\">inc</span> and <span class=\"math\">exc</span>), even when ignoring topology. Thus, if one is given a compatible set which lacks one or more transactions in <span class=\"math\">(pot \\setminus inc)</span>, then adding those transactions will <em>always</em> be an improvement to the feerate.</p>\n<p>This implies that if <span class=\"math\">pot</span> contains any topologically-valid subset, that entire subset can be added to <span class=\"math\">inc</span> as well. This works because regardless of what this work item evolves into (by including or excluding elements in its undecided set), adding a subset of <span class=\"math\">pot</span> will always be an improvement. This effectively lets us jump ahead, by (possibly) including multiple transactions automatically without needing to split on each individually.</p>\n<p>We also move the computation of <span class=\"math\">pot</span> and updating of <span class=\"math\">best</span> inside the addition loop, as we want to perform the jumping as soon as possible and update <span class=\"math\">best</span> accordingly. This can replace the \u201cif there are undecided transactions left\u201d test, as a lack of undecided transactions implies <span class=\"math\">pot = inc</span>:</p>\n<ul>\n<li>Let <span class=\"math\">W = \\{(\\emptyset,\\emptyset)\\}</span>.</li>\n<li>Set <span class=\"math\">best = \\emptyset</span>.</li>\n<li>While <span class=\"math\">W</span> is non-empty and computation limit is not reached:\n<ul>\n<li>Take some work item <span class=\"math\">(inc, exc)</span> out of <span class=\"math\">W</span>.</li>\n<li>Find a transaction <span class=\"math\">t</span> not in <span class=\"math\">inc</span> or <span class=\"math\">exc</span> to split on; this must exist.</li>\n<li>Let <span class=\"math\">work_{add} = (inc \\cup \\operatorname{anc}(t), exc)</span>.</li>\n<li>Let <span class=\"math\">work_{del} = (inc, exc \\cup \\operatorname{desc}(t))</span>.</li>\n<li>For each <span class=\"math\">(inc_{new}, exc_{new}) \\in \\{work_{add}, work_{del}\\}</span>:\n<ul>\n<li>Set <span class=\"math\">pot_{new} = inc_{new}</span>.</li>\n<li>For each <span class=\"math\">u</span> not in <span class=\"math\">pot_{new}</span> or <span class=\"math\">exc_{new}</span>, in decreasing individual feerate order:\n<ul>\n<li>If <span class=\"math\">\\operatorname{feerate}(u) &gt; \\operatorname{feerate}(pot_{new})</span>: set <span class=\"math\">pot_{new} = pot_{new} \\cup \\{u\\}</span>.</li>\n<li>Otherwise, stop iterating.</li>\n</ul>\n</li>\n<li>For every transaction <span class=\"math\">p \\in (pot_{new} \\setminus inc_{new})</span>:\n<ul>\n<li>If <span class=\"math\">\\operatorname{anc}(p) \\subset pot_{new}</span>: set <span class=\"math\">inc_{new} = inc_{new} \\cup \\operatorname{anc}(p)</span>.</li>\n</ul>\n</li>\n<li>If <span class=\"math\">\\operatorname{feerate}(inc_{new}) &gt; \\operatorname{feerate}(best)</span> or <span class=\"math\">best = \\emptyset</span>: set <span class=\"math\">best = inc_{new}</span>.</li>\n<li>If <span class=\"math\">\\operatorname{feerate}(pot_{new}) &gt; \\operatorname{feerate}(best)</span>: add <span class=\"math\">(inc_{new}, exc_{new})</span> to <span class=\"math\">W</span>.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Return <span class=\"math\">best</span></li>\n</ul>\n<h3><a name=\"h-24-choosing-the-transaction-to-split-on-9\" class=\"anchor\" href=\"#h-24-choosing-the-transaction-to-split-on-9\"></a>2.4 Choosing the transaction to split on</h3>\n<p>One thing that is unspecified so far is how to pick <span class=\"math\">t</span>, the transaction being added to <span class=\"math\">inc</span> or <span class=\"math\">exc</span> in every iteration.</p>\n<p>The choice matters; there appear to be a number of \u201cgood\u201d choices which combined with the jump ahead optimization above result in an ~<span class=\"math\">\\mathcal{O}(1.6^n)</span> algorithm (purely empirical number, no proof), while others yield <span class=\"math\">\\mathcal{O}(2^n)</span>.</p>\n<p>These all appear to be good choices, with no meaningful differences for the worst case between them:</p>\n<ul>\n<li>Use as <span class=\"math\">t</span> the highest-individual-feerate undecided transaction.</li>\n<li>Use as <span class=\"math\">t</span> the transaction for which splitting on its minimizes the search space the most (first maximize\n<span class=\"math\">\\operatorname{min}(|exc|+|inc \\cup \\operatorname{anc}(t)|,|exc \\cup \\operatorname{desc}(t)|+|inc|)</span>, then maximize the <span class=\"math\">\\operatorname{max}</span> of those values). This can be done over:\n<ul>\n<li>All undecided transactions.</li>\n<li>All undecided transactions in <span class=\"math\">pot</span>.</li>\n<li>All undecided transactions that are ancestors or descendants of the highest-individual-feerate undecided transaction.</li>\n</ul>\n</li>\n</ul>\n<p>In particular the last two options appear to be good choices, with no clear winner among them. Specific clusters exist for which either of the algorithms performs significantly better than the other, but this works both ways.</p>\n<h3><a name=\"h-25-choosing-which-work-item-to-process-10\" class=\"anchor\" href=\"#h-25-choosing-which-work-item-to-process-10\"></a>2.5 Choosing which work item to process</h3>\n<p>Lots of heuristics for the choice of <span class=\"math\">(inc,exc) \\in W</span> are possible which can greatly affect the runtime in specific cases, but the worst case is unaffected by this choice.</p>\n<p>Thus it\u2019s reasonable to stick to a simple choice: treating <span class=\"math\">W</span> like a (LIFO) stack which work items get appended tot, and popped from. This effectively results in a depth first traversal of the search tree, with a stack size that cannot exceed the total number of transactions in the cluster. This is probably the best choice from a memory usage (and locality) perspective.</p>\n<p>If introducing randomness is desired (which may be the case if the algorithm is only given a bounded runtime), it\u2019s possible to instead treat <span class=\"math\">W</span> like a small (say, <span class=\"math\">k=4</span>) fixed-size array of <span class=\"math\">k</span> LIFO stacks, and picking from <span class=\"math\">W</span> and/or additions to it are appending to/popping from a random one. This retains DFS-ish behavior with (in almost all cases) only a small constant factor larger memory usage.</p>\n<h3><a name=\"h-26-caching-feerates-and-potential-sets-11\" class=\"anchor\" href=\"#h-26-caching-feerates-and-potential-sets-11\"></a>2.6 Caching feerates and potential sets</h3>\n<p>To avoid recomputing the feerates of the involved sets (<span class=\"math\">inc</span>, <span class=\"math\">pot</span>, and <span class=\"math\">best</span>, specifically), the fees and sizes can be precomputed and storing them alongside the sets themselves (including inside the work items). When sets are updated, e.g. in <span class=\"math\">inc = inc \\cup \\operatorname{anc}(t)</span>, only the fees and sizes of <span class=\"math\">(\\operatorname{anc}(t) \\setminus inc)</span> need to be looked up and added to the cached value.</p>\n<p>By extending our definition of work item to <span class=\"math\">(inc, exc, pot)</span>, which stores the potential set <span class=\"math\">pot</span> between its computation and the item being processed, more duplicate work can be avoided. A <span class=\"math\">pot_{new}</span> entry is added to the <span class=\"math\">work_{add}</span> and <span class=\"math\">work_{del}</span> variables, containing conservative subsets for <span class=\"math\">pot_{new}</span> in these branches.</p>\n<p>Finally, this also lets us move the check that <span class=\"math\">pot</span> has higher feerate than <span class=\"math\">best</span> to the beginning of the processing loop, which can catch cases where <span class=\"math\">best</span> improved between adding a work item and it being processed. The check inside the addition loop can be weakened to <span class=\"math\">pot \\neq inc</span>, which is sufficient to make sure undecided transactions remain, and faster than a feerate comparison.</p>\n<ul>\n<li>Let <span class=\"math\">W = \\{(\\emptyset,\\emptyset, \\emptyset)\\}</span>.</li>\n<li>Set <span class=\"math\">best = \\emptyset</span>.</li>\n<li>While <span class=\"math\">W</span> is non-empty and computation limit is not reached:\n<ul>\n<li>Take some work item <span class=\"math\">(inc, exc, pot)</span> out of <span class=\"math\">W</span>.</li>\n<li>If <span class=\"math\">\\operatorname{feerate}(pot) &gt; \\operatorname{feerate}(best)</span> or <span class=\"math\">best = \\emptyset</span>:\n<ul>\n<li>Find a transaction <span class=\"math\">t</span> not in <span class=\"math\">inc</span> or <span class=\"math\">exc</span> to split on; this must exist.</li>\n<li>Let <span class=\"math\">work_{add} = (inc \\cup \\operatorname{anc}(t), exc, pot \\cup \\operatorname{anc}(t))</span>.</li>\n<li>Let <span class=\"math\">work_{del} = (inc, exc \\cup \\operatorname{desc}(t), pot \\setminus \\operatorname{desc}(t))</span>.</li>\n<li>For each <span class=\"math\">(inc_{new}, exc_{new}, pot_{new}) \\in \\{work_{add}, work_{del}\\}</span>:\n<ul>\n<li>For each <span class=\"math\">u</span> not in <span class=\"math\">pot_{new}</span> or <span class=\"math\">exc_{new}</span>, in decreasing individual feerate order:\n<ul>\n<li>If <span class=\"math\">\\operatorname{feerate}(u) &gt; \\operatorname{feerate}(pot_{new})</span>: set <span class=\"math\">pot_{new} = pot_{new} \\cup \\{u\\}</span>.</li>\n<li>Otherwise, stop iterating.</li>\n</ul>\n</li>\n<li>For every transaction <span class=\"math\">p \\in (pot_{new} \\setminus inc_{new})</span>:\n<ul>\n<li>If <span class=\"math\">\\operatorname{anc}(p) \\subset pot_{new}</span>: set <span class=\"math\">inc_{new} = inc_{new} \\cup \\operatorname{anc}(p)</span>.</li>\n</ul>\n</li>\n<li>If <span class=\"math\">\\operatorname{feerate}(inc_{new}) &gt; \\operatorname{feerate}(best)</span> or <span class=\"math\">best = \\emptyset</span>: set <span class=\"math\">best = inc_{new}</span>.</li>\n<li>If <span class=\"math\">pot_{new} \\neq inc_{new}</span>: add <span class=\"math\">(inc_{new}, exc_{new}, pot_{new})</span> to <span class=\"math\">W</span>.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Return <span class=\"math\">best</span></li>\n</ul>\n<h3><a name=\"h-27-seeding-with-best-ancestor-sets-12\" class=\"anchor\" href=\"#h-27-seeding-with-best-ancestor-sets-12\"></a>2.7 Seeding with best ancestor sets</h3>\n<p>Under no circumstances do we want to end up with a <span class=\"math\">best</span> whose feerate is worse than the highest-feerate ancestor set, as that\u2019d mean we\u2019re worse off than just ancestor set based linearization. If the algorithm runs to completion (until <span class=\"math\">W = \\emptyset</span>), it will always find the optimal. But when running with a bound on computation, it is possible that the result is worse than ancestor-set based.</p>\n<p>To prevent that, it is possible to run ancestor set based linearization and a bounded version of the search algorithm developed so far and then <a href=\"https://delvingbitcoin.org/t/merging-incomparable-linearizations/209\">merge</a> the two, but a better and more efficient approach is to instead tweak the search algorithm to pre-split the initial work based on the best ancestor set:</p>\n<ul>\n<li>Find <span class=\"math\">a</span>, the transaction whose ancestor set feerate is highest.</li>\n<li>Let <span class=\"math\">W = \\{(\\operatorname{anc}(a), \\emptyset, \\operatorname{anc}(a)), (\\emptyset, \\operatorname{desc}(a), \\emptyset)\\}</span>.</li>\n<li>Let <span class=\"math\">best = \\operatorname{anc}(a)</span>.</li>\n<li>While <span class=\"math\">W</span> is non-empty \u2026</li>\n</ul>\n<p>An even better option is abstracting out the entire body of the \u201cFor each <span class=\"math\">(inc_{new}, exc_{new}, pot_{new})</span>\u201d loop to a helper that potentially updates <span class=\"math\">best</span> and potentially adds an element to <span class=\"math\">W</span>. This helper can then be invoked for the initial populating of <span class=\"math\">W</span> too; this makes the jump ahead optimization available to even that first step.</p>\n<p>Overall, this leaves us with:</p>\n<ul>\n<li>Let <span class=\"math\">W = \\emptyset</span>.</li>\n<li>Let <span class=\"math\">best = \\emptyset</span>.</li>\n<li>Define helper operation <span class=\"math\">\\operatorname{add}(inc_{new}, exc_{new}, pot_{new})</span> as:\n<ul>\n<li>For each <span class=\"math\">u</span> not in <span class=\"math\">pot_{new}</span> or <span class=\"math\">exc_{new}</span>, in decreasing individual feerate order:\n<ul>\n<li>If <span class=\"math\">\\operatorname{feerate}(u) &gt; \\operatorname{feerate}(pot_{new})</span>: set <span class=\"math\">pot_{new} = pot_{new} \\cup \\{u\\}</span>.</li>\n<li>Otherwise, stop iterating.</li>\n</ul>\n</li>\n<li>For every transaction <span class=\"math\">p \\in (pot_{new} \\setminus inc_{new})</span>:\n<ul>\n<li>If <span class=\"math\">\\operatorname{anc}(p) \\subset pot_{new}</span>: set <span class=\"math\">inc_{new} = inc_{new} \\cup \\operatorname{anc}(p)</span>.</li>\n</ul>\n</li>\n<li>If <span class=\"math\">\\operatorname{feerate}(inc_{new}) &gt; \\operatorname{feerate}(best)</span> or <span class=\"math\">best = \\emptyset</span>: set <span class=\"math\">best = inc_{new}</span>.</li>\n<li>If <span class=\"math\">pot_{new} \\neq inc_{new}</span>: add <span class=\"math\">(inc_{new}, exc_{new}, pot_{new})</span> to <span class=\"math\">W</span>.</li>\n</ul>\n</li>\n<li>Find <span class=\"math\">a</span>, the transaction whose ancestor set feerate is highest.</li>\n<li>Invoke <span class=\"math\">\\operatorname{add}(\\operatorname{anc}(a), \\emptyset, \\operatorname{anc}(a))</span>.</li>\n<li>Invoke <span class=\"math\">\\operatorname{add}(\\emptyset, \\operatorname{desc}(a), \\emptyset)</span>.</li>\n<li>While <span class=\"math\">W</span> is non-empty and computation limit is not reached:\n<ul>\n<li>Take some work item <span class=\"math\">(inc, exc, pot)</span> out of <span class=\"math\">W</span>.</li>\n<li>If <span class=\"math\">\\operatorname{feerate}(pot) &gt; \\operatorname{feerate}(best)</span>:\n<ul>\n<li>Find a transaction <span class=\"math\">t</span> not in <span class=\"math\">inc</span> or <span class=\"math\">exc</span> to split on; this must exist.</li>\n<li>Invoke <span class=\"math\">\\operatorname{add}(inc \\cup \\operatorname{anc}(t), exc, pot \\cup \\operatorname{anc}(t))</span>.</li>\n<li>Invoke <span class=\"math\">\\operatorname{add}(inc, exc \\cup \\operatorname{desc}(t), pot \\setminus \\operatorname{desc}(t))</span>.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Return <span class=\"math\">best</span>.</li>\n</ul>\n<h2><a name=\"h-3-current-implementation-13\" class=\"anchor\" href=\"#h-3-current-implementation-13\"></a>3. Current implementation</h2>\n<p>My current <a href=\"https://github.com/sipa/bitcoin/blob/wip_memepool_fuzz/src/cluster_linearize.h\">implementation</a> incorporates most of the ideas listed above, with a few deviations:</p>\n<ul>\n<li>The connected-component splitting isn\u2019t implemented for linearization in general, but done inside the find-high-feerate-subset algorithm. It\u2019s combined with the ancestor pre-seeding there (<span class=\"math\">W</span> is initialized with 2 elements per connected component: each excludes every other component, but one includes the component\u2019s best ancestor set, and one excludes the best ancestor set\u2019s transaction\u2019s descendants). This is somewhat suboptimal, as the find-high-feerate-subset algorithm only finds one subset, so in case there are multiple components, work for the later ones is duplicated. However, it was a lot simpler to implement than having the linearize code perform merging of multiple sublinearizations, and still beneficial.</li>\n<li>Newly added work items are added to one of <span class=\"math\">k=4</span> LIFO stacks, in a round-robin fashion. A uniformly random stack is chosen to pop work items to process from.</li>\n<li>The transaction to split on is, among the set of ancestors and descendants of the highest-individual-feerate undecided transaction, the one that minimizes the search space the most.</li>\n</ul>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2023-12-19T03:07:14.147Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 6,
  "readers_count": 5,
  "score": 1.2,
  "yours": false,
  "topic_id": 303,
  "topic_slug": "how-to-linearize-your-cluster",
  "topic_title": "How to linearize your cluster",
  "topic_html_title": "How to linearize your cluster",
  "category_id": 9,
  "display_username": "Pieter Wuille",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 18,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "# How to linearize your cluster\n\nMost transaction clusters are small. At least today, the majority consist of just a single transaction, and those which aren't usually have no more than a few transactions.  We plan to set the cluster size limit so that even at the limit, the ancestor-set based linearization algorithm completes in a reasonable time. Yet, most clusters will be smaller, and better algorithms can be used.\n\nHere I build up an algorithm that eventually finds the optimal linearization. It can be run with a computation limit, in which case it'll find something at least as good as ancestor-set based linearization.\n\n<div data-theme-toc=\"true\"> </div>\n\n## 1. Linearization overall\n\nThe most high-level description for pretty much any cluster linearization algorithm is:\n* While there are remaining transactions:\n  * Find a high-feerate subset of the remaining transactions in the cluster (or ideally, the highest-feerate)\n  * Sort that subset according to some topologically valid order (doesn't matter which one, so e.g. sorting by number of unconfirmed ancestors suffices), append those transactions to the output, and remove them from the cluster.\n  * Continue with the remainder of the cluster.\n* Optionally run a post-processing algorithm on the output, like [this one](https://delvingbitcoin.org/t/linearization-post-processing-o-n-2-fancy-chunking/201/8).\n\nAlmost all the complexity (both in the computational sense and the implementation complexity sense) is in the \"find high-feerate subset\" algorithm. If we instantiate that with \"pick highest-feerate ancestor set\", we get ancestor-set based linearization. The next section will go into finding better subsets, but first there are a few high-level improvements possible to the overall algorithm.\n\nIn practice of course transactions aren't removed from the cluster, but instead of set of remaining transactions is kept, and all operations (connectivity checks, ancestor sets, descendant sets, ...) only care about the part of the cluster that remains. For readability we drop the $_G$ index to $\\operatorname{anc}()$ and $\\operatorname{desc}()$; it is always implicitly the part of the cluster that remains.\n\n### 1.1 Splitting in connected components\n\nA cluster is (by definition) always connected, but it need not remain connected once some subset of transactions have been included. For example:\n\n```mermaid height=234,auto\ngraph BT\n  A[\"A: 5\"];\n  B[\"B: 1 \"] --> A;\n  C[\"C: 4\"] --> B;\n  D[\"D: 2\"] --> A;\n  E[\"E: 3\"] --> D;\n```\n\nThe highest-feerate subset is [A], but once that is included the cluster breaks apart into two components.\n\nWhenever the remainder of the cluster consists of multiple components, it is possible to run the linearization algorithm recursively on those components separately, and then merge them (by chunking  and merge-sorting the chunks).\n\n### 1.2 Bottleneck splitting\n\nGiven a cluster $G$, define the set of its bottlenecks as\n\n$$\nB = \\bigcap_{x \\in S} \\operatorname{anc}_G(x) \\cup \\operatorname{desc}_G(x) \n$$\n\nThese are the transactions that are either a descendant or an ancestor of every other transaction in the cluster. These transactions must be included in a fixed order, and by doing so, they partition the set into separate groups that can be linearized separately. For example\n\n```mermaid height=167,auto\ngraph RL\n  A;\n  B --> A;\n  C --> B; C --> D;\n  D --> A;\n  E --> D;\n \n  F --> C; F --> E;\n  G --> F;\n  H --> F;\n  I --> G; I --> H;\n```\n\nIn this example, A, F, and I are bottleneck transactions. If there is a single root which everything descends from, or a single leaf that descends from everything, these will necessarily be bottlenecks, but the concept is more general and can include inner transactions too, like F above.\n\nBottleneck splitting consists of computing bottlenecks, and then linearizing the parts between them separately, and then combining them by concatenation. In a way, bottleneck splitting is the serial analogue of the parallel connected-component splitting. Here it would amount to invoking linearization recursively for BCDE and GH, and then outputting [A] + lin(BCDE) + [F] + lin(GH) + [I].\n\nI'm not convinced bottleneck splitting is worth it as an optimization, as it only seems to help with clusters that are already relatively easy to linearize by what follows.\n\n## 2. Finding high-feerate subsets\n\nThe bulk of the work is in the internal algorithm to find high-feerate subsets (or ideally, *the* highest-feerate subset). I conjecture that finding the highest-feerate subset is an NP-hard problem, so we're very likely limited to small (remainders of) clusters, or approximations.\n\n### 2.1 Searching\n\nOverall, the search for high-feerate subsets of a given (remainder of a) cluster $G$ follows an approach where a set of work items is maintained, each of which corresponds to some definitely-included transactions, some definitely-excluded transactions, and some undecided transactions. Then a processing loop follows which in every iteration \"splits\" one work item in two: one where the transaction becomes included, and one where the transaction becomes excluded.\n\n* Let $W = \\{(\\emptyset,\\emptyset)\\}$, the set of work items, initialized with a single element $(\\emptyset,\\emptyset)$.\n  * Each work item $(inc,exc)$ consists of two non-overlapping sets; $inc$ represents transactions that have to be included, and $exc$ represents transactions that cannot be included. Transactions that are not in either are undecided. $inc$ always includes its own ancestors $(\\operatorname{anc}(inc)=inc)$, while $exc$ always includes its own descendants $(\\operatorname{desc}(exc)=exc).$\n  * The initial item $(\\emptyset,\\emptyset)$ represents \"everything undecided\".\n* Set $best = \\emptyset$, the best subset seen so far.\n* While $W$ is non-empty and computation limit is not reached:\n  * Take some work item $(inc, exc)$ out of $W$.\n  * Find a transaction $t$ not in $inc$ and not in $exc$ (an undecided one).\n  * Let $work_{add} = (inc \\cup \\operatorname{anc}(t), exc)$, the work item for $t$ being included.\n  * Let $work_{del} = (inc, exc \\cup \\operatorname{desc}(t))$, the work item for $t$ being excluded.\n  * For each $(inc_{new}, exc_{new}) \\in \\{work_{add}, work_{del}\\}$:\n    * If $\\operatorname{feerate}(inc_{new}) > \\operatorname{feerate}(best)$ (or $best = \\emptyset$): set $best = inc_{new}$.\n    * If there are undecided transactions left corresponding to $(inc_{new}, exc_{new})$:\n      * Add $(inc_{new}, exc_{new})$ to $W$.\n* Return $best$\n\nRegardless of the choice of element to take out of $W$, or the choice of undecided transaction $t$ within it, this will iterate over all valid topological subsets of $G$, and thus put in $best$ the actual best subset.\n\nIt would be possible to restrict the choice of undecided transaction to only consider ones that share ancestry with $inc$ (if non-empty). Doing so will make the algorithm only consider *connected* subsets, and we know at least one connected highest-feerate subset always exists. This would result in a moderate speedup as it reduces the search space, but interferes with a much more important improvement later.\n\n### 2.2 Bounding through potential sets\n\nTo avoid iterating over literally every topological subset, we can compute a conservative upper bound on how good (the evolution of) each work item can get. If that is not better than $best$, the item can be discarded.\n\nThis conservative upper bound is the *potential set* $pot$, which we will compute for every work item. For a given work item $(inc, exc)$, $pot$ is the highest-feerate set among *all* sets (not just topologically valid ones) that are compatible with $inc$ and $exc$: $inc \\subset pot$ and $exc \\cap pot = \\emptyset$. This is easy to compute:\n* Initialize $pot = inc$.\n* For each $u$ not in $pot$ or $exc$, in decreasing individual feerate order:\n  * If $\\operatorname{feerate}(u) > \\operatorname{feerate}(pot)$: set $pot = pot \\cup \\{u\\}$.\n  * Otherwise, stop iterating.\n\nObserve that all elements of $(pot \\setminus inc)$ have a strictly higher feerate than $pot$ itself (it's true for the last one added, and all previously-added ones have an even higher feerate), and all undecided elements not in $pot$ have a feerate not exceeding $pot$ (if they did, they'd have been included). Thus, adding any other undecided transactions to $pot$, or removing any non-$inc$ transactions from it, or any combination thereof, decreases its feerate. Therefore, it must be a maximum.\n\nIncorporating this into the search algorithm we get:\n\n* Let $W = \\{(\\emptyset,\\emptyset)\\}$.\n* Set $best = \\emptyset$.\n* While $W$ is non-empty and computation limit is not reached:\n  * Take some work item $(inc, exc)$ out of $W$.\n  * Set $pot = inc$.\n  * For each $u$ not in $pot$ or $exc$, in decreasing individual feerate order:\n    * If $\\operatorname{feerate}(u) > \\operatorname{feerate}(pot)$: set $pot = pot \\cup \\{u\\}$.\n    * Otherwise, stop iterating.\n  * If $\\operatorname{feerate}(pot) > \\operatorname{feerate}(best)$ or $best = \\emptyset$:\n    * Find a transaction $t$ not in $inc$ and not in $exc$ to split on.\n    * Let $work_{add} = (inc \\cup \\operatorname{anc}(t), exc)$.\n    * Let $work_{del} = (inc, exc \\cup \\operatorname{desc}(t))$.\n  * For each $(inc_{new}, exc_{new}) \\in \\{work_{add}, work_{del}\\}$:\n    * If $\\operatorname{feerate}(inc_{new}) > \\operatorname{feerate}(best)$ or $best = \\emptyset$: set $best = inc_{new}$.\n    * If there are undecided transactions left (not in $inc_{new}$ or $exc_{new}$):\n      * Add $(inc_{new}, exc_{new})$ to $W$.\n* Return $best$\n\nThis change helps the average case, but not the worst case, as it's always possible that the optimal subset is only found in the last iteration. However, it's a necessary preparation for the next improvement, which very much does improve the worst case.\n\n### 2.3 Jumping ahead\n\nThe potential set, as introduced in the previous section, has an important property: its non-$inc$ transactions each have a higher feerate than the highest-feerate set possible (compatible with the work item's $inc$ and $exc$), even when ignoring topology. Thus, if one is given a compatible set which lacks one or more transactions in $(pot \\setminus inc)$, then adding those transactions will *always* be an improvement to the feerate.\n\nThis implies that if $pot$ contains any topologically-valid subset, that entire subset can be added to $inc$ as well. This works because regardless of what this work item evolves into (by including or excluding elements in its undecided set), adding a subset of $pot$ will always be an improvement. This effectively lets us jump ahead, by (possibly) including multiple transactions automatically without needing to split on each individually.\n\nWe also move the computation of $pot$ and updating of $best$ inside the addition loop, as we want to perform the jumping as soon as possible and update $best$ accordingly. This can replace the \"if there are undecided transactions left\" test, as a lack of undecided transactions implies $pot = inc$:\n\n* Let $W = \\{(\\emptyset,\\emptyset)\\}$.\n* Set $best = \\emptyset$.\n* While $W$ is non-empty and computation limit is not reached:\n  * Take some work item $(inc, exc)$ out of $W$.\n  * Find a transaction $t$ not in $inc$ or $exc$ to split on; this must exist.\n  * Let $work_{add} = (inc \\cup \\operatorname{anc}(t), exc)$.\n  * Let $work_{del} = (inc, exc \\cup \\operatorname{desc}(t))$.\n  * For each $(inc_{new}, exc_{new}) \\in \\{work_{add}, work_{del}\\}$:\n    * Set $pot_{new} = inc_{new}$.\n    * For each $u$ not in $pot_{new}$ or $exc_{new}$, in decreasing individual feerate order:\n      * If $\\operatorname{feerate}(u) > \\operatorname{feerate}(pot_{new})$: set $pot_{new} = pot_{new} \\cup \\{u\\}$.\n      * Otherwise, stop iterating.\n    * For every transaction $p \\in (pot_{new} \\setminus inc_{new})$:\n      * If $\\operatorname{anc}(p) \\subset pot_{new}$: set $inc_{new} = inc_{new} \\cup \\operatorname{anc}(p)$.\n    * If $\\operatorname{feerate}(inc_{new}) > \\operatorname{feerate}(best)$ or $best = \\emptyset$: set $best = inc_{new}$.\n    * If $\\operatorname{feerate}(pot_{new}) > \\operatorname{feerate}(best)$: add $(inc_{new}, exc_{new})$ to $W$.\n* Return $best$\n\n### 2.4 Choosing the transaction to split on\n\nOne thing that is unspecified so far is how to pick $t$, the transaction being added to $inc$ or $exc$ in every iteration.\n\nThe choice matters; there appear to be a number of \"good\" choices which combined with the jump ahead optimization above result in an ~$\\mathcal{O}(1.6^n)$ algorithm (purely empirical number, no proof), while others yield $\\mathcal{O}(2^n)$.\n\nThese all appear to be good choices, with no meaningful differences for the worst case between them:\n* Use as $t$ the highest-individual-feerate undecided transaction.\n* Use as $t$ the transaction for which splitting on its minimizes the search space the most (first maximize \n$\\operatorname{min}(|exc|+|inc \\cup \\operatorname{anc}(t)|,|exc \\cup \\operatorname{desc}(t)|+|inc|)$, then maximize the $\\operatorname{max}$ of those values). This can be done over:\n  * All undecided transactions.\n  * All undecided transactions in $pot$.\n  * All undecided transactions that are ancestors or descendants of the highest-individual-feerate undecided transaction.\n\nIn particular the last two options appear to be good choices, with no clear winner among them. Specific clusters exist for which either of the algorithms performs significantly better than the other, but this works both ways.\n\n### 2.5 Choosing which work item to process\n\nLots of heuristics for the choice of $(inc,exc) \\in W$ are possible which can greatly affect the runtime in specific cases, but the worst case is unaffected by this choice.\n\nThus it's reasonable to stick to a simple choice: treating $W$ like a (LIFO) stack which work items get appended tot, and popped from. This effectively results in a depth first traversal of the search tree, with a stack size that cannot exceed the total number of transactions in the cluster. This is probably the best choice from a memory usage (and locality) perspective.\n\nIf introducing randomness is desired (which may be the case if the algorithm is only given a bounded runtime), it's possible to instead treat $W$ like a small (say, $k=4$) fixed-size array of $k$ LIFO stacks, and picking from $W$ and/or additions to it are appending to/popping from a random one. This retains DFS-ish behavior with (in almost all cases) only a small constant factor larger memory usage.\n\n### 2.6 Caching feerates and potential sets\n\nTo avoid recomputing the feerates of the involved sets ($inc$, $pot$, and $best$, specifically), the fees and sizes can be precomputed and storing them alongside the sets themselves (including inside the work items). When sets are updated, e.g. in $inc = inc \\cup \\operatorname{anc}(t)$, only the fees and sizes of $(\\operatorname{anc}(t) \\setminus inc)$ need to be looked up and added to the cached value.\n\nBy extending our definition of work item to $(inc, exc, pot)$, which stores the potential set $pot$ between its computation and the item being processed, more duplicate work can be avoided. A $pot_{new}$ entry is added to the $work_{add}$ and $work_{del}$ variables, containing conservative subsets for $pot_{new}$ in these branches.\n\nFinally, this also lets us move the check that $pot$ has higher feerate than $best$ to the beginning of the processing loop, which can catch cases where $best$ improved between adding a work item and it being processed. The check inside the addition loop can be weakened to $pot \\neq inc$, which is sufficient to make sure undecided transactions remain, and faster than a feerate comparison.\n\n* Let $W = \\{(\\emptyset,\\emptyset, \\emptyset)\\}$.\n* Set $best = \\emptyset$.\n* While $W$ is non-empty and computation limit is not reached:\n  * Take some work item $(inc, exc, pot)$ out of $W$.\n  * If $\\operatorname{feerate}(pot) > \\operatorname{feerate}(best)$ or $best = \\emptyset$:\n    * Find a transaction $t$ not in $inc$ or $exc$ to split on; this must exist.\n    * Let $work_{add} = (inc \\cup \\operatorname{anc}(t), exc, pot \\cup \\operatorname{anc}(t))$.\n    * Let $work_{del} = (inc, exc \\cup \\operatorname{desc}(t), pot \\setminus \\operatorname{desc}(t))$.\n    * For each $(inc_{new}, exc_{new}, pot_{new}) \\in \\{work_{add}, work_{del}\\}$:\n      * For each $u$ not in $pot_{new}$ or $exc_{new}$, in decreasing individual feerate order:\n        * If $\\operatorname{feerate}(u) > \\operatorname{feerate}(pot_{new})$: set $pot_{new} = pot_{new} \\cup \\{u\\}$.\n        * Otherwise, stop iterating.\n      * For every transaction $p \\in (pot_{new} \\setminus inc_{new})$:\n        * If $\\operatorname{anc}(p) \\subset pot_{new}$: set $inc_{new} = inc_{new} \\cup \\operatorname{anc}(p)$.\n      * If $\\operatorname{feerate}(inc_{new}) > \\operatorname{feerate}(best)$ or $best = \\emptyset$: set $best = inc_{new}$.\n      * If $pot_{new} \\neq inc_{new}$: add $(inc_{new}, exc_{new}, pot_{new})$ to $W$.\n* Return $best$\n\n### 2.7 Seeding with best ancestor sets\n\nUnder no circumstances do we want to end up with a $best$ whose feerate is worse than the highest-feerate ancestor set, as that'd mean we're worse off than just ancestor set based linearization. If the algorithm runs to completion (until $W = \\emptyset$), it will always find the optimal. But when running with a bound on computation, it is possible that the result is worse than ancestor-set based.\n\nTo prevent that, it is possible to run ancestor set based linearization and a bounded version of the search algorithm developed so far and then [merge](https://delvingbitcoin.org/t/merging-incomparable-linearizations/209) the two, but a better and more efficient approach is to instead tweak the search algorithm to pre-split the initial work based on the best ancestor set:\n* Find $a$, the transaction whose ancestor set feerate is highest.\n* Let $W = \\{(\\operatorname{anc}(a), \\emptyset, \\operatorname{anc}(a)), (\\emptyset, \\operatorname{desc}(a), \\emptyset)\\}$.\n* Let $best = \\operatorname{anc}(a)$.\n* While $W$ is non-empty ...\n\nAn even better option is abstracting out the entire body of the \"For each $(inc_{new}, exc_{new}, pot_{new})$\" loop to a helper that potentially updates $best$ and potentially adds an element to $W$. This helper can then be invoked for the initial populating of $W$ too; this makes the jump ahead optimization available to even that first step.\n\nOverall, this leaves us with:\n* Let $W = \\emptyset$.\n* Let $best = \\emptyset$.\n* Define helper operation $\\operatorname{add}(inc_{new}, exc_{new}, pot_{new})$ as:\n  * For each $u$ not in $pot_{new}$ or $exc_{new}$, in decreasing individual feerate order:\n    * If $\\operatorname{feerate}(u) > \\operatorname{feerate}(pot_{new})$: set $pot_{new} = pot_{new} \\cup \\{u\\}$.\n    * Otherwise, stop iterating.\n  * For every transaction $p \\in (pot_{new} \\setminus inc_{new})$:\n    * If $\\operatorname{anc}(p) \\subset pot_{new}$: set $inc_{new} = inc_{new} \\cup \\operatorname{anc}(p)$.\n  * If $\\operatorname{feerate}(inc_{new}) > \\operatorname{feerate}(best)$ or $best = \\emptyset$: set $best = inc_{new}$.\n  * If $pot_{new} \\neq inc_{new}$: add $(inc_{new}, exc_{new}, pot_{new})$ to $W$.\n* Find $a$, the transaction whose ancestor set feerate is highest.\n* Invoke $\\operatorname{add}(\\operatorname{anc}(a), \\emptyset, \\operatorname{anc}(a))$.\n* Invoke $\\operatorname{add}(\\emptyset, \\operatorname{desc}(a), \\emptyset)$.\n* While $W$ is non-empty and computation limit is not reached:\n  * Take some work item $(inc, exc, pot)$ out of $W$.\n  * If $\\operatorname{feerate}(pot) > \\operatorname{feerate}(best)$:\n    * Find a transaction $t$ not in $inc$ or $exc$ to split on; this must exist.\n    * Invoke $\\operatorname{add}(inc \\cup \\operatorname{anc}(t), exc, pot \\cup \\operatorname{anc}(t))$.\n    * Invoke $\\operatorname{add}(inc, exc \\cup \\operatorname{desc}(t), pot \\setminus \\operatorname{desc}(t))$.\n* Return $best$.\n\n## 3. Current implementation\n\nMy current [implementation](https://github.com/sipa/bitcoin/blob/wip_memepool_fuzz/src/cluster_linearize.h) incorporates most of the ideas listed above, with a few deviations:\n* The connected-component splitting isn't implemented for linearization in general, but done inside the find-high-feerate-subset algorithm. It's combined with the ancestor pre-seeding there ($W$ is initialized with 2 elements per connected component: each excludes every other component, but one includes the component's best ancestor set, and one excludes the best ancestor set's transaction's descendants). This is somewhat suboptimal, as the find-high-feerate-subset algorithm only finds one subset, so in case there are multiple components, work for the later ones is duplicated. However, it was a lot simpler to implement than having the linearize code perform merging of multiple sublinearizations, and still beneficial.\n* Newly added work items are added to one of $k=4$ LIFO stacks, in a round-robin fashion. A uniformly random stack is chosen to pop work items to process from.\n* The transaction to split on is, among the set of ancestors and descendants of the highest-individual-feerate undecided transaction, the one that minimizes the search space the most.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 96,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "open_mouth",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}