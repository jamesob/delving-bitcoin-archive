{
  "id": 1406,
  "name": "Gregory Sanders",
  "username": "instagibbs",
  "avatar_template": "/user_avatar/delvingbitcoin.org/instagibbs/{size}/28_2.png",
  "created_at": "2024-02-01T16:50:52.610Z",
  "cooked": "<p>We\u2019re going to take a look through many of the common\nfee tropes that wallets and smart contracts use and hopefully\nfigure out a more common language in how we discuss these\nrather than just \u201cCPFP vs RBF\u201d. For mempool design, this\nis important as we should be looking to support what users\nare attempting to make, where reasonable, to avoid out-of-band fee solutions.\nThis becomes even\nmore important as people discuss the design characteristics\nof covenants proposals, and their potential Bitcoin-scaling\nbenefits.</p>\n<p>For this post, \u201csmart contracts\u201d can also simply\nbe understood as logical transactions: people\nwant some state change effectuated, and they\nmay make otherwise-unrelated logical transactions\nto pay fees for them.</p>\n<p>In the below diagrams, green\narrows indicate where fees are \u201ccoming from\u201d.</p>\n<h1><a name=\"endogenous-fees-single-transaction-rbf-1\" class=\"anchor\" href=\"#endogenous-fees-single-transaction-rbf-1\"></a>Endogenous fees, single transaction RBF</h1>\n<p>These bring fees from \u201cinside\u201d the logical transaction\nwhich also happens to be a single Bitcoin transaction.</p>\n<pre data-code-height=\"450\" data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">flowchart TD\n    Pi4([state_i]) -.-&gt;|conflicted| P4[Endo fees, Single RBF]\n    P4 --&gt; Po4([state_i+1])\n    \n    linkStyle 0 stroke-width:4px,stroke:green\n    linkStyle 1 stroke-width:4px,stroke:green\n</code></pre>\n<p>This is the most basic setup, and includes things like\nsimple wallet sends, up to non-anchor ln-penalty channels.\nThey are \u201cmaximally\u201d compact in that fee-sizing aside,\nthe transaction itself is quite compact.</p>\n<h1><a name=\"exogenous-fees-single-transaction-rbf-2\" class=\"anchor\" href=\"#exogenous-fees-single-transaction-rbf-2\"></a>Exogenous fees, single transaction RBF</h1>\n<p>These bring fees from outside the smart contract, but contain\nit within a single Bitcoin transaction.</p>\n<pre data-code-height=\"450\" data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">flowchart TD\n    Pi5([state_i]) -.-&gt;|conflicted| P5[Exo fees, Single RBF]\n    Pi5_2([fee input])--&gt; P5\n    P5 --&gt; Po5([state_i+1])\n    P5 --&gt; Co5([change])\n    \n    linkStyle 1 stroke-width:4px,stroke:green\n    linkStyle 3 stroke-width:4px,stroke:green\n</code></pre>\n<p>Typically seen with <code>SIGHASH_SINGLE | ANYONCANPAY</code> arrangements.</p>\n<p>Examples in LN spec HTLC presigned transactions,\nln-symmetry \u201cupdate\u201d transactions, Murcery Wallet\u2019s\nstatechains, degen NFT trades, and likely more.</p>\n<p>Keeping it within a single transaction saves a bit\nof overhead vs other strategies, but requires additional\ninputs and possibly an output to be added.</p>\n<p>Without additional mitigations it can</p>\n<p>Both single-transaction RBF types benefit\nfrom simplicity of the RBF case in today\u2019s\nmempool and relay policies.</p>\n<h1><a name=\"endogenous-fees-cpfp-3\" class=\"anchor\" href=\"#endogenous-fees-cpfp-3\"></a>Endogenous fees, CPFP</h1>\n<p>Fees are brought from within the parent\ntransaction, with no requirements to\nresolve a conflict from the parent\u2019s\ninput set.</p>\n<pre data-code-height=\"450\" data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">flowchart TD\n    Pi3([state_i]) --&gt; P3[parent]\n    P3 --&gt; Po3([state_i+1])\n    Po3 --&gt; C3[Endo fees, CPFP]\n    C3 --&gt; Co3([change])\n    \n    linkStyle 2 stroke-width:4px,stroke:green\n    linkStyle 3 stroke-width:4px,stroke:green\n</code></pre>\n<p>This is most applicable to when the parent\ntransaction is not under the control of the\nuser making the CPFP, or when replacing\nit would be too expensive, disallowing RBF.</p>\n<p>A common use-case would be users receiving\na transaction from someone and the sender\nunwilling or unable to increase the fee\nthemselves. ln-symmetry settlement\ntransactions have all outputs freely spendable,\nalso allowing endogenous spends.\nAnother would be fee bumping\nan LN remote transaction using your own\nbalance output in pre-anchor channels.</p>\n<h1><a name=\"exogenous-fees-cpfp-4\" class=\"anchor\" href=\"#exogenous-fees-cpfp-4\"></a>Exogenous fees, CPFP</h1>\n<p>Same use-cases as above, but perhaps\nsome outputs in the smart contract\nare unable to be spent due to locktimes\nor other factors.</p>\n<pre data-code-height=\"450\" data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">flowchart TD\n    Pi([state_i]) --&gt; P[parent]\n    P --&gt; Po([state_i+1])\n    Po --&gt; C[Exo fees, CPFP]\n    fee([fee input]) --&gt; C\n    C --&gt; Co([change])\n    \n    linkStyle 3 stroke-width:4px,stroke:green\n    linkStyle 4 stroke-width:4px,stroke:green\n</code></pre>\n<p>We see this pattern in today\u2019s LN anchor channels\nwhich requires all fees to be exogenous to avoid\npinning scenarios.</p>\n<h1><a name=\"endogenous-fees-package-rbf-5\" class=\"anchor\" href=\"#endogenous-fees-package-rbf-5\"></a>Endogenous fees, Package RBF</h1>\n<p>\u201cPackage RBF\u201d is a term to describe the combination\nof CPFP and package RBF, where the child is paying\nfor the parent\u2019s conflict.</p>\n<p>If the smart contract\u2019s outputs are otherwise\nunencumbered, fees can be paid for endogenously.</p>\n<pre data-code-height=\"450\" data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">flowchart TD\n    Pi6([state_i]) -.-&gt;|conflicted| P6[parent]\n    P6 --&gt; Po6([state_i+1])\n    Po6 --&gt; C6[Endo fees, package RBF]\n    C6 --&gt; Co6([change])\n    \n    linkStyle 2 stroke-width:4px,stroke:green\n    linkStyle 3 stroke-width:4px,stroke:green\n</code></pre>\n<p>Currently this is unavailable to Bitcoin\u2019s\nvarious mempool implementations as this requires\nevaluation of entire packages, but users of this\nwould be LN for commitment transactions plus\nfee paying child if outputs became otherwise\nunencumbered by a one block relative timelock.</p>\n<h1><a name=\"exogenous-fees-package-rbf-6\" class=\"anchor\" href=\"#exogenous-fees-package-rbf-6\"></a>Exogenous fees, Package RBF</h1>\n<pre data-code-height=\"432\" data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">flowchart TD\n    Pi2([state_i]) -.-&gt;|conflicted| P2[parent]\n    P2 --&gt; Po2([state_i+1])\n    Po2 --&gt; C2[Exo fees, package RBF]\n    fee2([fee input]) --&gt; C2\n    C2 --&gt; Co2([change])\n    \n    linkStyle 3 stroke-width:4px,stroke:green\n    linkStyle 4 stroke-width:4px,stroke:green\n</code></pre>\n<p>Today\u2019s LN anchor channels is the primary example.</p>\n<h1><a name=\"composeable-transaction-structures-7\" class=\"anchor\" href=\"#composeable-transaction-structures-7\"></a>Composeable Transaction Structures</h1>\n<p>Not all smart contract paradigms use the parent and child scheme.</p>\n<p>For example, there are a number of schemes involving either pre-signed or\nCTV-encumbered transaction trees.</p>\n<p>These transaction trees will end up fitting in these above\nbuckets in different ways, depending on tradeoffs like usual:</p>\n<ol>\n<li>Are we able to relay and get package evaluation for the final package?</li>\n<li>Are the ultimate (\u201cvirtual\u201d)UTXOs immediately spendable, allowing endogenous fees?</li>\n<li>Do we need <a href=\"https://delvingbitcoin.org/t/sibling-eviction-for-v3-transactions/472/9\">sibling eviction</a> to avoid cluster limits? How would it need to differ from v3-style sibling eviction?</li>\n</ol>\n<p>Composing these ideas, you could imagine a Timeout Tree where the leaf nodes use\nEndogenous, single transaction RBF-compatible channels, and if users want to go to\nchain, it composes to endogenous fees paying for the CPFP, and exercising package\nRBF if sibling eviction becomes required or any ancestor input in the chain was conflicted. This unilateral exit could also be used to pay for a separate exogenously-fee-settled smart contract that has failed.</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2024-02-01T16:52:08.683Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 41,
  "reads": 25,
  "readers_count": 24,
  "score": 220.0,
  "yours": false,
  "topic_id": 512,
  "topic_slug": "taxonomy-of-transaction-fees-in-smart-contracts",
  "topic_title": "Taxonomy of Transaction Fees in Smart Contracts",
  "topic_html_title": "Taxonomy of Transaction Fees in Smart Contracts",
  "category_id": 7,
  "display_username": "Gregory Sanders",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "We're going to take a look through many of the common\nfee tropes that wallets and smart contracts use and hopefully\nfigure out a more common language in how we discuss these\nrather than just \"CPFP vs RBF\". For mempool design, this\nis important as we should be looking to support what users\nare attempting to make, where reasonable, to avoid out-of-band fee solutions.\nThis becomes even\nmore important as people discuss the design characteristics\nof covenants proposals, and their potential Bitcoin-scaling\nbenefits.\n\nFor this post, \"smart contracts\" can also simply\nbe understood as logical transactions: people\nwant some state change effectuated, and they\nmay make otherwise-unrelated logical transactions\nto pay fees for them.\n\nIn the below diagrams, green\narrows indicate where fees are \"coming from\".\n\n# Endogenous fees, single transaction RBF\n\nThese bring fees from \"inside\" the logical transaction\nwhich also happens to be a single Bitcoin transaction.\n\n```mermaid height=450,auto\nflowchart TD\n    Pi4([state_i]) -.->|conflicted| P4[Endo fees, Single RBF]\n    P4 --> Po4([state_i+1])\n    \n    linkStyle 0 stroke-width:4px,stroke:green\n    linkStyle 1 stroke-width:4px,stroke:green\n```\n\nThis is the most basic setup, and includes things like\nsimple wallet sends, up to non-anchor ln-penalty channels.\nThey are \"maximally\" compact in that fee-sizing aside,\nthe transaction itself is quite compact.\n\n# Exogenous fees, single transaction RBF\n\nThese bring fees from outside the smart contract, but contain\nit within a single Bitcoin transaction.\n\n```mermaid height=450,auto\nflowchart TD\n    Pi5([state_i]) -.->|conflicted| P5[Exo fees, Single RBF]\n    Pi5_2([fee input])--> P5\n    P5 --> Po5([state_i+1])\n    P5 --> Co5([change])\n    \n    linkStyle 1 stroke-width:4px,stroke:green\n    linkStyle 3 stroke-width:4px,stroke:green\n```\n\nTypically seen with `SIGHASH_SINGLE | ANYONCANPAY` arrangements.\n\nExamples in LN spec HTLC presigned transactions,\nln-symmetry \"update\" transactions, Murcery Wallet's\nstatechains, degen NFT trades, and likely more.\n\nKeeping it within a single transaction saves a bit\nof overhead vs other strategies, but requires additional\ninputs and possibly an output to be added.\n\nWithout additional mitigations it can \n\nBoth single-transaction RBF types benefit\nfrom simplicity of the RBF case in today's\nmempool and relay policies.\n\n# Endogenous fees, CPFP\n\nFees are brought from within the parent\ntransaction, with no requirements to\nresolve a conflict from the parent's\ninput set.\n\n```mermaid height=450,auto\nflowchart TD\n    Pi3([state_i]) --> P3[parent]\n    P3 --> Po3([state_i+1])\n    Po3 --> C3[Endo fees, CPFP]\n    C3 --> Co3([change])\n    \n    linkStyle 2 stroke-width:4px,stroke:green\n    linkStyle 3 stroke-width:4px,stroke:green\n```\n\nThis is most applicable to when the parent\ntransaction is not under the control of the\nuser making the CPFP, or when replacing\nit would be too expensive, disallowing RBF.\n\nA common use-case would be users receiving\na transaction from someone and the sender\nunwilling or unable to increase the fee\nthemselves. ln-symmetry settlement\ntransactions have all outputs freely spendable,\nalso allowing endogenous spends. \nAnother would be fee bumping\nan LN remote transaction using your own\nbalance output in pre-anchor channels.\n\n# Exogenous fees, CPFP\n\nSame use-cases as above, but perhaps\nsome outputs in the smart contract\nare unable to be spent due to locktimes\nor other factors.\n\n```mermaid height=450,auto\nflowchart TD\n    Pi([state_i]) --> P[parent]\n    P --> Po([state_i+1])\n    Po --> C[Exo fees, CPFP]\n    fee([fee input]) --> C\n    C --> Co([change])\n    \n    linkStyle 3 stroke-width:4px,stroke:green\n    linkStyle 4 stroke-width:4px,stroke:green\n```\n\nWe see this pattern in today's LN anchor channels\nwhich requires all fees to be exogenous to avoid\npinning scenarios.\n\n# Endogenous fees, Package RBF\n\n\"Package RBF\" is a term to describe the combination\nof CPFP and package RBF, where the child is paying\nfor the parent's conflict.\n\nIf the smart contract's outputs are otherwise\nunencumbered, fees can be paid for endogenously.\n\n```mermaid height=450,auto\nflowchart TD\n    Pi6([state_i]) -.->|conflicted| P6[parent]\n    P6 --> Po6([state_i+1])\n    Po6 --> C6[Endo fees, package RBF]\n    C6 --> Co6([change])\n    \n    linkStyle 2 stroke-width:4px,stroke:green\n    linkStyle 3 stroke-width:4px,stroke:green\n```  \n\nCurrently this is unavailable to Bitcoin's\nvarious mempool implementations as this requires\nevaluation of entire packages, but users of this\nwould be LN for commitment transactions plus\nfee paying child if outputs became otherwise\nunencumbered by a one block relative timelock.\n\n\n# Exogenous fees, Package RBF\n\n```mermaid height=432,auto\nflowchart TD\n    Pi2([state_i]) -.->|conflicted| P2[parent]\n    P2 --> Po2([state_i+1])\n    Po2 --> C2[Exo fees, package RBF]\n    fee2([fee input]) --> C2\n    C2 --> Co2([change])\n    \n    linkStyle 3 stroke-width:4px,stroke:green\n    linkStyle 4 stroke-width:4px,stroke:green\n```\n\nToday's LN anchor channels is the primary example.\n\n# Composeable Transaction Structures\n\nNot all smart contract paradigms use the parent and child scheme.\n\nFor example, there are a number of schemes involving either pre-signed or\nCTV-encumbered transaction trees. \n\nThese transaction trees will end up fitting in these above\nbuckets in different ways, depending on tradeoffs like usual:\n\n1. Are we able to relay and get package evaluation for the final package?\n1. Are the ultimate (\"virtual\")UTXOs immediately spendable, allowing endogenous fees?\n1. Do we need [sibling eviction](https://delvingbitcoin.org/t/sibling-eviction-for-v3-transactions/472/9) to avoid cluster limits? How would it need to differ from v3-style sibling eviction? \n\nComposing these ideas, you could imagine a Timeout Tree where the leaf nodes use\nEndogenous, single transaction RBF-compatible channels, and if users want to go to\nchain, it composes to endogenous fees paying for the CPFP, and exercising package\nRBF if sibling eviction becomes required or any ancestor input in the chain was conflicted. This unilateral exit could also be used to pay for a separate exogenously-fee-settled smart contract that has failed.",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 31,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}