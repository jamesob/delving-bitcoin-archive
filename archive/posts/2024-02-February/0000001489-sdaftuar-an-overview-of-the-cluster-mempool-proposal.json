{
  "id": 1489,
  "name": "Suhas Daftuar",
  "username": "sdaftuar",
  "avatar_template": "/letter_avatar_proxy/v4/letter/s/0ea827/{size}.png",
  "created_at": "2024-02-08T14:48:06.857Z",
  "cooked": "<p>Nothing strikes me as particularly problematic with the algorithm you describe \u2013 I think there are a bunch of bounded search algorithms we could consider which look for a subset that is strictly better than what we started with \u2013 but I think if we accept that (a) we don\u2019t currently have a framework for deciding what an optimal subset of transactions from a too-big-cluster is, and (b) that therefore any approach that tries to find something better than what we have is going to be guesswork for now, then I think it would make sense to motivate the logic with a use case that would need it.</p>\n<p>I\u2019d hope that with more research, at some point in the future we are able to come up with a rigorous notion of what an optimal subset of transactions from a too-big-cluster is, and at that point it would be a shame if we were held up in deploying it due to reliance that has developed on existing behavior.  (Of course, if there are use cases that would concretely benefit today from our guesswork solutions, then that would be a reason in favor of trying something like this.)</p>\n<p>EDIT: regarding this:</p>\n<aside class=\"quote no-group\" data-username=\"instagibbs\" data-post=\"14\" data-topic=\"393\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/instagibbs/48/28_2.png\" class=\"avatar\"> instagibbs:</div>\n<blockquote>\n<p>These should allow improvements to the mempool with O(nlogn) processing, and no resubmission of transactions? Doesn\u2019t solve incremental relay pins of course.</p>\n</blockquote>\n</aside>\n<p>You could have a resubmission of transactions that works, if I understand the algorithm right. Consider this picture:</p>\n<pre data-code-height=\"146\" data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">    flowchart\n         A[\"A: 10kvb, 1 sat/vb\"] --&gt; B:[\"B: 90 kvb, 50 sat/vb\"]\n         A--&gt;C:[\"C: 1kvb, 5 sat/vb\"]\n         A-.-&gt;D:[\"D: 5kvb, 1M sat/vb\"]\n</code></pre>\n<p>So A, B, C are in the mempool and D arrives.  ABC is at the cluster size limit, and the cluster should chunk as [AB, C]. Running your algorithm, we mark C for eviction, and then mark B for eviction \u2013 at which point we\u2019ve freed enough space.  We compare [AD] to [AB, C] and assuming I made D\u2019s feerate high enough, it gets in.  But now there is room for C to be re-added as well.</p>",
  "post_number": 15,
  "post_type": 1,
  "updated_at": "2024-02-08T15:00:36.660Z",
  "reply_count": 1,
  "reply_to_post_number": 14,
  "quote_count": 1,
  "incoming_link_count": 0,
  "reads": 4,
  "readers_count": 3,
  "score": 20.8,
  "yours": false,
  "topic_id": 393,
  "topic_slug": "an-overview-of-the-cluster-mempool-proposal",
  "topic_title": "An overview of the cluster mempool proposal",
  "topic_html_title": "An overview of the cluster mempool proposal",
  "category_id": 8,
  "display_username": "Suhas Daftuar",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Nothing strikes me as particularly problematic with the algorithm you describe -- I think there are a bunch of bounded search algorithms we could consider which look for a subset that is strictly better than what we started with -- but I think if we accept that (a) we don't currently have a framework for deciding what an optimal subset of transactions from a too-big-cluster is, and (b) that therefore any approach that tries to find something better than what we have is going to be guesswork for now, then I think it would make sense to motivate the logic with a use case that would need it.\n\nI'd hope that with more research, at some point in the future we are able to come up with a rigorous notion of what an optimal subset of transactions from a too-big-cluster is, and at that point it would be a shame if we were held up in deploying it due to reliance that has developed on existing behavior.  (Of course, if there are use cases that would concretely benefit today from our guesswork solutions, then that would be a reason in favor of trying something like this.)\n\nEDIT: regarding this:\n\n[quote=\"instagibbs, post:14, topic:393\"]\nThese should allow improvements to the mempool with O(nlogn) processing, and no resubmission of transactions? Doesn\u2019t solve incremental relay pins of course.\n[/quote]\n\nYou could have a resubmission of transactions that works, if I understand the algorithm right. Consider this picture:\n\n\n```mermaid height=146,auto\n    flowchart\n         A[\"A: 10kvb, 1 sat/vb\"] --> B:[\"B: 90 kvb, 50 sat/vb\"]\n         A-->C:[\"C: 1kvb, 5 sat/vb\"]\n         A-.->D:[\"D: 5kvb, 1M sat/vb\"]\n```\n\nSo A, B, C are in the mempool and D arrives.  ABC is at the cluster size limit, and the cluster should chunk as [AB, C]. Running your algorithm, we mark C for eviction, and then mark B for eviction -- at which point we've freed enough space.  We compare [AD] to [AB, C] and assuming I made D's feerate high enough, it gets in.  But now there is room for C to be re-added as well.",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 95,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}