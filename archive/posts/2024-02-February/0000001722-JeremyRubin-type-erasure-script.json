{
  "id": 1722,
  "name": "Jeremy Rubin",
  "username": "JeremyRubin",
  "avatar_template": "/user_avatar/delvingbitcoin.org/jeremyrubin/{size}/264_2.png",
  "created_at": "2024-02-27T18:44:54.735Z",
  "cooked": "<p>Sharing some (old) thoughts as I see there a lot of discussion around covenants and particularly around handling amounts, integers, etc.</p>\n<p>Currently, Bitcoin operates as a low-level VM without type information. However, frequently, types are implicit (e.g., arith operations fail on too-long bitstrings).</p>\n<p>As an alternative (e.g., new tapscript version), suppose that tapscript fragments start with an ABI that specifies at each field position what the types of the arguments should be (N.B., this assumes that witnesses in Tapscript should be function-like, and not variadic or generic). Let\u2019s assume the basic types as follows (feel free to propose alternatives):</p>\n<ul>\n<li>empty</li>\n<li>bool</li>\n<li>u8 / i8</li>\n<li>u16 / i16</li>\n<li>u20/i20</li>\n<li>u32 / i32</li>\n<li>u64 / i64</li>\n<li>u128 / i128</li>\n<li>u256 / i256</li>\n<li>Scalar</li>\n<li>Pubkey</li>\n<li>Signature</li>\n<li>HeightSequence</li>\n<li>TimeSequence</li>\n<li>HeightNLockTime</li>\n<li>TimeNLockTime</li>\n<li>ByteVec</li>\n<li>Input</li>\n<li>Output</li>\n<li>Amount</li>\n<li>Transaction</li>\n<li>InputIndexInThisTxn</li>\n<li>OutputIndexInThisTxn</li>\n</ul>\n<p>Any \u201cunknown\u201d type in the ABI would operate like an op_success, and make validation ignore the script. (This is sort of equivalent to having in script an  OP_PICK  OP_IS_ sort of script preamble, but more efficient &amp; pedantic.)</p>\n<p>These types should be persisted <em>during</em> execution. This has many benefits:</p>\n<ol>\n<li>You get more opcodes because you can define OP_ADD on Byte Vectors to be different than OP_ADD on u64 etc. Otherwise you need to</li>\n<li>You can more easily define operations that expect arguments of a certain kind and put them into a certain type (e.g., instead of OP_CAT, you can have   OP_OUTPUT_FROM_PARTS which handles the length fields)</li>\n<li>Validation can be \u2013 especially for covenants \u2013 more efficient as you don\u2019t need to re-parse stuff or do complicated field length logic</li>\n<li>when you add a new external ABI type (op_success) you can define how all the existing opcodes should handle it</li>\n<li>You can reject \u201cnonsense\u201d operations, even when the underlying byte types might work by chance</li>\n<li>Tooling is greatly simplified since posession of the fragment hints at how to satisfy and at how much cost it might have</li>\n</ol>\n<p>Sometimes types are not good for validation \u2013 really, what do we care if we know a type is an 8 byte integer if validation will fail at some other step? Or if it will succeed no matter what type it is? However, having in-band primitive types, for all but the simplest scripts, can actually reduce complexity and lead to simpler scripts. Consider the bolt-3 offered HTLC script:</p>\n<pre><code class=\"lang-auto\"># To remote node with revocation key\nOP_DUP OP_HASH160 &lt;RIPEMD160(SHA256(revocationpubkey))&gt; OP_EQUAL\nOP_IF\n    OP_CHECKSIG\nOP_ELSE\n    &lt;remote_htlcpubkey&gt; OP_SWAP OP_SIZE 32 OP_EQUAL\n    OP_NOTIF\n        # To local node via HTLC-timeout transaction (timelocked).\n        OP_DROP 2 OP_SWAP &lt;local_htlcpubkey&gt; 2 OP_CHECKMULTISIG\n    OP_ELSE\n        # To remote node with preimage.\n        OP_HASH160 &lt;RIPEMD160(payment_hash)&gt; OP_EQUALVERIFY\n        OP_CHECKSIG\n    OP_ENDIF\nOP_ENDIF\n</code></pre>\n<p>We can decompose this to:</p>\n<p>Branch 1:</p>\n<pre><code class=\"lang-auto\">ABI&lt;SIGNATURE, PUBKEY&gt;\nOP_DUP OP_HASH160 &lt;RIPEMD160(SHA256(revocationpubkey))&gt; OP_EQUALVERIFY OP_CHECKSIG\n</code></pre>\n<p>Branch 2</p>\n<pre><code class=\"lang-auto\">        ABI&lt;SIGNATURE, SIGNATURE&gt;\n        # To local node via HTLC-timeout transaction (timelocked).\n        &lt;remote htlcpubkey&gt; CHECKSIGVERIFY &lt;local_htlcpubkey&gt; CHECKSIGVERIFY\n</code></pre>\n<p>Branch 3</p>\n<pre><code class=\"lang-auto\">    ABI&lt;SIGNATURE, u128&gt;\n   OP_HASH160 &lt;RIPEMD160(payment_hash)&gt; OP_EQUALVERIFY\n    &lt;remote_htlcpubkey&gt; OP_CHECKSIG\n</code></pre>\n<p>One way of more generically implementing these ABIs would be as an OP_STACKTYPECHECKS{,VERIFY} which takes a byte vector and asserts all the types on the stack &amp; altstack either currently match, or could be \u201ccast\u201d to the desired type (perhaps as OP_TRYCASTSTACK). This would aid for circumstances where one tap-path must support &gt;1 ABI, or could be helpful in joining two scripts together that part A can attest to the output of part B being properly checked. But I think I prefer the \u201cone ABI\u201d mode for simplicity.</p>\n<p>We can view miniscript as a best effort attempt at being able to run type inference over well formed scripts, as an alternative to tracking actual types. More explicit type checks would be fully compatible with miniscript, and would (potentially) expand the depth of scripts that can fit in to a miniscript-like context, enabling more script programmability (espeically with covenants).</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2024-02-27T18:44:54.735Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 1,
  "reads": 13,
  "readers_count": 12,
  "score": 7.6,
  "yours": false,
  "topic_id": 615,
  "topic_slug": "type-erasure-script",
  "topic_title": "Type Erasure & Script",
  "topic_html_title": "Type Erasure &amp; Script",
  "category_id": 7,
  "display_username": "Jeremy Rubin",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Sharing some (old) thoughts as I see there a lot of discussion around covenants and particularly around handling amounts, integers, etc.\n\nCurrently, Bitcoin operates as a low-level VM without type information. However, frequently, types are implicit (e.g., arith operations fail on too-long bitstrings). \n\nAs an alternative (e.g., new tapscript version), suppose that tapscript fragments start with an ABI that specifies at each field position what the types of the arguments should be (N.B., this assumes that witnesses in Tapscript should be function-like, and not variadic or generic). Let's assume the basic types as follows (feel free to propose alternatives):\n\n- empty\n- bool\n- u8 / i8\n- u16 / i16\n- u20/i20\n- u32 / i32\n- u64 / i64\n- u128 / i128\n- u256 / i256\n- Scalar\n- Pubkey\n- Signature\n- HeightSequence\n- TimeSequence\n- HeightNLockTime\n- TimeNLockTime\n- ByteVec\n- Input\n- Output\n- Amount\n- Transaction\n- InputIndexInThisTxn\n- OutputIndexInThisTxn\n\nAny \"unknown\" type in the ABI would operate like an op_success, and make validation ignore the script. (This is sort of equivalent to having in script an <n> OP_PICK  OP_IS_<TYPE> sort of script preamble, but more efficient & pedantic.)\n\nThese types should be persisted _during_ execution. This has many benefits:\n\n1) You get more opcodes because you can define OP_ADD on Byte Vectors to be different than OP_ADD on u64 etc. Otherwise you need to \n2) You can more easily define operations that expect arguments of a certain kind and put them into a certain type (e.g., instead of OP_CAT, you can have <amount> <script> OP_OUTPUT_FROM_PARTS which handles the length fields)\n3) Validation can be -- especially for covenants -- more efficient as you don't need to re-parse stuff or do complicated field length logic\n4) when you add a new external ABI type (op_success) you can define how all the existing opcodes should handle it\n5) You can reject \"nonsense\" operations, even when the underlying byte types might work by chance\n6) Tooling is greatly simplified since posession of the fragment hints at how to satisfy and at how much cost it might have\n\nSometimes types are not good for validation -- really, what do we care if we know a type is an 8 byte integer if validation will fail at some other step? Or if it will succeed no matter what type it is? However, having in-band primitive types, for all but the simplest scripts, can actually reduce complexity and lead to simpler scripts. Consider the bolt-3 offered HTLC script:\n\n```\n# To remote node with revocation key\nOP_DUP OP_HASH160 <RIPEMD160(SHA256(revocationpubkey))> OP_EQUAL\nOP_IF\n    OP_CHECKSIG\nOP_ELSE\n    <remote_htlcpubkey> OP_SWAP OP_SIZE 32 OP_EQUAL\n    OP_NOTIF\n        # To local node via HTLC-timeout transaction (timelocked).\n        OP_DROP 2 OP_SWAP <local_htlcpubkey> 2 OP_CHECKMULTISIG\n    OP_ELSE\n        # To remote node with preimage.\n        OP_HASH160 <RIPEMD160(payment_hash)> OP_EQUALVERIFY\n        OP_CHECKSIG\n    OP_ENDIF\nOP_ENDIF\n```\n\n\nWe can decompose this to:\n\nBranch 1:\n```\nABI<SIGNATURE, PUBKEY>\nOP_DUP OP_HASH160 <RIPEMD160(SHA256(revocationpubkey))> OP_EQUALVERIFY OP_CHECKSIG\n```\nBranch 2\n```\n        ABI<SIGNATURE, SIGNATURE>\n        # To local node via HTLC-timeout transaction (timelocked).\n        <remote htlcpubkey> CHECKSIGVERIFY <local_htlcpubkey> CHECKSIGVERIFY\n```\nBranch 3\n```\n    ABI<SIGNATURE, u128>\n   OP_HASH160 <RIPEMD160(payment_hash)> OP_EQUALVERIFY\n    <remote_htlcpubkey> OP_CHECKSIG\n```\n\nOne way of more generically implementing these ABIs would be as an OP_STACKTYPECHECKS{,VERIFY} which takes a byte vector and asserts all the types on the stack & altstack either currently match, or could be \"cast\" to the desired type (perhaps as OP_TRYCASTSTACK). This would aid for circumstances where one tap-path must support >1 ABI, or could be helpful in joining two scripts together that part A can attest to the output of part B being properly checked. But I think I prefer the \"one ABI\" mode for simplicity.\n\n\nWe can view miniscript as a best effort attempt at being able to run type inference over well formed scripts, as an alternative to tracking actual types. More explicit type checks would be fully compatible with miniscript, and would (potentially) expand the depth of scripts that can fit in to a miniscript-like context, enabling more script programmability (espeically with covenants).",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 224,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}