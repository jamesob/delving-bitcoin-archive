{
  "id": 1552,
  "name": "Sanket Kanjalkar",
  "username": "sanket1729",
  "avatar_template": "/user_avatar/delvingbitcoin.org/sanket1729/{size}/13_2.png",
  "created_at": "2024-02-13T23:49:50.877Z",
  "cooked": "<p>Before delving further into this topic, I\u2019d like to address the concern about the potential risks associated with evil covenants. Here are a few points to consider:</p>\n<ol>\n<li>Evil covenant functionality already exists in altcoins with significant market capitalization. Despite this, we haven\u2019t observed any notable issues arising from such features in these coins.</li>\n<li>The capability for evil covenants exists within current Bitcoin scripting. Therefore, implementing them doesn\u2019t introduce new risks per se. Concerns regarding high interactivity requirements can be mitigated by incentivizing compliance with the covenants. For instance, implementing a one-time transition into a script controlled by an internal key held by the government, coupled with a script path featuring a CSV of <code>n</code> blocks. Users than must send to addresses that recursively enforce this covenant or risk losing funds. In case of policy violations, the government can freeze the funds associated with the address.</li>\n</ol>\n<p>Now, returning to the topic at hand, I think we can improve it:</p>\n<p>Given the government\u2019s ability to freeze addresses, a simpler approach might involve incorporating a designated freeze internal key. This approach would separate the freezing policy from the Bitcoin script. Utilizing <code>CAT</code> and <code>CSFS</code>), it\u2019s possible (albeit challenging) to restrict the merkle root in such a way that all outputs spending from the covenant input require the same freeze key for spending.</p>\n<p>Here\u2019s how this could work:</p>\n<ul>\n<li>Each coin would have a freeze key that directs funds to a predetermined government-controlled address, enforced through a recursive covenant by leveraging <code>CAT</code> and <code>CSFS</code>.</li>\n<li>The government can maintain and update a list of permitted addresses dynamically as needed.</li>\n<li>Before transacting users check if the transaction satisfies the requirement and goes on with the transaction.</li>\n</ul>\n<p>One approach to implementing this involves restricting the internal key to function as the freeze key. Alternatively, in the context of SegWit scripting, it might be simpler to ensure that every script begins with an <code>IF &lt;freeze_key&gt; CHECKSIG ELSE &lt;unchecked input provided by user&gt;</code> structure. I\u2019ve successfully employed a similar approach utilizing <code>CAT</code> and <code>CSFS</code> for a different script, which I can delve into in a subsequent post if there\u2019s interest.</p>\n<p>On a practical note, it\u2019s important to acknowledge that the applications of <code>CAT</code> often encounter limitations, particularly with the 520-byte constraint. While workarounds like <code>CODESEPARATOR</code> exist, they can become cumbersome over time.</p>",
  "post_number": 12,
  "post_type": 1,
  "updated_at": "2024-02-13T23:50:36.188Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 12,
  "readers_count": 11,
  "score": 47.4,
  "yours": false,
  "topic_id": 556,
  "topic_slug": "perpetually-kycd-coins-using-evil-covenants",
  "topic_title": "Perpetually KYC'd Coins Using Evil Covenants",
  "topic_html_title": "Perpetually KYC&rsquo;d Coins Using Evil Covenants",
  "category_id": 7,
  "display_username": "Sanket Kanjalkar",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Before delving further into this topic, I'd like to address the concern about the potential risks associated with evil covenants. Here are a few points to consider:\n\n1. Evil covenant functionality already exists in altcoins with significant market capitalization. Despite this, we haven't observed any notable issues arising from such features in these coins.\n2. The capability for evil covenants exists within current Bitcoin scripting. Therefore, implementing them doesn't introduce new risks per se. Concerns regarding high interactivity requirements can be mitigated by incentivizing compliance with the covenants. For instance, implementing a one-time transition into a script controlled by an internal key held by the government, coupled with a script path featuring a CSV of `n` blocks. Users than must send to addresses that recursively enforce this covenant or risk losing funds. In case of policy violations, the government can freeze the funds associated with the address.\n\nNow, returning to the topic at hand, I think we can improve it:\n\nGiven the government's ability to freeze addresses, a simpler approach might involve incorporating a designated freeze internal key. This approach would separate the freezing policy from the Bitcoin script. Utilizing `CAT` and `CSFS`), it's possible (albeit challenging) to restrict the merkle root in such a way that all outputs spending from the covenant input require the same freeze key for spending. \n\nHere's how this could work:\n\n* Each coin would have a freeze key that directs funds to a predetermined government-controlled address, enforced through a recursive covenant by leveraging `CAT` and `CSFS`.\n* The government can maintain and update a list of permitted addresses dynamically as needed.\n* Before transacting users check if the transaction satisfies the requirement and goes on with the transaction.\n\nOne approach to implementing this involves restricting the internal key to function as the freeze key. Alternatively, in the context of SegWit scripting, it might be simpler to ensure that every script begins with an `IF <freeze_key> CHECKSIG ELSE <unchecked input provided by user>` structure. I've successfully employed a similar approach utilizing `CAT` and `CSFS` for a different script, which I can delve into in a subsequent post if there's interest.\n\nOn a practical note, it's important to acknowledge that the applications of `CAT` often encounter limitations, particularly with the 520-byte constraint. While workarounds like `CODESEPARATOR` exist, they can become cumbersome over time.",
  "actions_summary": [
    {
      "id": 2,
      "count": 3
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 14,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 3
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 3,
  "current_user_used_main_reaction": false
}