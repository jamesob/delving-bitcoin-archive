{
  "id": 1449,
  "name": "Ethan Heilman",
  "username": "EthanHeilman",
  "avatar_template": "/user_avatar/delvingbitcoin.org/ethanheilman/{size}/328_2.png",
  "created_at": "2024-02-02T18:44:23.074Z",
  "cooked": "<blockquote>\n<p>If more-than-64bit arithmetic is desired, then I would say rustyrussell\u2019s idea of using only-positive variable-length integers where larger lengths are allowed is more elegant,</p>\n</blockquote>\n<p>I agree variable length would be more elegant. My worry was about fee pricing since, depending on the math operations allowed, really big nums require more computation than small numbers. You can put big numbers on the stack with single byte opcodes like HASH256. 64-bit chucks provides a very nice way to capture that increase in cost since need more opcodes to perform operations on bigger numbers.</p>\n<p>The more I think about my fee cost argument here, the more convinced I am that it doesn\u2019t matter and I am wrong. It seems perfectly fine to have operations on very large numbers in Bitcoin because if one wanted to maximize computational resources spent and minimize fee code that are much better opcodes than arithmetic.</p>\n<p>The computational cost of performing arithmetic on even very large numbers, say 520 byte numbers, is probably much smaller than many single opcode instructions like HASH160 or CHECKSIG. I don\u2019t have actual performance numbers on this though.</p>",
  "post_number": 39,
  "post_type": 1,
  "updated_at": "2024-02-02T18:46:32.187Z",
  "reply_count": 0,
  "reply_to_post_number": 38,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 3,
  "readers_count": 2,
  "score": 0.6,
  "yours": false,
  "topic_id": 397,
  "topic_slug": "64-bit-arithmetic-soft-fork",
  "topic_title": "64 bit arithmetic soft fork",
  "topic_html_title": "64 bit arithmetic soft fork",
  "category_id": 7,
  "display_username": "Ethan Heilman",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "reply_to_user": {
    "username": "dgpv",
    "name": "",
    "avatar_template": "/user_avatar/delvingbitcoin.org/dgpv/{size}/75_2.png"
  },
  "bookmarked": false,
  "raw": "> If more-than-64bit arithmetic is desired, then I would say rustyrussell\u2019s idea of using only-positive variable-length integers where larger lengths are allowed is more elegant,\n\nI agree variable length would be more elegant. My worry was about fee pricing since, depending on the math operations allowed, really big nums require more computation than small numbers. You can put big numbers on the stack with single byte opcodes like HASH256. 64-bit chucks provides a very nice way to capture that increase in cost since need more opcodes to perform operations on bigger numbers. \n\nThe more I think about my fee cost argument here, the more convinced I am that it doesn't matter and I am wrong. It seems perfectly fine to have operations on very large numbers in Bitcoin because if one wanted to maximize computational resources spent and minimize fee code that are much better opcodes than arithmetic. \n\nThe computational cost of performing arithmetic on even very large numbers, say 520 byte numbers, is probably much smaller than many single opcode instructions like HASH160 or CHECKSIG. I don't have actual performance numbers on this though.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 267,
  "hidden": false,
  "trust_level": 0,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}