{
  "id": 1583,
  "name": "",
  "username": "rijndael",
  "avatar_template": "/letter_avatar_proxy/v4/letter/r/8797f3/{size}.png",
  "created_at": "2024-02-15T22:13:48.180Z",
  "cooked": "<p>I\u2019ve been curious to see what it would look like in practice to use OP_CAT to assert transaction fields and properties. I hacked together a very basic vault using OP_CAT and no other non-mainnet features.</p>\n<p>The repo with a working demo you can run on regtest is available here: <a href=\"https://github.com/taproot-wizards/purrfect_vault\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">GitHub - taproot-wizards/purrfect_vault</a></p>\n<p><a href=\"https://github.com/bitcoin/bips/blob/deae64bfd31f6938253c05392aa355bf6d7e7605/bip-0341.mediawiki#common-signature-message\" rel=\"noopener nofollow ugc\">BIP341 signature validation has us create a message called a <code>SigMsg</code></a> that contains commitments to the fields of a transaction. That SigMsg is then used as the message in constructing a Schnorr signature. <a href=\"https://medium.com/blockstream/cat-and-schnorr-tricks-i-faf1b59bd298\" rel=\"noopener nofollow ugc\">Andrew Polestra observed</a> that if you set the Public Key (P) and Public Nonce Commitment (R) to the generator point (G), then the s value of the resulting Schnorr signature will be equal to the SigMsg + 1. We are using that technique in order to allow for transaction introspection by passing in the SigMsg components as witness data, and then using OP_CAT to construct the SigMsg on the stack. We then construct the tagged hashes specified in BIP341, and eventually CAT on an extra G to serve as the R component of the signature. Then we call CHECKSIG to validate the signature. If it is valid, then it means we\u2019ve constructed the SigMsg correctly, and the transaction is valid.</p>\n<p>We use that in a few different ways in this demo.</p>\n<p>All the scripts are commented and in the <code>src/vault/script.rs</code> file.</p>\n<h3><a name=\"trigger-withdrawal-1\" class=\"anchor\" href=\"#trigger-withdrawal-1\"></a>Trigger Withdrawal</h3>\n<ul>\n<li>Inputs\n<ol>\n<li>contract input</li>\n<li>fee-paying input</li>\n</ol>\n</li>\n<li>Outputs\n<ol>\n<li>Contract output with amount to be withdrawn</li>\n<li>Target address with dust amount</li>\n</ol>\n</li>\n</ul>\n<p>We use the CAT-checksig technique to validate that the amount and scriptpubkey of the first input and first output are the same. We enforce that the second output is amount is exactly 546 sats, but we do not place any restrictions on the scriptpubkey. We also enforce that there are two inputs and two outputs.</p>\n<h3><a name=\"complete-withdrawal-2\" class=\"anchor\" href=\"#complete-withdrawal-2\"></a>Complete Withdrawal</h3>\n<ul>\n<li>Inputs\n<ol>\n<li>Withdrawal input</li>\n<li>Fee-paying input</li>\n</ol>\n</li>\n<li>Outputs\n<ol>\n<li>Destination output with contract amount</li>\n</ol>\n</li>\n</ul>\n<p>This is probably the most interesting transaction. We want to enforce that the first output has the scriptpubkey that matches the second output of the <strong>trigger</strong> transaction. To validate this, we pass in the serialized transaction data (version, inputs, outputs, locktime) as witness data, do some manipulation of the outputs, and then hash this previous-transaction data twice to get the TXID. We then validate that the first input of the current transaction is the same as the TXID of the previous transaction with vout=0. This ensures that the first input of the current transaction is the same as the first output of the previous transaction, and lets us <em>inspect the state of the previous transaction</em>.</p>\n<p>The first output of this transaction is enforced to be the scriptpubkey of the second output of the trigger, and the amount is enforced to be the same as the amount of the first output of the trigger. The second input is unencumbered and used for change.</p>\n<p>There is also a plain-old CSV relative timelock of 20 blocks on the first input.</p>\n<h3><a name=\"cancel-withdrawal-3\" class=\"anchor\" href=\"#cancel-withdrawal-3\"></a>Cancel Withdrawal</h3>\n<ul>\n<li>Inputs\n<ol>\n<li>Any contract input</li>\n<li>Fee-paying input</li>\n</ol>\n</li>\n<li>Outputs\n<ol>\n<li>Contract output</li>\n</ol>\n</li>\n</ul>\n<p>This is the simplest transaction. We just enforce that there are two inputs and one output, and that the first input is the same as the first output.</p>\n<p>There are some missing features and rough edges in the demo, but I think its constructive to see what it looks like in practice to use CAT to enforce different components of inputs and outputs, and to assert state from a previous transaction.</p>\n<p>Check out the README and code for gory details.</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2024-02-15T22:18:50.558Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 5,
  "readers_count": 4,
  "score": 0.8,
  "yours": false,
  "topic_id": 576,
  "topic_slug": "basic-vault-prototype-using-op-cat",
  "topic_title": "Basic vault prototype using OP_CAT",
  "topic_html_title": "Basic vault prototype using OP_CAT",
  "category_id": 7,
  "display_username": "",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "I've been curious to see what it would look like in practice to use OP_CAT to assert transaction fields and properties. I hacked together a very basic vault using OP_CAT and no other non-mainnet features. \n\nThe repo with a working demo you can run on regtest is available here: https://github.com/taproot-wizards/purrfect_vault\n\n[BIP341 signature validation has us create a message called a `SigMsg`](https://github.com/bitcoin/bips/blob/deae64bfd31f6938253c05392aa355bf6d7e7605/bip-0341.mediawiki#common-signature-message) that contains commitments to the fields of a transaction. That SigMsg is then used as the message in constructing a Schnorr signature. [Andrew Polestra observed](https://medium.com/blockstream/cat-and-schnorr-tricks-i-faf1b59bd298) that if you set the Public Key (P) and Public Nonce Commitment (R) to the generator point (G), then the s value of the resulting Schnorr signature will be equal to the SigMsg + 1. We are using that technique in order to allow for transaction introspection by passing in the SigMsg components as witness data, and then using OP_CAT to construct the SigMsg on the stack. We then construct the tagged hashes specified in BIP341, and eventually CAT on an extra G to serve as the R component of the signature. Then we call CHECKSIG to validate the signature. If it is valid, then it means we've constructed the SigMsg correctly, and the transaction is valid.\n\nWe use that in a few different ways in this demo.\n\nAll the scripts are commented and in the `src/vault/script.rs` file.\n\n### Trigger Withdrawal\n\n* Inputs\n  1. contract input\n  2. fee-paying input\n* Outputs\n  1. Contract output with amount to be withdrawn\n  2. Target address with dust amount\n\nWe use the CAT-checksig technique to validate that the amount and scriptpubkey of the first input and first output are the same. We enforce that the second output is amount is exactly 546 sats, but we do not place any restrictions on the scriptpubkey. We also enforce that there are two inputs and two outputs.\n\n### Complete Withdrawal\n\n* Inputs\n  1. Withdrawal input\n  2. Fee-paying input\n* Outputs\n  1. Destination output with contract amount\n\nThis is probably the most interesting transaction. We want to enforce that the first output has the scriptpubkey that matches the second output of the **trigger** transaction. To validate this, we pass in the serialized transaction data (version, inputs, outputs, locktime) as witness data, do some manipulation of the outputs, and then hash this previous-transaction data twice to get the TXID. We then validate that the first input of the current transaction is the same as the TXID of the previous transaction with vout=0. This ensures that the first input of the current transaction is the same as the first output of the previous transaction, and lets us *inspect the state of the previous transaction*.\n\nThe first output of this transaction is enforced to be the scriptpubkey of the second output of the trigger, and the amount is enforced to be the same as the amount of the first output of the trigger. The second input is unencumbered and used for change.\n\nThere is also a plain-old CSV relative timelock of 20 blocks on the first input.\n\n### Cancel Withdrawal\n\n* Inputs\n  1. Any contract input\n  2. Fee-paying input\n* Outputs\n  1. Contract output\n\nThis is the simplest transaction. We just enforce that there are two inputs and one output, and that the first input is the same as the first output.\n\n\nThere are some missing features and rough edges in the demo, but I think its constructive to see what it looks like in practice to use CAT to enforce different components of inputs and outputs, and to assert state from a previous transaction. \n\nCheck out the README and code for gory details.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 288,
  "hidden": false,
  "trust_level": 0,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": "Github link was replaced with a permanent link",
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}