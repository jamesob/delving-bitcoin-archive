{
  "id": 1467,
  "name": "Gregory Sanders",
  "username": "instagibbs",
  "avatar_template": "/user_avatar/delvingbitcoin.org/instagibbs/{size}/28_2.png",
  "created_at": "2024-02-06T18:11:07.655Z",
  "cooked": "<p><a href=\"https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340/\">V3 transactions</a> were an answer to pinning that predates the practical idea of a totally ordered mempool.\nBeing unable to answer simple questions about allowable transactional topologies on the local\nmempool makes reasoning about safety of simple operations like transaction entry impossible.\nBy restricting topologies of these kinds of transactions, it made it easier to reason about.\nIn a <a href=\"https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393\">post-cluster mempool world</a>, with our ability to reason about things, it is worth a re-examination.</p>\n<p>As a semi-sequel to <a href=\"https://delvingbitcoin.org/t/opt-in-transaction-policies-for-anti-pinning/159/3\">priority transactions</a>, this post explores possibilities for v3 and v3-like policies in a post-cluster mempool world. It tries to answer questions:</p>\n<ul>\n<li>How much can we remove the topology restrictions? Given the general resistance of people to concept ACK a specific transaction topology like V3, I was thinking it would be useful to think ahead and see what policy relaxations or restrictions we could enact in the future to make things more flexible, incentive compatible, and overall more useful, in a backwards compatible manner.</li>\n<li>What other rules can we add to express the intention of v3? If we think of this as a way for smart contracts to opt in to a set of policies where \u201cI\u2019m only going to {add, replace} transactions if it\u2019s a fee-bump,\u201d can we implement rules that are closer to that?</li>\n<li>After cluster mempool, how useful is v3? Will we regret having deployed v3 and its features, seeing it as a future maintenence burden?</li>\n</ul>\n<p><strong>TL;DR: V3 is useful and likely upgradeable to something more post-cluster mempool world in a backwards compatible way.</strong></p>\n<h1><a name=\"definitions-1\" class=\"anchor\" href=\"#definitions-1\"></a>Definitions</h1>\n<p>\u201c<strong>top block</strong>\u201d refers to whatever level we want. Using a cluster mempool we can check properties of incoming transactions such as: \u201cchunk would enter the first or second block even if we estimate 10 minutes of additional inflow\u201d, or whatever statistical massaging we want to reduce pins, while not unduly impeding the ability for miners to have a backlog of transactions from which to mine in the short term.</p>\n<p>\u201c<strong>goldfinger++</strong>\u201d is the concept where an adversary either knows transactional load is incoming or induces a transaction load in the mempool, such that all the top-block-using transactions become buried on each other, and may be unable to reorder effectively due to incremental fee pinning induced by the attacker. Goldfinger attacks are not a new concept, and outside the scope of mempools to solve. The \u201c++\u201d is to indicate the additional pin vector which allows the attacker to possibly choose the order of the defenders\u2019 time-sensitive transactions in the mempool, which may allow additional value extraction on top of a classical goldfinger attack where the defenders are at least able to reorder transactions respectful to the total funds at risk. I have no data or simulations on how much worse this is, but it\u2019s worth noting as a possibility.</p>\n<h1><a name=\"ideas-2\" class=\"anchor\" href=\"#ideas-2\"></a>Ideas</h1>\n<p>All deployment ideas below are suggested paths that could be taken,\nwith their benefits and drawbacks hopegully enumerated.</p>\n<p><em>The future labels and version numbers came to me in a dream.</em></p>\n<h2><a name=\"v3-3\" class=\"anchor\" href=\"#v3-3\"></a>V3</h2>\n<ol>\n<li>One parent, up to one &lt;=1kvB child.</li>\n</ol>\n<p>Pros:</p>\n<ul>\n<li>Trivially optimal <a href=\"https://delvingbitcoin.org/t/sibling-eviction-for-v3-transactions/472\">sibling eviction</a> due to reduced topology</li>\n<li>It\u2019s coded. Relatively simple. Doesn\u2019t require cluster mempool.</li>\n<li>Reduces max pinning ~100x, and package limit pinning for this topology.</li>\n<li>Requires fewer relay changes to fully use, like 1-parent-1-child(1p1c) relay</li>\n</ul>\n<p>Cons:</p>\n<ul>\n<li>Not clearly incentive compatible: If we\u2019re asking wallets to make structural\nchanges beyond flipping a bit, is that too much?</li>\n<li>1kvB is a guess on what size is required for a CPFP, so it leaves pinning potential\nalong with the potential that it\u2019s not even big enough for larger value bumps.</li>\n<li>Does not support batched CPFP.</li>\n<li>Does not fix ANYONCANPAY usage and other useful single tx RBF fee cases.</li>\n<li>Does not support chains of larger than two, such as 0-conf channel funding chains,\nor chains from presigned/CTV trees, two CPFPs of an anchor, etc.</li>\n</ul>\n<p>As we can see, V3 leaves a lot to be desired, but can be done today\nwith known pinning bounds.</p>\n<h2><a name=\"v305-4\" class=\"anchor\" href=\"#v305-4\"></a>V3.0.5</h2>\n<ol>\n<li>Deploy V3.</li>\n<li>Deploy Cluster Mempool.</li>\n<li>Require \u201ctop block\u201d for V3 <em>child</em> (parent can still just hit minfee)</li>\n<li>Relax child size</li>\n</ol>\n<p>Pros:</p>\n<ul>\n<li>Small leap from V3</li>\n<li>Allows wallets to not always shoot for top block, unless they need a CPFP</li>\n<li>Less/no more guesswork on CPFP size</li>\n<li>Maintains trivial <a href=\"https://delvingbitcoin.org/t/sibling-eviction-for-v3-transactions/472/9\">sibling eviction</a></li>\n</ul>\n<p>Cons:</p>\n<ul>\n<li>Same topologically based cons as V3.</li>\n<li>Additional size may allow for additional \u201cgoldfinger attack++\u201d damage.</li>\n</ul>\n<p>This is both a tightening and relaxation of policy, which is arguably\nmore incentive compatible, and blunts a lot of pinning attacks. Single\ntransactions are allowed to relay at any feerate about minfee.</p>\n<h2><a name=\"v31-5\" class=\"anchor\" href=\"#v31-5\"></a>V3.1</h2>\n<ol>\n<li>Deploy V3.</li>\n<li>Deploy Cluster Mempool.</li>\n<li>Require \u201ctop block\u201d for any cluster size of 2 or more</li>\n</ol>\n<p>Pros:</p>\n<ul>\n<li>Relaxed topology allows anything normally representable, allowing\nfor easier migration for wallet systems, provided they can be\naggressive about fees when making size 2+ clusters.</li>\n<li>Multi-tx pin-resistant constructs possible.</li>\n<li>Still allows for less-fee-aggressive size 1 clusters that can be later\nbumped or batched in more fee-aggressive way in less adversarial settings.</li>\n<li>If the parent is 0-fee(and SIGHASH_ALL), it\u2019s relatively pin\nresistant since getting CPFP into mempool\nrequires top-block. Smart contracts can do less introspection of\nother people\u2019s scripts.</li>\n</ul>\n<p>Cons:</p>\n<ul>\n<li>Need to rethink <a href=\"https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393/8\">V3 sibling eviction</a>. With top block do we need it?</li>\n<li>Both <a href=\"https://delvingbitcoin.org/t/taxonomy-of-transaction-fees-in-smart-contracts/512#endogenous-fees-single-transaction-rbf-1\">endogenous and exogenous fee single transaction RBF</a> transactions are not pin\nresistant in general. Parent contract can be inflated with 0-fee\njunk then put into the mempool just above minfee.</li>\n</ul>\n<h2><a name=\"v4a-6\" class=\"anchor\" href=\"#v4a-6\"></a>V4(a)</h2>\n<ul>\n<li>To enter mempool the tx must be entering \u201ctop block\u201d.</li>\n<li>Cluster can only be &lt;= X kvB</li>\n</ul>\n<p>Pros:</p>\n<ul>\n<li>No topological restrictions, aside from lower bound in vbytes.\n<ul>\n<li>ANYONECANPAY support. <a href=\"https://delvingbitcoin.org/t/taxonomy-of-transaction-fees-in-smart-contracts/512#endogenous-fees-single-transaction-rbf-1\">Endogenous and exogenous single tx RBF are pin resistant.</a></li>\n</ul>\n</li>\n<li>Maybe less pinning potential from golfinger++ and fee spikes than default cluster size</li>\n<li>Limit could be expanded later with more research/reasoning (i.e. V4(b))</li>\n</ul>\n<p>Cons:</p>\n<ul>\n<li>Need to rethink V3 sibling eviction.  With top block do we need it?</li>\n<li>Limited vsize makes it cheaper to hit cluster size limits. Might want to think more about this.</li>\n<li>Size restriction may stop usage like LN commitment tx, ln-symmetry settlement tx, unless\nHTLC number restricted (though it looks like 10kvB would support almost 230 HTLCs\u2026)</li>\n<li>\u201cnormal\u201d transactions won\u2019t propagate unless they\u2019re top block.\n<ul>\n<li>It might not be useful enough to get widespread usage from non-time\nsensitive usecases?</li>\n</ul>\n</li>\n</ul>\n<h2><a name=\"v4b-7\" class=\"anchor\" href=\"#v4b-7\"></a>V4(b)</h2>\n<ul>\n<li>To enter mempool the tx must be entering \u201ctop block\u201d.</li>\n</ul>\n<p>Pros:</p>\n<ul>\n<li>Same as V4(a)</li>\n<li>Not much to bikeshed about.</li>\n<li>Easy to reason about under same cluster limits as mempool default.</li>\n</ul>\n<p>Cons:</p>\n<ul>\n<li>\u201cnormal\u201d transactions won\u2019t propagate unless they\u2019re top block.\n<ul>\n<li>It might not be useful enough to get widespread usage from non-time\nsensitive usecases?</li>\n</ul>\n</li>\n</ul>\n<h2><a name=\"v4c-8\" class=\"anchor\" href=\"#v4c-8\"></a>V4(c)</h2>\n<p>Can we somehow unify the benefits of V3.1 and V4?</p>\n<ul>\n<li>V4(b), with two possible relaxations:\n<ul>\n<li>if single tx and &lt;= X vbytes, allow non-top block, or</li>\n<li>if chunk being added is &lt;= X vbytes out of top block, allow</li>\n</ul>\n</li>\n</ul>\n<p>You can imagine X being something quite small, since rather than\ndisallowing the transaction entirely, breaching the limit \u201cmerely\u201d\nrequires the transaction to pay much more aggressive fees\nto be relayed.</p>\n<p>Pros:</p>\n<ul>\n<li>V4(b), but allows more natural non-top block usage</li>\n<li>Allows more backlog to build.\nOne opt-in policy to rule them all?</li>\n</ul>\n<p>Cons:</p>\n<ul>\n<li>Reintroduces a less important bikeshed, and additional\npin vector.</li>\n</ul>\n<p>These are related ideas, with subtle differences, but fundamentally\nthese are about allowing \u201cnon-pin\u201d transactions to propagate without\nbeing top block, introducing minimal pinning risk alongside it.</p>\n<p>This may allow more users to opt into this regime, build up\nmore backlog, reducing the UX pain and incentive compatibility\nquestion of dropping low-feerate but small transactions.</p>\n<p>The remaining use-cases for V3.1 style policy would essentially\nbe consolidation transactions.</p>\n<h1><a name=\"some-possible-deployments-9\" class=\"anchor\" href=\"#some-possible-deployments-9\"></a>Some Possible Deployments</h1>\n<p>Here are some ideas on what path we could take. Aside from\ncluster mempool, there are no hard constraints on what has to be\nshipped in what order, almost any steps can be completely skipped.\nThe most logical ordering will involve simple relaxations to relay rules.</p>\n<pre data-code-height=\"728\" data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">flowchart TD\n    V3([V3]) --&gt;|cpfp carveout maybe dead| C\n    C([Cluster mempool]):::required\n    C -.-&gt;|V3, but child top\\nblock| V3.0.5([V3.0.5])\n    V3.0.5 --&gt;|any topo,\\nnon-single tx\\ntop block| V3.1([V3.1])\n    C --&gt;|small cluster,\\ntop block\\nonly| V4a([V4a])\n    V4a:::genvict --&gt;|any vsize cluster| V4b([V4b]):::genvict\n    V3.1:::genvict -.-&gt;|topblockify  single tx| V4b\n    V4b --&gt;|&lt;= X vbytes\\nnon-top block| V4c([V4c]):::genvict\n\n    Tx([No V3 style sibling eviction]):::genvict\n\n    classDef required fill:#aaaaaa\n    classDef genvict fill:#FF7F50\n</code></pre>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2024-02-06T18:11:07.655Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 6,
  "readers_count": 5,
  "score": 0.6,
  "yours": false,
  "topic_id": 523,
  "topic_slug": "v3-and-some-possible-futures",
  "topic_title": "V3 and some possible futures",
  "topic_html_title": "V3 and some possible futures",
  "category_id": 7,
  "display_username": "Gregory Sanders",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "\n[V3 transactions](https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340/) were an answer to pinning that predates the practical idea of a totally ordered mempool.\nBeing unable to answer simple questions about allowable transactional topologies on the local\nmempool makes reasoning about safety of simple operations like transaction entry impossible.\nBy restricting topologies of these kinds of transactions, it made it easier to reason about.\nIn a [post-cluster mempool world](https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393), with our ability to reason about things, it is worth a re-examination.\n\nAs a semi-sequel to [priority transactions](https://delvingbitcoin.org/t/opt-in-transaction-policies-for-anti-pinning/159/3), this post explores possibilities for v3 and v3-like policies in a post-cluster mempool world. It tries to answer questions:\n\n- How much can we remove the topology restrictions? Given the general resistance of people to concept ACK a specific transaction topology like V3, I was thinking it would be useful to think ahead and see what policy relaxations or restrictions we could enact in the future to make things more flexible, incentive compatible, and overall more useful, in a backwards compatible manner.\n- What other rules can we add to express the intention of v3? If we think of this as a way for smart contracts to opt in to a set of policies where \u201cI\u2019m only going to {add, replace} transactions if it\u2019s a fee-bump,\u201d can we implement rules that are closer to that?\n- After cluster mempool, how useful is v3? Will we regret having deployed v3 and its features, seeing it as a future maintenence burden?\n\n**TL;DR: V3 is useful and likely upgradeable to something more post-cluster mempool world in a backwards compatible way.**\n\n# Definitions\n\n\u201c**top block**\u201d refers to whatever level we want. Using a cluster mempool we can check properties of incoming transactions such as: \u201cchunk would enter the first or second block even if we estimate 10 minutes of additional inflow\u201d, or whatever statistical massaging we want to reduce pins, while not unduly impeding the ability for miners to have a backlog of transactions from which to mine in the short term.\n\n\u201c**goldfinger++**\u201d is the concept where an adversary either knows transactional load is incoming or induces a transaction load in the mempool, such that all the top-block-using transactions become buried on each other, and may be unable to reorder effectively due to incremental fee pinning induced by the attacker. Goldfinger attacks are not a new concept, and outside the scope of mempools to solve. The \u201c++\u201d is to indicate the additional pin vector which allows the attacker to possibly choose the order of the defenders' time-sensitive transactions in the mempool, which may allow additional value extraction on top of a classical goldfinger attack where the defenders are at least able to reorder transactions respectful to the total funds at risk. I have no data or simulations on how much worse this is, but it's worth noting as a possibility.\n\n# Ideas\n\nAll deployment ideas below are suggested paths that could be taken,\nwith their benefits and drawbacks hopegully enumerated.\n\n*The future labels and version numbers came to me in a dream.*\n\n## V3\n\n1. One parent, up to one <=1kvB child.\n\nPros:\n- Trivially optimal [sibling eviction](https://delvingbitcoin.org/t/sibling-eviction-for-v3-transactions/472) due to reduced topology\n- It's coded. Relatively simple. Doesn't require cluster mempool.\n- Reduces max pinning ~100x, and package limit pinning for this topology.\n- Requires fewer relay changes to fully use, like 1-parent-1-child(1p1c) relay\n\nCons:\n- Not clearly incentive compatible: If we're asking wallets to make structural\n changes beyond flipping a bit, is that too much?\n- 1kvB is a guess on what size is required for a CPFP, so it leaves pinning potential\n  along with the potential that it's not even big enough for larger value bumps.\n- Does not support batched CPFP.\n- Does not fix ANYONCANPAY usage and other useful single tx RBF fee cases.\n- Does not support chains of larger than two, such as 0-conf channel funding chains,\n    or chains from presigned/CTV trees, two CPFPs of an anchor, etc.\n\nAs we can see, V3 leaves a lot to be desired, but can be done today\nwith known pinning bounds.\n  \n## V3.0.5\n\n1. Deploy V3.\n2. Deploy Cluster Mempool.\n3. Require \"top block\" for V3 *child* (parent can still just hit minfee)\n4. Relax child size\n\nPros:\n- Small leap from V3\n- Allows wallets to not always shoot for top block, unless they need a CPFP\n- Less/no more guesswork on CPFP size\n- Maintains trivial [sibling eviction](https://delvingbitcoin.org/t/sibling-eviction-for-v3-transactions/472/9)\n\nCons:\n- Same topologically based cons as V3.\n- Additional size may allow for additional \"goldfinger attack++\" damage.\n\nThis is both a tightening and relaxation of policy, which is arguably\nmore incentive compatible, and blunts a lot of pinning attacks. Single\ntransactions are allowed to relay at any feerate about minfee.\n\n## V3.1\n\n1. Deploy V3.\n2. Deploy Cluster Mempool.\n3. Require \"top block\" for any cluster size of 2 or more\n\nPros:\n- Relaxed topology allows anything normally representable, allowing\n  for easier migration for wallet systems, provided they can be\n  aggressive about fees when making size 2+ clusters.\n- Multi-tx pin-resistant constructs possible.\n- Still allows for less-fee-aggressive size 1 clusters that can be later\n  bumped or batched in more fee-aggressive way in less adversarial settings.\n- If the parent is 0-fee(and SIGHASH_ALL), it's relatively pin\n  resistant since getting CPFP into mempool\n  requires top-block. Smart contracts can do less introspection of\n  other people's scripts.\n\nCons:\n- Need to rethink [V3 sibling eviction](https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393/8). With top block do we need it?\n- Both [endogenous and exogenous fee single transaction RBF](https://delvingbitcoin.org/t/taxonomy-of-transaction-fees-in-smart-contracts/512#endogenous-fees-single-transaction-rbf-1) transactions are not pin\n  resistant in general. Parent contract can be inflated with 0-fee\n  junk then put into the mempool just above minfee. \n\n## V4(a)\n\n- To enter mempool the tx must be entering \"top block\".\n- Cluster can only be <= X kvB\n\nPros:\n- No topological restrictions, aside from lower bound in vbytes.\n  - ANYONECANPAY support. [Endogenous and exogenous single tx RBF are pin resistant.](https://delvingbitcoin.org/t/taxonomy-of-transaction-fees-in-smart-contracts/512#endogenous-fees-single-transaction-rbf-1)\n- Maybe less pinning potential from golfinger++ and fee spikes than default cluster size\n- Limit could be expanded later with more research/reasoning (i.e. V4(b))\n\nCons:\n- Need to rethink V3 sibling eviction.  With top block do we need it?\n- Limited vsize makes it cheaper to hit cluster size limits. Might want to think more about this.\n- Size restriction may stop usage like LN commitment tx, ln-symmetry settlement tx, unless\n  HTLC number restricted (though it looks like 10kvB would support almost 230 HTLCs...)\n- \"normal\" transactions won't propagate unless they're top block.\n  - It might not be useful enough to get widespread usage from non-time\nsensitive usecases? \n\n## V4(b)\n\n- To enter mempool the tx must be entering \"top block\".\n\nPros:\n- Same as V4(a)\n- Not much to bikeshed about.\n- Easy to reason about under same cluster limits as mempool default.\n\nCons:\n- \"normal\" transactions won't propagate unless they're top block.\n  - It might not be useful enough to get widespread usage from non-time\nsensitive usecases? \n\n## V4(c)\n\nCan we somehow unify the benefits of V3.1 and V4?\n\n- V4(b), with two possible relaxations:\n  - if single tx and <= X vbytes, allow non-top block, or\n  - if chunk being added is <= X vbytes out of top block, allow\n\nYou can imagine X being something quite small, since rather than\ndisallowing the transaction entirely, breaching the limit \"merely\"\nrequires the transaction to pay much more aggressive fees\nto be relayed.\n\nPros:\n- V4(b), but allows more natural non-top block usage\n- Allows more backlog to build.\nOne opt-in policy to rule them all?\n\nCons:\n- Reintroduces a less important bikeshed, and additional\npin vector.\n\nThese are related ideas, with subtle differences, but fundamentally\nthese are about allowing \"non-pin\" transactions to propagate without\nbeing top block, introducing minimal pinning risk alongside it.\n\nThis may allow more users to opt into this regime, build up\nmore backlog, reducing the UX pain and incentive compatibility\nquestion of dropping low-feerate but small transactions.\n\nThe remaining use-cases for V3.1 style policy would essentially\nbe consolidation transactions.\n\n# Some Possible Deployments\n\nHere are some ideas on what path we could take. Aside from\ncluster mempool, there are no hard constraints on what has to be\nshipped in what order, almost any steps can be completely skipped.\nThe most logical ordering will involve simple relaxations to relay rules.\n\n```mermaid height=728,auto\nflowchart TD\n    V3([V3]) -->|cpfp carveout maybe dead| C\n    C([Cluster mempool]):::required\n    C -.->|V3, but child top\\nblock| V3.0.5([V3.0.5])\n    V3.0.5 -->|any topo,\\nnon-single tx\\ntop block| V3.1([V3.1])\n    C -->|small cluster,\\ntop block\\nonly| V4a([V4a])\n    V4a:::genvict -->|any vsize cluster| V4b([V4b]):::genvict\n    V3.1:::genvict -.->|topblockify  single tx| V4b\n    V4b -->|<= X vbytes\\nnon-top block| V4c([V4c]):::genvict\n\n    Tx([No V3 style sibling eviction]):::genvict\n\n    classDef required fill:#aaaaaa\n    classDef genvict fill:#FF7F50\n```",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 31,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}