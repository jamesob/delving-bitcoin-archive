{
  "id": 1526,
  "name": "Suhas Daftuar",
  "username": "sdaftuar",
  "avatar_template": "/letter_avatar_proxy/v4/letter/s/0ea827/{size}.png",
  "created_at": "2024-02-13T02:06:15.860Z",
  "cooked": "<p>In this post, I\u2019ll attempt to summarize my current understanding of how to think about incentive compatibility, which has evolved over the past year while working on the cluster mempool project<sup class=\"footnote-ref\"><a href=\"#footnote-1526-1\" id=\"footnote-ref-1526-1\">[1]</a></sup>.</p>\n<h2><a name=\"motivating-questions-1\" class=\"anchor\" href=\"#motivating-questions-1\"></a>Motivating questions</h2>\n<p>Given a mempool with many transactions, which ones should be selected in the next block?  Assuming there\u2019s more than one miner on the network<sup class=\"footnote-ref\"><a href=\"#footnote-1526-2\" id=\"footnote-ref-1526-2\">[2]</a></sup>, the incentive is to maximize the next block\u2019s fees<sup class=\"footnote-ref\"><a href=\"#footnote-1526-3\" id=\"footnote-ref-1526-3\">[3]</a></sup> given the block size constraints.</p>\n<p>Of course, once the next block is found, we\u2019re going to want to do this again. So a natural extension of that question is to ask: how should we order all the transactions in the mempool, to fill all the blocks that could be filled, in such a way as to maximize the (cumulative) fees collected as each block is mined?  (This question would be nice to answer, because having a total ordering on all mempool transactions seems useful for knowing which transactions we should evict if we need to.)</p>\n<p>A related but more difficult question will follow: suppose we have two incompatible sets of transactions.  How can we determine which is the best set of transactions for miners to pick?  If we can answer this question, then this will give us some insights about how to develop a suitable RBF policy.</p>\n<h2><a name=\"ordering-the-mempool-by-feerate-2\" class=\"anchor\" href=\"#ordering-the-mempool-by-feerate-2\"></a>Ordering the mempool by \u201cfeerate\u201d</h2>\n<p>Due to the influx of new transactions, at any given point in time it\u2019s not clear how much of the mempool that we can see will ultimately be mined in the next block \u2013 new transactions may arrive that will be preferable to include, reducing what we select from what we can see right now.</p>\n<p>For a fixed mempool, the optimal sort order of the transactions in it will depend on how many vbytes we select. So the ideal set of questions to ask would be something like: for every integer N &gt; 0 , what is the optimal ordering of the transactions in the mempool to maximize total fees, if we were to select exactly N vbytes of transactions?  If we knew this answer, that would tell us everything we could possibly want to know about a transaction\u2019s value to us.  For example, if a transaction always sorted last (for every value of N), then that would be the first transaction we should evict if our mempool needed to be trimmed.</p>\n<p>Of course, as instances of the knapsack problem, answering these questions as stated is not feasible. And as a practical matter, it would be much more convenient to approximate the answer by just having a single ordering, or \u201c<strong>linearization</strong>\u201d, of our transactions, which we would use to estimate the contents of the best block at any given size by simply cutting off our ordered list at whatever size is needed.</p>\n<p>If topology<sup class=\"footnote-ref\"><a href=\"#footnote-1526-4\" id=\"footnote-ref-1526-4\">[4]</a></sup> were not an issue, we could approximate this answer very well by simply sorting all transactions in descending feerate order. As long as individual transactions are small compared to the block size, then this approximation would be close to the optimal answer we\u2019d get by actually solving the knapsack problem (the error is bounded by the ratio between the largest transaction in our mempool and the block size).</p>\n<p>However, topology requirements add an additional constraint \u2013 Bitcoin\u2019s consensus rules require us to order child transactions after their parents.  This introduces a new question: how should we think about linearizations in the presence of dependencies?  Consider a motivating example (assume all transactions shown are 100 vbytes):</p>\n<pre data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">flowchart TD\n    A[Tx A: 1 sat/vbyte] --&gt;B[Tx B: 10 sat/vbyte]\n    \n    C[Tx C: 3 sat/vbyte]\n</code></pre>\n<p>Tx A is low feerate, and Tx C has a higher feerate then A; but A+B together have a higher feerate than C. Of course, the intuitive answer here is that we probably want to bundle A+B together, and select them as a single \u201cchunk\u201d of transactions before C. But how can we systematize this understanding, and reconcile it with the idea that tx C has higher feerate than tx A, and therefore in some scenarios ought to be selected first?</p>\n<h3><a name=\"feerate-diagrams-as-a-way-to-resolve-this-question-3\" class=\"anchor\" href=\"#feerate-diagrams-as-a-way-to-resolve-this-question-3\"></a>Feerate diagrams as a way to resolve this question</h3>\n<p>That example raises the question of how we know whether to prefer linearizing those transactions as ABC or CAB \u2013 can we characterize what it means for one ordering of a set of transactions to be better than another?  Naively, we think of an optimal linearization as one where the most fees are collected in the fewest vbytes of transaction data.  We can represent this idea graphically; for a given linearization, plot the set of points:</p>\n<p><span class=\"math\">\\{(x_n, y_n) | x_n = </span> total_vbytes_of_first_n_transactions, <span class=\"math\"> y_n = </span> total_fees_of_first_n_transactions, <span class=\"math\"> 0 &lt;= n &lt;= </span> total_number_of_transactions <span class=\"math\">\\}</span></p>\n<p>These points measure the accumulated fees collected by a miner for selecting some subset of transactions in a way that is consistent with the linearization.</p>\n<p>In the 3-transaction example above, the two linearizations ABC and CAB would produce these diagrams:</p>\n<p><img src=\"https://delvingbitcoin.org/uploads/default/original/1X/011276e923c2448873e567a29c3e4da44d78b897.png\" alt=\"line-graph\" data-base62-sha1=\"9u2k1LsLCWunBpobWk4dcbv5RR\" width=\"600\" height=\"390\"></p>\n<p>Looking at this, it\u2019s not at first clear which ordering is better, because if 100 vbytes were to be selected from the mempool, then using the CAB order is best, while if 200 vbytes were to be selected, then ABC is the best order.  However, if we apply our reasoning from before, that if transactions \u2013 or in this case, chunks of transactions \u2013 are small compared to the block size, then a better approximation would be to assume that we\u2019d never need to consider splitting the pair A+B into separate pieces (we can pretend they represent a single indivisible transaction). With this assumption, we can construct new feerate diagrams that look like this:</p>\n<p><img src=\"https://delvingbitcoin.org/uploads/default/original/1X/bf99c5b57ae4509c42ec4548fddce2ac7ab583ab.png\" alt=\"line-graph (1)\" data-base62-sha1=\"rkYEsaD8fKolDqHzzqF2GGFrkuv\" width=\"600\" height=\"390\"></p>\n<p>In this graph, A+B is treated as indivisible in both orderings, and we can see now that the diagram for ABC is now the convex\nhull of its original diagram: as we move from left to right, the slope (ie feerate) of successive line segments is monotonically decreasing.  Looking at the CAB ordering, we can now also realize that we ought to never choose C without also selecting A+B, because the feerate goes <em>up</em> if we select all 3 together; so we ought to consider its convex hull as well, which would produce this diagram:</p>\n<p><img src=\"https://delvingbitcoin.org/uploads/default/original/1X/ffed9945665885f83a913c7edbcdd34e0edfd1f5.png\" alt=\"line-graph (2)\" data-base62-sha1=\"Aw2O5qDyUjtW1gbB5wdCvnul2QZ\" width=\"600\" height=\"390\"></p>\n<p>Taking these new graphs \u2013 the convex hulls of what we started with \u2013 as our canonical <strong>feerate diagram</strong> representation of a linearization, we can define that a linearization <span class=\"math\">O</span> is \u201cat least as good as\u201d linearization <span class=\"math\">P</span> if the graph of <span class=\"math\">O</span> contains the graph of <span class=\"math\">P</span>, or equivalently, if there are no points on the graphs of either for which <span class=\"math\">P</span>'s accumulated fees exceed that of <span class=\"math\">O</span>. (Similarly, we can say that <span class=\"math\">O</span> is \u201cstrictly better\u201d than <span class=\"math\">P</span> if it is at least as good as <span class=\"math\">P</span>, but <span class=\"math\">P</span> is not at least as good as <span class=\"math\">O</span> \u2013 ie, there is some point on the graphs of <span class=\"math\">O</span> or <span class=\"math\">P</span> where <span class=\"math\">O</span>'s accumulated fee exceeds that of <span class=\"math\">P</span>.)</p>\n<p>Note that it\u2019s also possible that two feerate diagrams might be incomparable, if neither one contains the other. So for a given fixed set of transactions, this introduces a partial ordering on the set of linearizations of those transactions.</p>\n<blockquote>\n<p><strong>Note:</strong>\nOverall, the key insight is that under the assumption that transaction chunks are small compared to the block size, then the convex hull of these accumulated fee diagrams captures the fee-maximizing strategy of a miner who will be using a\nsingle linearization of transactions to construct blocks.</p>\n</blockquote>\n<h3><a name=\"optimal-orderings-possible-in-this-setting-4\" class=\"anchor\" href=\"#optimal-orderings-possible-in-this-setting-4\"></a>Optimal orderings possible in this setting</h3>\n<p>Using the convex hull as our basis for defining a comparison of two linearizations turns out to have a very nice property.  Given this partial ordering, it turns out that for any given set of transactions, there always exists an optimal linearization (not necessarily unique) that is at least as good as any other linearization that can be constructed.  Pieter Wuille has proven this theorem <a href=\"https://delvingbitcoin.org/t/cluster-mempool-definitions-theory/202#optimal-linearizations-6\">here</a>.</p>\n<p>The intuitive way to construct an optimal ordering is by simply selecting amongst all topologically valid subsets of transaction the one that has the highest feerate, and then repeating until all transactions have been selected.  It is easy to see that if an optimal linearization exists, this algorithm must achieve it.</p>\n<h3><a name=\"clusters-5\" class=\"anchor\" href=\"#clusters-5\"></a>Clusters</h3>\n<p>Another simple observation is that transaction chunks in an optimal sort will always be topologically connected (if not, we could do better by splitting the chunk into connected components and then sorting the resulting pieces by feerate).  Thus, we can separately linearize the connected components, or <strong>clusters</strong>, of a given set of transactions and still be able to recover the optimal transaction ordering across all clusters (just by merge sorting the chunks of each cluster).  This insight is the motivation behind the <a href=\"https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393/1\"><strong>cluster mempool</strong></a> proposal.</p>\n<h3><a name=\"summary-6\" class=\"anchor\" href=\"#summary-6\"></a>Summary</h3>\n<p>Given the feerate diagram construction and partial ordering defined above, there must exist a single (not necessarily unique) linearization of transactions which we can use to construct blocks of arbitrary size. This gives an approximate solution to the block construction problem, and the deviation from the optimal block that could be found is bounded by the ratio between the maximum chunk size and the block size.</p>\n<h2><a name=\"comparing-linearizations-of-different-transaction-sets-7\" class=\"anchor\" href=\"#comparing-linearizations-of-different-transaction-sets-7\"></a>Comparing linearizations of different transaction sets</h2>\n<p>The feerate diagram defined above can be used to determine how we might compare different options for linearizing the <strong>same</strong> set of transactions.  However, our second question to address is how we might compare the desirability of two different incompatible sets of transactions; this is exactly the question we need to answer when implementing an RBF policy.</p>\n<h3><a name=\"background-8\" class=\"anchor\" href=\"#background-8\"></a>Background</h3>\n<p>As far as I am aware, in Bitcoin\u2019s 15 year history, no one has ever implemented RBF rules that satisfy the property that replacements are rejected unless they definitely make miners better off (with the exception of software versions that disallowed <em>all</em> replacements(!)).</p>\n<p>Here are some motivating examples that demonstrate the issues<sup class=\"footnote-ref\"><a href=\"#footnote-1526-5\" id=\"footnote-ref-1526-5\">[5]</a></sup>.  I\u2019ll focus on the RBF implementation from Bitcoin Core (largely described in BIP 125, and which has been around for 8+ years) and also touch on some other ideas that have come up from time to time.</p>\n<h4><a name=\"feerate-rule-9\" class=\"anchor\" href=\"#feerate-rule-9\"></a>Feerate rule</h4>\n<p>A rule that appears in BIP 125 is that the feerate of a replacement transaction must exceed that of all its (direct<sup class=\"footnote-ref\"><a href=\"#footnote-1526-6\" id=\"footnote-ref-1526-6\">[6]</a></sup>) conflicts. This might make it <em>seem</em> that the replacement transaction should be mined sooner than the transaction it replaces, meaning that miners would collect more fees sooner \u2013 which sounds like a better mempool than the original.  However this is not the case:</p>\n<pre data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">flowchart TD\n    A[Tx A: 1 sat/vbyte, 10k vbytes] --&gt;B[Tx B: 5 sat/vbyte, 20kvbytes]\n    A -.-&gt; B'[Tx B': 10 sat/vbyte, 100 vbytes]\n</code></pre>\n<p>In this example, A and B are in the mempool, and B\u2019 is a potential replacement of B.  B\u2019 pays a higher feerate than B, yet a miner including A+B\u2019 collects a lower feerate (and lower total fee) than a miner taking A+B.  This should make it clear that merely requiring the feerate of a replacement to be higher (even much higher!) than its conflicting transaction is insufficient by itself to guarantee incentive compatibility.</p>\n<h4><a name=\"total-fee-rule-10\" class=\"anchor\" href=\"#total-fee-rule-10\"></a>Total fee rule</h4>\n<p>BIP 125 also specifies that the total fee of a replacement must go up.  However this does not fix the problem described in the last section; just using that last example, we can see that if A and B\u2019 were already in the mempool, and then transaction B arrived, then it would be rejected under BIP 125 rules (since its feerate is below that of B\u2019), even though A+B has a better feerate than A+B\u2019.</p>\n<p>Of course, that would be an example of a replacement not being permitted where it should be. We have the other problem as well, which is that these rules can still be used to allow replacements which should not be permitted.  Consider:</p>\n<pre data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">flowchart TD\n    A[Tx A: 1 sat/vbyte, 100 vbytes] --&gt;B[Tx B: 49 sat/vbyte, 100 vbytes]\n    A'[Tx A': 2 sat/vbyte, 10k vbytes]\n</code></pre>\n<p>Imagine that A and B are already in the mempool, and transaction A\u2019 arrives that conflicts with A. It has a feerate that is greater than that of A (its only direct conflict), and pays a total fee in excess of A+B.  So under the feerate + total fee rule, A\u2019 could replace A+B, even though A+B have a feerate of 25 sat/vbyte, which is much higher than the feerate of A\u2019.</p>\n<p>Trying to modify this rule to take into account the feerate of indirect conflicts doesn\u2019t help much either.  If we require\nthat a replacement beat the feerate of indirect conflicts, then (a) that still is insufficient to prevent incentive incompatible replacements, AND (b) it introduces some significant pinning issues (preventing replacements that should be allowed).  Here are two small examples demonstrating each of these properties:</p>\n<pre data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">flowchart TD\n    A[Tx A: 1 sat/vbyte, 100 vbytes] --&gt;B1[Tx B1: 49 sat/vbyte, 100 vbytes]\n    C[Tx C: 1 sat/vbyte, 100kvbytes] --&gt; B2[Tx B2: 1 sat/vbyte, 100 bytes]\n    C -.-&gt; B'[Tx B': 50 sat/vbyte, 1000 vbytes]\n</code></pre>\n<p>In this example, B\u2019 conflicts with both B1 and B2.  Since it has a higher feerate than B1 and B2 and pays more total fees than both, it would pass both a total fee and feerate comparison test, yet it would be selected by miners at a lower feerate than B1 (due to its large, low fee parent C).  So we should not accept B\u2019 as a replacement.</p>\n<p>On the other hand, if we required a transaction to beat the feerates of all conflicting transactions, that would prevent some replacements from occurring which should be permitted:</p>\n<pre data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">flowchart TD\n    A[Tx A: 1 sat/vbyte, 100k vbytes] --&gt;B[Tx B: 1000 sat/vbyte, 100 vbytes]\n    A'[Tx A': 10 sat/vbyte, 100k vbytes]\n</code></pre>\n<p>In this example, if A+B are already in the mempool, then A\u2019 would not be permitted as a replacement, even though the feerate and total fees are substantially higher if we take A\u2019<sup class=\"footnote-ref\"><a href=\"#footnote-1526-7\" id=\"footnote-ref-1526-7\">[7]</a></sup>.  In order for A\u2019 to exceed B\u2019s feerate in this example, it would have to pay a very large amount in total fees.</p>\n<h4><a name=\"using-the-ancestor-feerate-11\" class=\"anchor\" href=\"#using-the-ancestor-feerate-11\"></a>Using the ancestor feerate</h4>\n<p>I\u2019ve previously suggested not just using a transaction\u2019s feerate<sup class=\"footnote-ref\"><a href=\"#footnote-1526-8\" id=\"footnote-ref-1526-8\">[8]</a></sup>, but also its ancestor feerate as a score to consider in our RBF rules. Specifically, my initial suggestion was to use the minimum of a transactions feerate and its ancestor feerate as a proxy for its mining score, thinking that this would be a lower bound on where it would get mined. But it turns out this is not conservative enough \u2013 consider this example:</p>\n<pre data-code-height=\"146\" data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">flowchart TD\n    A[Tx A: 1 sat/vbyte, 10k vbytes] -.-&gt; C[Tx C: 100 sat/vbyte, 100 vbytes]\n    B[Tx B: 300 sat/vbyte, 10k vbytes] -.-&gt; C\n</code></pre>\n<p>Imagine that C would be a replacement of some other mempool transaction, and we want to know what C\u2019s mining score is. C\u2019s own feerate is 100 sats/vbyte; its ancestor feerate is clearly much higher, but its actual feerate when mined will be very low, because tx B would get mined by itself.</p>\n<p>It seems instead that any RBF policy would need to take the actual topology into account, which is something that statistics like the ancestor feerate gloss over.</p>\n<h3><a name=\"using-feerate-diagrams-as-an-rbf-policy-tool-12\" class=\"anchor\" href=\"#using-feerate-diagrams-as-an-rbf-policy-tool-12\"></a>Using feerate diagrams as an RBF policy tool</h3>\n<p>After the previous section argued for the virtues of feerate diagrams as a way to compare the quality of linearizations, it is\nnatural to wonder whether feerate diagrams might help us in the RBF setting as well.</p>\n<p>Suppose we have one set of transactions S and some incompatible other set of transactions T (arrived at by adding some transactions that conflict with one or more transactions in S).  We want to know if miners should stick with S or switch to T.</p>\n<p>As before, we can calculate the feerate diagram of the linearization of S (F(S)) and compare it to the feerate diagram of the linearization of T (F(T)).  If F(S) is strictly better than F(T) then it seeems clear that miners should prefer S to T.  However, if F(S) and F(T) are incomparable, meaning there is some size at which F(T) has a higher accumulated fee \u2013 and therefore higher feerate \u2013 than F(S), and vice versa, then we have no way to tell which is better for miners.</p>\n<p>In the setting of linearizations of a single set of transactions, we had the nice property that we know an optimal linearization always exists that is at least as good as any other, so dealing with what to do in the face of incomparable linearizations is not really an issue<sup class=\"footnote-ref\"><a href=\"#footnote-1526-9\" id=\"footnote-ref-1526-9\">[9]</a></sup>. However, that concept does not generalize to how we think about incompatible transaction sets.  Consider two conflicting transactions:</p>\n<ul>\n<li>Tx A: feerate 100 s/vbyte, 100 vbytes, 10k sats total</li>\n<li>Tx A\u2019: feerate 50 s/vbyte, 2000 vbytes, 100k sats total</li>\n</ul>\n<p>Which one is better for a miner? The feerate diagram of two mempools that differ only in the presence of tx A vs A\u2019 would have incomparable feerate diagrams.  If nothing else in the mempool was anywhere near the feerate of A\u2019, then a miner would probably prefer it, as that would maximize the fee in the next block. On the other hand, if there are a lot of transactions with feerates in between A and A\u2019, then it\u2019s possible that a miner would prefer tx A.</p>\n<h4><a name=\"a-simple-analysis-of-a-toy-problem-13\" class=\"anchor\" href=\"#a-simple-analysis-of-a-toy-problem-13\"></a>A simple analysis of a toy problem</h4>\n<p>To illustrate this point further, consider another example of two conflicting transactions that are the same size (and assume for simplicity that there are no other transactions in the mempool):</p>\n<ul>\n<li>Tx B: 1000 sats, eligible to be mined in next block</li>\n<li>Tx B\u2019: 100k sats, but timelocked so it can only be mined <em>after</em> the next block, ie in the second block from now</li>\n</ul>\n<p>What should a miner do in this situation? I believe it depends on factors outside of what is stated.  Every miner has a choice of whether to follow a GREEDY strategy and try to include tx B now (and tx B\u2019 in the next block, if tx B is NOT mined in the first block), or a WAIT strategy where they include nothing in the next block in the hopes of being able to include B\u2019 in the second block.</p>\n<p>First, let\u2019s consider a miner with 0.5% of the total hash rate on the network.</p>\n<p>We can calculate the payoffs for following each strategy for this miner, conditioning on what the rest of the network does:</p>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th>Strategy of rest of network</th>\n<th>Payoff for WAIT</th>\n<th>Payoff for GREEDY</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WAIT</td>\n<td><span class=\"math\">0.005 * 100000 = 500</span></td>\n<td><span class=\"math\">0.005 * 1000 + 0.995 * 0.005 * 100000 = 502.5</span></td>\n</tr>\n<tr>\n<td>GREEDY</td>\n<td><span class=\"math\">0.005 * 0.005 * 100000 = 2.5</span></td>\n<td><span class=\"math\">0.005 * 1000 = 5</span></td>\n</tr>\n</tbody>\n</table>\n</div><p>So regardless of what the rest of the network does, for the 0.5% miner, the payoff for GREEDY is greater than the payoff for WAIT, and this miner should be including tx B now.</p>\n<p>Consider instead how this analysis plays out for a miner with 25% hashrate:</p>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th>Strategy of rest of network</th>\n<th>Payoff for WAIT</th>\n<th>Payoff for GREEDY</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WAIT</td>\n<td><span class=\"math\">0.25 * 100000 = 25000</span></td>\n<td><span class=\"math\">0.25 * 1000 + 0.75 * 0.25 * 100000 = 19000</span></td>\n</tr>\n<tr>\n<td>GREEDY</td>\n<td><span class=\"math\">0.25 * 0.25 * 100000 = 6250</span></td>\n<td><span class=\"math\">0.25 * 1000 = 250</span></td>\n</tr>\n</tbody>\n</table>\n</div><p>For this miner, regardless of what the rest of the network does, the payoff for WAIT exceeds that of GREEDY, and the 25% miner would prefer to <strong>not</strong> work on tx B in the next block, unlike the 0.5% miner.</p>\n<p>I imagine there\u2019s a more comprehensive way of thinking about this problem, but I believe this illustrates that the choice of which transaction to prefer in the face of conflicts depends on more information than just\nthe transactions themselves<sup class=\"footnote-ref\"><a href=\"#footnote-1526-10\" id=\"footnote-ref-1526-10\">[10]</a></sup>.</p>\n<blockquote>\n<p><strong>Note:</strong> Having an RBF policy that requires the feerate diagram to strictly improve prevents incentive incompatible replacements, but it likely also excludes replacements which are incentive compatible as well. This seems like an area that would be a good future research project.</p>\n</blockquote>\n<h2><a name=\"anti-dos-considerations-14\" class=\"anchor\" href=\"#anti-dos-considerations-14\"></a>Anti-DoS considerations</h2>\n<p>All of the above discussion is just focused on incentive compatibility, without regard to denial of service concerns \u2013 all we were concerned with was ordering transactions we somehow have, or figuring out which transactions that we have access to are best to keep.</p>\n<p>In practice, we have to also ask the question of whether our incentive compatibility reasoning introduces denial-of-service concerns \u2013 it\u2019s not a priori obvious that this shouldn\u2019t be the case.  Our main concern is typically preventing \u201cfree relay\u201d, ie preventing situations where transactions are relayed on the network without any kind of external cost being borne \u2013 if that were possible, then it would be free to overwhelm the network with such \u201cfree\u201d transactions and tie up nodes\u2019 CPU and network resources.</p>\n<p>Since our goal for the Bitcoin p2p network is one that is decentralized and open to anyone to join, we can\u2019t easily assign fees to particular network peers. Instead, we prevent free relay by ensuring that the fees in the transactions being relayed are commensurate with the bytes being relayed \u2013 our goal is that over any given time period (say, where no blocks have been found), we want that <code>total_fees_added_to_mempool / bytes_relayed &gt;= minimum_relay_fee</code>.</p>\n<p>While the minimum relay fee is itself an arbitrary value (1 sat/vbyte by default in Bitcoin Core), this principle ensures that increased network usage comes with increased costs. Moreover, raising the minimum relay fee is a way to increase\nthe costs associated with increased network use, while decreasing the fee lowers the cost for users (or attackers) to tie up network resources.</p>\n<h3><a name=\"example-bip-125s-prevention-of-free-relay-15\" class=\"anchor\" href=\"#example-bip-125s-prevention-of-free-relay-15\"></a>Example: BIP 125\u2019s prevention of free relay</h3>\n<p>One of the most important (but frustrating!) BIP 125 policy rules is the requirement that the total fees in the mempool after processing a replacement must increase by <code>minimum_relay_fee * new_transaction_size</code>. As discussed above, the BIP 125 rules do not achieve incentive compatibility, but because of this rule they do at least prevent free relay.</p>\n<p>This rule is also the chief source of RBF \u201cpinning\u201d, where large, low-feerate transactions cannot easily be replaced by smaller, high feerate transactions.  But if we were to eliminate it, then the minimum relay fee will cease to be a bound on <code>fees paid / bytes relayed</code>.  Analyzing a particular scenario requires taking into account the variety of other policy rules in place (which may serve to limit usage patterns in some way), but a simple example that would become possible if we just dropped the total fee rule of BIP 125 would be the following:</p>\n<ul>\n<li>100 transactions of size 100kvb are relayed on the network and added to the mempool, at the min relay fee (say 1 sat/vbyte)</li>\n<li>A single 100-input transaction that conflicts with a single input from each of those transactions is relayed at 1.001 sat/vbyte (I\u2019ll approximate it as 10kvb in total size, but it\u2019s actually a bit less).</li>\n</ul>\n<p>At this point, a little over 10MvB have been relayed on the network, but only about 10k sats have been spent in fees available to be mined.  This is a factor of almost 1000 decrease in the minimum relay fee we\u2019d like to enforce \u2013 meaning that if users wanted to update their node settings so that the resource usage costs are the same in this hypothetical as they are today, they\u2019d have to update their min relay fee to 1000 sats/vbyte \u2013 probably not something anyone wants to do.<sup class=\"footnote-ref\"><a href=\"#footnote-1526-11\" id=\"footnote-ref-1526-11\">[11]</a></sup></p>\n<h3><a name=\"example-mempool-eviction-is-a-source-of-bounded-free-relay-16\" class=\"anchor\" href=\"#example-mempool-eviction-is-a-source-of-bounded-free-relay-16\"></a>Example: mempool eviction is a source of (bounded) free-relay</h3>\n<p>When the mempool exceeds its size limit (after accepting a new transaction), we will evict transactions from the \u201cbottom\u201d \u2013 and potentially the total fee of the mempool will have gone down as a result.  To avoid unbounded free relay, we increase the feerate required to enter the mempool whenever an eviction takes place, by bumping the minimum relay to a value equal to the feerate of what we have evicted plus an increment (equal to the min relay fee).</p>\n<p>Effectively, we use new transactions being added to the mempool to pay for the eviction that has just happened. Since that happens after the eviction, though, there is an opportunity for free relay if no new transactions come in, because eventually the minimum relay fee will decay back down to its starting value. That decay parameter, coupled with maximum size we might evict at once, gives us a way to calculate the amount of free relay that is possible (over some time period).</p>\n<h3><a name=\"summary-17\" class=\"anchor\" href=\"#summary-17\"></a>Summary</h3>\n<p>An interesting and valuable area of research would be to determine if there are incentive compatible behaviors that would not be DoS-resistant to deploy on the entire network (and characterize them, if they exist). If so, such behaviors could introduce an incentive for users to connect directly to miners, which might be mutually beneficial to those parties but harmful to the decentralization of mining on the network overall.</p>\n<p>Understanding those scenarios may also be helpful to us as we try to design incentive compatible protocols that <em>are</em> DoS-resistant, so that we know where the boundaries are of what is possible.</p>\n<hr class=\"footnotes-sep\">\n\n<ol class=\"footnotes-list\">\n<li id=\"footnote-1526-1\" class=\"footnote-item\"><p>My thoughts here are based on many discussions with others, particularly in the last year; thanks especially to Pieter Wuille, Mark Erhardt, Clara Shikhelman, Greg Sanders, Gloria Zhao, and Anthony Towns for sharing their insights and analysis with me. <a href=\"#footnote-ref-1526-1\" class=\"footnote-backref\">\u21a9\ufe0e</a></p>\n</li>\n<li id=\"footnote-1526-2\" class=\"footnote-item\"><p>In the case that there is only 1 miner, then the order doesn\u2019t matter since the miner eventually collects everything; all the miner would care about is total fees collected. <a href=\"#footnote-ref-1526-2\" class=\"footnote-backref\">\u21a9\ufe0e</a></p>\n</li>\n<li id=\"footnote-1526-3\" class=\"footnote-item\"><p>In this post, I\u2019m focused on the narrow question of how to order transactions in the mempool to maximize fees.  I\u2019m ignoring the game theoretic effects of miners potentially leaving high-fee paying transactions out of a block as an incentive for other miners to extend the chain, rather than reorg it. <a href=\"#footnote-ref-1526-3\" class=\"footnote-backref\">\u21a9\ufe0e</a></p>\n</li>\n<li id=\"footnote-1526-4\" class=\"footnote-item\"><p>By \u201ctopology\u201d, I mean the consensus rules that govern valid orderings of transactions in a block, namely that parent transactions must appear before child transactions. <a href=\"#footnote-ref-1526-4\" class=\"footnote-backref\">\u21a9\ufe0e</a></p>\n</li>\n<li id=\"footnote-1526-5\" class=\"footnote-item\"><p>TODO: find references to prior work and update this footnote, as this has been covered at length in various forums. But for instance: see Gloria\u2019s <a href=\"https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html\">mailing list post on RBF</a>, and also some discussion in <a href=\"https://github.com/bitcoin/bitcoin/pull/26451\">#26451</a>. <a href=\"#footnote-ref-1526-5\" class=\"footnote-backref\">\u21a9\ufe0e</a></p>\n</li>\n<li id=\"footnote-1526-6\" class=\"footnote-item\"><p>By \u201cdirect\u201d conflicts, we refer to transactions which are spending 1 or more of the same inputs. By \u201cindirect\u201d conflicts, we mean transactions that do not directly spend the same inputs as a given transaction, but are descendant transactions of a direct conflict. <a href=\"#footnote-ref-1526-6\" class=\"footnote-backref\">\u21a9\ufe0e</a></p>\n</li>\n<li id=\"footnote-1526-7\" class=\"footnote-item\"><p>Note that the other BIP 125 rules (eg against not introducing new unconfirmed parents, or the maximum number of conflicts allowed) don\u2019t help the situation at all.  The examples in this section wouldn\u2019t have triggered violations of those rules either. <a href=\"#footnote-ref-1526-7\" class=\"footnote-backref\">\u21a9\ufe0e</a></p>\n</li>\n<li id=\"footnote-1526-8\" class=\"footnote-item\"><p>I started to propose an approach like this <a href=\"https://github.com/bitcoin/bitcoin/pull/26451\">here</a>, before realizing it was pretty broken (and not just because it would making RBF pinning far worse than it is today!). <a href=\"#footnote-ref-1526-8\" class=\"footnote-backref\">\u21a9\ufe0e</a></p>\n</li>\n<li id=\"footnote-1526-9\" class=\"footnote-item\"><p>In fact, Pieter came up with a polynomial-time <a href=\"https://delvingbitcoin.org/t/cluster-mempool-definitions-theory/202#merging-linearizations-5\">merging algorithm</a> that can take two incomparable linearizations as input, and produce a linearization that is strictly better than either. <a href=\"#footnote-ref-1526-9\" class=\"footnote-backref\">\u21a9\ufe0e</a></p>\n</li>\n<li id=\"footnote-1526-10\" class=\"footnote-item\"><p>An interesting side note to this example is that while offering a feerate-only RBF policy may be in the best interests of a user and a small miner, because large miners benefit from maximizing total fees, it seems plausible that that users attempting to do feerate-only RBF might create incentives for miners to form coalitions and cooperate to prevent this from happening, since they all benefit when total fees are maximized. I have no idea if the game theory would actually play out this way, however; perhaps this is a question worthy of further study. <a href=\"#footnote-ref-1526-10\" class=\"footnote-backref\">\u21a9\ufe0e</a></p>\n</li>\n<li id=\"footnote-1526-11\" class=\"footnote-item\"><p>I imagine there are ways to make network usage go up by more than what I just described here \u2013 this is not a very sophisticated scenario! I can think of one modification to raise the effect from being a 1000x decreaes to 50,000x decrease, but the details are boring and possibly there are more clever scenarios that exist anyway. <a href=\"#footnote-ref-1526-11\" class=\"footnote-backref\">\u21a9\ufe0e</a></p>\n</li>\n</ol>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2024-02-13T02:13:31.506Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 6,
  "readers_count": 5,
  "score": 16.2,
  "yours": false,
  "topic_id": 553,
  "topic_slug": "mempool-incentive-compatibility",
  "topic_title": "Mempool Incentive Compatibility",
  "topic_html_title": "Mempool Incentive Compatibility",
  "category_id": 7,
  "display_username": "Suhas Daftuar",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 3,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "In this post, I'll attempt to summarize my current understanding of how to think about incentive compatibility, which has evolved over the past year while working on the cluster mempool project[^0].\n\n## Motivating questions\n\nGiven a mempool with many transactions, which ones should be selected in the next block?  Assuming there's more than one miner on the network[^1], the incentive is to maximize the next block's fees[^2] given the block size constraints.\n\nOf course, once the next block is found, we're going to want to do this again. So a natural extension of that question is to ask: how should we order all the transactions in the mempool, to fill all the blocks that could be filled, in such a way as to maximize the (cumulative) fees collected as each block is mined?  (This question would be nice to answer, because having a total ordering on all mempool transactions seems useful for knowing which transactions we should evict if we need to.)\n\nA related but more difficult question will follow: suppose we have two incompatible sets of transactions.  How can we determine which is the best set of transactions for miners to pick?  If we can answer this question, then this will give us some insights about how to develop a suitable RBF policy.\n\n## Ordering the mempool by \"feerate\"\n\nDue to the influx of new transactions, at any given point in time it's not clear how much of the mempool that we can see will ultimately be mined in the next block -- new transactions may arrive that will be preferable to include, reducing what we select from what we can see right now.\n\nFor a fixed mempool, the optimal sort order of the transactions in it will depend on how many vbytes we select. So the ideal set of questions to ask would be something like: for every integer N > 0 , what is the optimal ordering of the transactions in the mempool to maximize total fees, if we were to select exactly N vbytes of transactions?  If we knew this answer, that would tell us everything we could possibly want to know about a transaction's value to us.  For example, if a transaction always sorted last (for every value of N), then that would be the first transaction we should evict if our mempool needed to be trimmed. \n\nOf course, as instances of the knapsack problem, answering these questions as stated is not feasible. And as a practical matter, it would be much more convenient to approximate the answer by just having a single ordering, or \"**linearization**\", of our transactions, which we would use to estimate the contents of the best block at any given size by simply cutting off our ordered list at whatever size is needed.\n\nIf topology[^3] were not an issue, we could approximate this answer very well by simply sorting all transactions in descending feerate order. As long as individual transactions are small compared to the block size, then this approximation would be close to the optimal answer we'd get by actually solving the knapsack problem (the error is bounded by the ratio between the largest transaction in our mempool and the block size).\n\nHowever, topology requirements add an additional constraint -- Bitcoin's consensus rules require us to order child transactions after their parents.  This introduces a new question: how should we think about linearizations in the presence of dependencies?  Consider a motivating example (assume all transactions shown are 100 vbytes):\n\n```mermaid\nflowchart TD\n    A[Tx A: 1 sat/vbyte] -->B[Tx B: 10 sat/vbyte]\n    \n    C[Tx C: 3 sat/vbyte]\n```\nTx A is low feerate, and Tx C has a higher feerate then A; but A+B together have a higher feerate than C. Of course, the intuitive answer here is that we probably want to bundle A+B together, and select them as a single \"chunk\" of transactions before C. But how can we systematize this understanding, and reconcile it with the idea that tx C has higher feerate than tx A, and therefore in some scenarios ought to be selected first?\n\n### Feerate diagrams as a way to resolve this question\n\nThat example raises the question of how we know whether to prefer linearizing those transactions as ABC or CAB -- can we characterize what it means for one ordering of a set of transactions to be better than another?  Naively, we think of an optimal linearization as one where the most fees are collected in the fewest vbytes of transaction data.  We can represent this idea graphically; for a given linearization, plot the set of points:\n\n$\\{(x_n, y_n) | x_n = $ total_vbytes_of_first_n_transactions, $ y_n = $ total_fees_of_first_n_transactions, $ 0 <= n <= $ total_number_of_transactions $\\}$\n\nThese points measure the accumulated fees collected by a miner for selecting some subset of transactions in a way that is consistent with the linearization.\n\nIn the 3-transaction example above, the two linearizations ABC and CAB would produce these diagrams:\n\n![line-graph](upload://9u2k1LsLCWunBpobWk4dcbv5RR.png)\n\nLooking at this, it's not at first clear which ordering is better, because if 100 vbytes were to be selected from the mempool, then using the CAB order is best, while if 200 vbytes were to be selected, then ABC is the best order.  However, if we apply our reasoning from before, that if transactions -- or in this case, chunks of transactions -- are small compared to the block size, then a better approximation would be to assume that we'd never need to consider splitting the pair A+B into separate pieces (we can pretend they represent a single indivisible transaction). With this assumption, we can construct new feerate diagrams that look like this:\n\n![line-graph (1)](upload://rkYEsaD8fKolDqHzzqF2GGFrkuv.png)\n\nIn this graph, A+B is treated as indivisible in both orderings, and we can see now that the diagram for ABC is now the convex\nhull of its original diagram: as we move from left to right, the slope (ie feerate) of successive line segments is monotonically decreasing.  Looking at the CAB ordering, we can now also realize that we ought to never choose C without also selecting A+B, because the feerate goes *up* if we select all 3 together; so we ought to consider its convex hull as well, which would produce this diagram:\n\n![line-graph (2)](upload://Aw2O5qDyUjtW1gbB5wdCvnul2QZ.png)\n\nTaking these new graphs -- the convex hulls of what we started with -- as our canonical **feerate diagram** representation of a linearization, we can define that a linearization $O$ is \"at least as good as\" linearization $P$ if the graph of $O$ contains the graph of $P$, or equivalently, if there are no points on the graphs of either for which $P$'s accumulated fees exceed that of $O$. (Similarly, we can say that $O$ is \"strictly better\" than $P$ if it is at least as good as $P$, but $P$ is not at least as good as $O$ -- ie, there is some point on the graphs of $O$ or $P$ where $O$'s accumulated fee exceeds that of $P$.)\n\nNote that it's also possible that two feerate diagrams might be incomparable, if neither one contains the other. So for a given fixed set of transactions, this introduces a partial ordering on the set of linearizations of those transactions.\n\n> **Note:**\n> Overall, the key insight is that under the assumption that transaction chunks are small compared to the block size, then the convex hull of these accumulated fee diagrams captures the fee-maximizing strategy of a miner who will be using a\n> single linearization of transactions to construct blocks.\n\n### Optimal orderings possible in this setting\n\nUsing the convex hull as our basis for defining a comparison of two linearizations turns out to have a very nice property.  Given this partial ordering, it turns out that for any given set of transactions, there always exists an optimal linearization (not necessarily unique) that is at least as good as any other linearization that can be constructed.  Pieter Wuille has proven this theorem [here](https://delvingbitcoin.org/t/cluster-mempool-definitions-theory/202#optimal-linearizations-6).\n\nThe intuitive way to construct an optimal ordering is by simply selecting amongst all topologically valid subsets of transaction the one that has the highest feerate, and then repeating until all transactions have been selected.  It is easy to see that if an optimal linearization exists, this algorithm must achieve it.\n\n### Clusters\n\nAnother simple observation is that transaction chunks in an optimal sort will always be topologically connected (if not, we could do better by splitting the chunk into connected components and then sorting the resulting pieces by feerate).  Thus, we can separately linearize the connected components, or **clusters**, of a given set of transactions and still be able to recover the optimal transaction ordering across all clusters (just by merge sorting the chunks of each cluster).  This insight is the motivation behind the [**cluster mempool**](https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393/1) proposal.\n\n### Summary\n\nGiven the feerate diagram construction and partial ordering defined above, there must exist a single (not necessarily unique) linearization of transactions which we can use to construct blocks of arbitrary size. This gives an approximate solution to the block construction problem, and the deviation from the optimal block that could be found is bounded by the ratio between the maximum chunk size and the block size.\n\n## Comparing linearizations of different transaction sets\n\nThe feerate diagram defined above can be used to determine how we might compare different options for linearizing the **same** set of transactions.  However, our second question to address is how we might compare the desirability of two different incompatible sets of transactions; this is exactly the question we need to answer when implementing an RBF policy.\n\n### Background\n\nAs far as I am aware, in Bitcoin's 15 year history, no one has ever implemented RBF rules that satisfy the property that replacements are rejected unless they definitely make miners better off (with the exception of software versions that disallowed *all* replacements(!)).\n\nHere are some motivating examples that demonstrate the issues[^4].  I'll focus on the RBF implementation from Bitcoin Core (largely described in BIP 125, and which has been around for 8+ years) and also touch on some other ideas that have come up from time to time.\n\n#### Feerate rule\n\nA rule that appears in BIP 125 is that the feerate of a replacement transaction must exceed that of all its (direct[^direct]) conflicts. This might make it *seem* that the replacement transaction should be mined sooner than the transaction it replaces, meaning that miners would collect more fees sooner -- which sounds like a better mempool than the original.  However this is not the case:\n\n```mermaid\nflowchart TD\n    A[Tx A: 1 sat/vbyte, 10k vbytes] -->B[Tx B: 5 sat/vbyte, 20kvbytes]\n    A -.-> B'[Tx B': 10 sat/vbyte, 100 vbytes]\n```\n\nIn this example, A and B are in the mempool, and B' is a potential replacement of B.  B' pays a higher feerate than B, yet a miner including A+B' collects a lower feerate (and lower total fee) than a miner taking A+B.  This should make it clear that merely requiring the feerate of a replacement to be higher (even much higher!) than its conflicting transaction is insufficient by itself to guarantee incentive compatibility.\n\n#### Total fee rule\n\nBIP 125 also specifies that the total fee of a replacement must go up.  However this does not fix the problem described in the last section; just using that last example, we can see that if A and B' were already in the mempool, and then transaction B arrived, then it would be rejected under BIP 125 rules (since its feerate is below that of B'), even though A+B has a better feerate than A+B'.\n\nOf course, that would be an example of a replacement not being permitted where it should be. We have the other problem as well, which is that these rules can still be used to allow replacements which should not be permitted.  Consider:\n\n```mermaid\nflowchart TD\n    A[Tx A: 1 sat/vbyte, 100 vbytes] -->B[Tx B: 49 sat/vbyte, 100 vbytes]\n    A'[Tx A': 2 sat/vbyte, 10k vbytes]\n```\n\nImagine that A and B are already in the mempool, and transaction A' arrives that conflicts with A. It has a feerate that is greater than that of A (its only direct conflict), and pays a total fee in excess of A+B.  So under the feerate + total fee rule, A' could replace A+B, even though A+B have a feerate of 25 sat/vbyte, which is much higher than the feerate of A'.\n\nTrying to modify this rule to take into account the feerate of indirect conflicts doesn't help much either.  If we require\nthat a replacement beat the feerate of indirect conflicts, then (a) that still is insufficient to prevent incentive incompatible replacements, AND (b) it introduces some significant pinning issues (preventing replacements that should be allowed).  Here are two small examples demonstrating each of these properties:\n\n```mermaid\nflowchart TD\n    A[Tx A: 1 sat/vbyte, 100 vbytes] -->B1[Tx B1: 49 sat/vbyte, 100 vbytes]\n    C[Tx C: 1 sat/vbyte, 100kvbytes] --> B2[Tx B2: 1 sat/vbyte, 100 bytes]\n    C -.-> B'[Tx B': 50 sat/vbyte, 1000 vbytes]\n```\n\nIn this example, B' conflicts with both B1 and B2.  Since it has a higher feerate than B1 and B2 and pays more total fees than both, it would pass both a total fee and feerate comparison test, yet it would be selected by miners at a lower feerate than B1 (due to its large, low fee parent C).  So we should not accept B' as a replacement.\n\nOn the other hand, if we required a transaction to beat the feerates of all conflicting transactions, that would prevent some replacements from occurring which should be permitted:\n\n```mermaid\nflowchart TD\n    A[Tx A: 1 sat/vbyte, 100k vbytes] -->B[Tx B: 1000 sat/vbyte, 100 vbytes]\n    A'[Tx A': 10 sat/vbyte, 100k vbytes]\n```\n\nIn this example, if A+B are already in the mempool, then A' would not be permitted as a replacement, even though the feerate and total fees are substantially higher if we take A'[^5].  In order for A' to exceed B's feerate in this example, it would have to pay a very large amount in total fees.\n\n#### Using the ancestor feerate\n\nI've previously suggested not just using a transaction's feerate[^26451], but also its ancestor feerate as a score to consider in our RBF rules. Specifically, my initial suggestion was to use the minimum of a transactions feerate and its ancestor feerate as a proxy for its mining score, thinking that this would be a lower bound on where it would get mined. But it turns out this is not conservative enough -- consider this example:\n\n```mermaid height=146,auto\nflowchart TD\n    A[Tx A: 1 sat/vbyte, 10k vbytes] -.-> C[Tx C: 100 sat/vbyte, 100 vbytes]\n    B[Tx B: 300 sat/vbyte, 10k vbytes] -.-> C\n```\n\nImagine that C would be a replacement of some other mempool transaction, and we want to know what C's mining score is. C's own feerate is 100 sats/vbyte; its ancestor feerate is clearly much higher, but its actual feerate when mined will be very low, because tx B would get mined by itself.\n\nIt seems instead that any RBF policy would need to take the actual topology into account, which is something that statistics like the ancestor feerate gloss over.\n\n### Using feerate diagrams as an RBF policy tool\n\nAfter the previous section argued for the virtues of feerate diagrams as a way to compare the quality of linearizations, it is\nnatural to wonder whether feerate diagrams might help us in the RBF setting as well.\n\nSuppose we have one set of transactions S and some incompatible other set of transactions T (arrived at by adding some transactions that conflict with one or more transactions in S).  We want to know if miners should stick with S or switch to T.\n\nAs before, we can calculate the feerate diagram of the linearization of S (F(S)) and compare it to the feerate diagram of the linearization of T (F(T)).  If F(S) is strictly better than F(T) then it seeems clear that miners should prefer S to T.  However, if F(S) and F(T) are incomparable, meaning there is some size at which F(T) has a higher accumulated fee -- and therefore higher feerate -- than F(S), and vice versa, then we have no way to tell which is better for miners.\n\nIn the setting of linearizations of a single set of transactions, we had the nice property that we know an optimal linearization always exists that is at least as good as any other, so dealing with what to do in the face of incomparable linearizations is not really an issue[^merging]. However, that concept does not generalize to how we think about incompatible transaction sets.  Consider two conflicting transactions:\n\n* Tx A: feerate 100 s/vbyte, 100 vbytes, 10k sats total\n* Tx A': feerate 50 s/vbyte, 2000 vbytes, 100k sats total\n\nWhich one is better for a miner? The feerate diagram of two mempools that differ only in the presence of tx A vs A' would have incomparable feerate diagrams.  If nothing else in the mempool was anywhere near the feerate of A', then a miner would probably prefer it, as that would maximize the fee in the next block. On the other hand, if there are a lot of transactions with feerates in between A and A', then it's possible that a miner would prefer tx A.\n\n#### A simple analysis of a toy problem\n\nTo illustrate this point further, consider another example of two conflicting transactions that are the same size (and assume for simplicity that there are no other transactions in the mempool):\n\n* Tx B: 1000 sats, eligible to be mined in next block\n* Tx B': 100k sats, but timelocked so it can only be mined *after* the next block, ie in the second block from now\n\nWhat should a miner do in this situation? I believe it depends on factors outside of what is stated.  Every miner has a choice of whether to follow a GREEDY strategy and try to include tx B now (and tx B' in the next block, if tx B is NOT mined in the first block), or a WAIT strategy where they include nothing in the next block in the hopes of being able to include B' in the second block.\n\nFirst, let's consider a miner with 0.5% of the total hash rate on the network. \n\nWe can calculate the payoffs for following each strategy for this miner, conditioning on what the rest of the network does:\n\n| Strategy of rest of network | Payoff for WAIT | Payoff for GREEDY|\n|-----------------------------|-----------------|------------------|\n| WAIT | $0.005 * 100000 = 500$ | $0.005 * 1000 + 0.995 * 0.005 * 100000 = 502.5$ |\n| GREEDY | $0.005 * 0.005 * 100000 = 2.5$ | $0.005 * 1000 = 5$ |\n\nSo regardless of what the rest of the network does, for the 0.5% miner, the payoff for GREEDY is greater than the payoff for WAIT, and this miner should be including tx B now.\n\nConsider instead how this analysis plays out for a miner with 25% hashrate:\n \n| Strategy of rest of network | Payoff for WAIT | Payoff for GREEDY|\n|-----------------------------|-----------------|------------------|\n| WAIT | $0.25 * 100000 = 25000$ | $0.25 * 1000 + 0.75 * 0.25 * 100000 = 19000$ |\n| GREEDY | $0.25 * 0.25 * 100000 = 6250$ | $0.25 * 1000 = 250$ |\n\nFor this miner, regardless of what the rest of the network does, the payoff for WAIT exceeds that of GREEDY, and the 25% miner would prefer to **not** work on tx B in the next block, unlike the 0.5% miner.\n\nI imagine there's a more comprehensive way of thinking about this problem, but I believe this illustrates that the choice of which transaction to prefer in the face of conflicts depends on more information than just\nthe transactions themselves[^centralization].\n\n\n> **Note:** Having an RBF policy that requires the feerate diagram to strictly improve prevents incentive incompatible replacements, but it likely also excludes replacements which are incentive compatible as well. This seems like an area that would be a good future research project.\n\n## Anti-DoS considerations\n\nAll of the above discussion is just focused on incentive compatibility, without regard to denial of service concerns -- all we were concerned with was ordering transactions we somehow have, or figuring out which transactions that we have access to are best to keep.\n\nIn practice, we have to also ask the question of whether our incentive compatibility reasoning introduces denial-of-service concerns -- it's not a priori obvious that this shouldn't be the case.  Our main concern is typically preventing \"free relay\", ie preventing situations where transactions are relayed on the network without any kind of external cost being borne -- if that were possible, then it would be free to overwhelm the network with such \"free\" transactions and tie up nodes' CPU and network resources.\n\nSince our goal for the Bitcoin p2p network is one that is decentralized and open to anyone to join, we can't easily assign fees to particular network peers. Instead, we prevent free relay by ensuring that the fees in the transactions being relayed are commensurate with the bytes being relayed -- our goal is that over any given time period (say, where no blocks have been found), we want that `total_fees_added_to_mempool / bytes_relayed >= minimum_relay_fee`.\n\nWhile the minimum relay fee is itself an arbitrary value (1 sat/vbyte by default in Bitcoin Core), this principle ensures that increased network usage comes with increased costs. Moreover, raising the minimum relay fee is a way to increase\nthe costs associated with increased network use, while decreasing the fee lowers the cost for users (or attackers) to tie up network resources.\n\n### Example: BIP 125's prevention of free relay\n\nOne of the most important (but frustrating!) BIP 125 policy rules is the requirement that the total fees in the mempool after processing a replacement must increase by `minimum_relay_fee * new_transaction_size`. As discussed above, the BIP 125 rules do not achieve incentive compatibility, but because of this rule they do at least prevent free relay.\n\nThis rule is also the chief source of RBF \"pinning\", where large, low-feerate transactions cannot easily be replaced by smaller, high feerate transactions.  But if we were to eliminate it, then the minimum relay fee will cease to be a bound on `fees paid / bytes relayed`.  Analyzing a particular scenario requires taking into account the variety of other policy rules in place (which may serve to limit usage patterns in some way), but a simple example that would become possible if we just dropped the total fee rule of BIP 125 would be the following:\n\n * 100 transactions of size 100kvb are relayed on the network and added to the mempool, at the min relay fee (say 1 sat/vbyte)\n * A single 100-input transaction that conflicts with a single input from each of those transactions is relayed at 1.001 sat/vbyte (I'll approximate it as 10kvb in total size, but it's actually a bit less).\n\nAt this point, a little over 10MvB have been relayed on the network, but only about 10k sats have been spent in fees available to be mined.  This is a factor of almost 1000 decrease in the minimum relay fee we'd like to enforce -- meaning that if users wanted to update their node settings so that the resource usage costs are the same in this hypothetical as they are today, they'd have to update their min relay fee to 1000 sats/vbyte -- probably not something anyone wants to do.[^worse]\n\n### Example: mempool eviction is a source of (bounded) free-relay\n\nWhen the mempool exceeds its size limit (after accepting a new transaction), we will evict transactions from the \"bottom\" -- and potentially the total fee of the mempool will have gone down as a result.  To avoid unbounded free relay, we increase the feerate required to enter the mempool whenever an eviction takes place, by bumping the minimum relay to a value equal to the feerate of what we have evicted plus an increment (equal to the min relay fee).\n\nEffectively, we use new transactions being added to the mempool to pay for the eviction that has just happened. Since that happens after the eviction, though, there is an opportunity for free relay if no new transactions come in, because eventually the minimum relay fee will decay back down to its starting value. That decay parameter, coupled with maximum size we might evict at once, gives us a way to calculate the amount of free relay that is possible (over some time period).\n\n### Summary\n\nAn interesting and valuable area of research would be to determine if there are incentive compatible behaviors that would not be DoS-resistant to deploy on the entire network (and characterize them, if they exist). If so, such behaviors could introduce an incentive for users to connect directly to miners, which might be mutually beneficial to those parties but harmful to the decentralization of mining on the network overall.\n\nUnderstanding those scenarios may also be helpful to us as we try to design incentive compatible protocols that *are* DoS-resistant, so that we know where the boundaries are of what is possible.\n\n[^0]: My thoughts here are based on many discussions with others, particularly in the last year; thanks especially to Pieter Wuille, Mark Erhardt, Clara Shikhelman, Greg Sanders, Gloria Zhao, and Anthony Towns for sharing their insights and analysis with me.\n[^1]: In the case that there is only 1 miner, then the order doesn't matter since the miner eventually collects everything; all the miner would care about is total fees collected.\n[^2]: In this post, I'm focused on the narrow question of how to order transactions in the mempool to maximize fees.  I'm ignoring the game theoretic effects of miners potentially leaving high-fee paying transactions out of a block as an incentive for other miners to extend the chain, rather than reorg it.\n[^3]: By \"topology\", I mean the consensus rules that govern valid orderings of transactions in a block, namely that parent transactions must appear before child transactions.\n[^direct]: By \"direct\" conflicts, we refer to transactions which are spending 1 or more of the same inputs. By \"indirect\" conflicts, we mean transactions that do not directly spend the same inputs as a given transaction, but are descendant transactions of a direct conflict.\n[^4]: TODO: find references to prior work and update this footnote, as this has been covered at length in various forums. But for instance: see Gloria's [mailing list post on RBF](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html), and also some discussion in [#26451](https://github.com/bitcoin/bitcoin/pull/26451).\n[^5]: Note that the other BIP 125 rules (eg against not introducing new unconfirmed parents, or the maximum number of conflicts allowed) don't help the situation at all.  The examples in this section wouldn't have triggered violations of those rules either.\n[^26451]: I started to propose an approach like this [here](https://github.com/bitcoin/bitcoin/pull/26451), before realizing it was pretty broken (and not just because it would making RBF pinning far worse than it is today!).\n[^merging]: In fact, Pieter came up with a polynomial-time [merging algorithm](https://delvingbitcoin.org/t/cluster-mempool-definitions-theory/202#merging-linearizations-5) that can take two incomparable linearizations as input, and produce a linearization that is strictly better than either.\n[^worse]: I imagine there are ways to make network usage go up by more than what I just described here -- this is not a very sophisticated scenario! I can think of one modification to raise the effect from being a 1000x decreaes to 50,000x decrease, but the details are boring and possibly there are more clever scenarios that exist anyway.\n[^centralization]: An interesting side note to this example is that while offering a feerate-only RBF policy may be in the best interests of a user and a small miner, because large miners benefit from maximizing total fees, it seems plausible that that users attempting to do feerate-only RBF might create incentives for miners to form coalitions and cooperate to prevent this from happening, since they all benefit when total fees are maximized. I have no idea if the game theory would actually play out this way, however; perhaps this is a question worthy of further study.",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 95,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}