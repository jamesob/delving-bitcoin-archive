{
  "id": 1452,
  "name": "Anthony Towns",
  "username": "ajtowns",
  "avatar_template": "/user_avatar/delvingbitcoin.org/ajtowns/{size}/3_2.png",
  "created_at": "2024-02-03T12:02:57.768Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"EthanHeilman\" data-post=\"39\" data-topic=\"397\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/ethanheilman/48/328_2.png\" class=\"avatar\"> EthanHeilman:</div>\n<blockquote>\n<p>The computational cost of performing arithmetic on even very large numbers, say 520 byte numbers, is probably much smaller than many single opcode instructions</p>\n</blockquote>\n</aside>\n<p>I think there\u2019s a few choices here:</p>\n<ul>\n<li>what happens with \u201coverflows\u201d ?\n<ul>\n<li>they\u2019re not possible, everything happens modulo <span class=\"math\">2^n</span></li>\n<li>if the inputs are \u201ctoo large\u201d, the script aborts</li>\n<li>you get an overflow indicator in every result</li>\n</ul>\n</li>\n<li>what is <span class=\"math\">2^n</span> or what constitutes \u201ctoo large\u201d ?\n<ul>\n<li>BTC\u2019s max supply is about <span class=\"math\">2^{51}</span> satoshis, so 64bit is a fine minimum</li>\n<li><span class=\"math\">2^{256}</span> would let you manipulate scalars for secp256k1 which might be useful</li>\n<li><span class=\"math\">2^{4160}</span> would let you do numbers of to 520 bytes which matches current stack entry limits</li>\n</ul>\n</li>\n<li>unsigned only, or signed\n<ul>\n<li>if we\u2019re doing modular arithmetic, unsigned seems easier</li>\n<li>signed maths probably makes some contracts a bunch easier though</li>\n</ul>\n</li>\n<li>what serialization format?\n<ul>\n<li>if signed, use a sign-bit or 2\u2019s complement?</li>\n<li>fixed length or variable length \u2013 if fixed length, that constrains the precision we could use</li>\n<li>if variable length, does every integer have a unique serialization, or can you have \u201c0000\u201d and \u201c0\u201d and \u201c-0\u201d all as different representations of 0?</li>\n</ul>\n</li>\n</ul>\n<p>I guess 64-bit unsigned modular arithmetic would be easiest (<code>uint64_t</code> already works), but 4160-bit signed numbers (or some similarly large value that benchmarks fast enough) with abort-on-overflow behaviour and stored/serialized like CScriptNum format might be more appropriate?</p>\n<p>Abort-on-overflow seems kind of appealing as far as writing contracts goes: we\u2019ve already had an \u201coverflow allows printing money\u201d bug in bitcoin proper, so immediately aborting if that happens in script seems like a wise protection. If people want to do modular arithmetic, they could perhaps manually calculate <code>((x % k) * (y % k)) % k</code> provided they pick <span class=\"math\">k \\le \\sqrt{2^{n}}</span> or similar.</p>",
  "post_number": 40,
  "post_type": 1,
  "updated_at": "2024-02-03T12:02:57.768Z",
  "reply_count": 2,
  "reply_to_post_number": 39,
  "quote_count": 1,
  "incoming_link_count": 1,
  "reads": 11,
  "readers_count": 10,
  "score": 17.2,
  "yours": false,
  "topic_id": 397,
  "topic_slug": "64-bit-arithmetic-soft-fork",
  "topic_title": "64 bit arithmetic soft fork",
  "topic_html_title": "64 bit arithmetic soft fork",
  "category_id": 7,
  "display_username": "Anthony Towns",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"EthanHeilman, post:39, topic:397\"]\nThe computational cost of performing arithmetic on even very large numbers, say 520 byte numbers, is probably much smaller than many single opcode instructions\n[/quote]\n\nI think there's a few choices here:\n\n * what happens with \"overflows\" ?\n    * they're not possible, everything happens modulo $2^n$\n    * if the inputs are \"too large\", the script aborts\n    * you get an overflow indicator in every result\n * what is $2^n$ or what constitutes \"too large\" ?\n     * BTC's max supply is about $2^{51}$ satoshis, so 64bit is a fine minimum\n     * $2^{256}$ would let you manipulate scalars for secp256k1 which might be useful\n     * $2^{4160}$ would let you do numbers of to 520 bytes which matches current stack entry limits\n * unsigned only, or signed\n    * if we're doing modular arithmetic, unsigned seems easier\n    * signed maths probably makes some contracts a bunch easier though\n * what serialization format?\n    * if signed, use a sign-bit or 2's complement?\n    * fixed length or variable length -- if fixed length, that constrains the precision we could use\n    * if variable length, does every integer have a unique serialization, or can you have \"0000\" and \"0\" and \"-0\" all as different representations of 0?\n\nI guess 64-bit unsigned modular arithmetic would be easiest (`uint64_t` already works), but 4160-bit signed numbers (or some similarly large value that benchmarks fast enough) with abort-on-overflow behaviour and stored/serialized like CScriptNum format might be more appropriate?\n\nAbort-on-overflow seems kind of appealing as far as writing contracts goes: we've already had an \"overflow allows printing money\" bug in bitcoin proper, so immediately aborting if that happens in script seems like a wise protection. If people want to do modular arithmetic, they could perhaps manually calculate `((x % k) * (y % k)) % k` provided they pick $k \\le \\sqrt{2^{n}}$ or similar.",
  "actions_summary": [],
  "moderator": true,
  "admin": true,
  "staff": true,
  "user_id": 3,
  "hidden": false,
  "trust_level": 4,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}