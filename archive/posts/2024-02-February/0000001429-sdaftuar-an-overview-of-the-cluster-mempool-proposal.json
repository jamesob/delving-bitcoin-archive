{
  "id": 1429,
  "name": "Suhas Daftuar",
  "username": "sdaftuar",
  "avatar_template": "/letter_avatar_proxy/v4/letter/s/0ea827/{size}.png",
  "created_at": "2024-02-02T14:30:38.096Z",
  "cooked": "<p>I was wondering if a form of sibling eviction might work as a topological (if not economic) substitute for the carveout rule going away.  That is, is there a sibling eviction policy that we could adopt which would give current users of the CPFP carveout rule an economic way to get a transaction into the mempool when the cluster it would be joining is full? If so, then this might be an alternative we could consider to the suggestion of using v3 policy rules as a carveout replacement.</p>\n<p>Specifically, I was wondering if we could implement the following sibling eviction policy, as part of the cluster mempool approach:</p>\n<p>If a new transaction is rejected from the mempool due to a cluster size limit, and it has a single unconfirmed parent, and that parent has exactly 1 other unconfirmed child, then consider that child as a candidate for eviction in order to accept the new transaction.  Specifically, we\u2019d use our RBF rules (feerate diagram check) to determine if the mempool + new transaction - replacement candidate is strictly better than the existing mempool, and process the replacement if so.</p>\n<p>I should point out immediately that with no other constraints on the sibling described in that rule, that RBF pinning with a high fee transaction would be possible.  Still, I wondered if having <em>some</em> way to evict a transaction to make room for another might still be valuable, in a general setting, as that gives users more options than rules which have no economic mechanism to bypass.</p>\n<p>However, I don\u2019t think we can easily achieve this behavior while maintaining an additional intuitive property:</p>\n<ul>\n<li>Any transactions we evict under this policy should not succeed in re-entering the mempool if immediately resubmitted.</li>\n</ul>\n<p>The proposed rule fails this test.  Consider this picture:</p>\n<pre data-code-height=\"233\" data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">    flowchart \n         A --&gt; B\n         A-.-&gt; C\n         B--&gt; D\n        E[\"E: some tx connected to a big cluster\"] --&gt; B\n</code></pre>\n<p>Imagine tx C arrives, and we consider eviction of tx B to make room for it. Even if \u201caccept tx C and evict tx B (along with B\u2019s descendants)\u201d is a valid replacement under the feerate diagram check, it\u2019s possible that immediately re-accepting tx B would be successful, because without tx D it might be under the cluster size limits.</p>\n<p>To resolve this, we could (say) require for our rule that tx B only be evaluated for eviction if it has no unconfirmed children.  However, then we immediately lose the benefits for something like this as a carveout alternative, because it\u2019s trivially pinnable by a counterparty where if the other sibling has multiple children, no sibling eviction would be considered.</p>\n<p>Alternatively, we could find some child transaction to consider evicting; however if there is more than one candidate, then we might be in a difficult situation of trying to pick which one to evaluate, and there\u2019s no obvious way to make that choice.</p>\n<p>By contrast, the v3 rules resolve this problem, by requiring that v3 children have no children of their own.</p>\n<p>(Just sharing this in the spirit of <a class=\"mention\" href=\"/u/harding\">@harding</a>\u2019s comment about the potential value in looking at failed ideas!)</p>",
  "post_number": 8,
  "post_type": 1,
  "updated_at": "2024-02-02T14:30:38.096Z",
  "reply_count": 2,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 10,
  "readers_count": 9,
  "score": 12.0,
  "yours": false,
  "topic_id": 393,
  "topic_slug": "an-overview-of-the-cluster-mempool-proposal",
  "topic_title": "An overview of the cluster mempool proposal",
  "topic_html_title": "An overview of the cluster mempool proposal",
  "category_id": 8,
  "display_username": "Suhas Daftuar",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "I was wondering if a form of sibling eviction might work as a topological (if not economic) substitute for the carveout rule going away.  That is, is there a sibling eviction policy that we could adopt which would give current users of the CPFP carveout rule an economic way to get a transaction into the mempool when the cluster it would be joining is full? If so, then this might be an alternative we could consider to the suggestion of using v3 policy rules as a carveout replacement.\n\nSpecifically, I was wondering if we could implement the following sibling eviction policy, as part of the cluster mempool approach:\n\nIf a new transaction is rejected from the mempool due to a cluster size limit, and it has a single unconfirmed parent, and that parent has exactly 1 other unconfirmed child, then consider that child as a candidate for eviction in order to accept the new transaction.  Specifically, we'd use our RBF rules (feerate diagram check) to determine if the mempool + new transaction - replacement candidate is strictly better than the existing mempool, and process the replacement if so.\n\nI should point out immediately that with no other constraints on the sibling described in that rule, that RBF pinning with a high fee transaction would be possible.  Still, I wondered if having *some* way to evict a transaction to make room for another might still be valuable, in a general setting, as that gives users more options than rules which have no economic mechanism to bypass.\n\nHowever, I don't think we can easily achieve this behavior while maintaining an additional intuitive property:\n\n * Any transactions we evict under this policy should not succeed in re-entering the mempool if immediately resubmitted.\n\nThe proposed rule fails this test.  Consider this picture:\n\n```mermaid height=233,auto\n    flowchart \n         A --> B\n         A-.-> C\n         B--> D\n        E[\"E: some tx connected to a big cluster\"] --> B\n```\n\nImagine tx C arrives, and we consider eviction of tx B to make room for it. Even if \"accept tx C and evict tx B (along with B's descendants)\" is a valid replacement under the feerate diagram check, it's possible that immediately re-accepting tx B would be successful, because without tx D it might be under the cluster size limits.\n\nTo resolve this, we could (say) require for our rule that tx B only be evaluated for eviction if it has no unconfirmed children.  However, then we immediately lose the benefits for something like this as a carveout alternative, because it's trivially pinnable by a counterparty where if the other sibling has multiple children, no sibling eviction would be considered.\n\nAlternatively, we could find some child transaction to consider evicting; however if there is more than one candidate, then we might be in a difficult situation of trying to pick which one to evaluate, and there's no obvious way to make that choice. \n\nBy contrast, the v3 rules resolve this problem, by requiring that v3 children have no children of their own.\n\n(Just sharing this in the spirit of @harding's comment about the potential value in looking at failed ideas!)",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 95,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}