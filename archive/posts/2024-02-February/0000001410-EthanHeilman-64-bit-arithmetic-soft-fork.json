{
  "id": 1410,
  "name": "Ethan Heilman",
  "username": "EthanHeilman",
  "avatar_template": "/user_avatar/delvingbitcoin.org/ethanheilman/{size}/328_2.png",
  "created_at": "2024-02-01T22:21:46.037Z",
  "cooked": "<p><a class=\"mention\" href=\"/u/chris_stewart_5\">@Chris_Stewart_5</a></p>\n<p>Continuing my question from BIP.</p>\n<p>The BIP states: \u201cIf the operation results in an overflow, push false onto the stack\u201d.</p>\n<p>I would propose altering this to so that the result and the overflow amount are pushed onto the stack.</p>\n<p><strong>Case 1, no overflow:</strong></p>\n<p>1, 1, OP_ADD64 \u2192  2, 0</p>\n<p>where 2 is the result and 0 is the overflow amount.</p>\n<p><strong>Case 2, overflow:</strong></p>\n<p>2^64 - 1, 5, OP_ADD64 \u2192 4, 1</p>\n<p>where 4 is the result (mod 2^64), and 1 is the overflow amount. You can think of these two stack values as representing the 128 bit number 2^64+4 broken into two 64 bit chunks.</p>\n<p>Push values on the stack in this fashion makes it esimple use these 64 opcodes to do math on numbers larger than 64 bits by chunking them into 64-bit stack elements. The overflow amount tells you how much to carry into the next chunk.</p>\n<p>You\u2019d still get the benefit of having a flag to check, if overflow amount is not 0, overflow occurred.</p>\n<p>I think the BIP as written lets you add numbers larger than 64-bits using a similar chunking approach, but it is less straight forward and requires IF statements and substructions operations.</p>",
  "post_number": 36,
  "post_type": 1,
  "updated_at": "2024-02-01T22:23:40.258Z",
  "reply_count": 1,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 7,
  "readers_count": 6,
  "score": 6.4,
  "yours": false,
  "topic_id": 397,
  "topic_slug": "64-bit-arithmetic-soft-fork",
  "topic_title": "64 bit arithmetic soft fork",
  "topic_html_title": "64 bit arithmetic soft fork",
  "category_id": 7,
  "display_username": "Ethan Heilman",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "@Chris_Stewart_5 \n\nContinuing my question from BIP. \n\nThe BIP states: \"If the operation results in an overflow, push false onto the stack\".\n\nI would propose altering this to so that the result and the overflow amount are pushed onto the stack.\n\n**Case 1, no overflow:**\n\n1, 1, OP_ADD64 -->  2, 0 \n\nwhere 2 is the result and 0 is the overflow amount.\n\n**Case 2, overflow:**\n\n2^64 - 1, 5, OP_ADD64 --> 4, 1 \n\nwhere 4 is the result (mod 2^64), and 1 is the overflow amount. You can think of these two stack values as representing the 128 bit number 2^64+4 broken into two 64 bit chunks.\n\nPush values on the stack in this fashion makes it esimple use these 64 opcodes to do math on numbers larger than 64 bits by chunking them into 64-bit stack elements. The overflow amount tells you how much to carry into the next chunk.\n\nYou'd still get the benefit of having a flag to check, if overflow amount is not 0, overflow occurred. \n\nI think the BIP as written lets you add numbers larger than 64-bits using a similar chunking approach, but it is less straight forward and requires IF statements and substructions operations.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 267,
  "hidden": false,
  "trust_level": 0,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}