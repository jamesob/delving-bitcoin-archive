{
  "id": 1518,
  "name": "ZmnSCPxj jxPCSnmZ",
  "username": "ZmnSCPxj",
  "avatar_template": "/letter_avatar_proxy/v4/letter/z/ee7513/{size}.png",
  "created_at": "2024-02-12T11:15:33.744Z",
  "cooked": "<p>Subject: An Onchain Implementation Of Mining Feerate Futures</p>\n<h1><a name=\"introduction-1\" class=\"anchor\" href=\"#introduction-1\"></a>Introduction</h1>\n<p>Future onchain fees to be paid to miners cannot, in\ngeneral, be predicted, as unpredictable novel uses of\nthe blockchain may increase use of block space, and\nunpredictable novel innovations on block space use\nreduction may decrease use of block space.\nThis uncertainty makes onchain use unpalatable, and\neven non-custodial offchain uses like the Lightning\nNetwork incur risk of onchain enforcement, and the\nuncertain onchain fees could still affect offchain\nbehaviors.</p>\n<p>On the other hand, as more halvenings occur, the\nproportion of miner earnings that come from onchain\nfees increases, such that low onchain fees may reduce\nminer earnings, which discourages miners from mining\nand thereby reduce the security of the blockchain\nlayer.</p>\n<p>As such, mining fee futures are incentivized on both\nsides:</p>\n<ul>\n<li>Blockchain users want to bet that future mining\nfees will be high, so that if mining fees <em>become</em>\nhigh the users will be compensated, offsetting\ntheir losses due to high onchain fees.</li>\n<li>Miners want to bet that future mining fees will be\nlow, so that if mining fees <em>become</em> low the miners\nwill be compensated, offsetting their reduced income\ndue to low onchain fees.</li>\n</ul>\n<p>In effect, a mining feerate futures scheme has\nblockchain users pay miners a flat rate above the\nmedian low-fee rate, with miners giving assured\nconfirmations if a high-fee spike occurs.\nMiners get assured income, blockchain users get\nassured confirmation even in a high-fee spike.</p>\n<p>In this writeup I describe a method by which a miner\nand a blockchain user may create a simple futures\ncontract in a trustless manner.</p>\n<h1><a name=\"a-binary-mining-fee-futures-contract-2\" class=\"anchor\" href=\"#a-binary-mining-fee-futures-contract-2\"></a>A Binary Mining Fee Futures Contract</h1>\n<p>First, the parameters:</p>\n<ul>\n<li>An amount <code>A[Alice]</code> from the blockchain user\n<code>Alice</code>, which will be given to the miner in case\nof low onchain fees.</li>\n<li>An amount <code>A[Bob]</code> from the miner <code>Bob</code>, which\nwill be given to the blockchain user in case of\nhigh onchain fees.</li>\n<li>A feerate boundary <code>F</code>: \u201clow onchain fees\u201d means\nbelow this feerate, \u201chigh onchain fees\u201d means\nabove this feerate.</li>\n<li>A future blockheight <code>T</code>, and a miner execution time\nin blocks <code>N</code> after this blockheight (<code>T + N</code>).</li>\n</ul>\n<p>Onchain, the SCRIPT involves the three branches below:</p>\n<ul>\n<li><code>MuSig(Alice, Bob)</code> - Taproot keyspend branch\n<ul>\n<li>Cooperative resolution branch</li>\n</ul>\n</li>\n<li><code>OP_SIZE &lt;520&gt; OP_EQUALVERIFY &lt;T&gt; OP_CHECKLOCKTIMEVERIFY OP_DROP &lt;Alice&gt; OP_CHECKSIGVERIFY &lt;Bob&gt; OP_CHECKSIG</code>\n<ul>\n<li>Miner unilateral execution branch</li>\n</ul>\n</li>\n<li><code>&lt;T + N&gt; OP_CHECKLOCKTIMEVERIFY OP_DROP &lt;Alice&gt; OP_CHECKSIG</code>\n<ul>\n<li>User unilateral execution branch</li>\n</ul>\n</li>\n</ul>\n<p>The user and the miner both cooperatively make a\ntransaction spending from SegWit funds (<code>A[Alice]</code>\nfrom the user, <code>A[Bob]</code> from the miner) to a\nTaproot address with the above.\nBut before they sign, broadcast, and confirm the\nfunding transaction, the user first needs to\nprovide signatures to spend from the miner\nunilateral branch.</p>\n<h2><a name=\"miner-unilateral-low-fees-branch-3\" class=\"anchor\" href=\"#miner-unilateral-low-fees-branch-3\"></a>Miner Unilateral (Low Fees) Branch</h2>\n<p>This branch is implemented using a\nblockspace-wasteful Taproot transaction, like all\nproper modern constructions, such as ordinals.\n(This is a joke.\nThe cooperative branch can be used by the miner so\nit can get its funds immediately and with little\nblock space wasted, if the user agrees that fees\nare low.\nBlock space is only vicariously consumed if the\nuser does not agree fees are low, or is not\nresponding when the miner requests for execution\nof the low-fee case.)</p>\n<p>(Being space-wasteful is also the reason why the\nminer unilateral execution branch uses separate\n<code>&lt;Alice&gt; OP_CHECKSIGVERIFY</code> and <code>&lt;Bob&gt; OP_CHECKSIG</code>,\ninstead of just <code>&lt;1&gt; OP_CHECKSIG</code>.)</p>\n<p>Wasting block space in this branch is not a problem\nas this branch only triggers when mining fees are\nlow (i.e. block space is cheap).</p>\n<p>The transaction that spends from this branch is the\nminer unilateral transaction, which has only an\n<code>OP_RETURN</code> output.\nIt thus has one input with the wasteful witness\nspending from the address defined above, and one\n<code>OP_RETURN</code> output with some large data of 80 bytes\nor 320 weight units (or whatever <code>datacarriersize</code>\nsetting is typically available on miners).</p>\n<p>The total <code>A[Alice] + A[Bob]</code> should be divided by\nthe boundary feerate <code>F</code> to get a number of weight\nunits to target.\nThis means that the <code>OP_SIZE &lt;520&gt; OP_EQUALVERIFY</code>\npart may vary the <code>&lt;520&gt;</code> so that the targeted\nweight units is achieved.\nThe <code>OP_RETURN</code> output size can also be varied to\nget the targeted weight units.</p>\n<p>An alternative to <code>OP_SIZE &lt;targetsize&gt; OP_EQUALVERIFY</code>\nwould be to use <code>OP_SHA256 &lt;hash&gt; OP_EQUALVERIFY</code> with\nthe preimage of <code>&lt;targetsize&gt;</code> bytes generated\ncooperatively (say by seeding a crypto PRNG from the\nECDH of the miner and user).\nThis would prevent witness malleation, and is in fact\nwhat is recommended; we simply show the <code>OP_SIZE</code>\nversion to better explain how we create the contract,\nbut an <code>OP_SHA256</code> of a pre-arranged large data is\nstrictly better.</p>\n<p>If the total amount <code>A[Alice] + A[Bob]</code> is large,\nor the boundary feerate <code>F</code> is low, then the\nnumber of weight units to target might be too\nlarge for a single transaction, even with a large\nwitness item and a large <code>OP_RETURN</code> output.\nIn that case, it should have another output with\nthe SCRIPT branches below (internal pubkey can be\nsome standardized NUMS point, or just the\n<code>MuSig(Alice[eph], Bob[eph])</code> with neither side\never signing this particular aggregated keypair\n\u2014 these can be ephemeral pubkeys generated by\nuser and miner instead of their normal pubkeys,\nwith the private key forgetten immediately).</p>\n<ul>\n<li><code>OP_SIZE &lt;520&gt; OP_EQUALVERIFY &lt;Alice&gt; OP_CHECKSIGVERIFY &lt;Bob&gt; OP_CHECKSIG</code>\n<ul>\n<li>Continuation branch</li>\n</ul>\n</li>\n<li><code>&lt;1&gt; OP_CHECKSEQUENCEVERIFY OP_DROP &lt;Alice&gt; OP_CHECKSIG</code>\n<ul>\n<li>Single-block assurance branch</li>\n</ul>\n</li>\n</ul>\n<p>The continuation branch should then be spent in\nanother transaction with expensive witness and\n<code>OP_RETURN</code> outputs, and again optionally with\nanother output for continuation.\nThe size being compared to can be varied if\nthe particular continuation is the last one.</p>\n<p>The second branch exists to force the miner to\nput the entire sequence of transactions in a\nsingle block.\nIf the miner puts only the first transaction in\nthe sequence in a block, then the user can steal\nthe remaining fund unilaterally on the next block\n(in particular, since a rational miner wold only\nuse this in a low-fee condition, the user can\neasily pay a different miner to confirm that\npunishment transaction).\nA rational non-majority miner would thus prefer\nto just put all the miner-unilateral transactions\ninto a single block.</p>\n<h3><a name=\"using-the-miner-unilateral-branch-4\" class=\"anchor\" href=\"#using-the-miner-unilateral-branch-4\"></a>Using The Miner Unilateral Branch</h3>\n<p>Prior to signing and broadcasting the funding\ntransaction, the miner unilateral transaction\n(or transactions if the targeted weight is\nparticularly high) is signed by the user\nusing the miner unilateral execution branch\n(and for continuation transactions, the\ncontinuation branch).\nThe user sends those signatures to the miner,\nbut the miner does <strong>NOT</strong> send back signatures\nto the user, as the transactions are intended\nto be a miner-unilateral control.</p>\n<p>If the mempool has only transactions with fees\nbelow the boundary, then the miner would earn\nmore by actually taking the miner unilateral\ntransactions and mining them.\nThe <code>N</code> miner execution time is the grace period\nto allow the miner to get <em>some</em> block into the\nblockchain with the miner-unilateral transactions.</p>\n<p>The miner effectively gets the <code>A[Alice]</code> amount,\nand gets back its <code>A[Bob]</code> wager, via mining fees.</p>\n<p>There is a risk of chain reorgs, with the\nminer-unilateral transaction already seen by\nother miners, who can then take the same\ntransction and acquire its mining fees.\nOn the other hand, chain reorgs are unlikely,\nand deliberate chain forking in order to\nacquire the miner-unilateral transaction of\nanother miner is expensive.\nThis risk can be considered by the miner when\nproposing its <code>A[Bob]</code> wager.</p>\n<p>If the mempool is dominated by transactions\nwith fees above the boundary, and this condition\npersists up to blockheight <code>T + N</code>, then the\nminer can earn more by putting the higher-fee\ntransactions into its blocks rather than this\nunilateral transaction.\nWhile it would \u201close\u201d its <code>A[Bob]</code> wager, it\nwould end up earning more than the combined\n<code>A[Alice] + A[Bob]</code> amount anyway if there are\nenough transactions with feerate higher than\n<code>F</code> to fill a block (i.e. <code>A[Bob]</code> is a sunk\ncost for the miner).</p>\n<h3><a name=\"cooperative-low-fees-case-5\" class=\"anchor\" href=\"#cooperative-low-fees-case-5\"></a>Cooperative Low Fees Case</h3>\n<p>When fees are low, there is a mild incentive\nfor blockchain users to cooperate by instead\nsigning a transaction that simply transfers\nthe funds to the miner.</p>\n<p>As the unilateral miner transaction is\nwasteful of block space, if the miner is\nforced to use it, this puts a mild pressure\non mempool space usage, which mildly\nincreases onchain fees.</p>\n<p>The expectation is that the blockchain user\nis engaging in this contract in order to\nmitigate the effect of high fees.\nBy cooperating, the blockchain user is able\nto provide a small help in keeping fees low.</p>\n<p>Although the blockchain user would lose its\n<code>A[Alice]</code> wager, it would lose it anyway\nif it did not cooperate (i.e. sunk cost),\nas the miner can always exercise its\nunilateral transaction.\nThe blockchain user would still prefer to\n<em>keep</em> onchain fees low by cooperating.</p>\n<p>The miner also has a mild incentive to\ncooperate in this branch: the resulting\ntransaction is smaller, it ends up paying\nto the miner directly instead of via fees\n(thus making it safe to broadcast to\ncompetitor miners and increase the chance\nthat it can be enforced before <code>T + N</code>,\nand also letting the miner access the funds\nimmediately instead of 100 blocks after it\nwins a block).</p>\n<h2><a name=\"unilateral-user-high-fees-branch-6\" class=\"anchor\" href=\"#unilateral-user-high-fees-branch-6\"></a>Unilateral User (High Fees) Branch</h2>\n<p>The miner wants the low fees branch to trigger,\nas it gets <code>A[Alice] + A[Bob]</code> in that branch.\nIt gets first dibs by being given an earlier\ntimelock (<code>T</code>) compared to the timelock the\nuser has (<code>T + N</code>).</p>\n<p>However, as noted in previous sections, this\nbranch has economic incentives to not be taken\nin a high-onchain-fee environment.</p>\n<p>Thus, we expect that if the high-fee condition\npersists until <code>T + N</code>, the miner will not have\nclaimed the fund shared with the user.\nAt that point, the user will be able to claim\nthose funds via its unilateral branch.</p>\n<p>The user unilateral branch can be used with any\ntransaction.\nFor example, if the user needs to add fees to\nsome high-priority transaction that needs to\nconfirm <em>right now</em>, the user can just use\nthis fund to pay for the fees by adding just\none more input (albeit with a witness that\nincludes a Tapscript revelation with its\n33-byte pubkey, at least one 32-byte Merkle\nTree branch, a 32-byte internal pubkey,\nand a 64-byte signature).</p>\n<p>The miner can offer to also cooperatively\nsign a transaction that spends the fund in a\ntransaction specified by the user.\nThis allows the user to reduce the witness\nto just a 64-byte signature.</p>\n<p>In order to pay fees effectively even at\nridiculously high feerates, it is likely\nthat the miner would have to offer an\n<code>A[Bob]</code> wager that is at least one order\nof magnitude larger than <code>A[Alice]</code>.\nNevertheless, if the probability of high\nfees is low enough, the miner would be\nwilling to take on that risk in order to\nget some assured income during low fee\nperiods.</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2024-02-12T11:15:33.744Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 1,
  "reads": 8,
  "readers_count": 7,
  "score": 6.6,
  "yours": false,
  "topic_id": 547,
  "topic_slug": "an-onchain-implementation-of-mining-feerate-futures",
  "topic_title": "An Onchain Implementation Of Mining Feerate Futures",
  "topic_html_title": "An Onchain Implementation Of Mining Feerate Futures",
  "category_id": 7,
  "display_username": "ZmnSCPxj jxPCSnmZ",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Subject: An Onchain Implementation Of Mining Feerate Futures\n\nIntroduction\n============\n\nFuture onchain fees to be paid to miners cannot, in\ngeneral, be predicted, as unpredictable novel uses of\nthe blockchain may increase use of block space, and\nunpredictable novel innovations on block space use\nreduction may decrease use of block space.\nThis uncertainty makes onchain use unpalatable, and\neven non-custodial offchain uses like the Lightning\nNetwork incur risk of onchain enforcement, and the\nuncertain onchain fees could still affect offchain\nbehaviors.\n\nOn the other hand, as more halvenings occur, the\nproportion of miner earnings that come from onchain\nfees increases, such that low onchain fees may reduce\nminer earnings, which discourages miners from mining\nand thereby reduce the security of the blockchain\nlayer.\n\nAs such, mining fee futures are incentivized on both\nsides:\n\n* Blockchain users want to bet that future mining\n  fees will be high, so that if mining fees *become*\n  high the users will be compensated, offsetting\n  their losses due to high onchain fees.\n* Miners want to bet that future mining fees will be\n  low, so that if mining fees *become* low the miners\n  will be compensated, offsetting their reduced income\n  due to low onchain fees.\n\nIn effect, a mining feerate futures scheme has\nblockchain users pay miners a flat rate above the\nmedian low-fee rate, with miners giving assured\nconfirmations if a high-fee spike occurs.\nMiners get assured income, blockchain users get\nassured confirmation even in a high-fee spike.\n\nIn this writeup I describe a method by which a miner\nand a blockchain user may create a simple futures\ncontract in a trustless manner.\n\nA Binary Mining Fee Futures Contract\n====================================\n\nFirst, the parameters:\n\n* An amount `A[Alice]` from the blockchain user\n  `Alice`, which will be given to the miner in case\n  of low onchain fees.\n* An amount `A[Bob]` from the miner `Bob`, which\n  will be given to the blockchain user in case of\n  high onchain fees.\n* A feerate boundary `F`: \"low onchain fees\" means\n  below this feerate, \"high onchain fees\" means\n  above this feerate.\n* A future blockheight `T`, and a miner execution time\n  in blocks `N` after this blockheight (`T + N`).\n\nOnchain, the SCRIPT involves the three branches below:\n\n* `MuSig(Alice, Bob)` - Taproot keyspend branch\n  - Cooperative resolution branch\n* `OP_SIZE <520> OP_EQUALVERIFY <T> OP_CHECKLOCKTIMEVERIFY OP_DROP <Alice> OP_CHECKSIGVERIFY <Bob> OP_CHECKSIG`\n  - Miner unilateral execution branch\n* `<T + N> OP_CHECKLOCKTIMEVERIFY OP_DROP <Alice> OP_CHECKSIG`\n  - User unilateral execution branch\n\nThe user and the miner both cooperatively make a\ntransaction spending from SegWit funds (`A[Alice]`\nfrom the user, `A[Bob]` from the miner) to a\nTaproot address with the above.\nBut before they sign, broadcast, and confirm the\nfunding transaction, the user first needs to\nprovide signatures to spend from the miner\nunilateral branch.\n\nMiner Unilateral (Low Fees) Branch\n----------------------------------\n\nThis branch is implemented using a\nblockspace-wasteful Taproot transaction, like all\nproper modern constructions, such as ordinals.\n(This is a joke.\nThe cooperative branch can be used by the miner so\nit can get its funds immediately and with little\nblock space wasted, if the user agrees that fees\nare low.\nBlock space is only vicariously consumed if the\nuser does not agree fees are low, or is not\nresponding when the miner requests for execution\nof the low-fee case.)\n\n(Being space-wasteful is also the reason why the\nminer unilateral execution branch uses separate\n`<Alice> OP_CHECKSIGVERIFY` and `<Bob> OP_CHECKSIG`,\ninstead of just `<1> OP_CHECKSIG`.)\n\nWasting block space in this branch is not a problem\nas this branch only triggers when mining fees are\nlow (i.e. block space is cheap).\n\nThe transaction that spends from this branch is the\nminer unilateral transaction, which has only an\n`OP_RETURN` output.\nIt thus has one input with the wasteful witness\nspending from the address defined above, and one\n`OP_RETURN` output with some large data of 80 bytes\nor 320 weight units (or whatever `datacarriersize`\nsetting is typically available on miners).\n\nThe total `A[Alice] + A[Bob]` should be divided by\nthe boundary feerate `F` to get a number of weight\nunits to target.\nThis means that the `OP_SIZE <520> OP_EQUALVERIFY`\npart may vary the `<520>` so that the targeted\nweight units is achieved.\nThe `OP_RETURN` output size can also be varied to\nget the targeted weight units.\n\nAn alternative to `OP_SIZE <targetsize> OP_EQUALVERIFY`\nwould be to use `OP_SHA256 <hash> OP_EQUALVERIFY` with\nthe preimage of `<targetsize>` bytes generated\ncooperatively (say by seeding a crypto PRNG from the\nECDH of the miner and user).\nThis would prevent witness malleation, and is in fact\nwhat is recommended; we simply show the `OP_SIZE`\nversion to better explain how we create the contract,\nbut an `OP_SHA256` of a pre-arranged large data is\nstrictly better.\n\nIf the total amount `A[Alice] + A[Bob]` is large,\nor the boundary feerate `F` is low, then the\nnumber of weight units to target might be too\nlarge for a single transaction, even with a large\nwitness item and a large `OP_RETURN` output.\nIn that case, it should have another output with\nthe SCRIPT branches below (internal pubkey can be\nsome standardized NUMS point, or just the\n`MuSig(Alice[eph], Bob[eph])` with neither side\never signing this particular aggregated keypair\n--- these can be ephemeral pubkeys generated by\nuser and miner instead of their normal pubkeys,\nwith the private key forgetten immediately).\n\n* `OP_SIZE <520> OP_EQUALVERIFY <Alice> OP_CHECKSIGVERIFY <Bob> OP_CHECKSIG`\n  - Continuation branch\n* `<1> OP_CHECKSEQUENCEVERIFY OP_DROP <Alice> OP_CHECKSIG`\n  - Single-block assurance branch\n\nThe continuation branch should then be spent in\nanother transaction with expensive witness and\n`OP_RETURN` outputs, and again optionally with\nanother output for continuation.\nThe size being compared to can be varied if\nthe particular continuation is the last one.\n\nThe second branch exists to force the miner to\nput the entire sequence of transactions in a\nsingle block.\nIf the miner puts only the first transaction in\nthe sequence in a block, then the user can steal\nthe remaining fund unilaterally on the next block\n(in particular, since a rational miner wold only\nuse this in a low-fee condition, the user can\neasily pay a different miner to confirm that\npunishment transaction).\nA rational non-majority miner would thus prefer\nto just put all the miner-unilateral transactions\ninto a single block.\n\n### Using The Miner Unilateral Branch\n\nPrior to signing and broadcasting the funding\ntransaction, the miner unilateral transaction\n(or transactions if the targeted weight is\nparticularly high) is signed by the user\nusing the miner unilateral execution branch\n(and for continuation transactions, the\ncontinuation branch).\nThe user sends those signatures to the miner,\nbut the miner does **NOT** send back signatures\nto the user, as the transactions are intended\nto be a miner-unilateral control.\n\nIf the mempool has only transactions with fees\nbelow the boundary, then the miner would earn\nmore by actually taking the miner unilateral\ntransactions and mining them.\nThe `N` miner execution time is the grace period\nto allow the miner to get *some* block into the\nblockchain with the miner-unilateral transactions.\n\nThe miner effectively gets the `A[Alice]` amount,\nand gets back its `A[Bob]` wager, via mining fees.\n\nThere is a risk of chain reorgs, with the\nminer-unilateral transaction already seen by\nother miners, who can then take the same\ntransction and acquire its mining fees.\nOn the other hand, chain reorgs are unlikely,\nand deliberate chain forking in order to\nacquire the miner-unilateral transaction of\nanother miner is expensive.\nThis risk can be considered by the miner when\nproposing its `A[Bob]` wager.\n\nIf the mempool is dominated by transactions\nwith fees above the boundary, and this condition\npersists up to blockheight `T + N`, then the\nminer can earn more by putting the higher-fee\ntransactions into its blocks rather than this\nunilateral transaction.\nWhile it would \"lose\" its `A[Bob]` wager, it\nwould end up earning more than the combined\n`A[Alice] + A[Bob]` amount anyway if there are\nenough transactions with feerate higher than\n`F` to fill a block (i.e. `A[Bob]` is a sunk\ncost for the miner).\n\n### Cooperative Low Fees Case\n\nWhen fees are low, there is a mild incentive\nfor blockchain users to cooperate by instead\nsigning a transaction that simply transfers\nthe funds to the miner.\n\nAs the unilateral miner transaction is\nwasteful of block space, if the miner is\nforced to use it, this puts a mild pressure\non mempool space usage, which mildly\nincreases onchain fees.\n\nThe expectation is that the blockchain user\nis engaging in this contract in order to\nmitigate the effect of high fees.\nBy cooperating, the blockchain user is able\nto provide a small help in keeping fees low.\n\nAlthough the blockchain user would lose its\n`A[Alice]` wager, it would lose it anyway\nif it did not cooperate (i.e. sunk cost),\nas the miner can always exercise its\nunilateral transaction.\nThe blockchain user would still prefer to\n*keep* onchain fees low by cooperating.\n\nThe miner also has a mild incentive to\ncooperate in this branch: the resulting\ntransaction is smaller, it ends up paying\nto the miner directly instead of via fees\n(thus making it safe to broadcast to\ncompetitor miners and increase the chance\nthat it can be enforced before `T + N`,\nand also letting the miner access the funds\nimmediately instead of 100 blocks after it\nwins a block).\n\nUnilateral User (High Fees) Branch\n----------------------------------\n\nThe miner wants the low fees branch to trigger,\nas it gets `A[Alice] + A[Bob]` in that branch.\nIt gets first dibs by being given an earlier\ntimelock (`T`) compared to the timelock the\nuser has (`T + N`).\n\nHowever, as noted in previous sections, this\nbranch has economic incentives to not be taken\nin a high-onchain-fee environment.\n\nThus, we expect that if the high-fee condition\npersists until `T + N`, the miner will not have\nclaimed the fund shared with the user.\nAt that point, the user will be able to claim\nthose funds via its unilateral branch.\n\nThe user unilateral branch can be used with any\ntransaction.\nFor example, if the user needs to add fees to\nsome high-priority transaction that needs to\nconfirm *right now*, the user can just use\nthis fund to pay for the fees by adding just\none more input (albeit with a witness that\nincludes a Tapscript revelation with its\n33-byte pubkey, at least one 32-byte Merkle\nTree branch, a 32-byte internal pubkey,\nand a 64-byte signature).\n\nThe miner can offer to also cooperatively\nsign a transaction that spends the fund in a\ntransaction specified by the user.\nThis allows the user to reduce the witness\nto just a 64-byte signature.\n\nIn order to pay fees effectively even at\nridiculously high feerates, it is likely\nthat the miner would have to offer an\n`A[Bob]` wager that is at least one order\nof magnitude larger than `A[Alice]`.\nNevertheless, if the probability of high\nfees is low enough, the miner would be\nwilling to take on that risk in order to\nget some assured income during low fee\nperiods.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 104,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}