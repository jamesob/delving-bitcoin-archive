{
  "id": 1458,
  "name": "ZmnSCPxj jxPCSnmZ",
  "username": "ZmnSCPxj",
  "avatar_template": "/letter_avatar_proxy/v4/letter/z/ee7513/{size}.png",
  "created_at": "2024-02-04T12:21:02.487Z",
  "cooked": "<p>Intuitively, we can consider that the entire point of this scheme is to specify that one output pays the fees, thus we do not commit to that particular output having a particular amount. Optionally, we can impose a maximum amount that the output can pay, in case the output is (still) a shared output.  Protocols using this require a separate signature, coming from an owner of the output, which allows that owner to fix the fee paid. This also requires only one participant to be online at that time (i.e. other participants need not be online), allowing that participant to arbitrarily sign unilaterally and decide how much fees to deduct from their owned output, while still imposing that the other outputs are untouched.</p>\n<p>Just as <code>SIGHASH_NOINPUT</code> is implementable via <code>OP_CHECKTEMPLATEVERIFY</code> and <code>OP_CHECKSIGFROMSTACK</code>, we can also consider how to implement this scheme using <code>OP_CHECKTEMPLATEVERIFY</code>.</p>\n<p>For example, suppose we extend <code>OP_CHECKTEMPLATEVERIFY</code> in the following manner:</p>\n<ul>\n<li>If the stack top is 32 bytes, follow BIP-119.</li>\n<li>If the stack top is 33 bytes or more:\n<ul>\n<li>Take the first byte as the <code>CTVHASH</code> type.</li>\n<li>If the first byte is:\n<ul>\n<li><code>0x00</code>, this is an \u201coutput pays fee\u201d <code>CTVHASH</code> type.</li>\n<li>anything else, <code>OP_CHECKTEMPLATEVERIFY</code> acts as an <code>OP_NOP</code> (this allows for future extensions).</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>When verifying an \u201coutput pays fee\u201d <code>CTVHASH</code> type, we extract the following pieces of data:</p>\n<ul>\n<li>An output index.</li>\n<li>An optional amount to be deducted.</li>\n<li>A 32-byte hash commitment.</li>\n</ul>\n<p>The length of the stack top determines how the data is interpreted.  The last 32 bytes is always the 32-byte hash commitment.  Then if the stack top length is:</p>\n<ul>\n<li>34 bytes: byte 1 is the output index, there is no amount to deduct.</li>\n<li>35 bytes: bytes 1-2 is the output index in little-endian, there is no amount to deduct.</li>\n<li>36 bytes: bytes 1-3 is the output index in little-endian, there is no amount to deduct.</li>\n<li>37 bytes: bytes 1-4 is the output index in little-endian, there is no amount to deduct.</li>\n<li>38 bytes: byte 1 is the output index, bytes 2 to 5 is the amount to deduct in little-endian.</li>\n<li>39 bytes: bytes 1-2 is the output index, bytes 3 to 6 is the amount to deduct in little-endian.</li>\n<li>40 bytes: bytes 1-3 is the output index, bytes 4 to 7 is the amount to deduct in little-endian.</li>\n<li>41 bytes: bytes 1-4 is the output index, bytes 5 to 8 is the amount to deduct in little-endian.</li>\n<li>42 bytes: byte 1 is the output index, bytes 2 to 9 is the amount to deduct in little-endian.</li>\n<li>43 bytes: bytes 1-2 is the output index in little-endian, bytes 3 to 10 is the amount to deduct in little-endian.</li>\n<li>44 bytes: bytes 1-3 is the output index in little-endian, bytes 4 to 11 is the amount to deduct in little-endian.</li>\n<li>45 bytes: bytes 1-4 is the output index in little-endian, bytes 5 to 12 is the amount to deduct in little-endian.</li>\n<li>otherwise: fail validation</li>\n</ul>\n<blockquote>\n<p><strong>Rationale</strong> The above encoding does not require spending extra bytes as for <code>CVarSize</code>; instead, the push opcode that gets the above onto the stack effectively encodes how many bytes to use for the output index and (optional) amount to deduct.</p>\n<p>The expectation is that most transactions will be small and the output index will correspondingly be small as well. In contrast, amounts are expected to be large. Nevertheless, it is also expected that amounts involved will rarely exceed 42.94967295 BTC, thus the amount to deduct may also be encoded in 4 bytes instead of 8. The expectation is that every byte matters.</p>\n</blockquote>\n<p>In addition, the \u201coutput pays fee\u201d <code>CTVHASH</code> type requires the following validation:</p>\n<ul>\n<li>The script interpreter maintains a \u201cheavy CTV hashes\u201d variable that is initialized to 0 on starting script execution. On encountering an \u201coutput pays fee\u201d <code>CTVHASH</code>, increment this variable. If the variable is now 2 or higher, fail validation.</li>\n<li>The transaction must have exactly 1 input. Otherwise, fail validation.</li>\n<li><code>nSequence</code> of the sole input must be <code>0x00000000</code>.</li>\n<li>If the \u201camount to deduct\u201d is specified, then perform the following additional validation:\n<ul>\n<li>Get the amount of this input, then subtract the amount to deduct.</li>\n<li>The amount of the output at the given output index must be <strong>greater than or equal to</strong> the above difference.</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><strong>Rationale</strong> The above prevents quadratic hashing via this new \u201coutput pays fee\u201d <code>CTVHASH</code> extension. As this changes the hashing of the outputs, the output hashes cannot be cached as in the original BIP-119. Instead, the above rules prevent quadratic hashing by only allowing a single heavyweight hash operation per transaction.</p>\n<p>We specify that the script interpreter maintains a \u201cheavy CTV hashes\u201d variable so that future <code>CTVHASH</code> types may also use the same variable, preventing quadratic hashing by using different heavyweight <code>CTVHASH</code> types.</p>\n<p>The transaction can feasibly be limited to exactly 1 input since this mechanism is intended to replace other mechanisms where fees are paid by other inputs. Instead, the fees are paid from the given single input, which serves as a shared fund, with one of the outputs being reduced in order to fund the mining fee.</p>\n<p>An <code>nSequence</code> of <code>0</code> forces the transaction to opt-in to RBF (which is a desired feature of this mechanism, which allows one participant to RBF freely by deducting the output it owns, which is specified in the stack argument here), and enables <code>nLockTime</code> if that is needed.</p>\n<p>The amount to deduct, if specified, prevents the output from being entirely used up to pay for fees. This may be used if the output is still shared among multiple participants, as in Decker-Russell-Osuntokun or intermediate outputs in CTV-trees. The amount is subtracted from the input, and the input is <strong>not</strong> committed to in the hash, to allow intermediate <code>OP_CHECKTEMPLATEVERIFY</code> transactions to have variable fees that can adapt to changing onchain conditions, with having the total fees of all intermediate transactions debited from a final output.</p>\n</blockquote>\n<p>The template hash is then computed by hashing the below:</p>\n<ul>\n<li>All but the last 32 bytes of the stack top argument (i.e. <code>CTVHASH</code> type, the formatted output index that pays fees, plus the optional amont to deduct, in the formatted order).</li>\n<li><code>nVersion</code></li>\n<li><code>nLockTime</code></li>\n<li>output count</li>\n<li>output hash, modified as follows:\n<ul>\n<li>For the output at the index specified in the stack top argument, set the amount as 0.</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><strong>Rationale</strong> As this <code>CTVHASH</code> type is intended to support an \u201cinternal fees\u201d mechanism, as noted above, it already restricts the number of inputs to just 1. There is thus no need to commit to the number of inputs or the <code>nSequence</code> (which is fixed above, as well), or the input index this is executing on.</p>\n</blockquote>\n<hr>\n<p>The uses of this new <code>CTVHASH</code> mode are, <em>in combination with <code>OP_CHECKSIGFROMSTACK</code></em>, congruent to the original posting up top, and the equivalence is left to the reader.</p>\n<p>We can create a CTV-tree where fees are dynamically decided at publish time, with all fees paid internally instead of externally (i.e. there is no need to own another UTXO that pays for fees) by using this mechanism. For example, suppose we want to commit to outputs A, B, C, D with particular amounts. We construct a root address that spends to 4 possible tapleaves to create a 1-input, 2-output top node:</p>\n<ul>\n<li>\u201coutput pays fee\u201d <code>CTVHASH</code> that points to <code>A,B</code> output paying up to some max fee plus fixes the <code>C,D</code>output, plus a <code>OP_CHECKSIG</code> from <code>A</code>.</li>\n<li>\u201coutput pays fee\u201d <code>CTVHASH</code> that points to <code>A,B</code> output paying up to some max  fee plus fixes the <code>C,D</code> output, plus a <code>OP_CHECKSIG</code> from <code>B</code>.</li>\n<li>\u201coutput pays fee\u201d <code>CTVHASH</code> that points to <code>C,D</code> output paying up to some max  fee plus fixes the <code>A,B</code> output, plus a <code>OP_CHECKSIG</code> from <code>C</code>.</li>\n<li>\u201coutput pays fee\u201d <code>CTVHASH</code> that points to <code>C,D</code> output paying up to some max  fee plus fixes the <code>A,B</code> output, plus a <code>OP_CHECKSIG</code> from <code>D</code>.</li>\n</ul>\n<p>Then, the <code>A,B</code> (corresponding <code>C,D</code>) output of the top node would have 2 possible tapleaves to create a 1-input, 2-output final node:</p>\n<ul>\n<li>\u201coutput pays fee\u201d <code>CTVHASH</code> that points to <code>A</code> output paying the fee plus fixes the <code>B</code> output, plus a <code>OP_CHECKSIG</code> from <code>A</code>.</li>\n<li>\u201coutput pays fee\u201d <code>CTVHASH</code> that points to <code>B</code> output paying the fee plus fixes the <code>A</code> output, plus a <code>OP_CHECKSIG</code> from <code>B</code>.</li>\n</ul>\n<p>Then, if a participants wants to publish their output, they can instantiate the path to their node, paying all fees for intermediate nodes and the final node in the CTV-tree.</p>",
  "post_number": 2,
  "post_type": 1,
  "updated_at": "2024-02-04T23:47:42.569Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 3,
  "reads": 13,
  "readers_count": 12,
  "score": 17.6,
  "yours": false,
  "topic_id": 504,
  "topic_slug": "sighash-outputdeltabounds",
  "topic_title": "`sighash_outputdeltabounds`",
  "topic_html_title": "`sighash_outputdeltabounds`",
  "category_id": 7,
  "display_username": "ZmnSCPxj jxPCSnmZ",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Intuitively, we can consider that the entire point of this scheme is to specify that one output pays the fees, thus we do not commit to that particular output having a particular amount. Optionally, we can impose a maximum amount that the output can pay, in case the output is (still) a shared output.  Protocols using this require a separate signature, coming from an owner of the output, which allows that owner to fix the fee paid. This also requires only one participant to be online at that time (i.e. other participants need not be online), allowing that participant to arbitrarily sign unilaterally and decide how much fees to deduct from their owned output, while still imposing that the other outputs are untouched.\n\nJust as `SIGHASH_NOINPUT` is implementable via `OP_CHECKTEMPLATEVERIFY` and `OP_CHECKSIGFROMSTACK`, we can also consider how to implement this scheme using `OP_CHECKTEMPLATEVERIFY`.\n\nFor example, suppose we extend `OP_CHECKTEMPLATEVERIFY` in the following manner:\n\n* If the stack top is 32 bytes, follow BIP-119.\n* If the stack top is 33 bytes or more:\n  * Take the first byte as the `CTVHASH` type.\n  * If the first byte is:\n    * `0x00`, this is an \"output pays fee\" `CTVHASH` type.\n    * anything else, `OP_CHECKTEMPLATEVERIFY` acts as an `OP_NOP` (this allows for future extensions).\n\nWhen verifying an \"output pays fee\" `CTVHASH` type, we extract the following pieces of data:\n\n* An output index.\n* An optional amount to be deducted.\n* A 32-byte hash commitment.\n\nThe length of the stack top determines how the data is interpreted.  The last 32 bytes is always the 32-byte hash commitment.  Then if the stack top length is:\n\n* 34 bytes: byte 1 is the output index, there is no amount to deduct.\n* 35 bytes: bytes 1-2 is the output index in little-endian, there is no amount to deduct.\n* 36 bytes: bytes 1-3 is the output index in little-endian, there is no amount to deduct.\n* 37 bytes: bytes 1-4 is the output index in little-endian, there is no amount to deduct.\n* 38 bytes: byte 1 is the output index, bytes 2 to 5 is the amount to deduct in little-endian.\n* 39 bytes: bytes 1-2 is the output index, bytes 3 to 6 is the amount to deduct in little-endian.\n* 40 bytes: bytes 1-3 is the output index, bytes 4 to 7 is the amount to deduct in little-endian.\n* 41 bytes: bytes 1-4 is the output index, bytes 5 to 8 is the amount to deduct in little-endian.\n* 42 bytes: byte 1 is the output index, bytes 2 to 9 is the amount to deduct in little-endian.\n* 43 bytes: bytes 1-2 is the output index in little-endian, bytes 3 to 10 is the amount to deduct in little-endian.\n* 44 bytes: bytes 1-3 is the output index in little-endian, bytes 4 to 11 is the amount to deduct in little-endian.\n* 45 bytes: bytes 1-4 is the output index in little-endian, bytes 5 to 12 is the amount to deduct in little-endian.\n* otherwise: fail validation\n\n> **Rationale** The above encoding does not require spending extra bytes as for `CVarSize`; instead, the push opcode that gets the above onto the stack effectively encodes how many bytes to use for the output index and (optional) amount to deduct.\n>\n> The expectation is that most transactions will be small and the output index will correspondingly be small as well. In contrast, amounts are expected to be large. Nevertheless, it is also expected that amounts involved will rarely exceed 42.94967295 BTC, thus the amount to deduct may also be encoded in 4 bytes instead of 8. The expectation is that every byte matters.\n\nIn addition, the \"output pays fee\" `CTVHASH` type requires the following validation:\n\n* The script interpreter maintains a \"heavy CTV hashes\" variable that is initialized to 0 on starting script execution. On encountering an \"output pays fee\" `CTVHASH`, increment this variable. If the variable is now 2 or higher, fail validation.\n* The transaction must have exactly 1 input. Otherwise, fail validation.\n* `nSequence` of the sole input must be `0x00000000`.\n* If the \"amount to deduct\" is specified, then perform the following additional validation:\n  * Get the amount of this input, then subtract the amount to deduct.\n  * The amount of the output at the given output index must be **greater than or equal to** the above difference.\n\n> **Rationale** The above prevents quadratic hashing via this new \"output pays fee\" `CTVHASH` extension. As this changes the hashing of the outputs, the output hashes cannot be cached as in the original BIP-119. Instead, the above rules prevent quadratic hashing by only allowing a single heavyweight hash operation per transaction.\n>\n> We specify that the script interpreter maintains a \"heavy CTV hashes\" variable so that future `CTVHASH` types may also use the same variable, preventing quadratic hashing by using different heavyweight `CTVHASH` types.\n>\n> The transaction can feasibly be limited to exactly 1 input since this mechanism is intended to replace other mechanisms where fees are paid by other inputs. Instead, the fees are paid from the given single input, which serves as a shared fund, with one of the outputs being reduced in order to fund the mining fee.\n>\n> An `nSequence` of `0` forces the transaction to opt-in to RBF (which is a desired feature of this mechanism, which allows one participant to RBF freely by deducting the output it owns, which is specified in the stack argument here), and enables `nLockTime` if that is needed.\n>\n> The amount to deduct, if specified, prevents the output from being entirely used up to pay for fees. This may be used if the output is still shared among multiple participants, as in Decker-Russell-Osuntokun or intermediate outputs in CTV-trees. The amount is subtracted from the input, and the input is **not** committed to in the hash, to allow intermediate `OP_CHECKTEMPLATEVERIFY` transactions to have variable fees that can adapt to changing onchain conditions, with having the total fees of all intermediate transactions debited from a final output.\n\nThe template hash is then computed by hashing the below:\n\n* All but the last 32 bytes of the stack top argument (i.e. `CTVHASH` type, the formatted output index that pays fees, plus the optional amont to deduct, in the formatted order).\n* `nVersion`\n* `nLockTime`\n* output count\n* output hash, modified as follows:\n  * For the output at the index specified in the stack top argument, set the amount as 0.\n\n> **Rationale** As this `CTVHASH` type is intended to support an \"internal fees\" mechanism, as noted above, it already restricts the number of inputs to just 1. There is thus no need to commit to the number of inputs or the `nSequence` (which is fixed above, as well), or the input index this is executing on.\n\n---------\n\nThe uses of this new `CTVHASH` mode are, *in combination with `OP_CHECKSIGFROMSTACK`*, congruent to the original posting up top, and the equivalence is left to the reader.\n\nWe can create a CTV-tree where fees are dynamically decided at publish time, with all fees paid internally instead of externally (i.e. there is no need to own another UTXO that pays for fees) by using this mechanism. For example, suppose we want to commit to outputs A, B, C, D with particular amounts. We construct a root address that spends to 4 possible tapleaves to create a 1-input, 2-output top node:\n\n* \"output pays fee\" `CTVHASH` that points to `A,B` output paying up to some max fee plus fixes the `C,D`output, plus a `OP_CHECKSIG` from `A`.\n* \"output pays fee\" `CTVHASH` that points to `A,B` output paying up to some max  fee plus fixes the `C,D` output, plus a `OP_CHECKSIG` from `B`.\n* \"output pays fee\" `CTVHASH` that points to `C,D` output paying up to some max  fee plus fixes the `A,B` output, plus a `OP_CHECKSIG` from `C`.\n* \"output pays fee\" `CTVHASH` that points to `C,D` output paying up to some max  fee plus fixes the `A,B` output, plus a `OP_CHECKSIG` from `D`.\n\nThen, the `A,B` (corresponding `C,D`) output of the top node would have 2 possible tapleaves to create a 1-input, 2-output final node:\n\n* \"output pays fee\" `CTVHASH` that points to `A` output paying the fee plus fixes the `B` output, plus a `OP_CHECKSIG` from `A`.\n* \"output pays fee\" `CTVHASH` that points to `B` output paying the fee plus fixes the `A` output, plus a `OP_CHECKSIG` from `B`.\n\nThen, if a participants wants to publish their output, they can instantiate the path to their node, paying all fees for intermediate nodes and the final node in the CTV-tree.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 104,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}