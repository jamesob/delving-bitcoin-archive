{
  "id": 3159,
  "name": "",
  "username": "virtu",
  "avatar_template": "/user_avatar/delvingbitcoin.org/virtu/{size}/540_2.png",
  "created_at": "2024-09-11T07:43:47.522Z",
  "cooked": "<p>As far as I know <code>getaddrinfo</code> will only return A and AAAA records.</p>\n<p>I understand we don\u2019t want to add some dependency library for this. But since we only need to send a particular query I don\u2019t think that\u2019s necessary. From what I learned writing the seeder, DNS is refreshingly straightforward. Here\u2019s some C++ to send and receive a NULL query to demonstrate.</p>\n<pre data-code-wrap=\"C++\"><code class=\"lang-C++\">#include &lt;arpa/inet.h&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;netinet/in.h&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;sys/socket.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;vector&gt;\n\nstruct DNSHeader {\n  uint16_t id;\n  uint16_t flags;\n  uint16_t q_count;\n  uint16_t ans_count;\n  uint16_t auth_count;\n  uint16_t add_count;\n};\n\nstruct DNSQuestion {\n  std::vector&lt;unsigned char&gt; qname;\n  uint16_t qtype;\n  uint16_t qclass;\n\n  DNSQuestion(const std::string &amp;domain, uint16_t type, uint16_t cls)\n      : qtype(type), qclass(cls) {\n    // Convert domain to DNS format: prefix parts with their length and\n    // end with null byte (e.g. dnsseed.21.ninja -&gt; 7dnsseed2215ninja0)\n    std::stringstream ss(domain);\n    std::string segment;\n    while (getline(ss, segment, '.')) {\n      qname.push_back(static_cast&lt;uint8_t&gt;(segment.size()));\n      qname.insert(qname.end(), segment.begin(), segment.end());\n    }\n    qname.push_back(0);\n  }\n\n  std::vector&lt;unsigned char&gt; serialize() const {\n    std::vector&lt;unsigned char&gt; serialized;\n    serialized.insert(serialized.end(), qname.begin(), qname.end());\n    serialized.insert(\n        serialized.end(), reinterpret_cast&lt;const unsigned char *&gt;(&amp;qtype),\n        reinterpret_cast&lt;const unsigned char *&gt;(&amp;qtype) + sizeof(qtype));\n    serialized.insert(\n        serialized.end(), reinterpret_cast&lt;const unsigned char *&gt;(&amp;qclass),\n        reinterpret_cast&lt;const unsigned char *&gt;(&amp;qclass) + sizeof(qclass));\n    return serialized;\n  }\n};\n\nint main() {\n  const std::string domain = \"dnsseed.21.ninja\";\n  const std::string nameserver = \"89.116.30.184\";\n\n  // Prepare DNS query\n  std::vector&lt;unsigned char&gt; query;\n  DNSHeader header = {static_cast&lt;uint16_t&gt;(getpid() % 65536), htons(0x0100), htons(1), 0, 0, 0}; // 0x0100 for recursion desired\n  query.insert(query.end(), reinterpret_cast&lt;unsigned char *&gt;(&amp;header), reinterpret_cast&lt;unsigned char *&gt;(&amp;header) + sizeof(DNSHeader));\n  DNSQuestion question = {domain, htons(10), htons(1)}; // 10 for NULL record, 1 for IN class\n  auto serializedQuestion = question.serialize();\n  query.insert(query.end(), serializedQuestion.begin(), serializedQuestion.end());\n\n  int sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n  struct sockaddr_in dest = { .sin_family = AF_INET, .sin_port = htons(53), .sin_addr = {.s_addr = inet_addr(nameserver.c_str())}};\n  ssize_t bytes_sent = sendto(sock, query.data(), query.size(), 0, (struct sockaddr *)&amp;dest, sizeof(dest));\n  printf(\"Sent query (size=%ld, header id=%d)\\n\", bytes_sent, reinterpret_cast&lt;const DNSHeader *&gt;(query.data())-&gt;id);\n\n  std::vector&lt;unsigned char&gt; response(512);\n  socklen_t addr_len = sizeof(dest);\n  ssize_t bytes_received = recvfrom(sock, response.data(), response.size(), 0, (struct sockaddr *)&amp;dest, &amp;addr_len);\n  printf(\"Received reply (size=%ld, header id=%d)\\n\", bytes_received, reinterpret_cast&lt;const DNSHeader *&gt;(response.data())-&gt;id);\n\n  close(sock);\n  return 0;\n}\n</code></pre>",
  "post_number": 4,
  "post_type": 1,
  "updated_at": "2024-09-11T07:43:47.522Z",
  "reply_count": 0,
  "reply_to_post_number": 2,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 6,
  "readers_count": 5,
  "score": 1.2,
  "yours": false,
  "topic_id": 1123,
  "topic_slug": "hardcoded-seeds-dns-seeds-and-darknet-nodes",
  "topic_title": "Hardcoded seeds, DNS seeds and Darknet nodes",
  "topic_html_title": "Hardcoded seeds, DNS seeds and Darknet nodes",
  "category_id": 8,
  "display_username": "",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "reply_to_user": {
    "username": "sipa",
    "name": "Pieter Wuille",
    "avatar_template": "/user_avatar/delvingbitcoin.org/sipa/{size}/102_2.png"
  },
  "bookmarked": false,
  "raw": "As far as I know `getaddrinfo` will only return A and AAAA records.\n\nI understand we don't want to add some dependency library for this. But since we only need to send a particular query I don't think that's necessary. From what I learned writing the seeder, DNS is refreshingly straightforward. Here's some C++ to send and receive a NULL query to demonstrate.\n\n```C++\n#include <arpa/inet.h>\n#include <cstring>\n#include <iostream>\n#include <netinet/in.h>\n#include <sstream>\n#include <string>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <vector>\n\nstruct DNSHeader {\n  uint16_t id;\n  uint16_t flags;\n  uint16_t q_count;\n  uint16_t ans_count;\n  uint16_t auth_count;\n  uint16_t add_count;\n};\n\nstruct DNSQuestion {\n  std::vector<unsigned char> qname;\n  uint16_t qtype;\n  uint16_t qclass;\n\n  DNSQuestion(const std::string &domain, uint16_t type, uint16_t cls)\n      : qtype(type), qclass(cls) {\n    // Convert domain to DNS format: prefix parts with their length and\n    // end with null byte (e.g. dnsseed.21.ninja -> 7dnsseed2215ninja0)\n    std::stringstream ss(domain);\n    std::string segment;\n    while (getline(ss, segment, '.')) {\n      qname.push_back(static_cast<uint8_t>(segment.size()));\n      qname.insert(qname.end(), segment.begin(), segment.end());\n    }\n    qname.push_back(0);\n  }\n\n  std::vector<unsigned char> serialize() const {\n    std::vector<unsigned char> serialized;\n    serialized.insert(serialized.end(), qname.begin(), qname.end());\n    serialized.insert(\n        serialized.end(), reinterpret_cast<const unsigned char *>(&qtype),\n        reinterpret_cast<const unsigned char *>(&qtype) + sizeof(qtype));\n    serialized.insert(\n        serialized.end(), reinterpret_cast<const unsigned char *>(&qclass),\n        reinterpret_cast<const unsigned char *>(&qclass) + sizeof(qclass));\n    return serialized;\n  }\n};\n\nint main() {\n  const std::string domain = \"dnsseed.21.ninja\";\n  const std::string nameserver = \"89.116.30.184\";\n\n  // Prepare DNS query\n  std::vector<unsigned char> query;\n  DNSHeader header = {static_cast<uint16_t>(getpid() % 65536), htons(0x0100), htons(1), 0, 0, 0}; // 0x0100 for recursion desired\n  query.insert(query.end(), reinterpret_cast<unsigned char *>(&header), reinterpret_cast<unsigned char *>(&header) + sizeof(DNSHeader));\n  DNSQuestion question = {domain, htons(10), htons(1)}; // 10 for NULL record, 1 for IN class\n  auto serializedQuestion = question.serialize();\n  query.insert(query.end(), serializedQuestion.begin(), serializedQuestion.end());\n\n  int sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n  struct sockaddr_in dest = { .sin_family = AF_INET, .sin_port = htons(53), .sin_addr = {.s_addr = inet_addr(nameserver.c_str())}};\n  ssize_t bytes_sent = sendto(sock, query.data(), query.size(), 0, (struct sockaddr *)&dest, sizeof(dest));\n  printf(\"Sent query (size=%ld, header id=%d)\\n\", bytes_sent, reinterpret_cast<const DNSHeader *>(query.data())->id);\n\n  std::vector<unsigned char> response(512);\n  socklen_t addr_len = sizeof(dest);\n  ssize_t bytes_received = recvfrom(sock, response.data(), response.size(), 0, (struct sockaddr *)&dest, &addr_len);\n  printf(\"Received reply (size=%ld, header id=%d)\\n\", bytes_received, reinterpret_cast<const DNSHeader *>(response.data())->id);\n\n  close(sock);\n  return 0;\n}\n```",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 91,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}