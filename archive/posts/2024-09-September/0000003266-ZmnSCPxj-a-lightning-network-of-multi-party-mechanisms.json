{
  "id": 3266,
  "name": "ZmnSCPxj jxPCSnmZ",
  "username": "ZmnSCPxj",
  "avatar_template": "/letter_avatar_proxy/v4/letter/z/ee7513/{size}.png",
  "created_at": "2024-09-24T23:58:52.795Z",
  "cooked": "<p>I would like to propose splitting off the link layer\nof Lightning Network from the network layer.</p>\n<p>The motivation for this is to allow the network to\ndirectly connect multi-party (N&gt;=2) mechanisms together,\ninstead of having disparate multi-party mechanisms\ntransacting over 2-party channel straws, or presenting\na single multi-party pool as several 2-party channels\nto the Lightning Network.\nThe existing network of 2-party channels would then be\na degenerate case where N=2.</p>\n<p>This would require changes in the following:</p>\n<ul>\n<li>Gossip</li>\n<li>Onion Routing (of PTLCs, HTLCs, and onion messages)</li>\n</ul>\n<p>Of particular note is that, for the <em>rest</em> of the\npublic network, what a group of nodes use to transfer\nfunds between them is actually immaterial.\nThat is, the multi-party mechanism might be a\nfully-backed n-of-n Decker-Wattenhofer mechanism, or it\nmight be a federated custodial mechanism with credit\n(negative balances) that is enforced by legal contracts,\nor an Ark, or a BitVM machine, or whatever.\nThe rest of the network need not care about what the\nexact mechanisms are.\nInstead, the rest of the network only cares about how\nreliable it would be to route through that mechanism.</p>\n<h1><a name=\"p-3266-gossip-1\" class=\"anchor\" href=\"#p-3266-gossip-1\"></a>Gossip</h1>\n<p>For gossip, the <code>channel_announcement</code> message would\nhave a variable number of nodes.\nNote that not only do we need the public keys, we\nwould also need signatures from each node.\n(The signature effectively indicates agreement that\nthe node is willing to route over this multi-party\nmechanism.)\nWe can aggregate the signatures using MuSig2 so that\nno matter how many nodes there are on a mechanism,\nonly one Schnorr signature is necessary.</p>\n<p>An issue here is that messages are restricted by\nBOLT8 to 65535-byte payloads.\nWith 33-byte node IDs we can have up to 1985.9 nodes,\nthough since we need other data, we might want to\nrestrict to 1000 published nodes per multi-party\nmechanism.\n(The multi-party mechanism might have more parties\nthan 1000, but the rest would not participate in\npublic routing)</p>\n<p>Gossiped <code>channel_announcement</code>s would have to allow\nnodes to be added and removed, to support mechanisms\nthat have dynamic membership sets.</p>\n<h2><a name=\"p-3266-gossip-spam-2\" class=\"anchor\" href=\"#p-3266-gossip-spam-2\"></a>Gossip Spam</h2>\n<p>The current design for <code>channel_announcement</code>s require\nthat nodes (pretend to) validate their outpoint against\nthe actual blockchain.\nThe channel outpoint has to be an actual unspent UTXO.</p>\n<p>The intent of this is to prevent someone from making\nup nonexistent channels and then using the channel data\nto store information over the gossip network.\nActual users suffer since they have to spend more time\ndoing probes over a larger network where most of the\ngraph edges would never succeed in routing anyway\n(because they are actually nonexistent, and are being\nabused to store arbitrary data over the Lightning\nNetwork).</p>\n<p>Against this, we should note that some multi-party\nmechanism designs, such as Ark, hit the blockchain\noften.\nThat is, they will spend their \u201cmain\u201d UTXO and then\ncreate a new one every few blocks.</p>\n<p>So, my proposal is:</p>\n<ul>\n<li>We check that the <code>channel_announcement</code> outpoint\nexists without checking it was spent.</li>\n<li>We <em>reject</em> <code>channel_update</code>s if the TXO is <em>not</em> a\nUTXO.\n<ul>\n<li>This limits the amount of data that is propagated\nover the network to only be as large as the UTXO\nset.</li>\n<li>That is: we accept the <em>existence</em> of the mechanism\neven if the TXO backing it is already spent, but\nwe refuse <em>additional data about it</em> if the TXO\nbacking it is already spent.</li>\n</ul>\n</li>\n<li>A <code>channel_update</code> can re-point to a new TXO that\n<em>is</em> a UTXO.\n<ul>\n<li>Thus, for example, an Ark mechanism can send a\n<code>channel_update</code> by pointing to its latest TXO,\nthe one that is currently unspent.</li>\n</ul>\n</li>\n</ul>\n<h2><a name=\"p-3266-pathfinding-3\" class=\"anchor\" href=\"#p-3266-pathfinding-3\"></a>Pathfinding</h2>\n<p>Most pathfinding algorithms assume that edges\nconnect to exactly 2 nodes on the graph.</p>\n<p>To adapt these existing pathfinding algorithms to\nmulti-party mechanisms on the network,\npathfinding algorithms can \u201csplit\u201d a N-party (N&gt;2)\nmechanism into multiple 2-party channels to a\ncommon \u201cvirtual\u201d node that represents the N-party\nmechanism.\nWhen building the onion for routing, you simply\nskip over the virtual node that represents the\nN-party mechanism.</p>\n<h1><a name=\"p-3266-onion-routing-4\" class=\"anchor\" href=\"#p-3266-onion-routing-4\"></a>Onion Routing</h1>\n<p>An important point about onion routing is:</p>\n<blockquote>\n<p>We use SCIDs as a small way to identify the next\n<em>node</em>, not to identify the next <em>channel</em>.</p>\n</blockquote>\n<p>In principle, if a node is a member of multiple\nmulti-party mechanisms, and the next node in the\nonion is also a member of multiple multi-party\nmechanisms, then the node has a choice of which\nmechanism(s) to use to forward a payment.</p>\n<p>Now, when mechanisms are 2-party channels, for each\nnode, the SCID uniquely identifies which peer is\nthe next hop.</p>\n<p>However, when mechanisms are multi-party, then we\nneed further disambiguation.\nAn SCID is not enough to identify the next node in\nthe routing hop.</p>\n<p>My concrete proposal is to use a \u201cshort node ID\u201d,\nwhich is just the last 12 or 16 bytes of the node ID.\nThis should be sufficient to disambiguate, given\nthe random nature of node IDs.\nThis increases the size of the next hop ID by 4 or 8\nbytes.\nAs I understand it, 128 bits is still too large a\nspace to find collisions with other node IDs, and 96\nbits might also be sufficient.</p>\n<p>For legacy 2-party channels that cannot have more\nthan 2 parties, then it can use the shorter SCID, as\nin legacy onion routing.</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2024-09-24T23:58:52.795Z",
  "reply_count": 1,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 23,
  "reads": 7,
  "readers_count": 6,
  "score": 121.4,
  "yours": false,
  "topic_id": 1163,
  "topic_slug": "a-lightning-network-of-multi-party-mechanisms",
  "topic_title": "A Lightning Network of multi-party mechanisms",
  "topic_html_title": "A Lightning Network of multi-party mechanisms",
  "category_id": 7,
  "display_username": "ZmnSCPxj jxPCSnmZ",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "I would like to propose splitting off the link layer\nof Lightning Network from the network layer.\n\nThe motivation for this is to allow the network to\ndirectly connect multi-party (N>=2) mechanisms together,\ninstead of having disparate multi-party mechanisms\ntransacting over 2-party channel straws, or presenting\na single multi-party pool as several 2-party channels\nto the Lightning Network.\nThe existing network of 2-party channels would then be\na degenerate case where N=2.\n\nThis would require changes in the following:\n\n* Gossip\n* Onion Routing (of PTLCs, HTLCs, and onion messages)\n\nOf particular note is that, for the *rest* of the\npublic network, what a group of nodes use to transfer\nfunds between them is actually immaterial.\nThat is, the multi-party mechanism might be a\nfully-backed n-of-n Decker-Wattenhofer mechanism, or it\nmight be a federated custodial mechanism with credit\n(negative balances) that is enforced by legal contracts,\nor an Ark, or a BitVM machine, or whatever.\nThe rest of the network need not care about what the\nexact mechanisms are.\nInstead, the rest of the network only cares about how\nreliable it would be to route through that mechanism.\n\nGossip\n======\n\nFor gossip, the `channel_announcement` message would\nhave a variable number of nodes.\nNote that not only do we need the public keys, we\nwould also need signatures from each node.\n(The signature effectively indicates agreement that\nthe node is willing to route over this multi-party\nmechanism.)\nWe can aggregate the signatures using MuSig2 so that\nno matter how many nodes there are on a mechanism,\nonly one Schnorr signature is necessary.\n\nAn issue here is that messages are restricted by\nBOLT8 to 65535-byte payloads.\nWith 33-byte node IDs we can have up to 1985.9 nodes,\nthough since we need other data, we might want to\nrestrict to 1000 published nodes per multi-party\nmechanism.\n(The multi-party mechanism might have more parties\nthan 1000, but the rest would not participate in\npublic routing)\n\nGossiped `channel_announcement`s would have to allow\nnodes to be added and removed, to support mechanisms\nthat have dynamic membership sets.\n\nGossip Spam\n-----------\n\nThe current design for `channel_announcement`s require\nthat nodes (pretend to) validate their outpoint against\nthe actual blockchain.\nThe channel outpoint has to be an actual unspent UTXO.\n\nThe intent of this is to prevent someone from making\nup nonexistent channels and then using the channel data\nto store information over the gossip network.\nActual users suffer since they have to spend more time\ndoing probes over a larger network where most of the\ngraph edges would never succeed in routing anyway\n(because they are actually nonexistent, and are being\nabused to store arbitrary data over the Lightning\nNetwork).\n\nAgainst this, we should note that some multi-party\nmechanism designs, such as Ark, hit the blockchain\noften.\nThat is, they will spend their \"main\" UTXO and then\ncreate a new one every few blocks.\n\nSo, my proposal is:\n\n* We check that the `channel_announcement` outpoint\n  exists without checking it was spent.\n* We *reject* `channel_update`s if the TXO is *not* a\n  UTXO.\n  - This limits the amount of data that is propagated\n    over the network to only be as large as the UTXO\n    set.\n  - That is: we accept the *existence* of the mechanism\n    even if the TXO backing it is already spent, but\n    we refuse *additional data about it* if the TXO\n    backing it is already spent.\n* A `channel_update` can re-point to a new TXO that\n  *is* a UTXO.\n  - Thus, for example, an Ark mechanism can send a\n    `channel_update` by pointing to its latest TXO,\n    the one that is currently unspent.\n\nPathfinding\n-----------\n\nMost pathfinding algorithms assume that edges\nconnect to exactly 2 nodes on the graph.\n\nTo adapt these existing pathfinding algorithms to\nmulti-party mechanisms on the network,\npathfinding algorithms can \"split\" a N-party (N>2)\nmechanism into multiple 2-party channels to a\ncommon \"virtual\" node that represents the N-party\nmechanism.\nWhen building the onion for routing, you simply\nskip over the virtual node that represents the\nN-party mechanism.\n\nOnion Routing\n=============\n\nAn important point about onion routing is:\n\n> We use SCIDs as a small way to identify the next\n> *node*, not to identify the next *channel*.\n\nIn principle, if a node is a member of multiple\nmulti-party mechanisms, and the next node in the\nonion is also a member of multiple multi-party\nmechanisms, then the node has a choice of which\nmechanism(s) to use to forward a payment.\n\nNow, when mechanisms are 2-party channels, for each\nnode, the SCID uniquely identifies which peer is\nthe next hop.\n\nHowever, when mechanisms are multi-party, then we\nneed further disambiguation.\nAn SCID is not enough to identify the next node in\nthe routing hop.\n\nMy concrete proposal is to use a \"short node ID\",\nwhich is just the last 12 or 16 bytes of the node ID.\nThis should be sufficient to disambiguate, given\nthe random nature of node IDs.\nThis increases the size of the next hop ID by 4 or 8\nbytes.\nAs I understand it, 128 bits is still too large a\nspace to find collisions with other node IDs, and 96\nbits might also be sufficient.\n\nFor legacy 2-party channels that cannot have more\nthan 2 parties, then it can use the shorter SCID, as\nin legacy onion routing.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 104,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}