{
  "id": 3096,
  "name": "Anthony Towns",
  "username": "ajtowns",
  "avatar_template": "/user_avatar/delvingbitcoin.org/ajtowns/{size}/417_2.png",
  "created_at": "2024-09-04T03:16:40.829Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"harding\" data-post=\"42\" data-topic=\"710\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/harding/48/6_2.png\" class=\"avatar\"> harding:</div>\n<blockquote>\n<p>A lite client performing whitepaper-style SPV can be tricked into accepting a fake transaction if the coinbase transaction was actually 64 bytes. To avoid that, it needs to learn the contents of the entire coinbase transaction in order to derive its txid for verifying its depth in the merkle tree.</p>\n</blockquote>\n</aside>\n<p>I don\u2019t think that\u2019s strictly true? sha256 includes the size of its input when calculating the hash, so implicit in being provided a midstate is being provided the number of bytes that went into the midstate, in bitcoin that\u2019s <code>s</code> (the midstate), <code>buf</code> (the remaining bytes that will build the next chunk) and <code>bytes</code> (the number of bytes that went into both those things). So a preimage for the txid of a very large coinbase tx can still be reduced to as few as 104 bytes. That requires you have some way of differentiating a \u201cvalid\u201d 64 byte coinbase tx from an internal node of the tx merkle tree, but it\u2019s easy to transmit the full coinbase tx in that case anyway.</p>\n<aside class=\"quote no-group\" data-username=\"AntoineP\" data-post=\"41\" data-topic=\"710\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/antoinep/48/483_2.png\" class=\"avatar\"> AntoineP:</div>\n<blockquote>\n<p>Reduces the bandwidth of block inclusion proofs for transactions.</p>\n</blockquote>\n</aside>\n<p>Compared to the status quo, it improves the correctness of block inclusion proofs. Compared to including the coinbase in the proof, I think the reduction in complexity is more of an advantage tbh:</p>\n<ul>\n<li>you need a merkle path, and also to check the witness-stripped tx isn\u2019t 64 bytes</li>\n<li>you need a combined merkle path to both the coinbase and the tx; you need to check they\u2019re the same depth; you need to check the coinbase is valid; in order to minimise bandwidth you need to deal with sha256 midstates</li>\n<li>you need to lookup the block\u2019s merkle tree depth via (TBD), (except if the block height is prior to the activation height, in which case you\u2019ll need to use this fixed table and hope there\u2019s no absurdly large reorg) then check the merkle path is exactly that long</li>\n</ul>\n<p>Perhaps worth noting that these merkle proofs will only give you the witness-stripped tx anyway \u2013 in order to verify the tx\u2019s witness data you need the full coinbase in order to obtain the segwit commitment (which can be essentially anywhere in the coinbase tx), and then you need the matching merkle path from that to your non-stripped tx. So for a lite node, checking the stripped size of the tx is straight-forward \u2013 that\u2019s all the data it\u2019s likely to be able to verify anyway.</p>\n<p>It occurs to me that most of the time, you\u2019re probably more interested in whether an output is (was) in the utxo set, rather than whether a tx is in a block. But I think the concerns here are irrelevant for things like utreexo that have some new merkle tree: they can use a prefix to distinguish tree contents from internal nodes.</p>",
  "post_number": 43,
  "post_type": 1,
  "updated_at": "2024-09-04T03:16:40.829Z",
  "reply_count": 1,
  "reply_to_post_number": 42,
  "quote_count": 2,
  "incoming_link_count": 0,
  "reads": 8,
  "readers_count": 7,
  "score": 21.6,
  "yours": false,
  "topic_id": 710,
  "topic_slug": "great-consensus-cleanup-revival",
  "topic_title": "Great Consensus Cleanup Revival",
  "topic_html_title": "Great Consensus Cleanup Revival",
  "category_id": 7,
  "display_username": "Anthony Towns",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"harding, post:42, topic:710\"]\nA lite client performing whitepaper-style SPV can be tricked into accepting a fake transaction if the coinbase transaction was actually 64 bytes. To avoid that, it needs to learn the contents of the entire coinbase transaction in order to derive its txid for verifying its depth in the merkle tree.\n[/quote]\n\nI don't think that's strictly true? sha256 includes the size of its input when calculating the hash, so implicit in being provided a midstate is being provided the number of bytes that went into the midstate, in bitcoin that's `s` (the midstate), `buf` (the remaining bytes that will build the next chunk) and `bytes` (the number of bytes that went into both those things). So a preimage for the txid of a very large coinbase tx can still be reduced to as few as 104 bytes. That requires you have some way of differentiating a \"valid\" 64 byte coinbase tx from an internal node of the tx merkle tree, but it's easy to transmit the full coinbase tx in that case anyway.\n\n[quote=\"AntoineP, post:41, topic:710\"]\nReduces the bandwidth of block inclusion proofs for transactions.\n[/quote]\n\nCompared to the status quo, it improves the correctness of block inclusion proofs. Compared to including the coinbase in the proof, I think the reduction in complexity is more of an advantage tbh:\n\n  * you need a merkle path, and also to check the witness-stripped tx isn't 64 bytes\n  * you need a combined merkle path to both the coinbase and the tx; you need to check they're the same depth; you need to check the coinbase is valid; in order to minimise bandwidth you need to deal with sha256 midstates\n  * you need to lookup the block's merkle tree depth via (TBD), (except if the block height is prior to the activation height, in which case you'll need to use this fixed table and hope there's no absurdly large reorg) then check the merkle path is exactly that long\n\nPerhaps worth noting that these merkle proofs will only give you the witness-stripped tx anyway -- in order to verify the tx's witness data you need the full coinbase in order to obtain the segwit commitment (which can be essentially anywhere in the coinbase tx), and then you need the matching merkle path from that to your non-stripped tx. So for a lite node, checking the stripped size of the tx is straight-forward -- that's all the data it's likely to be able to verify anyway.\n\nIt occurs to me that most of the time, you're probably more interested in whether an output is (was) in the utxo set, rather than whether a tx is in a block. But I think the concerns here are irrelevant for things like utreexo that have some new merkle tree: they can use a prefix to distinguish tree contents from internal nodes.",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": true,
  "admin": true,
  "staff": true,
  "user_id": 3,
  "hidden": false,
  "trust_level": 4,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "thinking",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}