{
  "id": 3241,
  "name": "Adam Gibson",
  "username": "AdamISZ",
  "avatar_template": "/user_avatar/delvingbitcoin.org/adamisz/{size}/418_2.png",
  "created_at": "2024-09-20T22:46:58.079Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"1440000bytes\" data-post=\"16\" data-topic=\"934\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/1440000bytes/48/301_2.png\" class=\"avatar\"> 1440000bytes:</div>\n<blockquote>\n<p>TBH only coinjoin implementation that did try to fix it was joinstr.</p>\n</blockquote>\n</aside>\n<p>How does joinstr do more on this specific issue (<em>communication</em> coordination centralization) than Joinmarket?</p>\n<p>For context, over the years Joinmarket developed this model:</p>\n<p>At first, it supported 1 IRC server as a central communication coordinator, but encrypted the private information between makers and takers E2E using a DH key exchange (see: libsodium). So while the central coordinator could censor messages that could affect the market-making coordination, it couldn\u2019t censor in a way relevant to the coinjoins themselves (selecting certain utxos and not others etc.). Still of course, at that level, that\u2019s super censorable and weak, because one server.</p>\n<p>Then somewhat later it started supporting multiple redundant IRC servers, with here \u201credundant\u201d very specifically meaning <em>all</em> messages passed over <em>all</em> connected servers. We also added details like signatures over the endpoints and the communication servers to prevent replay attacks across different \u201cmessage channels\u201d (which is the abstraction, with IRC servers just being a type of that). At this point it\u2019s already quite robust. Probably 6-8 different IRC servers were used in practice, though usually only 3 at a time.</p>\n<p>A couple relevant details: obviously this required ephemeral public key identities to sign over, which were done with secp256k1 of course. Also, perhaps obvious, but we used onion endpoints of the IRC servers.</p>\n<p>Then even later we added \u201cdirectory nodes\u201d which tried to go a little bit farther: not only are the messages between parties encrypted on the message channel, but even the parties talk p2p; the taker/maker model helps here, because makers can run their own onion services since they\u2019re always online. This model worked extremely well for a while, allowing much larger coinjoins with more performant messaging (IRC servers are a bit of a bottleneck for coordinating), and a better privacy/censorship resistance model (the directory nodes effectively coordinate discovery of makers for takers and that\u2019s it). The problem was that it kind of started to collapse about 9 months after release, because the directory node onion services just weren\u2019t working. I don\u2019t know if this has been solved (I think not).</p>\n<p>(Also the \u2018redundant message channel concept\u2019 still applied, so you would send data over all available ones, whether the directory node type or the IRC type; btw it would not be at all difficult, imo, to code nostr as a further redundant message channel, here, but you\u2019d need to have some network anonymity as we do for the others).</p>\n<p>Is there some specific technique used by joinstr other than \u2018send over nostr\u2019? You could say that communication happens peer to peer but it\u2019s still going over relays right? Would you say multiple nostr relays is better than multiple redundant IRC servers? I suspect it <em>is</em> better, but mainly in that performance will be better; I\u2019d want to know how the anonymity part would work, but I\u2019m certainly no expert on that.</p>",
  "post_number": 17,
  "post_type": 1,
  "updated_at": "2024-09-20T22:46:58.079Z",
  "reply_count": 1,
  "reply_to_post_number": null,
  "quote_count": 1,
  "incoming_link_count": 0,
  "reads": 3,
  "readers_count": 2,
  "score": 5.6,
  "yours": false,
  "topic_id": 934,
  "topic_slug": "who-will-run-the-coinjoin-coordinators",
  "topic_title": "Who will run the CoinJoin coordinators?",
  "topic_html_title": "Who will run the CoinJoin coordinators?",
  "category_id": 5,
  "display_username": "Adam Gibson",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"1440000bytes, post:16, topic:934\"]\nTBH only coinjoin implementation that did try to fix it was joinstr.\n[/quote]\n\nHow does joinstr do more on this specific issue (*communication* coordination centralization) than Joinmarket?\n\nFor context, over the years Joinmarket developed this model:\n\nAt first, it supported 1 IRC server as a central communication coordinator, but encrypted the private information between makers and takers E2E using a DH key exchange (see: libsodium). So while the central coordinator could censor messages that could affect the market-making coordination, it couldn't censor in a way relevant to the coinjoins themselves (selecting certain utxos and not others etc.). Still of course, at that level, that's super censorable and weak, because one server.\n\nThen somewhat later it started supporting multiple redundant IRC servers, with here \"redundant\" very specifically meaning *all* messages passed over *all* connected servers. We also added details like signatures over the endpoints and the communication servers to prevent replay attacks across different \"message channels\" (which is the abstraction, with IRC servers just being a type of that). At this point it's already quite robust. Probably 6-8 different IRC servers were used in practice, though usually only 3 at a time.\n\nA couple relevant details: obviously this required ephemeral public key identities to sign over, which were done with secp256k1 of course. Also, perhaps obvious, but we used onion endpoints of the IRC servers.\n\nThen even later we added \"directory nodes\" which tried to go a little bit farther: not only are the messages between parties encrypted on the message channel, but even the parties talk p2p; the taker/maker model helps here, because makers can run their own onion services since they're always online. This model worked extremely well for a while, allowing much larger coinjoins with more performant messaging (IRC servers are a bit of a bottleneck for coordinating), and a better privacy/censorship resistance model (the directory nodes effectively coordinate discovery of makers for takers and that's it). The problem was that it kind of started to collapse about 9 months after release, because the directory node onion services just weren't working. I don't know if this has been solved (I think not).\n\n(Also the 'redundant message channel concept' still applied, so you would send data over all available ones, whether the directory node type or the IRC type; btw it would not be at all difficult, imo, to code nostr as a further redundant message channel, here, but you'd need to have some network anonymity as we do for the others).\n\nIs there some specific technique used by joinstr other than 'send over nostr'? You could say that communication happens peer to peer but it's still going over relays right? Would you say multiple nostr relays is better than multiple redundant IRC servers? I suspect it *is* better, but mainly in that performance will be better; I'd want to know how the anonymity part would work, but I'm certainly no expert on that.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 343,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}