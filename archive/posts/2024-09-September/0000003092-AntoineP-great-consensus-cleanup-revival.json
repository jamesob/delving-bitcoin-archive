{
  "id": 3092,
  "name": "Antoine Poinsot",
  "username": "AntoineP",
  "avatar_template": "/user_avatar/delvingbitcoin.org/antoinep/{size}/483_2.png",
  "created_at": "2024-09-03T16:06:05.301Z",
  "cooked": "<p>I see reasonable arguments on both sides. Thanks everyone for contributing those.</p>\n<p>To evaluate whether to include it in a future Consensus Cleanup proposal, i\u2019d like to weigh the remaining pros and cons of making 64 bytes transactions invalid through a soft fork. To do so i\u2019ll list the main pros and cons i can think of and/or were raised by others (notably Dave and Eric above). Then i\u2019ll try to make the best case for each position\u2019s arguments, and provide a rebuttal for some of the points presented when i can.</p>\n<p>Please let me know if an argument (or rebuttal) is missing or could be better presented.</p>\n<p>Here are the pros:</p>\n<ul>\n<li>Reduces the bandwidth of block inclusion proofs for transactions.</li>\n<li>Eliminates potential risks when implementing an application that verifies such a proof.</li>\n</ul>\n<p>And the cons:</p>\n<ul>\n<li>Introduces a non-obvious transaction validity rule.</li>\n<li>Requires a soft fork.</li>\n</ul>\n<p>Let\u2019s try to make the best case for each argument, starting with the pros.</p>\n<p>This change would allow merkle proofs to be ~50% smaller in both the worst and average cases for a typical 200 bytes transaction [0]. In addition it would remove a large footgun threatening anyone implementing software which needs to verify transaction merkle proofs. This concern is growing since, as network hashrate increases, the price of a fake inclusion proof using this method is decreasing compared to the price of mining an invalid block. This is in addition to the fact this method allows to fake any number of confirmations, compared to a single one by producing an invalid block.  Finally, it is important to not only consider lite clients. Proofs of inclusion of a transaction in a block are useful in other, existing or potential, applications. Examples include sidechains, or future Script changes which would allow to check a merkle proof directly in the interpreter.</p>\n<p>Here is a list of rebuttals to those specific points:</p>\n<ul>\n<li>Looking at the worst case cost is not a valid way of judging efficiency gains.\n<ul>\n<li>True. But the proof size reduction is (very) similar in the average case.</li>\n</ul>\n</li>\n<li>Hypothetical future consensus changes should not be taken into account for the purpose of this standalone fix. Because it\u2019s hard to weigh the benefit this usecase brings since we don\u2019t know whether it would ever exist, and simply because the fix could then be bundled with a future soft fork which enables this usecase.\n<ul>\n<li>Sure. Other usecases than lite-client remain though, such as sidechains. It\u2019s also not hard to imagine a Bitcoin-related application could verify a block inclusion proof.</li>\n</ul>\n</li>\n</ul>\n<p>Now, the cons.</p>\n<p>All changes to consensus rules bear a cost. The proof size reduction and proof verifier simplification does not meet the bar to be considered as a soft fork. The proof size reduction seems large in proportion, but it\u2019s small in absolute: a few hundred bytes. In addition you need only one per block, so the efficiency improvement decreases quickly as you query proofs for more than one transaction per block. The implementation simplification is also not a given. It removes one non-obvious check to be performed by inclusion proofs verifiers by another that needs to be performed by all validating nodes, which introduces <a href=\"https://groups.google.com/g/bitcoindev/c/CAfm7D5ppjo/m/kKD1x3gJCgAJ\">consensus \u201cseam\u201d</a>.</p>\n<p>And a list of rebuttals for those:</p>\n<ul>\n<li>Part of the fixed cost of the soft fork itself is compensated by bundling this fix with others. The cost inherent to changing the consensus rules should be weighed against the benefits brought by all the fixes together.</li>\n<li>It\u2019s true making 64 bytes transactions invalid introduces consensus \u201cseam\u201d, but it\u2019s not clear how it\u2019s an issue. It\u2019s a simple and straightforward rule which adds virtually no cost for full nodes to check.</li>\n<li>It\u2019s true that \u201call transaction sizes that fit in a block are valid except for 64 bytes\u201d is surprising as a rule. But we can\u2019t equate this with \u201cactually merkle proofs for 64 bytes transactions are insecure and you need to be aware of this clever-yet-convoluted workaround of asking for a proof for the coinbase too\u201d. In addition, we can generally expect protocol developers implementing a full node to be more aware of intricacies in the protocol than would be an application developer.</li>\n</ul>\n<p>Anything i\u2019m missing?</p>\n<hr>\n<p>[0] 200 bytes is a slight over-estimation. The median vsize of transactions using a moving average over the past 1000 days is about 189 vbytes according to <a href=\"https://transactionfee.info/charts/transactions-sizes\">transactionfee.info</a>. Calculation assumes a 260 bytes coinbase transaction, not compressed. In the worst case the proof is <code>80 + 14*32 + 200 = 728</code> without the coinbase vs <code>80 + 2*14*32 + 200 + 260 = 1436</code> with. In the modern average case under the same assumption the proof is <code>80 + 11*32 + 200 = 1244</code> without the coinbase vs <code>80 + 2*11*32 + 200 + 260 = 632</code> with.</p>",
  "post_number": 41,
  "post_type": 1,
  "updated_at": "2024-09-03T16:06:05.301Z",
  "reply_count": 2,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 10,
  "readers_count": 9,
  "score": 27.0,
  "yours": false,
  "topic_id": 710,
  "topic_slug": "great-consensus-cleanup-revival",
  "topic_title": "Great Consensus Cleanup Revival",
  "topic_html_title": "Great Consensus Cleanup Revival",
  "category_id": 7,
  "display_username": "Antoine Poinsot",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "I see reasonable arguments on both sides. Thanks everyone for contributing those.\n\nTo evaluate whether to include it in a future Consensus Cleanup proposal, i'd like to weigh the remaining pros and cons of making 64 bytes transactions invalid through a soft fork. To do so i'll list the main pros and cons i can think of and/or were raised by others (notably Dave and Eric above). Then i'll try to make the best case for each position's arguments, and provide a rebuttal for some of the points presented when i can.\n\nPlease let me know if an argument (or rebuttal) is missing or could be better presented.\n\nHere are the pros:\n- Reduces the bandwidth of block inclusion proofs for transactions.\n- Eliminates potential risks when implementing an application that verifies such a proof.\n\nAnd the cons:\n- Introduces a non-obvious transaction validity rule.\n- Requires a soft fork.\n\nLet's try to make the best case for each argument, starting with the pros.\n\nThis change would allow merkle proofs to be ~50% smaller in both the worst and average cases for a typical 200 bytes transaction [0]. In addition it would remove a large footgun threatening anyone implementing software which needs to verify transaction merkle proofs. This concern is growing since, as network hashrate increases, the price of a fake inclusion proof using this method is decreasing compared to the price of mining an invalid block. This is in addition to the fact this method allows to fake any number of confirmations, compared to a single one by producing an invalid block.  Finally, it is important to not only consider lite clients. Proofs of inclusion of a transaction in a block are useful in other, existing or potential, applications. Examples include sidechains, or future Script changes which would allow to check a merkle proof directly in the interpreter.\n\nHere is a list of rebuttals to those specific points:\n- Looking at the worst case cost is not a valid way of judging efficiency gains.\n  - True. But the proof size reduction is (very) similar in the average case.\n- Hypothetical future consensus changes should not be taken into account for the purpose of this standalone fix. Because it's hard to weigh the benefit this usecase brings since we don't know whether it would ever exist, and simply because the fix could then be bundled with a future soft fork which enables this usecase.\n  - Sure. Other usecases than lite-client remain though, such as sidechains. It's also not hard to imagine a Bitcoin-related application could verify a block inclusion proof.\n\nNow, the cons.\n\nAll changes to consensus rules bear a cost. The proof size reduction and proof verifier simplification does not meet the bar to be considered as a soft fork. The proof size reduction seems large in proportion, but it's small in absolute: a few hundred bytes. In addition you need only one per block, so the efficiency improvement decreases quickly as you query proofs for more than one transaction per block. The implementation simplification is also not a given. It removes one non-obvious check to be performed by inclusion proofs verifiers by another that needs to be performed by all validating nodes, which introduces [consensus \"seam\"](https://groups.google.com/g/bitcoindev/c/CAfm7D5ppjo/m/kKD1x3gJCgAJ).\n\nAnd a list of rebuttals for those:\n- Part of the fixed cost of the soft fork itself is compensated by bundling this fix with others. The cost inherent to changing the consensus rules should be weighed against the benefits brought by all the fixes together.\n- It's true making 64 bytes transactions invalid introduces consensus \"seam\", but it's not clear how it's an issue. It's a simple and straightforward rule which adds virtually no cost for full nodes to check.\n- It's true that \"all transaction sizes that fit in a block are valid except for 64 bytes\" is surprising as a rule. But we can't equate this with \"actually merkle proofs for 64 bytes transactions are insecure and you need to be aware of this clever-yet-convoluted workaround of asking for a proof for the coinbase too\". In addition, we can generally expect protocol developers implementing a full node to be more aware of intricacies in the protocol than would be an application developer.\n\n\nAnything i'm missing?\n\n----\n\n[0] 200 bytes is a slight over-estimation. The median vsize of transactions using a moving average over the past 1000 days is about 189 vbytes according to [transactionfee.info](https://transactionfee.info/charts/transactions-sizes). Calculation assumes a 260 bytes coinbase transaction, not compressed. In the worst case the proof is `80 + 14*32 + 200 = 728` without the coinbase vs `80 + 2*14*32 + 200 + 260 = 1436` with. In the modern average case under the same assumption the proof is `80 + 11*32 + 200 = 1244` without the coinbase vs `80 + 2*11*32 + 200 + 260 = 632` with.",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 12,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "heart",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}