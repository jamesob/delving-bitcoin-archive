{
  "id": 3240,
  "name": "ZmnSCPxj jxPCSnmZ",
  "username": "ZmnSCPxj",
  "avatar_template": "/letter_avatar_proxy/v4/letter/z/ee7513/{size}.png",
  "created_at": "2024-09-20T22:42:45.372Z",
  "cooked": "<h1><a name=\"p-3240-addendum-channel-funding-has-been-achieved-internally-via-op_cat-1\" class=\"anchor\" href=\"#p-3240-addendum-channel-funding-has-been-achieved-internally-via-op_cat-1\"></a>Addendum: Channel Funding Has Been Achieved Internally (via <code>OP_CAT</code>)</h1>\n<p><em><strong>WARNING</strong></em> This addendum requires a blockchain layer change, which\n<em><strong>violates the second constraint</strong></em> noted above.\nHowever, it has the major advantage that it requires only the client\nthat needs inbound liquidity to come online, and allows the LSP to\nuse up to half the funds in the leaf node with that client to new\ninbound liquidity to that client.</p>\n<p>Let us focus on the <code>A</code> <code>B</code> leaf node:</p>\n<pre><code>nSequence\n  +---+---+\n  |   |A&amp;L| LN channel\n  |   +---+\n  |432|B&amp;L| LN channel\n  |   +---+\n  |   | L |\n  +---+---+\n</code></pre>\n<p>Now, suppose <code>A</code> is online and in need of inbound liquidity, but\n<code>B</code> does not come online.\nWhat can the LSP <code>L</code> do?</p>\n<p>The LSP <code>L</code> can spend directly from the <code>L</code> output and fund a new\n<code>A</code>-<code>L</code> channel:</p>\n<pre><code>nSequence\n  +---+---+\n  |   |A&amp;L| LN channel\n  |   +---+\n  |432|B&amp;L| LN channel\n  |   +---+\n  |   | L |-+ +--+---+\n  +---+---+ | |  |A&amp;L| LN channel\n            +&gt;|  +---+\n              |  | L |\n              +--+---+\n</code></pre>\n<p>That is, we can have additional channel funding be achieved\n<em>internally</em> to the mechanism, instead of <em>externally</em> onchain.</p>\n<p>Of course, the problem is that the LSP can double-spend the above\ntransaction;\nthe tree is kept offchain, and the new transaction depends on the\ntree, and the LSP, being the sole signatory of that transaction,\ncan change the transaction freely.\nThus, <code>A</code> MUST NOT accept the above unless it trusts the LSP.</p>\n<p>Can we remove this trust requirement?</p>\n<p>If we had a way to ensure the LSP can only sign a transaction\nspending the <code>L</code> output exactly once, then in fact, we <em>can</em>\nremove this trust.</p>\n<p>One example of ensuring that the LSP can only sign once (and that\nsigning for a different transaction is impossible) is to fix the\n<code>R</code> component of the signature.\nThis can be achieved by using <code>OP_CAT</code>; the LSP precommits to some\nfixed <code>R</code> signature component, and can only provide the <code>s</code> on the\nwitness stack.\nThen <code>OP_CAT</code> would concatenate <code>R</code> and <code>s</code> signature components\nto be fed to an <code>OP_CHECKSIG</code>.\nThe <code>s</code> would vary depending on the transaction being signed; if\nthe LSP signs more than one transaction, then anyone who has seen\ntwo signatures of two different transactions can extract the private\nkey <code>L</code> of the LSP.</p>\n<p>(A less overpowered and more focused opcode can be added to the\nbase layer, such as a bespoke <code>OP_CHECKSEPARATEDSIG</code> where the <code>R</code>\nand <code>s</code> components must be two separate stack items instead of\nconcatenated into a single stack item.\nThe important part is that the <code>L</code> output has a contract \u201cif the\nLSP signs multiple times with this output, then it leaks the\nprivate key to <code>L</code>\u201d, or what I shall call <code>1sign(L)</code> meaning the\nLSP can only generate a single signature of <code>L</code> without leaking.)</p>\n<h2><a name=\"p-3240-bonding-the-lsp-2\" class=\"anchor\" href=\"#p-3240-bonding-the-lsp-2\"></a>Bonding The LSP</h2>\n<p>Now, <code>1sign(L)</code> is not sufficient to prevent the LSP from cheating\nthe client <code>A</code>.\nIf <code>L</code> itself is not used anywhere else, knowledge of the private\nkey of <code>L</code> is valueless to <code>A</code>.</p>\n<p>The trick is that the LSP has <em>another</em> output, with condition\n<code>(L &amp; (A|B)) | (L &amp; CLTV)</code>, where the <code>CLTV</code> has the same lifetime\nas the timeout-tree-structured Decker-Wattenhofer factory.</p>\n<pre><code>         nSequence\n           +---+--------+\n           |   |   A&amp;L  | LN channel\n           |   +--------+\noffchain -&gt;|432|   B&amp;L  | LN channel\n  tree     |   +--------+\n           |   |1sign(L)| liquidity stock\n           +---+--------+\n\n           ----+---------+\n               |(L&amp;(A|B))| Bond\nonchain -&gt;     ||(L&amp;CLTV)|\n           ----+---------+\n</code></pre>\n<p>Suppose <code>A</code> needs inbound liquidity but <code>B</code> is offline.\nIn that case, instead of recreating the leaf node and moving\nthe funds in the liquidity stock to the existing <code>A</code>-<code>L</code> channel,\nthe LSP can provide a signature spending the liquidity stock,\nfunding a second LN channel with <code>A</code>:</p>\n<pre><code>         nSequence\n           +---+--------+\n           |   |   A&amp;L  | LN channel\n           |   +--------+\noffchain -&gt;|432|   B&amp;L  | LN channel\n  tree     |   +--------+\n           |   |1sign(L)| -+ +--+--------+\n           +---+--------+  | |  |   A&amp;L  | LN channel again\n                           +&gt;|  +--------+\n                             |  |1sign(L)| liquidity stock\n                             +--+--------+\n\n           ----+---------+\n               |(L&amp;(A|B))| Bond\nonchain -&gt;     ||(L&amp;CLTV)|\n           ----+---------+\n</code></pre>\n<p>If the LSP tries to cheat <code>A</code> by publishing the leaf and <em>then</em>\nsigning a new version of the channel funding transaction of the\nsecond <code>A</code>-<code>L</code> channel, then <code>A</code> will learn the private key to\n<code>L</code>.\nThe condition <code>(L &amp; (A | B))</code> would then let the client <code>A</code>\nclaw back the bond output.</p>\n<p>The only condition is that the bond amount must be equal to the\ninitial <code>1sign(L)</code> liquidity stock amount.\nThis condition ensures that the most that <code>A</code> can lose would\nbe a channel that contains the <em>entire</em> liquidity stock amount.\nIf the bond is equal to that potential loss, then even if the\nLSP attempts to steal the entire channel content, it would\nstill lose an amount (the bond amount, which is equal to the\nliquidity stock amount, which is the largest channel it can\nprovide to <code>A</code> without waking up other clients) equal to what\nit stole, thus having 0 net earnings from the theft attempt\n(and probably losses due to onchain fees, if the LSP pays some\nof the onchain fees when the tree is published onchain).</p>\n<h2><a name=\"p-3240-digression-channel-funding-not-splicing-3\" class=\"anchor\" href=\"#p-3240-digression-channel-funding-not-splicing-3\"></a>Digression: Channel <em>Funding</em> Not <em>Splicing</em></h2>\n<p>Note that the client and the LSP still have to handle two\nchannels.\nBoth channels are internal to the timeout-tree-structured\nDecker-Wattenhofer channel factory, but are still two separate\nchannels, with separate, independent state machines.</p>\n<p>This is complicated because we can enter degenerate cases\nwhere an HTLC is to be forwarded to the client, which is too\nlarge to fit in either channel, but the inbound liquidity of\nboth channels, in total, could fit the HTLC being forwarded.\nIn that case, we would need to implement \u201clocal multipath\u201d,\nfirst proposed by Lightning Labs 7 years ago but which has\nno code or spec yet, wherein the LSP and client locally\nagree to split the HTLC being forwarded.</p>\n<p>We might now be tempted to consider a channel splice\n<em>internal</em> to the tree, like so:</p>\n<pre><code>         nSequence\n           +---+--------+\n           |   |   A&amp;L  | ------------+\n           |   +--------+             |\noffchain -&gt;|432|   B&amp;L  | LN channel  |\n  tree     |   +--------+             |\n           |   |1sign(L)| -+          | +--+--------+\n           +---+--------+  |          +&gt;|  |   A&amp;L  | LN channel\n                           |            |--+--------+\n                           +-----------&gt;|  |1sign(L)| liquidity stock\n                                        +--+--------+\n\n           ----+---------+\n               |(L&amp;(A|B))| Bond\nonchain -&gt;     ||(L&amp;CLTV)|\n           ----+---------+\n</code></pre>\n<p>The problem with the above is that the bond amout must\nnow be larger.\nYou see, part of the splicing flow is that any channel state\nthat spends from the pre-splice output <em>MUST</em> be invalidated.\nThus, if the LSP were to double-spend the first <code>1sign(L)</code>\noutput, it could also cause the client <code>A</code> to lose the funds\nequal to the first channel (it would not be able to <em>steal</em> it,\nbut it could also do this just to hurt the client <code>A</code> for\nnon-economic reasons, such as capitulating to political\npressure).\nTo prevent this, the bond amount <em>MUST</em> be large enough to\nrecompense the client <code>A</code> for the <em>total</em> channel size.\nThus, the bond amount must be the larger of the <code>A</code>-<code>L</code> and\n<code>B</code>-<code>L</code> channels, <em>plus</em> the liquidity stock, in the initial\nstate of the leaf node.</p>\n<p>Due to the bond amount being larger, this represents a greater\ncost: after all, if instead of implementing SuperScalar, the\nLSP just did LN routing as a published node, it would have\nearned from just having plain published LN channels, at no\nrisk of implementing new code for this novel scheme.\nThus, the bond amount being larger represents a cost on the\nLSP, which the LSP will pass to the clients.</p>\n<p>Thus, we <em>fund</em> channels internally to the mechanism, we\n<strong>do not</strong> splice channels internally.</p>\n<h2><a name=\"p-3240-internalized-bondage-4\" class=\"anchor\" href=\"#p-3240-internalized-bondage-4\"></a>Internalized Bondage</h2>\n<p>Whoever said that the bond output had to be <em>onchain</em>, like\nthe above diagrams showed?\nI never did actually tell you that it had to be onchain.\n(Tell, Do Not Show principle of misleading your readers for\nfun and profit)</p>\n<p>The only requirement is that the bond output <em>exist</em> when the\nleaf node liquidity stock output is published onchain.</p>\n<p>And we can do that by putting the bond output on the leaf\nnode itself:</p>\n<pre><code>         nSequence\n           +---+---------+\n           |   |   A&amp;L   | LN channel\n           |   +---------+\n           |   |   B&amp;L   | LN channel\noffchain -&gt;|432+---------+\n  tree     |   |1sign(L) | liquidity stock\n           |   +---------+\n           |   |(L&amp;(A|B))| Bond\n           |   ||(L&amp;CLTV)|\n           +---+---------+\n</code></pre>\n<p>This results in an <em>internalized</em> bond output.</p>\n<p>Of note is that the LSP can only claw back the channel funding\nif the leaf node, and all nodes in the tree leading to the\nleaf node, are published onchain.\nWhen the leaf node is published, then the bond is also\npublished.\nIf the LSP then claws back the channel funding for the second\n<code>A</code>-<code>L</code> channel, then client <code>A</code> can now take the bonded funds.</p>\n<p>Now, we must have the rule that the liquidity stock and the\nbond must be equal on every version of the leaf node.</p>\n<p>Let us provide a more concrete example.\nIn the below, the numbers indicate some abstract units of\nmoney:</p>\n<pre><code>         nSequence\n           +---+---------+\n           |   |   A&amp;L   | 10\n           |   +---------+\n           |   |   B&amp;L   | 10\noffchain -&gt;|432+---------+\n  tree     |   |1sign(L) | 4\n           |   +---------+\n           |   |(L&amp;(A|B))| 4\n           |   ||(L&amp;CLTV)|\n           +---+---------+\n</code></pre>\n<p>Suppose that <code>A</code> runs out of inbound liquidity, and buys\n4 units of liquidity from the LSP.\nHowever, <code>B</code> is not online.\nThe LSP can just create the below funding transaction, by\nitself, without <code>B</code>, with the bond output ensuring that it\nwill not cheat <code>A</code> later:</p>\n<pre><code>         nSequence\n           +---+---------+\n           |   |   A&amp;L   | 10\n           |   +---------+\n           |   |   B&amp;L   | 10 \noffchain -&gt;|432+---------+      +--+-----+\n  tree     |   |1sign(L) | 4 --&gt;|  | A&amp;L | 4\n           |   +---------+      +--+-----+\n           |   |(L&amp;(A|B))| 4\n           |   ||(L&amp;CLTV)|\n           +---+---------+\n</code></pre>\n<p>Now <code>A</code> and the LSP go on their merry way and continue\ntransacting offchain.</p>\n<p>Now suppose <code>B</code> now comes online, while <code>A</code> is also online.\nThen the LSP can now start a new state, with a lower\n<code>nSequence</code>, and then <em>redistribute the bond amount</em>:</p>\n<pre><code>         nSequence\n           +---+---------+\n           |   |   A&amp;L   | 14\n           |   +---------+\n           |   |   B&amp;L   | 10 \noffchain -&gt;|288+---------+\n  tree     |   |1sign(L) | 2\n           |   +---------+\n           |   |(L&amp;(A|B))| 2\n           |   ||(L&amp;CLTV)|\n           +---+---------+\n</code></pre>\n<p>This has a lower <code>nSequence</code> and is thus expected to confirm\nbefore the previous state, thus invalidating the previous\nleaf state node.\nBecause this invalidates the previous state, it is safe to\nhave a smaller bond output of only 2 units this time,\nbecause the previous state, where 4 units of money are at\nrisk and need to be protected by a 4-unit bond, has been\ncompletely invalidated.</p>\n<p>Then, even if <code>A</code> or <code>B</code> are offline, and the other client\nneeds inbound liquidity, the LSP can offer up to 2 units of\nfunding for inbound liquidity to the client that is online.</p>\n<p>If <em>both</em> <code>A</code> and <code>B</code> are online, and one of them needs\ninbound liquidity, the LSP can offer the total of 4 for\ninbound liquidity.\nThis is because the bond only needs to protect the case where\none of the clients is offline.</p>\n<p>Thus, putting the bond internally to the leaf, and thus also\npart of and modifiable by the leaf state, allows:</p>\n<ul>\n<li>If <em>all</em> clients in the leaf are <em>online</em>, the entire\nLSP-owned liquidity stock can be offered by the LSP for\ninbound liquidity needs of clients.</li>\n<li>If <em>any</em> client in the leaf is <em>offline</em>, up to <em>half</em>\nthe LSP-owned liquidity stock can be offered by the LSP\nfor inbound liquidity needs of clients.</li>\n</ul>\n<p>Thus, this scheme, with internalized bondage, allows for a\nbetter graceful degradation: if the other clients in the\nleaf are offline, the LSP can offer up to half its stock\nfor inbound liquidity, and if all clients in the leaf are\nonline, the LSP can offer its entire stock for inbound\nliquidity.</p>\n<p>Pity it needs a blockchain consensus change, which will\nnever happen.</p>",
  "post_number": 10,
  "post_type": 1,
  "updated_at": "2024-09-20T22:42:45.372Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 8,
  "reads": 2,
  "readers_count": 1,
  "score": 40.4,
  "yours": false,
  "topic_id": 1143,
  "topic_slug": "superscalar-laddered-timeout-tree-structured-decker-wattenhofer-factories",
  "topic_title": "SuperScalar: Laddered Timeout-Tree-Structured Decker-Wattenhofer Factories",
  "topic_html_title": "SuperScalar: Laddered Timeout-Tree-Structured Decker-Wattenhofer Factories",
  "category_id": 7,
  "display_username": "ZmnSCPxj jxPCSnmZ",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Addendum: Channel Funding Has Been Achieved Internally (via `OP_CAT`)\n=====================================================================\n\n***WARNING*** This addendum requires a blockchain layer change, which\n***violates the second constraint*** noted above.\nHowever, it has the major advantage that it requires only the client\nthat needs inbound liquidity to come online, and allows the LSP to\nuse up to half the funds in the leaf node with that client to new\ninbound liquidity to that client.\n\nLet us focus on the `A` `B` leaf node:\n\n    nSequence\n      +---+---+\n      |   |A&L| LN channel\n      |   +---+\n      |432|B&L| LN channel\n      |   +---+\n      |   | L |\n      +---+---+\n\nNow, suppose `A` is online and in need of inbound liquidity, but\n`B` does not come online.\nWhat can the LSP `L` do?\n\nThe LSP `L` can spend directly from the `L` output and fund a new\n`A`-`L` channel:\n\n    nSequence\n      +---+---+\n      |   |A&L| LN channel\n      |   +---+\n      |432|B&L| LN channel\n      |   +---+\n      |   | L |-+ +--+---+\n      +---+---+ | |  |A&L| LN channel\n                +>|  +---+\n                  |  | L |\n                  +--+---+\n\nThat is, we can have additional channel funding be achieved\n*internally* to the mechanism, instead of *externally* onchain.\n\nOf course, the problem is that the LSP can double-spend the above\ntransaction;\nthe tree is kept offchain, and the new transaction depends on the\ntree, and the LSP, being the sole signatory of that transaction,\ncan change the transaction freely.\nThus, `A` MUST NOT accept the above unless it trusts the LSP.\n\nCan we remove this trust requirement?\n\nIf we had a way to ensure the LSP can only sign a transaction\nspending the `L` output exactly once, then in fact, we *can*\nremove this trust.\n\nOne example of ensuring that the LSP can only sign once (and that\nsigning for a different transaction is impossible) is to fix the\n`R` component of the signature.\nThis can be achieved by using `OP_CAT`; the LSP precommits to some\nfixed `R` signature component, and can only provide the `s` on the\nwitness stack.\nThen `OP_CAT` would concatenate `R` and `s` signature components\nto be fed to an `OP_CHECKSIG`.\nThe `s` would vary depending on the transaction being signed; if\nthe LSP signs more than one transaction, then anyone who has seen\ntwo signatures of two different transactions can extract the private\nkey `L` of the LSP.\n\n(A less overpowered and more focused opcode can be added to the\nbase layer, such as a bespoke `OP_CHECKSEPARATEDSIG` where the `R`\nand `s` components must be two separate stack items instead of\nconcatenated into a single stack item.\nThe important part is that the `L` output has a contract \"if the\nLSP signs multiple times with this output, then it leaks the\nprivate key to `L`\", or what I shall call `1sign(L)` meaning the\nLSP can only generate a single signature of `L` without leaking.)\n\nBonding The LSP\n---------------\n\nNow, `1sign(L)` is not sufficient to prevent the LSP from cheating\nthe client `A`.\nIf `L` itself is not used anywhere else, knowledge of the private\nkey of `L` is valueless to `A`.\n\nThe trick is that the LSP has *another* output, with condition\n`(L & (A|B)) | (L & CLTV)`, where the `CLTV` has the same lifetime\nas the timeout-tree-structured Decker-Wattenhofer factory.\n\n             nSequence\n               +---+--------+\n               |   |   A&L  | LN channel\n               |   +--------+\n    offchain ->|432|   B&L  | LN channel\n      tree     |   +--------+\n               |   |1sign(L)| liquidity stock\n               +---+--------+\n\n               ----+---------+\n                   |(L&(A|B))| Bond\n    onchain ->     ||(L&CLTV)|\n               ----+---------+\n\nSuppose `A` needs inbound liquidity but `B` is offline.\nIn that case, instead of recreating the leaf node and moving\nthe funds in the liquidity stock to the existing `A`-`L` channel,\nthe LSP can provide a signature spending the liquidity stock,\nfunding a second LN channel with `A`:\n\n             nSequence\n               +---+--------+\n               |   |   A&L  | LN channel\n               |   +--------+\n    offchain ->|432|   B&L  | LN channel\n      tree     |   +--------+\n               |   |1sign(L)| -+ +--+--------+\n               +---+--------+  | |  |   A&L  | LN channel again\n                               +>|  +--------+\n                                 |  |1sign(L)| liquidity stock\n                                 +--+--------+\n\n               ----+---------+\n                   |(L&(A|B))| Bond\n    onchain ->     ||(L&CLTV)|\n               ----+---------+\n\nIf the LSP tries to cheat `A` by publishing the leaf and *then*\nsigning a new version of the channel funding transaction of the\nsecond `A`-`L` channel, then `A` will learn the private key to\n`L`.\nThe condition `(L & (A | B))` would then let the client `A`\nclaw back the bond output.\n\nThe only condition is that the bond amount must be equal to the\ninitial `1sign(L)` liquidity stock amount.\nThis condition ensures that the most that `A` can lose would\nbe a channel that contains the *entire* liquidity stock amount.\nIf the bond is equal to that potential loss, then even if the\nLSP attempts to steal the entire channel content, it would\nstill lose an amount (the bond amount, which is equal to the\nliquidity stock amount, which is the largest channel it can\nprovide to `A` without waking up other clients) equal to what\nit stole, thus having 0 net earnings from the theft attempt\n(and probably losses due to onchain fees, if the LSP pays some\nof the onchain fees when the tree is published onchain).\n\nDigression: Channel *Funding* Not *Splicing*\n--------------------------------------------\n\nNote that the client and the LSP still have to handle two\nchannels.\nBoth channels are internal to the timeout-tree-structured\nDecker-Wattenhofer channel factory, but are still two separate\nchannels, with separate, independent state machines.\n\nThis is complicated because we can enter degenerate cases\nwhere an HTLC is to be forwarded to the client, which is too\nlarge to fit in either channel, but the inbound liquidity of\nboth channels, in total, could fit the HTLC being forwarded.\nIn that case, we would need to implement \"local multipath\",\nfirst proposed by Lightning Labs 7 years ago but which has\nno code or spec yet, wherein the LSP and client locally\nagree to split the HTLC being forwarded.\n\nWe might now be tempted to consider a channel splice\n*internal* to the tree, like so:\n\n             nSequence\n               +---+--------+\n               |   |   A&L  | ------------+\n               |   +--------+             |\n    offchain ->|432|   B&L  | LN channel  |\n      tree     |   +--------+             |\n               |   |1sign(L)| -+          | +--+--------+\n               +---+--------+  |          +>|  |   A&L  | LN channel\n                               |            |--+--------+\n                               +----------->|  |1sign(L)| liquidity stock\n                                            +--+--------+\n\n               ----+---------+\n                   |(L&(A|B))| Bond\n    onchain ->     ||(L&CLTV)|\n               ----+---------+\n\nThe problem with the above is that the bond amout must\nnow be larger.\nYou see, part of the splicing flow is that any channel state\nthat spends from the pre-splice output *MUST* be invalidated.\nThus, if the LSP were to double-spend the first `1sign(L)`\noutput, it could also cause the client `A` to lose the funds\nequal to the first channel (it would not be able to *steal* it,\nbut it could also do this just to hurt the client `A` for\nnon-economic reasons, such as capitulating to political\npressure).\nTo prevent this, the bond amount *MUST* be large enough to\nrecompense the client `A` for the *total* channel size.\nThus, the bond amount must be the larger of the `A`-`L` and\n`B`-`L` channels, *plus* the liquidity stock, in the initial\nstate of the leaf node.\n\nDue to the bond amount being larger, this represents a greater\ncost: after all, if instead of implementing SuperScalar, the\nLSP just did LN routing as a published node, it would have\nearned from just having plain published LN channels, at no\nrisk of implementing new code for this novel scheme.\nThus, the bond amount being larger represents a cost on the\nLSP, which the LSP will pass to the clients.\n\nThus, we *fund* channels internally to the mechanism, we\n**do not** splice channels internally.\n\nInternalized Bondage\n--------------------\n\nWhoever said that the bond output had to be *onchain*, like\nthe above diagrams showed?\nI never did actually tell you that it had to be onchain.\n(Tell, Do Not Show principle of misleading your readers for\nfun and profit)\n\nThe only requirement is that the bond output *exist* when the\nleaf node liquidity stock output is published onchain.\n\nAnd we can do that by putting the bond output on the leaf\nnode itself:\n\n             nSequence\n               +---+---------+\n               |   |   A&L   | LN channel\n               |   +---------+\n               |   |   B&L   | LN channel\n    offchain ->|432+---------+\n      tree     |   |1sign(L) | liquidity stock\n               |   +---------+\n               |   |(L&(A|B))| Bond\n               |   ||(L&CLTV)|\n               +---+---------+\n\nThis results in an *internalized* bond output.\n\nOf note is that the LSP can only claw back the channel funding\nif the leaf node, and all nodes in the tree leading to the\nleaf node, are published onchain.\nWhen the leaf node is published, then the bond is also\npublished.\nIf the LSP then claws back the channel funding for the second\n`A`-`L` channel, then client `A` can now take the bonded funds.\n\nNow, we must have the rule that the liquidity stock and the\nbond must be equal on every version of the leaf node.\n\nLet us provide a more concrete example.\nIn the below, the numbers indicate some abstract units of\nmoney:\n\n             nSequence\n               +---+---------+\n               |   |   A&L   | 10\n               |   +---------+\n               |   |   B&L   | 10\n    offchain ->|432+---------+\n      tree     |   |1sign(L) | 4\n               |   +---------+\n               |   |(L&(A|B))| 4\n               |   ||(L&CLTV)|\n               +---+---------+\n\nSuppose that `A` runs out of inbound liquidity, and buys\n4 units of liquidity from the LSP.\nHowever, `B` is not online.\nThe LSP can just create the below funding transaction, by\nitself, without `B`, with the bond output ensuring that it\nwill not cheat `A` later:\n\n             nSequence\n               +---+---------+\n               |   |   A&L   | 10\n               |   +---------+\n               |   |   B&L   | 10 \n    offchain ->|432+---------+      +--+-----+\n      tree     |   |1sign(L) | 4 -->|  | A&L | 4\n               |   +---------+      +--+-----+\n               |   |(L&(A|B))| 4\n               |   ||(L&CLTV)|\n               +---+---------+\n\nNow `A` and the LSP go on their merry way and continue\ntransacting offchain.\n\nNow suppose `B` now comes online, while `A` is also online.\nThen the LSP can now start a new state, with a lower\n`nSequence`, and then *redistribute the bond amount*:\n\n             nSequence\n               +---+---------+\n               |   |   A&L   | 14\n               |   +---------+\n               |   |   B&L   | 10 \n    offchain ->|288+---------+\n      tree     |   |1sign(L) | 2\n               |   +---------+\n               |   |(L&(A|B))| 2\n               |   ||(L&CLTV)|\n               +---+---------+\n\nThis has a lower `nSequence` and is thus expected to confirm\nbefore the previous state, thus invalidating the previous\nleaf state node.\nBecause this invalidates the previous state, it is safe to\nhave a smaller bond output of only 2 units this time,\nbecause the previous state, where 4 units of money are at\nrisk and need to be protected by a 4-unit bond, has been\ncompletely invalidated.\n\nThen, even if `A` or `B` are offline, and the other client\nneeds inbound liquidity, the LSP can offer up to 2 units of\nfunding for inbound liquidity to the client that is online.\n\nIf *both* `A` and `B` are online, and one of them needs\ninbound liquidity, the LSP can offer the total of 4 for\ninbound liquidity.\nThis is because the bond only needs to protect the case where\none of the clients is offline.\n\nThus, putting the bond internally to the leaf, and thus also\npart of and modifiable by the leaf state, allows:\n\n* If *all* clients in the leaf are *online*, the entire\n  LSP-owned liquidity stock can be offered by the LSP for\n  inbound liquidity needs of clients.\n* If *any* client in the leaf is *offline*, up to *half*\n  the LSP-owned liquidity stock can be offered by the LSP\n  for inbound liquidity needs of clients.\n\nThus, this scheme, with internalized bondage, allows for a\nbetter graceful degradation: if the other clients in the\nleaf are offline, the LSP can offer up to half its stock\nfor inbound liquidity, and if all clients in the leaf are\nonline, the LSP can offer its entire stock for inbound\nliquidity.\n\nPity it needs a blockchain consensus change, which will\nnever happen.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 104,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}