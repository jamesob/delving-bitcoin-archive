{
  "id": 3104,
  "name": "rob",
  "username": "rustaceanrob",
  "avatar_template": "/user_avatar/delvingbitcoin.org/rustaceanrob/{size}/443_2.png",
  "created_at": "2024-09-05T18:13:42.088Z",
  "cooked": "<p>Hi folks. I am posting a draft proposal to attempt to improve the wallet recovery experience for users or their heirs.</p>\n<p>TLDR: I am worried an heir will have to copy-paste descriptors from a <code>txt</code> or <code>json</code> into future wallet software. Ideally, heirs may simply drag-and-drop a file into future wallet software and be assured all relevant data that encapsulates a wallet is present. This file should also store metadata, like where signers may be located, or a height to start searching for outputs.</p>\n<p>I know that reading a file format specification may not be very exciting, but I am hoping to gather feedback and ultimately improve recovery for the community. The specification is outlined below, and I also have a <a href=\"https://github.com/rustaceanrob/wdef\" rel=\"noopener nofollow ugc\">reference implementation in Rust</a> to experiment with. Any feedback is greatly appreciated!</p>\n<h3><a name=\"p-3104-motivation-1\" class=\"anchor\" href=\"#p-3104-motivation-1\"></a>Motivation</h3>\n<p>The purpose of a standarized file format is to decrease the chance of loss of funds in the case of wallet recovery or inheritance. BIP32 seed phrases are not sufficient information to recover funds if multiple signers are used, a non-standard derivation path is used, or if the recoverer does not know what to do with such seed phrase. Moreover, seed phrases must be entered into a device to recover wallet public keys. Output descriptors alleviate these issues, however the process of storing, exporting, and sharing descriptors is currently determined by users. A unified file format allows for \u201cone-click\u201d backups and recoveries for descriptor-based bitcoin wallets, transferring the responsibilities of handling descriptors from users to software.</p>\n<p>Output descriptors are often exported, shared, and stored in <code>.txt</code> files, but other formats such as JSON are also used. This discrepancy causes developer burden, and varying formats cause uncertainty of support for parsing such data in future wallet software. If descriptor parsing from a <code>txt</code> or <code>json</code> file fails, it is up to the heir or recoverer to resolve the problem. A unifed file format for importing and exporting descriptors not only decreases developer burden, but allows for a higher degree of certainty that an heir will not have to manually \u201ccopy and paste\u201d descriptors into future software. Files are portable, duplicable, and easily parsed by most devices. Files may also be encrypted and safely shared with attorneys, business partners, or other semi-trusted entities.</p>\n<p>Futher still, metadata about the descriptors, such as the name of the wallet, a description of its uses, where to start scanning for ouputs, and additional information to recover signers are either encoded as a comment in the <code>.txt</code>, introducing difficulty for software to parse reliably, or fields in a JSON, introducing forward-compatiblity concerns for future wallet software. These fields are easily encoded and decoded with a standard format.</p>\n<h3><a name=\"p-3104-definitions-2\" class=\"anchor\" href=\"#p-3104-definitions-2\"></a>Definitions</h3>\n<p><em>descriptor</em>, shorthand for \u201coutput descriptor.\u201d</p>\n<p><code>||</code> denotes the concatenation of two elements.</p>\n<p><code>[]bytes</code> represents a variable array of bytes.</p>\n<p><code>[N]bytes</code> represents an array of <code>N</code> bytes.</p>\n<p><code>Record</code> is an entry in an import.</p>\n<p><code>Import</code> an entry in the file that describes metadata and associated descriptors.</p>\n<h3><a name=\"p-3104-specification-3\" class=\"anchor\" href=\"#p-3104-specification-3\"></a>Specification</h3>\n<h4><a name=\"p-3104-record-4\" class=\"anchor\" href=\"#p-3104-record-4\"></a><code>Record</code></h4>\n<p>Information is stored in a WDEF file in the form of <code>Record</code>s. A <code>Record</code> is a tuple of a <code>Type</code>, <code>Length</code>, and <code>Value</code>, followed by a 4 byte checksum. Every WDEF file is prefixed with a single byte representing the number of records in the file. A record type is represented as a byte, with possible types listed below:</p>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th>Record Type (<code>Type</code>)</th>\n<th>Value (<code>u8</code>)</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Name</td>\n<td>0x00</td>\n<td>The name of the wallet in the file</td>\n</tr>\n<tr>\n<td>Description</td>\n<td>0x01</td>\n<td>Summary of this wallet\u2019s use(s)</td>\n</tr>\n<tr>\n<td>Info</td>\n<td>0x02</td>\n<td>Any additional information to recover funds</td>\n</tr>\n<tr>\n<td>RecoveryHeight</td>\n<td>0x03</td>\n<td>Height in the blockchain this wallet began to receive and send payments</td>\n</tr>\n<tr>\n<td>ExternalDescriptor</td>\n<td>0x04</td>\n<td>A descriptor that is used to receive bitcoins. Encodes public keys and cannot spend bitcoins</td>\n</tr>\n<tr>\n<td>InternalDescriptor</td>\n<td>0x05</td>\n<td>A descriptor that is used to generate change outputs when spending bitcoins. Encodes public keys and cannot spend bitcoins</td>\n</tr>\n<tr>\n<td>MultipathDescriptor</td>\n<td>0x06</td>\n<td>A descriptor that encodes multiple paths to unique descriptors.</td>\n</tr>\n</tbody>\n</table>\n</div><p>A <code>Length</code> is a 16-bit number represented as bytes in <em>little endian</em>. The length represents the number of bytes in the value encoding that follows.</p>\n<p><code>Name</code>, <code>Description</code>, <code>Info</code>, <code>ExternalDescriptor</code>, <code>InternalDescriptor</code>, and <code>MultipathDescriptor</code> are all represented as strings and encoded as the UTF-8 byte array\nfor such a string representation. <code>RecoveryHeight</code>s are represented as a 4 byte <em>little endian</em> array representation.</p>\n<p>The checksum for a <code>Record</code> is calculated by <code>SHA256( Type || Value )</code> and taking the first four bytes of the resulting hash.</p>\n<p>A <code>Record</code> is completely defined as:</p>\n<ul>\n<li><code>Type</code>: <code>[1]bytes</code> ID</li>\n<li><code>Length</code>: <code>[2]bytes</code> <em>little endian</em> value representing the length of the next field</li>\n<li><code>Value</code>: <code>[]bytes</code> variable length contents representing the record type, often a UTF-8 encoded string</li>\n<li><code>Checksum</code>: <code>[4]bytes</code> a commitment to the record type and record value</li>\n</ul>\n<h4><a name=\"p-3104-import-5\" class=\"anchor\" href=\"#p-3104-import-5\"></a><code>Import</code></h4>\n<p>An <code>Import</code> is simply a structured list of <code>Record</code>s. An import contains a single byte that represents the count of <code>Record</code>s in the file, followed by the <code>Record</code>s. All <code>Import</code>s must adhere to these requirements, or the file is invalid:</p>\n<ul>\n<li>A single <code>Name</code> is required.</li>\n<li>Any <code>Description</code> must be unique, but is not required.</li>\n<li>Any number of <code>Info</code> may be included.</li>\n<li>A <code>RecoveryHeight</code> may be provided, but is not required. The <code>RecoveryHeight</code> must be unique.</li>\n<li>Any number of <code>ExternalDescriptor</code>, <code>InternalDescriptor</code>, or <code>MultipathDescriptor</code> may be provided.</li>\n<li>At least one <code>ExternalDescriptor</code> or <code>MultipathDescriptor</code> must exist.</li>\n</ul>\n<p>An <code>Import</code> is encoded as:</p>\n<ul>\n<li><code>Length</code>: <code>[1]bytes</code> <em>little endian</em> integer representing the <code>Record</code> count</li>\n<li><code>Record</code>s: <code>[]bytes</code> the entries of the file.</li>\n</ul>\n<h4><a name=\"p-3104-file-prefix-6\" class=\"anchor\" href=\"#p-3104-file-prefix-6\"></a>File Prefix</h4>\n<p>Every WDEF file is prefixed with seven bytes of data that identifies the file: <code>0x00, 0x00, 0x00, 0x57, 0x44, 0x45, 0x46</code>. This data is followed by the protocol version, which is set to <code>0x00</code> for version one.</p>\n<h4><a name=\"p-3104-complete-structure-7\" class=\"anchor\" href=\"#p-3104-complete-structure-7\"></a>Complete Structure</h4>\n<ul>\n<li>File identifier: <code>0x00, 0x00, 0x00, 0x57, 0x44, 0x45, 0x46</code></li>\n<li><code>Version</code>: <code>[1]bytes</code></li>\n<li><code>Length</code>: <code>[1]bytes</code></li>\n<li><code>Record</code>s: <code>[]bytes</code></li>\n</ul>\n<h4><a name=\"p-3104-encoding-files-8\" class=\"anchor\" href=\"#p-3104-encoding-files-8\"></a>Encoding Files</h4>\n<p>First, the seven bytes of the file identifier and single verison byte are written to the file.</p>\n<p>Next, the number of records to be recorded in the file should be determined, and the byte representing the length is added to the serialization buffer. If the number of records cannot fit into an 8-bit unsigned integer, encoding fails.</p>\n<p>Next, each record is composed as <code>Type || Length || Value || Checksum</code>, and each array of bytes are concatinated together. Encoding fails if the <code>Length</code> cannot be represented as a 16-bit unsigned integer.</p>\n<p>If any of the <code>Import</code> requirements are violated, encoding fails.</p>\n<h4><a name=\"p-3104-decoding-files-9\" class=\"anchor\" href=\"#p-3104-decoding-files-9\"></a>Decoding Files</h4>\n<p>Read the first seven bytes of the file, failing the decoding if the file identifier does not match. Read the next byte and interpret it as the version. For versions greater than those supported by the software, decoding fails. All WDEF decoders must implement <code>0x00</code>.</p>\n<p>The next byte is read from the file and interpreted as the number of records. For each record in the record count:</p>\n<ol>\n<li>\n<p>Read and interpret the first byte as the <code>Type</code>. Decoding fails for unrecognized <code>Type</code> values.</p>\n</li>\n<li>\n<p>Read the next two bytes and interpret them as an 16-bit unsigned integer, denoted <code>L</code></p>\n</li>\n<li>\n<p>Read the next <code>L</code> bytes and parse into the desired representation. Decoding fails if the bytes cannot be parsed.</p>\n</li>\n<li>\n<p>Calculate the checksum using the <code>Value</code> and <code>Type</code></p>\n</li>\n<li>\n<p>Read the next 4 bytes and fail if the calculated and presented checksum do not match.</p>\n</li>\n<li>\n<p>For descriptors, parse the computed string and attempt to cast it to a descriptor that encodes public keys. Decoding fails for if the provided string cannot be cast to a public key descriptor.</p>\n</li>\n</ol>\n<p>After all the <code>Record</code>s have been collected, evalutate if the collection follows the rules for an <code>Import</code>. Decoding fails if a rule is violated.</p>\n<p>Files adhering to this standard should be postfixed with the <code>.wdef</code> extension.</p>\n<h3><a name=\"p-3104-rationale-10\" class=\"anchor\" href=\"#p-3104-rationale-10\"></a>Rationale</h3>\n<p>Descriptor <code>Value</code>s are represented strings for the following reasons:</p>\n<ol>\n<li>\n<p>Bitcoin Core supports parsing strings as descriptors within <code>bitcoin-cli</code>.</p>\n</li>\n<li>\n<p>UTF-8 encodings are an open standard with forwards compatability for new <code>Type</code>s.</p>\n</li>\n<li>\n<p>Most encoding logic may be shared for each <code>Type</code>.</p>\n</li>\n</ol>\n<p>The checksum is added to ensure that invalid <code>Record</code> encodings are discovered during decoding and file integrity is guaranteed when successfully parsing a WDEF file.</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2024-09-05T18:13:42.088Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 33,
  "reads": 13,
  "readers_count": 12,
  "score": 182.6,
  "yours": false,
  "topic_id": 1115,
  "topic_slug": "file-format-for-recovering-descriptor-wallets",
  "topic_title": "File Format for Recovering Descriptor Wallets",
  "topic_html_title": "File Format for Recovering Descriptor Wallets",
  "category_id": 7,
  "display_username": "rob",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Hi folks. I am posting a draft proposal to attempt to improve the wallet recovery experience for users or their heirs.\n\nTLDR: I am worried an heir will have to copy-paste descriptors from a `txt` or `json` into future wallet software. Ideally, heirs may simply drag-and-drop a file into future wallet software and be assured all relevant data that encapsulates a wallet is present. This file should also store metadata, like where signers may be located, or a height to start searching for outputs.\n\nI know that reading a file format specification may not be very exciting, but I am hoping to gather feedback and ultimately improve recovery for the community. The specification is outlined below, and I also have a [reference implementation in Rust](https://github.com/rustaceanrob/wdef) to experiment with. Any feedback is greatly appreciated!\n\n### Motivation\n\nThe purpose of a standarized file format is to decrease the chance of loss of funds in the case of wallet recovery or inheritance. BIP32 seed phrases are not sufficient information to recover funds if multiple signers are used, a non-standard derivation path is used, or if the recoverer does not know what to do with such seed phrase. Moreover, seed phrases must be entered into a device to recover wallet public keys. Output descriptors alleviate these issues, however the process of storing, exporting, and sharing descriptors is currently determined by users. A unified file format allows for \"one-click\" backups and recoveries for descriptor-based bitcoin wallets, transferring the responsibilities of handling descriptors from users to software.\n\nOutput descriptors are often exported, shared, and stored in `.txt` files, but other formats such as JSON are also used. This discrepancy causes developer burden, and varying formats cause uncertainty of support for parsing such data in future wallet software. If descriptor parsing from a `txt` or `json` file fails, it is up to the heir or recoverer to resolve the problem. A unifed file format for importing and exporting descriptors not only decreases developer burden, but allows for a higher degree of certainty that an heir will not have to manually \"copy and paste\" descriptors into future software. Files are portable, duplicable, and easily parsed by most devices. Files may also be encrypted and safely shared with attorneys, business partners, or other semi-trusted entities.\n\nFuther still, metadata about the descriptors, such as the name of the wallet, a description of its uses, where to start scanning for ouputs, and additional information to recover signers are either encoded as a comment in the `.txt`, introducing difficulty for software to parse reliably, or fields in a JSON, introducing forward-compatiblity concerns for future wallet software. These fields are easily encoded and decoded with a standard format.\n\n### Definitions\n\n_descriptor_, shorthand for \"output descriptor.\"\n\n`||` denotes the concatenation of two elements.\n\n`[]bytes` represents a variable array of bytes.\n\n`[N]bytes` represents an array of `N` bytes.\n\n`Record` is an entry in an import.\n\n`Import` an entry in the file that describes metadata and associated descriptors.\n\n\n### Specification\n\n#### `Record` \n\nInformation is stored in a WDEF file in the form of `Record`s. A `Record` is a tuple of a `Type`, `Length`, and `Value`, followed by a 4 byte checksum. Every WDEF file is prefixed with a single byte representing the number of records in the file. A record type is represented as a byte, with possible types listed below:\n\n| Record Type (`Type`) | Value (`u8`) | Description                        |\n| ------------------- | ---------- | ---------------------------------- |\n| Name | 0x00 | The name of the wallet in the file |\n| Description | 0x01 | Summary of this wallet's use(s) |\n| Info | 0x02 | Any additional information to recover funds |\n| RecoveryHeight | 0x03 | Height in the blockchain this wallet began to receive and send payments |\n| ExternalDescriptor | 0x04 | A descriptor that is used to receive bitcoins. Encodes public keys and cannot spend bitcoins |\n| InternalDescriptor | 0x05 | A descriptor that is used to generate change outputs when spending bitcoins. Encodes public keys and cannot spend bitcoins |\n| MultipathDescriptor | 0x06 | A descriptor that encodes multiple paths to unique descriptors. |\n\nA `Length` is a 16-bit number represented as bytes in _little endian_. The length represents the number of bytes in the value encoding that follows.\n\n`Name`, `Description`, `Info`, `ExternalDescriptor`, `InternalDescriptor`, and `MultipathDescriptor` are all represented as strings and encoded as the UTF-8 byte array\nfor such a string representation. `RecoveryHeight`s are represented as a 4 byte _little endian_ array representation.\n\nThe checksum for a `Record` is calculated by `SHA256( Type || Value )` and taking the first four bytes of the resulting hash.\n\nA `Record` is completely defined as:\n- `Type`: `[1]bytes` ID\n- `Length`: `[2]bytes` _little endian_ value representing the length of the next field\n- `Value`: `[]bytes` variable length contents representing the record type, often a UTF-8 encoded string\n- `Checksum`: `[4]bytes` a commitment to the record type and record value\n\n#### `Import`\n\nAn `Import` is simply a structured list of `Record`s. An import contains a single byte that represents the count of `Record`s in the file, followed by the `Record`s. All `Import`s must adhere to these requirements, or the file is invalid:\n\n- A single `Name` is required.\n- Any `Description` must be unique, but is not required.\n- Any number of `Info` may be included.\n- A `RecoveryHeight` may be provided, but is not required. The `RecoveryHeight` must be unique.\n- Any number of `ExternalDescriptor`, `InternalDescriptor`, or `MultipathDescriptor` may be provided.\n- At least one `ExternalDescriptor` or `MultipathDescriptor` must exist. \n\nAn `Import` is encoded as:\n- `Length`: `[1]bytes` _little endian_ integer representing the `Record` count\n- `Record`s: `[]bytes` the entries of the file.\n\n#### File Prefix\n\nEvery WDEF file is prefixed with seven bytes of data that identifies the file: `0x00, 0x00, 0x00, 0x57, 0x44, 0x45, 0x46`. This data is followed by the protocol version, which is set to `0x00` for version one.\n\n#### Complete Structure\n\n- File identifier: `0x00, 0x00, 0x00, 0x57, 0x44, 0x45, 0x46`\n- `Version`: `[1]bytes`\n- `Length`: `[1]bytes`\n- `Record`s: `[]bytes`\n\n#### Encoding Files\n\nFirst, the seven bytes of the file identifier and single verison byte are written to the file.\n\nNext, the number of records to be recorded in the file should be determined, and the byte representing the length is added to the serialization buffer. If the number of records cannot fit into an 8-bit unsigned integer, encoding fails.\n\nNext, each record is composed as `Type || Length || Value || Checksum`, and each array of bytes are concatinated together. Encoding fails if the `Length` cannot be represented as a 16-bit unsigned integer.\n\nIf any of the `Import` requirements are violated, encoding fails.\n\n#### Decoding Files\n\nRead the first seven bytes of the file, failing the decoding if the file identifier does not match. Read the next byte and interpret it as the version. For versions greater than those supported by the software, decoding fails. All WDEF decoders must implement `0x00`.\n\nThe next byte is read from the file and interpreted as the number of records. For each record in the record count:\n\n1. Read and interpret the first byte as the `Type`. Decoding fails for unrecognized `Type` values.\n\n2. Read the next two bytes and interpret them as an 16-bit unsigned integer, denoted `L`\n\n3. Read the next `L` bytes and parse into the desired representation. Decoding fails if the bytes cannot be parsed.\n\n4. Calculate the checksum using the `Value` and `Type`\n\n5. Read the next 4 bytes and fail if the calculated and presented checksum do not match.\n\n6. For descriptors, parse the computed string and attempt to cast it to a descriptor that encodes public keys. Decoding fails for if the provided string cannot be cast to a public key descriptor.\n\nAfter all the `Record`s have been collected, evalutate if the collection follows the rules for an `Import`. Decoding fails if a rule is violated.\n\nFiles adhering to this standard should be postfixed with the `.wdef` extension.\n\n### Rationale\n\nDescriptor `Value`s are represented strings for the following reasons:\n\n1. Bitcoin Core supports parsing strings as descriptors within `bitcoin-cli`.\n\n2. UTF-8 encodings are an open standard with forwards compatability for new `Type`s.\n\n3. Most encoding logic may be shared for each `Type`.\n\nThe checksum is added to ensure that invalid `Record` encodings are discovered during decoding and file integrity is guaranteed when successfully parsing a WDEF file.",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 360,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}