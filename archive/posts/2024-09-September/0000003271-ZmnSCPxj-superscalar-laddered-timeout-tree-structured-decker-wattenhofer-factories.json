{
  "id": 3271,
  "name": "ZmnSCPxj jxPCSnmZ",
  "username": "ZmnSCPxj",
  "avatar_template": "/letter_avatar_proxy/v4/letter/z/ee7513/{size}.png",
  "created_at": "2024-09-26T04:30:07.480Z",
  "cooked": "<p>Okay, some implementation notes.</p>\n<h2><a name=\"p-3271-tree-nodes-pay-fees-1\" class=\"anchor\" href=\"#p-3271-tree-nodes-pay-fees-1\"></a>Tree Nodes Pay Fees</h2>\n<p>Obviously <code>nVersion=3</code> &gt; <code>nVersion=2</code>. And we will soon be able to have transactions pay 0 fee and still propagate, as long as it has an attached child transaction that pays for it.</p>\n<p>However, for the implementation of SuperScalar, I intend that all tree nodes pay non-0 fee.</p>\n<p>The big issue with 0-fee transactions is that <strong>they require exogenous funds to pay for them</strong>.  And the goal of SuperScalar is to be able to onboard people, possibly people who do not have an existing UTXO they can use to pay exogenous fees.</p>\n<p>Thus, I propose that tree nodes pay a small amount of fees.  Because reaping a timeout tree means that the tree nodes will not exist and therefore will not pay the fees, the fees paid by tree nodes are recovered if the LSP reaps the UTXO without publishing the entire tree. The net effect is that <em><strong>tree node fees are default-paid by the LSP</strong></em>.  The result is that the tree has endogenous fees.</p>\n<p>As noted above, some tree nodes are state transactions that are modified.  When modifying a node, we reduce the <code>nSequence</code>.  In addition, we can <strong>also</strong> increase the feerate of that node.  Thus, even in a high feerate environment, we have a minor assurance that the latest state version is the one that is most likely to confirm.</p>\n<p>We can add P2A outputs to each tree node as well.  However, by itself it is unsafe.  Consider the following attack scenario:</p>\n<ul>\n<li>The LSP sells some inbound liquidity to a client within the SuperScalar mechanism.  The effect is that there are two version of a leaf node, one which has more funds in the LSP side.</li>\n<li>The client uses that inbound liquidity, such that loss of the channel capacity is loss of funds.</li>\n<li>The LSP waits for a high-fee period.</li>\n<li>The LSP initiates a unilateral exit for the victim client, confirming tree nodes until the parent of the leaf containing the victim.</li>\n<li>The client attempts to broadcast the latest leaf node, but because it has no external funds, it cannot feebump the latest leaf node above the prevailing confirmable rate.</li>\n<li>The LSP waits for the <em><strong>previous</strong></em> leaf node to be broadcastable (it has a later <code>nSequence</code> than the latest one) and attaches a higher feerate to it via the P2A output.</li>\n<li>The previous leaf node gets confirmed, the LSP claws back its funds, the client loses access to all its funds.</li>\n</ul>\n<p>The above inducts over every state transaction in the tree, thus we need to have state transactions without P2A outputs if we are worried about such an attack.</p>\n<p>To protect against this, we can observe:</p>\n<ul>\n<li>Within the SuperScalar mechanism, all state transfers are of the form:\n<ul>\n<li>fully owned by <code>L</code> \u2192 a channel between a client <code>A</code> and <code>L</code>.</li>\n<li>This is because the LSP sells inbound liquidity to clients.  The LSP wants to ensure that all sales are final, in that it never refunds inbound liquidity that has already been sold.</li>\n</ul>\n</li>\n</ul>\n<p>Within the SuperScalar mechanism, we do not intend to ever have the liquidity go back from the <code>A</code>-<code>L</code> channel to solely owned by <code>L</code> \u2014 as noted, once the LSP has sold some unit of inbound liquidity, it wants to <em><strong>not</strong></em> take back that liquidity and refund the client for the inbound liquidity.</p>\n<p>What we can thus do is to recognize that all <code>L</code>-owned funds are unidirectional, they will always go down.  So instead of having a \u201cplain\u201d <code>L</code> script, we can have the script <code>&lt;secret&gt; | L</code>.\nWhenever we invalidate a leaf node (and if we change a non-leaf node, we also invalidate all children down to the leaf nodes) the LSP shares the <code>&lt;secret&gt;</code> of every <code>L</code> liquidity stock output of the OLD version to each client that signs off on the change.  For the new version, the LSP generates a new secret for the <code>L</code> liquidity stock output.  This can use the same shachain mechanism we already use for Poon-Dryja BOLT Lightning channels.</p>\n<p>If the LSP uses the P2A output to confirm an older version during a high-fee environment, then the <code>L</code> outputs have an alternate <code>&lt;secret&gt;</code> path that the clients can use.  The clients can then retaliate by burning the <code>L</code> output to miner fees.  Thus, the LSP is incentivized to always ensure that the latest version of every state transaction gets confirmed before the older version can be broadcastable (because the clients also have a copy of the older version and can broadcast them for confirmation and subsequent burning of LSP funds).</p>\n<p>With this, we can have P2A on all tree nodes as well, and incentive for the LSP to always assist in confirming the latest version of a tree node if a client wants to unilaterally exit.</p>",
  "post_number": 13,
  "post_type": 1,
  "updated_at": "2024-09-26T04:30:47.207Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 1,
  "readers_count": 0,
  "score": 0.2,
  "yours": false,
  "topic_id": 1143,
  "topic_slug": "superscalar-laddered-timeout-tree-structured-decker-wattenhofer-factories",
  "topic_title": "SuperScalar: Laddered Timeout-Tree-Structured Decker-Wattenhofer Factories",
  "topic_html_title": "SuperScalar: Laddered Timeout-Tree-Structured Decker-Wattenhofer Factories",
  "category_id": 7,
  "display_username": "ZmnSCPxj jxPCSnmZ",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Okay, some implementation notes.\n\n## Tree Nodes Pay Fees\n\nObviously `nVersion=3` > `nVersion=2`. And we will soon be able to have transactions pay 0 fee and still propagate, as long as it has an attached child transaction that pays for it.\n\nHowever, for the implementation of SuperScalar, I intend that all tree nodes pay non-0 fee.\n\nThe big issue with 0-fee transactions is that **they require exogenous funds to pay for them**.  And the goal of SuperScalar is to be able to onboard people, possibly people who do not have an existing UTXO they can use to pay exogenous fees.\n\nThus, I propose that tree nodes pay a small amount of fees.  Because reaping a timeout tree means that the tree nodes will not exist and therefore will not pay the fees, the fees paid by tree nodes are recovered if the LSP reaps the UTXO without publishing the entire tree. The net effect is that ***tree node fees are default-paid by the LSP***.  The result is that the tree has endogenous fees.\n\nAs noted above, some tree nodes are state transactions that are modified.  When modifying a node, we reduce the `nSequence`.  In addition, we can **also** increase the feerate of that node.  Thus, even in a high feerate environment, we have a minor assurance that the latest state version is the one that is most likely to confirm.\n\nWe can add P2A outputs to each tree node as well.  However, by itself it is unsafe.  Consider the following attack scenario:\n\n* The LSP sells some inbound liquidity to a client within the SuperScalar mechanism.  The effect is that there are two version of a leaf node, one which has more funds in the LSP side.\n* The client uses that inbound liquidity, such that loss of the channel capacity is loss of funds.\n* The LSP waits for a high-fee period.\n* The LSP initiates a unilateral exit for the victim client, confirming tree nodes until the parent of the leaf containing the victim.\n* The client attempts to broadcast the latest leaf node, but because it has no external funds, it cannot feebump the latest leaf node above the prevailing confirmable rate.\n* The LSP waits for the ***previous*** leaf node to be broadcastable (it has a later `nSequence` than the latest one) and attaches a higher feerate to it via the P2A output.\n* The previous leaf node gets confirmed, the LSP claws back its funds, the client loses access to all its funds.\n\nThe above inducts over every state transaction in the tree, thus we need to have state transactions without P2A outputs if we are worried about such an attack.\n\nTo protect against this, we can observe:\n\n* Within the SuperScalar mechanism, all state transfers are of the form:\n  * fully owned by `L` -> a channel between a client `A` and `L`.\n  * This is because the LSP sells inbound liquidity to clients.  The LSP wants to ensure that all sales are final, in that it never refunds inbound liquidity that has already been sold.\n\nWithin the SuperScalar mechanism, we do not intend to ever have the liquidity go back from the `A`-`L` channel to solely owned by `L` --- as noted, once the LSP has sold some unit of inbound liquidity, it wants to ***not*** take back that liquidity and refund the client for the inbound liquidity.\n\nWhat we can thus do is to recognize that all `L`-owned funds are unidirectional, they will always go down.  So instead of having a \"plain\" `L` script, we can have the script `<secret> | L`. \n Whenever we invalidate a leaf node (and if we change a non-leaf node, we also invalidate all children down to the leaf nodes) the LSP shares the `<secret>` of every `L` liquidity stock output of the OLD version to each client that signs off on the change.  For the new version, the LSP generates a new secret for the `L` liquidity stock output.  This can use the same shachain mechanism we already use for Poon-Dryja BOLT Lightning channels.\n\nIf the LSP uses the P2A output to confirm an older version during a high-fee environment, then the `L` outputs have an alternate `<secret>` path that the clients can use.  The clients can then retaliate by burning the `L` output to miner fees.  Thus, the LSP is incentivized to always ensure that the latest version of every state transaction gets confirmed before the older version can be broadcastable (because the clients also have a copy of the older version and can broadcast them for confirmation and subsequent burning of LSP funds).\n\nWith this, we can have P2A on all tree nodes as well, and incentive for the LSP to always assist in confirming the latest version of a tree node if a client wants to unilaterally exit.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 104,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}