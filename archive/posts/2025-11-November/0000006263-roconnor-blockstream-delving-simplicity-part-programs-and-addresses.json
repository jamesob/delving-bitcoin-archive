{
  "id": 6263,
  "name": "",
  "username": "roconnor-blockstream",
  "avatar_template": "/user_avatar/delvingbitcoin.org/roconnor-blockstream/{size}/427_2.png",
  "created_at": "2025-11-17T19:57:25.994Z",
  "cooked": "<p>In <a href=\"https://delvingbitcoin.org/t/delving-simplicity-part-two-side-effects/2091\">Part \u2163</a> of this series, we discussed the side effects that Simplicity expressions can have. In particular, for Bitcoin and Liquid applications, Simplicity expressions can have a Reader effect, which provides read-only access to the transaction data and the Failure effect, which determines whether a transaction is successful or not.</p>\n<p>The program for a UTXO is ultimately just a function that decides whether a given transaction is acceptable to redeem that particular UTXO\u2019s funds. To this end, we define a <em>Simplicity program</em> as a Simplicity expression of type <code>\ud835\udfd9 \u22a2 \ud835\udfd9</code>. We rely on the Reader effect to capture the input (the transaction environment) and a Failure effect to capture the output (success or failure) of this program.</p>\n<p>This means that Simplicity types are not used for the input and output of Simplicity programs, but rather Simplicity types are used to ensure the soundness of the internal composition of subexpressions within a Simplicity program.</p>\n<h1><a name=\"p-6263-commitment-merkle-root-1\" class=\"anchor\" href=\"#p-6263-commitment-merkle-root-1\"></a>Commitment Merkle Root</h1>\n<p>We do not directly store an entire Simplicity program in a transaction\u2019s output. Since the days of Bitcoin\u2019s Pay-to-Script-Hash (P2SH), Bitcoin has stored only commitments to programs in transaction outputs. This, among other benefits, allows for a uniform addressing scheme for all programs, no matter their complexity.</p>\n<p>For Simplicity programs, we use a <em>commitment Merkle root</em> (or <em>CMR)</em> for our commitment. Each Simplicity combinator has an associated tag, which is a SHA-256 hash of an identifying ASCII string</p>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><span class=\"math\">tag_{iden}</span></td>\n<td>= SHA-256(<code>Simplicity\u241fCommitment\u241fiden</code>)</td>\n</tr>\n<tr>\n<td><span class=\"math\">tag_{comp}</span></td>\n<td>= SHA-256(<code>Simplicity\u241fCommitment\u241fcomp</code>)</td>\n</tr>\n<tr>\n<td><span class=\"math\">tag_{unit}</span></td>\n<td>= SHA-256(<code>Simplicity\u241fCommitment\u241funit</code>)</td>\n</tr>\n<tr>\n<td><span class=\"math\">tag_{injl}</span></td>\n<td>= SHA-256(<code>Simplicity\u241fCommitment\u241finjl</code>)</td>\n</tr>\n<tr>\n<td><span class=\"math\">tag_{injr}</span></td>\n<td>= SHA-256(<code>Simplicity\u241fCommitment\u241finjr</code>)</td>\n</tr>\n<tr>\n<td><span class=\"math\">tag_{case}</span></td>\n<td>= SHA-256(<code>Simplicity\u241fCommitment\u241fcase</code>)</td>\n</tr>\n<tr>\n<td><span class=\"math\">tag_{pair}</span></td>\n<td>= SHA-256(<code>Simplicity\u241fCommitment\u241fpair</code>)</td>\n</tr>\n<tr>\n<td><span class=\"math\">tag_{take}</span></td>\n<td>= SHA-256(<code>Simplicity\u241fCommitment\u241ftake</code>)</td>\n</tr>\n<tr>\n<td><span class=\"math\">tag_{drop}</span></td>\n<td>= SHA-256(<code>Simplicity\u241fCommitment\u241fdrop</code>)</td>\n</tr>\n</tbody>\n</table>\n</div><p>where <code>\u241f</code> stands for ASCII code 31.</p>\n<p>Simplicity expressions are recursively hashed to form a 256-bit CMR by computing tagged SHA-256 midstates for each combinator and its arguments.</p>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><span class=\"hashtag-raw\">#\u1d9c</span>(<code>iden</code>)</td>\n<td>= SHA-256-midstate <span class=\"math\">(tag_{iden} \\parallel tag_{iden})</span></td>\n</tr>\n<tr>\n<td><span class=\"hashtag-raw\">#\u1d9c</span>(<code>comp</code> <span class=\"math\">f</span> <span class=\"math\">g</span>)</td>\n<td>= SHA-256-midstate <span class=\"math\">(tag_{comp} \\parallel tag_{comp} \\parallel \\#^c(f) \\parallel \\#^c(g))</span></td>\n</tr>\n<tr>\n<td><span class=\"hashtag-raw\">#\u1d9c</span>(<code>unit</code>)</td>\n<td>= SHA-256-midstate <span class=\"math\">(tag_{unit} \\parallel tag_{unit})</span></td>\n</tr>\n<tr>\n<td><span class=\"hashtag-raw\">#\u1d9c</span>(<code>injl</code> <span class=\"math\">f</span>)</td>\n<td>= SHA-256-midstate <span class=\"math\">(tag_{injl} \\parallel tag_{injl} \\parallel 32\\cdot\\texttt{0x00} \\parallel \\#^c(f))</span></td>\n</tr>\n<tr>\n<td><span class=\"hashtag-raw\">#\u1d9c</span>(<code>injr</code> <span class=\"math\">f</span>)</td>\n<td>= SHA-256-midstate <span class=\"math\">(tag_{injr} \\parallel tag_{injr} \\parallel 32\\cdot\\texttt{0x00} \\parallel \\#^c(f))</span></td>\n</tr>\n<tr>\n<td><span class=\"hashtag-raw\">#\u1d9c</span>(<code>case</code> <span class=\"math\">f</span> <span class=\"math\">g</span>)</td>\n<td>= SHA-256-midstate <span class=\"math\">(tag_{case} \\parallel tag_{case} \\parallel \\#^c(f) \\parallel \\#^c(g))</span></td>\n</tr>\n<tr>\n<td><span class=\"hashtag-raw\">#\u1d9c</span>(<code>pair</code> <span class=\"math\">f</span> <span class=\"math\">g</span>)</td>\n<td>= SHA-256-midstate <span class=\"math\">(tag_{pair} \\parallel tag_{pair} \\parallel \\#^c(f) \\parallel \\#^c(g))</span></td>\n</tr>\n<tr>\n<td><span class=\"hashtag-raw\">#\u1d9c</span>(<code>take</code> <span class=\"math\">f</span>)</td>\n<td>= SHA-256-midstate <span class=\"math\">(tag_{take} \\parallel tag_{take} \\parallel 32\\cdot\\texttt{0x00} \\parallel \\#^c(f))</span></td>\n</tr>\n<tr>\n<td><span class=\"hashtag-raw\">#\u1d9c</span>(<code>drop</code> <span class=\"math\">f</span>)</td>\n<td>= SHA-256-midstate <span class=\"math\">(tag_{drop} \\parallel tag_{drop} \\parallel 32\\cdot\\texttt{0x00} \\parallel \\#^c(f))</span></td>\n</tr>\n</tbody>\n</table>\n</div><p>At redemption time, a Simplicity program with a matching CMR is revealed. We use a Merkle root for the CMR because we want to be able to prune unused branches from the revealed program.</p>\n<p>Notice that the CMR does not commit to the types of Simplicity expressions. Simplicity will use type inference to reconstruct the minimal typing of the revealed Simplicity program.</p>\n<p>We use SHA-256 midstates so that each expression requires at most one call to the SHA-256 compression function, assuming one precomputes the midstate up to the tags. In the case of one-argument constructors, we prefix the argument with 32 bytes of <code>0x00</code> padding because it allows for a small amount of extra precomputation if developers wish to implement it.</p>\n<h1><a name=\"p-6263-addresses-2\" class=\"anchor\" href=\"#p-6263-addresses-2\"></a>Addresses</h1>\n<p>Addresses for Simplicity programs use <a href=\"https://github.com/bitcoin/bips/blob/bbaea3182b258a4eadc100279ec71c7a4a30482e/bip-0341.mediawiki\" rel=\"noopener nofollow ugc\">BIP-0341</a>\u2019s Taproot mechanism with the program\u2019s CMR committed under a new TapLeaf version number. The Simplicity program\u2019s CMR is hashed with the Simplicity leaf version byte to form Simplicity\u2019s TapLeaf tagged hash.</p>\n<p>For Liquid and Elements, this would be</p>\n<div align=\"center\">\n<p><span class=\"math\">hash_{TapLeaf/elements}(\\texttt{0xbe} \\parallel \\texttt{0x20} \\parallel CMR)</span></p>\n</div>\n<p>where <code>0xbe</code> is Simplicity\u2019s TapLeaf version and <code>0x20</code> is the length of a CMR. A tagged hash is defined in <a href=\"https://github.com/bitcoin/bips/blob/bbaea3182b258a4eadc100279ec71c7a4a30482e/bip-0340.mediawiki#description\" rel=\"noopener nofollow ugc\">BIP-0340</a> as</p>\n<div align=\"center\">\n<p><span class=\"math\">hash_{str}(x) = \\textit{SHA-256}(\\textit{SHA-256}(str) \\parallel \\textit{SHA-256}(str) \\parallel x)</span>.</p>\n</div>\n<p>From here, other TapBranches could be added containing other TapLeaves, which themselves can be either other Simplicity programs or even other Script programs.</p>\n<p>Finally, the root of the TapTree is used in a TapTweak to tweak an internal public key and generate an output public key used to create a Segwit v1 address. If no key-spend path is desired, a NUMS point must be used for the internal public key. For more details, consult <a href=\"https://github.com/bitcoin/bips/blob/bbaea3182b258a4eadc100279ec71c7a4a30482e/bip-0341.mediawiki#constructing-and-spending-taproot-outputs\" rel=\"noopener nofollow ugc\">BIP-0341</a>.</p>\n<h2><a name=\"p-6263-from-simplicity-to-address-3\" class=\"anchor\" href=\"#p-6263-from-simplicity-to-address-3\"></a>From Simplicity to Address</h2>\n<p>Let\u2019s create an address for the simplest Simplicity program possible: <code>unit : \ud835\udfd9 \u22a2 \ud835\udfd9</code>. This is a no-op program that always succeeds.</p>\n<p>First, we compute the unit combinator\u2019s tag:</p>\n<div align=\"center\">\n<p><span class=\"math\">tag_{unit}</span>= <code>0xd723083cff3c75e29f296707ecf2750338f100591c86e0c71717f807ff3cf69d</code></p>\n</div>\n<p>Using this tag, we can compute the CMR for the <code>unit</code> expression.</p>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><span class=\"hashtag-raw\">#\u1d9c</span>(<code>unit</code>)</td>\n</tr>\n<tr>\n<td>=</td>\n</tr>\n<tr>\n<td>SHA-256-midstate <span class=\"math\">(tag_{unit} \\parallel tag_{unit})</span></td>\n</tr>\n<tr>\n<td>=</td>\n</tr>\n<tr>\n<td>SHA-256-midstate(<code>0xd723083cff3c75e29f296707ecf2750338f100591c86e0c71717f807ff3cf69d</code>\u2028\u2225<code>0xd723083cff3c75e29f296707ecf2750338f100591c86e0c71717f807ff3cf69d</code>)</td>\n</tr>\n<tr>\n<td>=</td>\n</tr>\n<tr>\n<td><code>0xc40a10263f7436b4160acbef1c36fba4be4d95df181a968afeab5eac247adff7</code></td>\n</tr>\n</tbody>\n</table>\n</div><p>Next, we compute a TapLeaf tagged hash by prefixing the CMR with Simplicity\u2019s TapLeaf version code and the CMR length.</p>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><span class=\"math\">hash_{TapLeaf/elements}(\\texttt{0xbe} \\parallel \\texttt{0x20} \\parallel CMR)</span></td>\n</tr>\n<tr>\n<td>=</td>\n</tr>\n<tr>\n<td><span class=\"math\">hash_{TapLeaf/elements}</span>(<code>0xbe20c40a10263f7436b4160acbef1c36fba4be4d95df181a968afeab5eac247adff7</code>)</td>\n</tr>\n<tr>\n<td>=</td>\n</tr>\n<tr>\n<td><code>0x44cc38311ec7e5dfb7b573baf38449496ecd334eb5509cfed1b4fd30da8dd41c</code></td>\n</tr>\n</tbody>\n</table>\n</div><p>In this example, our TapTree will only have this one leaf, so we won\u2019t be introducing any TapBranches. Next, we need to use this hash to tweak some public key. Since we don\u2019t want to enable a keyspend path in our example, we will use the NUMS point specified in <a href=\"https://github.com/bitcoin/bips/blob/bbaea3182b258a4eadc100279ec71c7a4a30482e/bip-0341.mediawiki#constructing-and-spending-taproot-outputs\" rel=\"noopener nofollow ugc\">BIP-0341</a>. In a real application, we would randomize this NUMS point as recommended by <a href=\"https://github.com/bitcoin/bips/blob/bbaea3182b258a4eadc100279ec71c7a4a30482e/bip-0341.mediawiki#constructing-and-spending-taproot-outputs\" rel=\"noopener nofollow ugc\">BIP-0341</a>.</p>\n<div align=\"center\">\n<p><em>internal_pk</em> = <code>0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code></p>\n</div>\n<p>The next step is to compute the tweaked hash of this public key with our TapLeaf hash.</p>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><span class=\"math\">hash_{TapTweak/elements}</span>(<code>0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code>\u2028\u2225 <code>0x44cc38311ec7e5dfb7b573baf38449496ecd334eb5509cfed1b4fd30da8dd41c</code>)</td>\n</tr>\n<tr>\n<td>=</td>\n</tr>\n<tr>\n<td><code>0xb3bef172389b0937d7e5a8b15cfa41e776777f13f2f659cb06220a6ff0658285</code></td>\n</tr>\n</tbody>\n</table>\n</div><p>Then we need to compute the Taproot output key by tweaking our internal public key by this value. This involves some elliptic curve calculations.</p>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><em>output_pk</em></td>\n</tr>\n<tr>\n<td>=</td>\n</tr>\n<tr>\n<td>lift_x(<code>0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code>) \u2028\u2295 <code>0xb3bef172389b0937d7e5a8b15cfa41e776777f13f2f659cb06220a6ff0658285</code>\u00b7G</td>\n</tr>\n<tr>\n<td>=</td>\n</tr>\n<tr>\n<td>lift_x(<code>0x2cb0c20acd7340b4d4b65f6a60e2888d0d64e3267261f3b3cf7290e5af3f9e09</code>)</td>\n</tr>\n</tbody>\n</table>\n</div><p>Next, we need to convert this x-only output public key into <a href=\"https://github.com/bitcoin/bips/blob/66a41d32bf9c4dfecd80a81f1165dd3f59b5374b/bip-0173.mediawiki\" rel=\"noopener nofollow ugc\">Bech32</a>\u2019s alphabet:</p>\n<div align=\"center\">\n<p><code>9jcvyzkdwdqtf49kta4xpc5g35xkfcexwfsl8v70w2gwttelncys</code></p>\n</div>\n<p>We prefix this string with a <code>p</code>, indicating this is a Segwit V1 address, and then we add a Bech32 prefix. For the Liquid testnet, this prefix is <code>tex1</code>. Then we append the <a href=\"https://github.com/bitcoin/bips/blob/66a41d32bf9c4dfecd80a81f1165dd3f59b5374b/bip-0350.mediawiki\" rel=\"noopener nofollow ugc\">Bech32m</a> checksum. In this example, the checksum is <code>hxjk56</code>.</p>\n<p>Finally, we have the address for our little Simplicity program:</p>\n<div align=\"center\">\n<p><a href=\"https://blockstream.info/liquidtestnet/address/tex1p9jcvyzkdwdqtf49kta4xpc5g35xkfcexwfsl8v70w2gwttelncyshxjk56\" rel=\"noopener nofollow ugc\"><code>tex1p9jcvyzkdwdqtf49kta4xpc5g35xkfcexwfsl8v70w2gwttelncyshxjk56</code></a></p>\n</div>\nWhew! That was a lot of work; however, much of this work is mandated by Taproot and is not Simplicity specific.\n<h1><a name=\"p-6263-witness-expressions-4\" class=\"anchor\" href=\"#p-6263-witness-expressions-4\"></a>Witness expressions</h1>\n<p>There is one more kind of input data that we have neglected so far: signature data and other witness data. This kind of input is separate from the transaction environment that the Reader effect can access. However, because Simplicity programs have no input, there appears to be no place to put signature data.</p>\n<p>Our remedy is to add a new kind of Simplicity expression: the <em>witness expression</em>.</p>\n<pre data-code-wrap=\"none\"><code class=\"lang-none\">      w : B\n-----------------\nwitness w : A \u22a2 B\n</code></pre>\n<p>This is the only combinator that takes an actual Simplicity value as an argument.</p>\n<p>The semantics of the witness expression is that it ignores its input and just returns the value <code>w</code>, which can be of any Simplicity type.</p>\n<p><code>\u27e6witness w\u27e7(a) = w</code></p>\n<p>We know from the Simplicity completeness theorem that this function can already be expressed in Simplicity. In particular, in <a href=\"https://delvingbitcoin.org/t/delving-simplicity-part-combinator-completeness-of-simplicity/1935\">Part \u2161</a> of this series, we saw the <code>scribe</code> macro that constructs such expressions.</p>\n<p>The purpose of the witness expression does not lie in its functional behavior, but rather in its CMR.</p>\n<p>First, we define the witness commitment tag.</p>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><span class=\"math\">tag^c_{witness}</span></td>\n<td>= SHA-256(<code>Simplicity\u241fCommitment\u241fwitnesss</code>)</td>\n</tr>\n</tbody>\n</table>\n</div><p>Then, we define the CMR for witness expressions.</p>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><span class=\"hashtag-raw\">#\u1d9c</span>(<code>witness</code> <span class=\"math\">w</span>)</td>\n<td>= SHA-256-midstate <span class=\"math\">(tag^c_{witness} \\parallel tag^c_{witness})</span></td>\n</tr>\n</tbody>\n</table>\n</div><p>Notice that the value <code>w</code> is <strong>excluded</strong> from the expression\u2019s CMR. This means we can calculate an address for an expression before we know the value <code>w</code>. In other words, we get to set the value of <code>w</code> at redemption time. Whenever we need witness data, such as a digital signature, we can place it inside a witness node.</p>\n<h2><a name=\"p-6263-witness-values-5\" class=\"anchor\" href=\"#p-6263-witness-values-5\"></a>Witness Values</h2>\n<p>It may seem like a limitation that witness expressions contain only values and not other Simplicity expressions more generally. However, programs for UTXO-based blockchains are executed only once. We don\u2019t need to pass a whole Simplicity expression into a witness expression because the user could instead run that expression themselves and transcribe its output into the witness\u2019s value to get the same result.</p>\n<p>That said, later on we will introduce the <code>disconnect</code> combinator, and as we will see, it behaves much like a witness expression that takes an entire Simplicity expression as an argument.</p>\n<p>An alternative design would be to take all witness data as an argument to the Simplicity program. We prefer to use witness expressions because of pruning. Pruning will be discussed later in this series, but the idea is that unexecuted branches of <code>case</code> expressions are not revealed on-chain. In particular, any witness expressions within those branches also get pruned away. Witness expressions also let us put witness values right where they are needed, rather than having to propagate those values down from the top-level program input.</p>\n<h1><a name=\"p-6263-conclusion-6\" class=\"anchor\" href=\"#p-6263-conclusion-6\"></a>Conclusion</h1>\n<p>In this part, we defined a Simplicity program as a Simplicity expression from <code>\ud835\udfd9</code> to <code>\ud835\udfd9</code>. We defined the commitment Merkle root (or CMR) of Simplicity expressions and used it to form a commitment to a Simplicity program. We also introduced witness expressions, which contain witness data that is excluded from this commitment. We also saw a worked example of how to construct an address for a trivial Simplicity program.</p>\n<p>In the next part, we will talk about jets, how their CMRs are constructed, and use some jets to construct a simple single-signature checking program.</p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 1,
  "updated_at": "2025-11-17T20:32:26.776Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 1,
  "reads": 6,
  "readers_count": 5,
  "score": 6.2,
  "yours": false,
  "topic_id": 2113,
  "topic_slug": "delving-simplicity-part-programs-and-addresses",
  "topic_title": "Delving Simplicity Part \u2164: Programs and Addresses",
  "topic_html_title": "Delving Simplicity Part \u2164: Programs and Addresses",
  "category_id": 7,
  "display_username": "",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 3,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "In [Part \u2163](https://delvingbitcoin.org/t/delving-simplicity-part-two-side-effects/2091) of this series, we discussed the side effects that Simplicity expressions can have. In particular, for Bitcoin and Liquid applications, Simplicity expressions can have a Reader effect, which provides read-only access to the transaction data and the Failure effect, which determines whether a transaction is successful or not.\n\nThe program for a UTXO is ultimately just a function that decides whether a given transaction is acceptable to redeem that particular UTXO\u2019s funds. To this end, we define a *Simplicity program* as a Simplicity expression of type `\ud835\udfd9 \u22a2 \ud835\udfd9`. We rely on the Reader effect to capture the input (the transaction environment) and a Failure effect to capture the output (success or failure) of this program.\n\nThis means that Simplicity types are not used for the input and output of Simplicity programs, but rather Simplicity types are used to ensure the soundness of the internal composition of subexpressions within a Simplicity program.\n\n# Commitment Merkle Root\n\nWe do not directly store an entire Simplicity program in a transaction\u2019s output. Since the days of Bitcoin\u2019s Pay-to-Script-Hash (P2SH), Bitcoin has stored only commitments to programs in transaction outputs. This, among other benefits, allows for a uniform addressing scheme for all programs, no matter their complexity.\n\nFor Simplicity programs, we use a *commitment Merkle root* (or *CMR)* for our commitment. Each Simplicity combinator has an associated tag, which is a SHA-256 hash of an identifying ASCII string\n\n| <!-- --> | <!-- --> |\n|---|---|\n| $tag_{iden}$ | = SHA-256(`Simplicity\u241fCommitment\u241fiden`) |\n| $tag_{comp}$ | = SHA-256(`Simplicity\u241fCommitment\u241fcomp`) |\n| $tag_{unit}$ | = SHA-256(`Simplicity\u241fCommitment\u241funit`) |\n| $tag_{injl}$ | = SHA-256(`Simplicity\u241fCommitment\u241finjl`) |\n| $tag_{injr}$ | = SHA-256(`Simplicity\u241fCommitment\u241finjr`) |\n| $tag_{case}$ | = SHA-256(`Simplicity\u241fCommitment\u241fcase`) |\n| $tag_{pair}$ | = SHA-256(`Simplicity\u241fCommitment\u241fpair`) |\n| $tag_{take}$ | = SHA-256(`Simplicity\u241fCommitment\u241ftake`) |\n| $tag_{drop}$ | = SHA-256(`Simplicity\u241fCommitment\u241fdrop`) |\n\nwhere `\u241f` stands for ASCII code 31.\n\nSimplicity expressions are recursively hashed to form a 256-bit CMR by computing tagged SHA-256 midstates for each combinator and its arguments.\n\n| <!-- --> | <!-- --> |\n|---|---|\n| #\u1d9c(`iden`) | = SHA-256-midstate $(tag_{iden} \\parallel tag_{iden})$ |\n| #\u1d9c(`comp` $f$ $g$) | = SHA-256-midstate $(tag_{comp} \\parallel tag_{comp} \\parallel \\#^c(f) \\parallel \\#^c(g))$ |\n| #\u1d9c(`unit`) | = SHA-256-midstate $(tag_{unit} \\parallel tag_{unit})$ |\n| #\u1d9c(`injl` $f$) | = SHA-256-midstate $(tag_{injl} \\parallel tag_{injl} \\parallel 32\\cdot\\texttt{0x00} \\parallel \\#^c(f))$ |\n| #\u1d9c(`injr` $f$) | = SHA-256-midstate $(tag_{injr} \\parallel tag_{injr} \\parallel 32\\cdot\\texttt{0x00} \\parallel \\#^c(f))$ |\n| #\u1d9c(`case` $f$ $g$) | = SHA-256-midstate $(tag_{case} \\parallel tag_{case} \\parallel \\#^c(f) \\parallel \\#^c(g))$ |\n| #\u1d9c(`pair` $f$ $g$) | = SHA-256-midstate $(tag_{pair} \\parallel tag_{pair} \\parallel \\#^c(f) \\parallel \\#^c(g))$ |\n| #\u1d9c(`take` $f$) | = SHA-256-midstate $(tag_{take} \\parallel tag_{take} \\parallel 32\\cdot\\texttt{0x00} \\parallel \\#^c(f))$ |\n| #\u1d9c(`drop` $f$) | = SHA-256-midstate $(tag_{drop} \\parallel tag_{drop} \\parallel 32\\cdot\\texttt{0x00} \\parallel \\#^c(f))$ |\n\nAt redemption time, a Simplicity program with a matching CMR is revealed. We use a Merkle root for the CMR because we want to be able to prune unused branches from the revealed program.\n\nNotice that the CMR does not commit to the types of Simplicity expressions. Simplicity will use type inference to reconstruct the minimal typing of the revealed Simplicity program.\n\nWe use SHA-256 midstates so that each expression requires at most one call to the SHA-256 compression function, assuming one precomputes the midstate up to the tags. In the case of one-argument constructors, we prefix the argument with 32 bytes of `0x00` padding because it allows for a small amount of extra precomputation if developers wish to implement it.\n\n# Addresses\n\nAddresses for Simplicity programs use [BIP-0341](https://github.com/bitcoin/bips/blob/bbaea3182b258a4eadc100279ec71c7a4a30482e/bip-0341.mediawiki)\u2019s Taproot mechanism with the program\u2019s CMR committed under a new TapLeaf version number. The Simplicity program\u2019s CMR is hashed with the Simplicity leaf version byte to form Simplicity\u2019s TapLeaf tagged hash.\n\nFor Liquid and Elements, this would be\n<div align=\"center\">\n\n$hash_{TapLeaf/elements}(\\texttt{0xbe} \\parallel \\texttt{0x20} \\parallel CMR)$\n</div>\n\nwhere `0xbe` is Simplicity\u2019s TapLeaf version and `0x20` is the length of a CMR. A tagged hash is defined in [BIP-0340](https://github.com/bitcoin/bips/blob/bbaea3182b258a4eadc100279ec71c7a4a30482e/bip-0340.mediawiki#description) as\n\n<div align=\"center\">\n\n$hash_{str}(x) = \\textit{SHA-256}(\\textit{SHA-256}(str) \\parallel \\textit{SHA-256}(str) \\parallel x)$.\n\n</div>\n\nFrom here, other TapBranches could be added containing other TapLeaves, which themselves can be either other Simplicity programs or even other Script programs.\n\nFinally, the root of the TapTree is used in a TapTweak to tweak an internal public key and generate an output public key used to create a Segwit v1 address. If no key-spend path is desired, a NUMS point must be used for the internal public key. For more details, consult [BIP-0341](https://github.com/bitcoin/bips/blob/bbaea3182b258a4eadc100279ec71c7a4a30482e/bip-0341.mediawiki#constructing-and-spending-taproot-outputs).\n\n## From Simplicity to Address\n\nLet\u2019s create an address for the simplest Simplicity program possible: `unit : \ud835\udfd9 \u22a2 \ud835\udfd9`. This is a no-op program that always succeeds.\n\nFirst, we compute the unit combinator\u2019s tag:\n<div align=\"center\">\n\n$tag_{unit}$= `0xd723083cff3c75e29f296707ecf2750338f100591c86e0c71717f807ff3cf69d`\n</div>\n\nUsing this tag, we can compute the CMR for the `unit` expression.\n| <!-- --> |\n|---|\n| #\u1d9c(`unit`) |\n| = |\n| SHA-256-midstate $(tag_{unit} \\parallel tag_{unit})$ |\n| = |\n| SHA-256-midstate(`0xd723083cff3c75e29f296707ecf2750338f100591c86e0c71717f807ff3cf69d`&#x2028;\u2225`0xd723083cff3c75e29f296707ecf2750338f100591c86e0c71717f807ff3cf69d`) |\n| = |\n| `0xc40a10263f7436b4160acbef1c36fba4be4d95df181a968afeab5eac247adff7` |\n\nNext, we compute a TapLeaf tagged hash by prefixing the CMR with Simplicity\u2019s TapLeaf version code and the CMR length.\n| <!-- --> |\n|---|\n| $hash_{TapLeaf/elements}(\\texttt{0xbe} \\parallel \\texttt{0x20} \\parallel CMR)$ |\n| = |\n| $hash_{TapLeaf/elements}$(`0xbe20c40a10263f7436b4160acbef1c36fba4be4d95df181a968afeab5eac247adff7`) |\n| = |\n| `0x44cc38311ec7e5dfb7b573baf38449496ecd334eb5509cfed1b4fd30da8dd41c` |\n\nIn this example, our TapTree will only have this one leaf, so we won\u2019t be introducing any TapBranches. Next, we need to use this hash to tweak some public key. Since we don\u2019t want to enable a keyspend path in our example, we will use the NUMS point specified in [BIP-0341](https://github.com/bitcoin/bips/blob/bbaea3182b258a4eadc100279ec71c7a4a30482e/bip-0341.mediawiki#constructing-and-spending-taproot-outputs). In a real application, we would randomize this NUMS point as recommended by [BIP-0341](https://github.com/bitcoin/bips/blob/bbaea3182b258a4eadc100279ec71c7a4a30482e/bip-0341.mediawiki#constructing-and-spending-taproot-outputs).\n<div align=\"center\">\n\n*internal_pk* = `0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0`\n</div>\n\nThe next step is to compute the tweaked hash of this public key with our TapLeaf hash.\n| <!-- --> |\n|---|\n| $hash_{TapTweak/elements}$(`0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0`&#x2028;\u2225 `0x44cc38311ec7e5dfb7b573baf38449496ecd334eb5509cfed1b4fd30da8dd41c`) |\n| = |\n| `0xb3bef172389b0937d7e5a8b15cfa41e776777f13f2f659cb06220a6ff0658285` |\n\nThen we need to compute the Taproot output key by tweaking our internal public key by this value. This involves some elliptic curve calculations.\n| <!-- --> |\n|---|\n| *output_pk* |\n| = |\n| lift_x(`0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0`) &#x2028;\u2295 `0xb3bef172389b0937d7e5a8b15cfa41e776777f13f2f659cb06220a6ff0658285`\u00b7G |\n| = |\n| lift_x(`0x2cb0c20acd7340b4d4b65f6a60e2888d0d64e3267261f3b3cf7290e5af3f9e09`) |\n\nNext, we need to convert this x-only output public key into [Bech32](https://github.com/bitcoin/bips/blob/66a41d32bf9c4dfecd80a81f1165dd3f59b5374b/bip-0173.mediawiki)\u2019s alphabet:\n<div align=\"center\">\n\n`9jcvyzkdwdqtf49kta4xpc5g35xkfcexwfsl8v70w2gwttelncys`\n</div>\n\nWe prefix this string with a `p`, indicating this is a Segwit V1 address, and then we add a Bech32 prefix. For the Liquid testnet, this prefix is `tex1`. Then we append the [Bech32m](https://github.com/bitcoin/bips/blob/66a41d32bf9c4dfecd80a81f1165dd3f59b5374b/bip-0350.mediawiki) checksum. In this example, the checksum is `hxjk56`.\n\nFinally, we have the address for our little Simplicity program:\n<div align=\"center\">\n\n[`tex1p9jcvyzkdwdqtf49kta4xpc5g35xkfcexwfsl8v70w2gwttelncyshxjk56`](https://blockstream.info/liquidtestnet/address/tex1p9jcvyzkdwdqtf49kta4xpc5g35xkfcexwfsl8v70w2gwttelncyshxjk56)\n</div>\nWhew! That was a lot of work; however, much of this work is mandated by Taproot and is not Simplicity specific.\n\n# Witness expressions\n\nThere is one more kind of input data that we have neglected so far: signature data and other witness data. This kind of input is separate from the transaction environment that the Reader effect can access. However, because Simplicity programs have no input, there appears to be no place to put signature data.\n\nOur remedy is to add a new kind of Simplicity expression: the *witness expression*.\n\n```none\n      w : B\n-----------------\nwitness w : A \u22a2 B\n```\n\nThis is the only combinator that takes an actual Simplicity value as an argument.\n\nThe semantics of the witness expression is that it ignores its input and just returns the value `w`, which can be of any Simplicity type.\n\n`\u27e6witness w\u27e7(a) = w`\n\nWe know from the Simplicity completeness theorem that this function can already be expressed in Simplicity. In particular, in [Part \u2161](https://delvingbitcoin.org/t/delving-simplicity-part-combinator-completeness-of-simplicity/1935) of this series, we saw the `scribe` macro that constructs such expressions.\n\nThe purpose of the witness expression does not lie in its functional behavior, but rather in its CMR.\n\nFirst, we define the witness commitment tag.\n\n| <!-- --> | <!-- --> |\n|---|---|\n| $tag^c_{witness}$ | = SHA-256(`Simplicity\u241fCommitment\u241fwitnesss`) |\n\nThen, we define the CMR for witness expressions.\n| <!-- --> | <!-- --> |\n|---|---|\n| #\u1d9c(`witness` $w$) | = SHA-256-midstate $(tag^c_{witness} \\parallel tag^c_{witness})$ |\n\nNotice that the value `w` is **excluded** from the expression\u2019s CMR. This means we can calculate an address for an expression before we know the value `w`. In other words, we get to set the value of `w` at redemption time. Whenever we need witness data, such as a digital signature, we can place it inside a witness node.\n\n## Witness Values\n\nIt may seem like a limitation that witness expressions contain only values and not other Simplicity expressions more generally. However, programs for UTXO-based blockchains are executed only once. We don\u2019t need to pass a whole Simplicity expression into a witness expression because the user could instead run that expression themselves and transcribe its output into the witness\u2019s value to get the same result.\n\nThat said, later on we will introduce the `disconnect` combinator, and as we will see, it behaves much like a witness expression that takes an entire Simplicity expression as an argument.\n\nAn alternative design would be to take all witness data as an argument to the Simplicity program. We prefer to use witness expressions because of pruning. Pruning will be discussed later in this series, but the idea is that unexecuted branches of `case` expressions are not revealed on-chain. In particular, any witness expressions within those branches also get pruned away. Witness expressions also let us put witness values right where they are needed, rather than having to propagate those values down from the top-level program input.\n\n# Conclusion\n\nIn this part, we defined a Simplicity program as a Simplicity expression from `\ud835\udfd9` to `\ud835\udfd9`. We defined the commitment Merkle root (or CMR) of Simplicity expressions and used it to form a commitment to a Simplicity program. We also introduced witness expressions, which contain witness data that is excluded from this commitment. We also saw a worked example of how to construct an address for a trivial Simplicity program.\n\nIn the next part, we will talk about jets, how their CMRs are constructed, and use some jets to construct a simple single-signature checking program.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 351,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "In <a href=\"https://delvingbitcoin.org/t/delving-simplicity-part-two-side-effects/2091\">Part \u2163</a> of this series, we discussed the side effects that Simplicity expressions can have. In particular, for Bitcoin and Liquid applications, Simplicity expressions can have a Reader effect, which provides read-only access to the transaction data and the Failure effect, which determines whether &hellip;",
  "truncated": true,
  "post_url": "/t/delving-simplicity-part-programs-and-addresses/2113/1",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}