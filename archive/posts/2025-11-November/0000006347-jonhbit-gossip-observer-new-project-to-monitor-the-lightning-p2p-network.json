{
  "id": 6347,
  "name": "Jonathan Harvey-Buschel",
  "username": "jonhbit",
  "avatar_template": "/user_avatar/delvingbitcoin.org/jonhbit/{size}/1661_2.png",
  "created_at": "2025-11-26T00:46:14.871Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"rustyrussell\" data-post=\"7\" data-topic=\"2105\" data-full=\"true\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/rustyrussell/48/154_2.png\" class=\"avatar\"> rustyrussell:</div>\n<blockquote>\n<p>Sorry to join the conversation late, and I haven\u2019t worked on this for years so my memory could be stale, but here\u2019s a brain dump of our conclusions.</p>\n</blockquote>\n</aside>\n<p>Thanks for reposting it here! Useful to have more context on this, and any snippets of earlier discussions.</p>\n<aside class=\"quote no-group\" data-username=\"rustyrussell\" data-post=\"7\" data-topic=\"2105\" data-full=\"true\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/rustyrussell/48/154_2.png\" class=\"avatar\"> rustyrussell:</div>\n<blockquote>\n<ol>\n<li>Short channel ids have a lot of bits to squeeze. Ultimate would be to refer to outputs by their index in the blockchain (i.e. the 123456th output), but you can easily use fewer than 64 bits for blocknum/txnum/outnum.</li>\n</ol>\n</blockquote>\n</aside>\n<p>Agreed; I think we could cut at least 6 bits off of txindex? And then use creative XORing to mix in missing bits that don\u2019t have their own spot.</p>\n<aside class=\"quote no-group\" data-username=\"rustyrussell\" data-post=\"7\" data-topic=\"2105\" data-full=\"true\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/rustyrussell/48/154_2.png\" class=\"avatar\"> rustyrussell:</div>\n<blockquote>\n<ol start=\"3\">\n<li>You maintain three minisketches. We tried a single, but it costs encoding bits, complexity and hits the O(N^2) harder.</li>\n<li>Channel minisketch is just the scids. Importantly, you send your blockheight with the sketch, because that informs the failure case.</li>\n<li>Channel update minisketch is compacted scid + direction bit + height. Note that height takes 10 or 11 bits, IIRC, since you don\u2019t send expired ones. You can only reliably decode this once you have reconciled the channels sketch.</li>\n<li>Node announce sketch is uses the same encoding, using the oldest channel attached to the node as its key. Again this assumes you reconciled the channels sketch first.</li>\n</ol>\n<p>If you cannot encode an scid compactly, just send it as a series of  \u201craw\" entries. IIRC creating such an scid requires an exceptional number of txs in a block or exceptional output count.</p>\n</blockquote>\n</aside>\n<p>Not sure what you mean with the \u201craw entries\u201d part? Do you mean, send the underlying gossip message outside of the set reconciliation messaging flow?</p>\n<aside class=\"quote no-group\" data-username=\"rustyrussell\" data-post=\"7\" data-topic=\"2105\" data-full=\"true\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/rustyrussell/48/154_2.png\" class=\"avatar\"> rustyrussell:</div>\n<blockquote>\n<p>With this scheme, you simply send the sketches every 60 seconds (like now), and your peer sends you what you\u2019re missing.</p>\n<p>Note that you can truncate the set you send if you want to save bandwidth, but really the cost is in the set maintenance, so maybe this is silly. My memory is that minisketch is <em>fast</em> in practice though, even if you keep a 64k (8k element) set which is our max message size anyway.</p>\n</blockquote>\n</aside>\n<p>IIUC the cost is mostly in the final parts of decode; I think if you wanted to save bandwidth, you could create a sketch with an overestimate of the true set difference, and then send some portion of that. If your peer signals that decode would fail, you can send the rest / another chunk of the oversized set.</p>\n<p>I didn\u2019t consider the max message size at all; that sounds like an argument for using shorter (32-bit) set elements and using a per-peer salt <img src=\"https://delvingbitcoin.org/images/emoji/twitter/upside_down_face.png?v=14\" title=\":upside_down_face:\" class=\"emoji\" alt=\":upside_down_face:\" loading=\"lazy\" width=\"20\" height=\"20\"></p>\n<aside class=\"quote no-group\" data-username=\"rustyrussell\" data-post=\"7\" data-topic=\"2105\" data-full=\"true\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/rustyrussell/48/154_2.png\" class=\"avatar\"> rustyrussell:</div>\n<blockquote>\n<p>If reconstruction fails, there are several things you can do:</p>\n<ol>\n<li>If block height differs, ignore. Time will sort it. Maybe include block hash here?</li>\n</ol>\n</blockquote>\n</aside>\n<p>Not sure I understand this bit; I figure you mean the block height you suggested sending alongside the channel announcement sketch. Is this the blockheight of the newest channel announcement you\u2019ve received, or something else?</p>\n<aside class=\"quote no-group\" data-username=\"rustyrussell\" data-post=\"7\" data-topic=\"2105\" data-full=\"true\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/rustyrussell/48/154_2.png\" class=\"avatar\"> rustyrussell:</div>\n<blockquote>\n<ol start=\"3\">\n<li>Enlarge your own set (or, send more of your set). If this allows your peer to reconstruct, it will learn that you cannot reconstruct, and it knows to send its largest set if it wasn\u2019t already.</li>\n<li>Wait for other peers. You might close the gap.</li>\n<li>Existing gossip queries for recent changes (assuming a pile of old changes haven\u2019t suddenly appeared).  You know if you need announcements, updates or node anns.</li>\n<li>Query for everything.</li>\n</ol>\n<p>Oh, we added a \u201ctotal entries\" counter to each message, which gives a clue as well: if your peer has far fewer entries, it\u2019s a cry for help <img src=\"https://delvingbitcoin.org/images/emoji/twitter/slight_smile.png?v=14\" title=\":slight_smile:\" class=\"emoji\" alt=\":slight_smile:\" loading=\"lazy\" width=\"20\" height=\"20\"></p>\n</blockquote>\n</aside>\n<p>Mm, I wonder if there are other values that would be useful to add in here.</p>\n<p>Re: your follow-up post - I agree on the napkin math working out, and it\u2019s even better if we\u2019re doing one set per message type. And having more peers should also help.</p>\n<p>Will think over the message ordering dependencies you mentioned in having three sketches vs. one. Fallback behavior <span class=\"hashtag-raw\">#4</span> could be promising, where you rebuild a sketch from the messages you received over the last n minutes vs. just 1 minute, reattempt a reconciliation, and hopefully catch up to that peer. I think I\u2019d like to avoid leaning too much on gossip queries if possible <img src=\"https://delvingbitcoin.org/images/emoji/twitter/sweat_smile.png?v=14\" title=\":sweat_smile:\" class=\"emoji\" alt=\":sweat_smile:\" loading=\"lazy\" width=\"20\" height=\"20\"></p>",
  "post_number": 10,
  "post_type": 1,
  "posts_count": 20,
  "updated_at": "2025-11-26T00:46:27.546Z",
  "reply_count": 2,
  "reply_to_post_number": 7,
  "quote_count": 1,
  "incoming_link_count": 0,
  "reads": 33,
  "readers_count": 32,
  "score": 16.6,
  "yours": false,
  "topic_id": 2105,
  "topic_slug": "gossip-observer-new-project-to-monitor-the-lightning-p2p-network",
  "topic_title": "Gossip Observer: New project to monitor the Lightning P2P network",
  "topic_html_title": "Gossip Observer: New project to monitor the Lightning P2P network",
  "category_id": 7,
  "display_username": "Jonathan Harvey-Buschel",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"rustyrussell, post:7, topic:2105, full:true\"]\nSorry to join the conversation late, and I haven\u2019t worked on this for years so my memory could be stale, but here\u2019s a brain dump of our conclusions.\n[/quote]\n\nThanks for reposting it here! Useful to have more context on this, and any snippets of earlier discussions.\n\n[quote=\"rustyrussell, post:7, topic:2105, full:true\"]\n1. Short channel ids have a lot of bits to squeeze. Ultimate would be to refer to outputs by their index in the blockchain (i.e. the 123456th output), but you can easily use fewer than 64 bits for blocknum/txnum/outnum.\n[/quote]\n\nAgreed; I think we could cut at least 6 bits off of txindex? And then use creative XORing to mix in missing bits that don't have their own spot.\n\n[quote=\"rustyrussell, post:7, topic:2105, full:true\"]\n3. You maintain three minisketches. We tried a single, but it costs encoding bits, complexity and hits the O(N^2) harder.\n4. Channel minisketch is just the scids. Importantly, you send your blockheight with the sketch, because that informs the failure case.\n5. Channel update minisketch is compacted scid + direction bit + height. Note that height takes 10 or 11 bits, IIRC, since you don\u2019t send expired ones. You can only reliably decode this once you have reconciled the channels sketch.\n6. Node announce sketch is uses the same encoding, using the oldest channel attached to the node as its key. Again this assumes you reconciled the channels sketch first.\n\nIf you cannot encode an scid compactly, just send it as a series of  \u201craw\" entries. IIRC creating such an scid requires an exceptional number of txs in a block or exceptional output count.\n[/quote]\n\nNot sure what you mean with the \"raw entries\" part? Do you mean, send the underlying gossip message outside of the set reconciliation messaging flow?\n\n[quote=\"rustyrussell, post:7, topic:2105, full:true\"]\nWith this scheme, you simply send the sketches every 60 seconds (like now), and your peer sends you what you\u2019re missing.\n\nNote that you can truncate the set you send if you want to save bandwidth, but really the cost is in the set maintenance, so maybe this is silly. My memory is that minisketch is *fast* in practice though, even if you keep a 64k (8k element) set which is our max message size anyway.\n[/quote]\n\nIIUC the cost is mostly in the final parts of decode; I think if you wanted to save bandwidth, you could create a sketch with an overestimate of the true set difference, and then send some portion of that. If your peer signals that decode would fail, you can send the rest / another chunk of the oversized set.\n\nI didn't consider the max message size at all; that sounds like an argument for using shorter (32-bit) set elements and using a per-peer salt :upside_down_face: \n\n[quote=\"rustyrussell, post:7, topic:2105, full:true\"]\nIf reconstruction fails, there are several things you can do:\n\n1. If block height differs, ignore. Time will sort it. Maybe include block hash here?\n[/quote]\n\nNot sure I understand this bit; I figure you mean the block height you suggested sending alongside the channel announcement sketch. Is this the blockheight of the newest channel announcement you've received, or something else?\n\n[quote=\"rustyrussell, post:7, topic:2105, full:true\"]\n3. Enlarge your own set (or, send more of your set). If this allows your peer to reconstruct, it will learn that you cannot reconstruct, and it knows to send its largest set if it wasn\u2019t already.\n4. Wait for other peers. You might close the gap.\n5. Existing gossip queries for recent changes (assuming a pile of old changes haven\u2019t suddenly appeared).  You know if you need announcements, updates or node anns.\n6. Query for everything.\n\nOh, we added a \u201ctotal entries\" counter to each message, which gives a clue as well: if your peer has far fewer entries, it\u2019s a cry for help :slight_smile:\n[/quote]\n\nMm, I wonder if there are other values that would be useful to add in here.\n\nRe: your follow-up post - I agree on the napkin math working out, and it's even better if we're doing one set per message type. And having more peers should also help.\n\nWill think over the message ordering dependencies you mentioned in having three sketches vs. one. Fallback behavior #4 could be promising, where you rebuild a sketch from the messages you received over the last n minutes vs. just 1 minute, reattempt a reconciliation, and hopefully catch up to that peer. I think I'd like to avoid leaning too much on gossip queries if possible :sweat_smile:",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 982,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "Thanks for reposting it here! Useful to have more context on this, and any snippets of earlier discussions. \n\nAgreed; I think we could cut at least 6 bits off of txindex? And then use creative XORing to mix in missing bits that don\u2019t have their own spot. \n\nNot sure what you mean with the \u201craw entri&hellip;",
  "truncated": true,
  "post_url": "/t/gossip-observer-new-project-to-monitor-the-lightning-p2p-network/2105/10",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}