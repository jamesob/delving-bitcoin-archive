{
  "id": 6300,
  "name": "Michael Zaikin",
  "username": "m-kus",
  "avatar_template": "/user_avatar/delvingbitcoin.org/m-kus/{size}/1446_2.png",
  "created_at": "2025-11-20T20:13:08.187Z",
  "cooked": "<p>These are really good points, thank you for the feedback!</p>\n<p>I generally agree with most of it, here are some comments:</p>\n<blockquote>\n<p>OP_STARK_VERIFY would introduce a complex \u201cblack box\u201d of tens of thousands of lines of code</p>\n</blockquote>\n<p>Actually the verifier is quite a lean program, such impression is common because most codebases contain the code for both prover and verifier, where the verifier inevitably reuse shared components. To give you a perspective, a pure Simplicity rewrite of Stwo (our latest prover) is 3k lines (1k without tests, comments, and empty lines). I think you can get even less in C, and the only dependency would be sha2 (which is not a new for Bitcoin core). So it is comparable with or even smaller than other cryptography primitives, like ECDSA/Schnorr.</p>\n<blockquote>\n<p>The validation cost (CPU/memory) of a STARK proof is not proportional to its byte size</p>\n</blockquote>\n<p>It actually is, but the proportion is not always linear.\nMost of verifier\u2019s work is checking Merkle proofs and doing arithmetics in a specific group. A proof consists of many Merkle openings, their number is determined by fixed parameters (determined by security requirements). Proof size depends on the execution trace size:</p>\n<ul>\n<li>logarithmic to the trace length (which is roughly how much computation you are compressing)</li>\n<li>linear to the trace width (which depends on the number/implementation of accelerators that are used to reduce the trace length)</li>\n</ul>\n<p>The larger the trace, the larger the Merkle proofs =&gt; verifier does more hashing\nThe wider the trade, the more the number of decommitted values =&gt; verifier does more arithmetics</p>\n<p>We can address DoS attack vector by introducing hard limits on both trace length and width. A good heuristic can be the cost of a recursive verification circuit:</p>\n<ul>\n<li>any computation can be recursively verified by it, so it\u2019s safe to claim you won\u2019t need anything beyond that</li>\n<li>it\u2019s typically very narrow, so proof size/input size ratio behaviour is close to logarithmic which would allow fair opcode pricing</li>\n</ul>\n<blockquote>\n<p>Enshrining a specific version of STARKs, even a mature one, locks Bitcoin into a technology that will inevitably become obsolete</p>\n</blockquote>\n<p>This is true, although there\u2019s an <a href=\"https://vitalik.eth.limo/general/2024/07/23/circlestarks.html\" rel=\"noopener nofollow ugc\">opinion</a> that most of the significant optimisations in STARKs have already been realised and the frontiers will move to the arithmetization level (given the recursive flow it does not affect the last verification step).</p>\n<blockquote>\n<p>A more prudent path, consistent with Bitcoin\u2019s design, is to keep such complexity at higher layers or, if necessary, consider introducing generic, composable primitives rather than monolithic, application-specific solutions.</p>\n</blockquote>\n<p>Agree, but unfortunately that would require much more opcodes to be reenabled/introduced.\nSomething like GSR+CTV would do the job, although the costs would still be quite high.</p>\n<p>Personally, I\u2019m a Simplicity fan <img src=\"https://delvingbitcoin.org/images/emoji/twitter/smiley.png?v=14\" title=\":smiley:\" class=\"emoji\" alt=\":smiley:\" loading=\"lazy\" width=\"20\" height=\"20\"></p>",
  "post_number": 17,
  "post_type": 1,
  "posts_count": 17,
  "updated_at": "2025-11-20T20:16:25.861Z",
  "reply_count": 0,
  "reply_to_post_number": 9,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 9,
  "readers_count": 8,
  "score": 1.6,
  "yours": false,
  "topic_id": 2056,
  "topic_slug": "proposal-op-stark-verify-native-stark-proof-verification-in-bitcoin-script",
  "topic_title": "Proposal: OP_STARK_VERIFY - Native STARK Proof Verification in Bitcoin Script",
  "topic_html_title": "Proposal: OP_STARK_VERIFY - Native STARK Proof Verification in Bitcoin Script",
  "category_id": 7,
  "display_username": "Michael Zaikin",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "reply_to_user": {
    "id": 694,
    "username": "ftw2100",
    "name": "F__T__W",
    "avatar_template": "/user_avatar/delvingbitcoin.org/ftw2100/{size}/1083_2.png"
  },
  "bookmarked": false,
  "raw": "These are really good points, thank you for the feedback!\n\nI generally agree with most of it, here are some comments:\n\n> OP_STARK_VERIFY would introduce a complex \u201cblack box\u201d of tens of thousands of lines of code\n\nActually the verifier is quite a lean program, such impression is common because most codebases contain the code for both prover and verifier, where the verifier inevitably reuse shared components. To give you a perspective, a pure Simplicity rewrite of Stwo (our latest prover) is 3k lines (1k without tests, comments, and empty lines). I think you can get even less in C, and the only dependency would be sha2 (which is not a new for Bitcoin core). So it is comparable with or even smaller than other cryptography primitives, like ECDSA/Schnorr.\n\n> The validation cost (CPU/memory) of a STARK proof is not proportional to its byte size\n\nIt actually is, but the proportion is not always linear.\nMost of verifier\u2019s work is checking Merkle proofs and doing arithmetics in a specific group. A proof consists of many Merkle openings, their number is determined by fixed parameters (determined by security requirements). Proof size depends on the execution trace size:\n\n* logarithmic to the trace length (which is roughly how much computation you are compressing)\n* linear to the trace width (which depends on the number/implementation of accelerators that are used to reduce the trace length)\n\nThe larger the trace, the larger the Merkle proofs => verifier does more hashing\nThe wider the trade, the more the number of decommitted values => verifier does more arithmetics\n\nWe can address DoS attack vector by introducing hard limits on both trace length and width. A good heuristic can be the cost of a recursive verification circuit:\n\n* any computation can be recursively verified by it, so it\u2019s safe to claim you won\u2019t need anything beyond that\n* it\u2019s typically very narrow, so proof size/input size ratio behaviour is close to logarithmic which would allow fair opcode pricing\n\n> Enshrining a specific version of STARKs, even a mature one, locks Bitcoin into a technology that will inevitably become obsolete\n\nThis is true, although there\u2019s an [opinion](https://vitalik.eth.limo/general/2024/07/23/circlestarks.html) that most of the significant optimisations in STARKs have already been realised and the frontiers will move to the arithmetization level (given the recursive flow it does not affect the last verification step).\n\n> A more prudent path, consistent with Bitcoin\u2019s design, is to keep such complexity at higher layers or, if necessary, consider introducing generic, composable primitives rather than monolithic, application-specific solutions.\n\nAgree, but unfortunately that would require much more opcodes to be reenabled/introduced.\nSomething like GSR+CTV would do the job, although the costs would still be quite high.\n\nPersonally, I\u2019m a Simplicity fan :smiley:",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 882,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "These are really good points, thank you for the feedback! \nI generally agree with most of it, here are some comments: \n\nOP_STARK_VERIFY would introduce a complex \u201cblack box\u201d of tens of thousands of lines of code \n\nActually the verifier is quite a lean program, such impression is common because most &hellip;",
  "truncated": true,
  "post_url": "/t/proposal-op-stark-verify-native-stark-proof-verification-in-bitcoin-script/2056/17",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}