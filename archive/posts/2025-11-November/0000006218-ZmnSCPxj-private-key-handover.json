{
  "id": 6218,
  "name": "ZmnSCPxj jxPCSnmZ",
  "username": "ZmnSCPxj",
  "avatar_template": "/letter_avatar_proxy/v4/letter/z/ee7513/{size}.png",
  "created_at": "2025-11-12T00:15:13.806Z",
  "cooked": "<h1><a name=\"p-6218-shared-spending-inter-protocol-framework-1\" class=\"anchor\" href=\"#p-6218-shared-spending-inter-protocol-framework-1\"></a>Shared-spending Inter-Protocol Framework</h1>\n<p>A high-quality <em><strong>general</strong></em> Bitcoin-management (a.k.a. \u201cwallet\u201d) implementation can implement the following software interface as a framework by which additional code can implement protocols that are capable of sufficient flexibility to allow arbitrarily adding new transaction inputs and new transaction outputs.</p>\n<p>As a concrete example, any protocol that uses Private Key Handover as described in the main text above can integrate with the below-described inter-protocol framework in order to create batched, RBFed transactions.</p>\n<p>The framework maintains a (possibly empty) set of requested commands.  A \u201ccommand\u201d in this context is either (1) a request to spend an input before some timeout or (2) a request to fund some address before some timeout.</p>\n<p>In particular, end-users can simply call <code>fund_output</code> one-at-a-time and the framework will, if feasible, batch the outputs into a single transaction, i.e. instead of requiring end-user code to call into a <code>send_multi</code>-equivalent command (so that end-user code has to decide to batch before calling into the Bitcoin-management framework), the end-user code calls multiple <code>fund_output</code> commands, and the framework automatically batches them, using RBF to replace any broadcasted transactions.</p>\n<p>The framework implicitly assumes that all inputs are some SegWit version, and thus have a non-malleable <code>txid</code> independent of signing.  The framework simply bans non-SegWit inputs outright.</p>\n<p>The framework has two entry points: <code>fund_output</code> and <code>spend_input</code>.  Both accept one or more callbacks, which the framework uses to coordinate with the actual protocols.</p>\n<ul>\n<li><code>fund_output(amount, timeout, requesterAddressCallback, requesterReadyCallback, requesterDoneCallback)</code> - Tell the framework that it has to make a transaction that sends out an <code>amount</code>, targeting the transaction to be confirmed before the <code>timeout</code> blockheight.\n<ul>\n<li>The <code>requesterAddressCallback</code> is called whenever the framework has decided on some number of owned UTXOs, plus any pending spend-an-input requests, and a feerate to use.  It is given the feerate the framework has decided on.  It should return either a destination address for the amount, or a request to cancel itself and remove its request to fund the output.\n<ul>\n<li>For example, consider the LN BOLT <code>openv1</code> protocol, where this might be used to initiate a new <code>open_channel</code>, and thus generate a new address from the replied <code>accept_channel</code> (i.e. this callback would send <code>open_channel</code> and wait for a corresponding <code>accept_channel</code>).</li>\n<li>The framework may call this at any time, as long as the request has not been cancelled, for example if it decides to RBF.</li>\n</ul>\n</li>\n<li>The <code>requesterReadyCallback</code> is called whenever the framework has already called <code>requesterAddressCallback</code> on all <code>fund_output</code> commands, and has created, but not signed, the transaction.  It is given the stable <code>txid</code> of the transaction and the output index of that transaction where it is created, as well as the corresponding address.  It returns either an <code>ok</code>, or a request to cancel the transaction and remove its request to fund the output.\n<ul>\n<li>For example, consider the LN BOLT <code>openv1</code> protocol, where this would be used to send <code>funding_created</code> and wait for a <code>funding_signed</code> (and if it times out waiting for <code>funding_signed</code>, to cancel the request instead of continuing).</li>\n<li>The framework will not sign and broadcast the transaction until after all <code>requesterReadyCallback</code>s return <code>ok</code>.  If any do not return <code>ok</code>, the framework will remove that output and then restart its loop starting with calling <code>requesterAddressCallback</code> on all unremoved output requests.</li>\n</ul>\n</li>\n<li>The <code>requesterDoneCallback</code> is called when some transaction that has funded the output has been confirmed (possibly to some depth determined by policy).  This is given the specific txout and address.\n<ul>\n<li>For example, consider the LN BOLT <code>openv1</code> protocol, where this would be used to send <code>funding_locked</code> / <code>channel_ready</code>.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>spend_input(txin, amount, timeout, requesterSignCallback)</code> - Tell the framework that some specific transaction <code>txin</code> (a stable <code>txid</code> + <code>outnum</code>) must be spent before the given <code>timeout</code> blockheight.  <code>amount</code> is given here but depending on implementation it may be possible to remove it from the interface (in principle a full UTXO-map would store the <code>amount</code> and spending conditions, but that is not trivially exposed by e.g. bitcoin-core).\n<ul>\n<li>If the framework currently has no <code>fund_output</code> requests, the funds (minus fees) should go to an address that the framework wallet unilaterally controls.</li>\n<li>The <code>requesterSignCallback</code> is called whenever the framework has already decided to sign and broadcast some transaction that includes this input.  It is given a PSBT, and it must return a PSBT with the corresponding input having the required witness filled in.\n<ul>\n<li>For example, consider the LN BOLT <code>revocation</code> protocol, where the only requirement is to sign with the <code>revocationpubkey</code>, and the transaction can spend to anything.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>For a simple \u201csend to an address\u201d base usecase, you can call <code>fund_output</code> with the amount to be sent, with trivial callbacks where <code>requesterAddressCallback</code> returns the target address, <code>requesterReadyCallback</code> trivially returns <code>ok</code>, and <code>requesterDoneCallback</code> notifies the user UI.  The magic here is that if the human operator performs multiple \u201csend to an address\u201d commands in sequence, the wallet framework automatically batches them (it can delay its decision loop to wait for new commands to reduce the number of times it RBFs, but it can always RBF newer transactions for each new \u201csend to an address\u201d request).  In addition, in case of a sudden surge in fees, the wallet framework can automatically RBF without further human operator input; further, the human operator can specify some maximum feerate, and then <code>requesterAddressCallback</code> can fail the request automatically if the feerate is higher than the maximum set by the human operator.</p>\n<p>For the proposed \u201cPrivate Key Handover\u201d, any protocol that implements Private Key Handover proposed in the original post can call into <code>spend_input</code>, and provide a <code>requesterSignCallback</code> that uses the handed-over private key to sign the input it is claiming.</p>\n<p>Of note is that obviously the framework needs to continue operating across restarts.  Thus, the actual callbacks would not be some kind of in-memory representation of a function; instead, you would need to pre-register some set of protocols that can use this framework, with some kind of per-protocol name or identifier that is stable across restarts (for example, it can be a versioned string, such as <code>simple_send_to_addr_v1</code>).  This registration for protocols that would call into <code>fund_output</code> could provide the function addresses for all the callbacks needed, so that the <em><strong>actual</strong></em> <code>fund_output</code> call accepts only the registered name.</p>\n<p>The framework would store the pending requests on persistent storage, and on restart, would load and look for any pending requests, and check the stored protocol names against the pre-registered protocols (and abort the restart if the in-storage string does not match any pre-registered protocols).  This make the framework a little harder to use, but makes it robust against restarts; the framework can record exactly where in its processing it has completed (e.g. if it has called some callback for some particular request).  This may require that individual requests also have an identifier (such as a UUID) across restarts.</p>",
  "post_number": 2,
  "post_type": 1,
  "posts_count": 2,
  "updated_at": "2025-11-12T00:15:13.806Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 11,
  "readers_count": 10,
  "score": 2.2,
  "yours": false,
  "topic_id": 2098,
  "topic_slug": "private-key-handover",
  "topic_title": "Private Key Handover",
  "topic_html_title": "Private Key Handover",
  "category_id": 7,
  "display_username": "ZmnSCPxj jxPCSnmZ",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Shared-spending Inter-Protocol Framework\n==\n\nA high-quality ***general*** Bitcoin-management (a.k.a. \"wallet\") implementation can implement the following software interface as a framework by which additional code can implement protocols that are capable of sufficient flexibility to allow arbitrarily adding new transaction inputs and new transaction outputs.\n\nAs a concrete example, any protocol that uses Private Key Handover as described in the main text above can integrate with the below-described inter-protocol framework in order to create batched, RBFed transactions.\n\nThe framework maintains a (possibly empty) set of requested commands.  A \"command\" in this context is either (1) a request to spend an input before some timeout or (2) a request to fund some address before some timeout.\n\nIn particular, end-users can simply call `fund_output` one-at-a-time and the framework will, if feasible, batch the outputs into a single transaction, i.e. instead of requiring end-user code to call into a `send_multi`-equivalent command (so that end-user code has to decide to batch before calling into the Bitcoin-management framework), the end-user code calls multiple `fund_output` commands, and the framework automatically batches them, using RBF to replace any broadcasted transactions.\n\nThe framework implicitly assumes that all inputs are some SegWit version, and thus have a non-malleable `txid` independent of signing.  The framework simply bans non-SegWit inputs outright.\n\nThe framework has two entry points: `fund_output` and `spend_input`.  Both accept one or more callbacks, which the framework uses to coordinate with the actual protocols.\n\n* `fund_output(amount, timeout, requesterAddressCallback, requesterReadyCallback, requesterDoneCallback)` - Tell the framework that it has to make a transaction that sends out an `amount`, targeting the transaction to be confirmed before the `timeout` blockheight.\n  * The `requesterAddressCallback` is called whenever the framework has decided on some number of owned UTXOs, plus any pending spend-an-input requests, and a feerate to use.  It is given the feerate the framework has decided on.  It should return either a destination address for the amount, or a request to cancel itself and remove its request to fund the output.\n    * For example, consider the LN BOLT `openv1` protocol, where this might be used to initiate a new `open_channel`, and thus generate a new address from the replied `accept_channel` (i.e. this callback would send `open_channel` and wait for a corresponding `accept_channel`).\n    * The framework may call this at any time, as long as the request has not been cancelled, for example if it decides to RBF.\n  * The `requesterReadyCallback` is called whenever the framework has already called `requesterAddressCallback` on all `fund_output` commands, and has created, but not signed, the transaction.  It is given the stable `txid` of the transaction and the output index of that transaction where it is created, as well as the corresponding address.  It returns either an `ok`, or a request to cancel the transaction and remove its request to fund the output.\n    * For example, consider the LN BOLT `openv1` protocol, where this would be used to send `funding_created` and wait for a `funding_signed` (and if it times out waiting for `funding_signed`, to cancel the request instead of continuing).\n    * The framework will not sign and broadcast the transaction until after all `requesterReadyCallback`s return `ok`.  If any do not return `ok`, the framework will remove that output and then restart its loop starting with calling `requesterAddressCallback` on all unremoved output requests.\n  *  The `requesterDoneCallback` is called when some transaction that has funded the output has been confirmed (possibly to some depth determined by policy).  This is given the specific txout and address.\n     * For example, consider the LN BOLT `openv1` protocol, where this would be used to send `funding_locked` / `channel_ready`.\n* `spend_input(txin, amount, timeout, requesterSignCallback)` - Tell the framework that some specific transaction `txin` (a stable `txid` + `outnum`) must be spent before the given `timeout` blockheight.  `amount` is given here but depending on implementation it may be possible to remove it from the interface (in principle a full UTXO-map would store the `amount` and spending conditions, but that is not trivially exposed by e.g. bitcoin-core).\n  * If the framework currently has no `fund_output` requests, the funds (minus fees) should go to an address that the framework wallet unilaterally controls.\n  * The `requesterSignCallback` is called whenever the framework has already decided to sign and broadcast some transaction that includes this input.  It is given a PSBT, and it must return a PSBT with the corresponding input having the required witness filled in.\n    * For example, consider the LN BOLT `revocation` protocol, where the only requirement is to sign with the `revocationpubkey`, and the transaction can spend to anything.\n\nFor a simple \"send to an address\" base usecase, you can call `fund_output` with the amount to be sent, with trivial callbacks where `requesterAddressCallback` returns the target address, `requesterReadyCallback` trivially returns `ok`, and `requesterDoneCallback` notifies the user UI.  The magic here is that if the human operator performs multiple \"send to an address\" commands in sequence, the wallet framework automatically batches them (it can delay its decision loop to wait for new commands to reduce the number of times it RBFs, but it can always RBF newer transactions for each new \"send to an address\" request).  In addition, in case of a sudden surge in fees, the wallet framework can automatically RBF without further human operator input; further, the human operator can specify some maximum feerate, and then `requesterAddressCallback` can fail the request automatically if the feerate is higher than the maximum set by the human operator.\n\nFor the proposed \"Private Key Handover\", any protocol that implements Private Key Handover proposed in the original post can call into `spend_input`, and provide a `requesterSignCallback` that uses the handed-over private key to sign the input it is claiming.\n\nOf note is that obviously the framework needs to continue operating across restarts.  Thus, the actual callbacks would not be some kind of in-memory representation of a function; instead, you would need to pre-register some set of protocols that can use this framework, with some kind of per-protocol name or identifier that is stable across restarts (for example, it can be a versioned string, such as `simple_send_to_addr_v1`).  This registration for protocols that would call into `fund_output` could provide the function addresses for all the callbacks needed, so that the ***actual*** `fund_output` call accepts only the registered name.\n\nThe framework would store the pending requests on persistent storage, and on restart, would load and look for any pending requests, and check the stored protocol names against the pre-registered protocols (and abort the restart if the in-storage string does not match any pre-registered protocols).  This make the framework a little harder to use, but makes it robust against restarts; the framework can record exactly where in its processing it has completed (e.g. if it has called some callback for some particular request).  This may require that individual requests also have an identifier (such as a UUID) across restarts.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 104,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "<a name=\"p-6218-shared-spending-inter-protocol-framework-1\" class=\"anchor\" href=\"#p-6218-shared-spending-inter-protocol-framework-1\"></a>Shared-spending Inter-Protocol Framework\nA high-quality general Bitcoin-management (a.k.a. \u201cwallet\u201d) implementation can implement the following software interface as a framework by which additional code can implement protocols that are capable of sufficient flexibility to allow arbitrarily adding ne&hellip;",
  "truncated": true,
  "post_url": "/t/private-key-handover/2098/2",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}