{
  "id": 6214,
  "name": "ZmnSCPxj jxPCSnmZ",
  "username": "ZmnSCPxj",
  "avatar_template": "/letter_avatar_proxy/v4/letter/z/ee7513/{size}.png",
  "created_at": "2025-11-11T04:06:55.729Z",
  "cooked": "<p>Subject: Private Key Handover</p>\n<h1><a name=\"p-6214-introduction-1\" class=\"anchor\" href=\"#p-6214-introduction-1\"></a>Introduction</h1>\n<p>There are protocols where, at the end of the protocol, semantically,\nsome lump fund which was previously shared by two or more\nparticipants, is now owned by only one of the participants.</p>\n<p>For example, an onchain HTLC starts with two participants: the offeror\nand the acceptor.\nAssuming the \u201chappy path\u201d where the preimage is learned by the offeror,\nat the end of the protocol, the offeror semantically releases its claim\non the HTLC funds and the fund (should) now be singularly controlled by\nthe acceptor.</p>\n<p>When implementing such a protocol onchain, on a blockchain that supports\nTaproot, a possible optimization is for the protocol to always require\nephemeral public keys in the keyspend path, and for participant(s) that\nwant to release their claim on the fund to simply hand over the ephemeral\nprivate key to the final single beneficiary, which would allow the\nbeneficiary party to use the keyspend path to claim the funds without\nfurther participation of any other party.</p>\n<p>In our HTLC motivating example, the keyspend path of the HTLC would be\nthe MuSig2 of the ephemeral keys of the offeror and acceptor, and in the\nhappy path, the acceptor gives the offeror the preimage directly (instead\nof onchain) and the offeror then hands over the ephemeral private key.\nThe acceptor, now in possession of both halves of the ephemeral private\nkey of the keyspend path, can now use the keyspend path unilaterally.</p>\n<h2><a name=\"p-6214-benefits-and-limitations-2\" class=\"anchor\" href=\"#p-6214-benefits-and-limitations-2\"></a>Benefits And Limitations</h2>\n<p>To be very clear, in a world where MuSig2 exists and is implemented, the\nadvantage is:</p>\n<ul>\n<li>The beneficiary party can RBF the transaction to claim the lump fund,\neven if the protocol has no support for RBF.\n<ul>\n<li>In particular, the transaction to claim the lump fund does <em><strong>not</strong></em>\nneed to have anchor outputs (which require extra blockspace weight)\nin order to freely (CPFP-)RBF after the termination of the protocol.</li>\n<li>This can simplify the design of the protocol, while allowing for\nhigh-quality implementations to RBF the transaction that claims the\nfund (simple proof-of-concept implementations need not implement\nRBF, and are simplified by the absence of RBF support in the\nprotocol; the RBF support can be added later without changing the\nprotocol or requiring that the simple initial implementation has\nRBF support).</li>\n<li>Without private key handover, we can still use MuSig2 to save\nblockspace, but must select one of these options:\n<ul>\n<li>Not have RBF, so you run the risk of sudden fee spikes after\ncompleting the MuSig2, possibly allowing timeout branches to\nbecome valid and risking funds loss.</li>\n<li>Support RBF in the protocol, so that all participants (not just\nthe beneficiary) need to stay online until the fund spend is\ndeeply confirmed onchain, with additional protocol messages and\nstate-tracking of multiple possible RBF candidates, needing to\nbe implemented by all participants.</li>\n<li>Support RBF-CPFP by adding an anchor output to the transaction\nsigned using MuSig2 in the protocol, which increases your\nblock space usage by that anchor output if RBF turns out to be\nunnecessary.\nThis also <em><strong>requires</strong></em> exogenous fees and additional\nblockspace usage if RBF <em><strong>does</strong></em> turn out to be necessary.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>The beneficiary party can batch the transaction that claims the\nlump fund with <em><strong>any</strong></em> other operations.\n<ul>\n<li>The \u201cother operations\u201d here can be completely different\nprotocols that do not themselves have any additional support for\nprivate key handover!</li>\n</ul>\n</li>\n</ul>\n<p>We should note the limitation as well:</p>\n<ul>\n<li>The fund must be a lump fund, i.e. a single UTXO onchain, and the\nfund must be transferred as a whole, at the end of the protocol, to\nunilateral control of some single beneficiary party.\n<ul>\n<li>In particular, this cannot be used to remove RBF support in the\nLightning splicing protocol, as after the end of the protocol, the\nfund in the protocol \u2014 the channel output \u2014 must still be in\nbilateral control of both parties.</li>\n<li>In particular, this cannot be used to create RBF support in the\nLightning cooperative close protocol, as after the end of the\ncooperative close, the likelihood is very high that the single\nfund \u2014 the channel output \u2014 must be split into <em><strong>two</strong></em>\nunilaterally-controlled funds; this optimization can only work on\nsingle funds.</li>\n</ul>\n</li>\n</ul>\n<h1><a name=\"p-6214-private-key-handover-3\" class=\"anchor\" href=\"#p-6214-private-key-handover-3\"></a>Private Key Handover</h1>\n<p>The \u201cprivate key handover\u201d is a building block for Bitcoin protocols:</p>\n<ul>\n<li>At the start of the protocol, each participant provides two public\nkeys:\n<ul>\n<li>An ephemeral public key.\n<ul>\n<li>This should be a fresh keypair from entropy.</li>\n<li>If using a keypair derived from some master private key,\nshould use the equivalent of hardened derivation (e.g.\nderive using HMAC, where the key is the master private key,\nand the message is some nonce tweak).</li>\n<li>Participants do not need to store the corresponding private\nkey in persistent storage, and it would probably be\nundesirable to store it (or its derivation path) in\npersistent storage.</li>\n</ul>\n</li>\n<li>A permanent public key.\n<ul>\n<li>This should be recoverable across restarts of the software.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>The keyspend branch of the Taproot output is computed as the\nMuSig2 of the <em><strong>ephemeral</strong></em> public keys of all participants.\n<ul>\n<li>The participants MUST store the MuSig2 sum of the public keys\nin persistent storage.</li>\n<li>Public keys are <em><strong>public</strong></em> and exfiltration of the public\nkeys only reduces privacy, but does not lead to loss of funds.</li>\n</ul>\n</li>\n<li>Individual leaves of the Taproot output use the <em><strong>permanent</strong></em>\npublic keys as appropriate.</li>\n<li>At the end of the protocol where a single beneficiary party is\nselected, the other participants send the ephemeral private key\nto the beneficiary.\n<ul>\n<li>In case one or more of the other participants do not\ncooperate by giving their ephemeral private key, the single\nbeneficiary can use the appropriate Taproot leaf.</li>\n</ul>\n</li>\n<li>On receiving all the ephemeral private keys of the other\nparties, the beneficiary party can then repeat the MuSig2\ncalculation using the private keys, to generate the combined\nprivate key.</li>\n</ul>\n<p>For an HTLC protocol to be used as a building block for a swap\nprotocol:</p>\n<ul>\n<li>When setting up the HTLC, the HTLC offeror and HTLC acceptor\nexchange their public keys:\n<ul>\n<li>Offeror ephemeral public key.</li>\n<li>Offeror permanent public key.</li>\n<li>Acceptor ephemeral public key.</li>\n<li>Acceptor permanent public key.</li>\n</ul>\n</li>\n<li>The HTLC Taproot output would have a keyspend branch that\nis composed of the MuSig2 of the offeror <em><strong>ephemeral</strong></em>\npublic key and the acceptor <em><strong>ephemeral</strong></em> public key.\n<ul>\n<li>The participants MUST store the MuSig2 sum of the public\nkeys in persistent storage.</li>\n</ul>\n</li>\n<li>The HTLC Tapleaves would then be:\n<ul>\n<li>Timeout branch: Signature from offeror <em><strong>permanent</strong></em>\npublic key after a <code>CLTV</code> or <code>CSV</code> timeout.</li>\n<li>Preimage branch: Signature from acceptor <em><strong>permanent</strong></em>\npublic key, and a preimage of a given hash.</li>\n</ul>\n</li>\n<li>At the end of the overall swap protocol, the acceptor then\nprovides the preimage to the offeror.\nIn response, the offeror hands over the offeror\n<em><strong>ephemeral</strong></em> private key.</li>\n<li>On receiving the offeror ephemeral private key, the acceptor\nderives the combined private key for the MuSig2 sum of the\nephemeral public keys.\nThe acceptor then checks that the resulting sum private key\nmatches the stored sum public key, and if so, can then spend\nthe fund unilaterally.\n<ul>\n<li>As mentioned, this allows the acceptor to RBF any spends of\nthe HTLC output without the protocol having to add special\nmessages for RBF, and without requiring CPFP-RBF support via\nan anchor output.</li>\n</ul>\n</li>\n</ul>\n<p>The following fallback cases need to be handled:</p>\n<ul>\n<li>In case the offeror does not hand over the offeror ephemeral\nprivate key after a few seconds, or the offeror sends an private\nkey that causes the resulting combined private key to not match,\nthe acceptor can fall back by spending using the Tapleaf branch\nwhere it has to sign and show the preimage of the hash.\n<ul>\n<li>This requires that the acceptor know the public key of the\nkeyspend path.</li>\n<li>The acceptor can recover this public key as long as it can\nrecover the MuSig2 sum of the ephemeral public keys.</li>\n</ul>\n</li>\n<li>In case the acceptor software is restarted after it has sent the\npreimage, but before it can receive the offeror ephemeral\nprivate key, the acceptor can fall back by spending the Tapleaf\nbranch where it ahs to sign and show the preimage of the hash.\n<ul>\n<li>The recommendation is to only store the ephemeral private keys\nin memory, so if the acceptor software is stopped and\nrestarted, the acceptor ephemeral private key is lost and it\ncannot calculate the sum of the ephemeral private keys.</li>\n<li>Thus, the requirement that the participants MUST store the\nMuSig2 sum of the ephemeral public keys, which lets the\nparticipants spend the funds using the Tapleaf branch by\nshowing the keyspend branch public key and the Merkle tree\nproof of the corresponding Tapleaf.</li>\n</ul>\n</li>\n</ul>\n<p>Of note is that, as the keys in the keyspend are ephemeral, and\nby \u201cephemeral\u201d we mean \u201cwill only be used for this run of the\nprotocol\u201d, this gets forward security once the spend of the fund\nis deeply confirmed.</p>\n<h2><a name=\"p-6214-graceful-implementation-4\" class=\"anchor\" href=\"#p-6214-graceful-implementation-4\"></a>Graceful Implementation</h2>\n<p>Initial implementations of a protocol that uses private key\nhandover need not <em><strong>immediately</strong></em> support RBF or batching.</p>\n<p>Thus, initial implementations of the protocol can be simple,\nnaive implementations that <em><strong>just</strong></em> spend the lump sum\noutput to an address with unilateral control of the\nbeneficiary, in a simple one-input-one-output unbatched\ntransaction with a feerate slightly higher than prevailing\nfeerates.</p>\n<p>The ability to add RBF or batching can be added later once the\nimplementors have enough confidence in their work for the\nsimple use-case, to pursue more ambitious sophistication.</p>\n<p>Importantly, implementations <em>with</em> RBF and/or batching\nsupport can talk seamlessly with simpler implementations\n<em>without</em> that support; the protocol remains the same, but\nthere is no need for the simple implementation to be aware of\nadditional messages or anything needed by the sophisticated\nimplementation.</p>\n<p>This allows for \u201cgraceful implementation\u201d where you can start\nwith a simple implementation and add features, without breaking\nprotocol compatibility, and also start off with a simpler\nprotocol that will work at both the \u201cproof-of-concept\u201d scale\nto \u201cmass adoption champagne problems\u201d scale.</p>\n<p>Particularly sophisticated implementations can even batch the\nspending of the lump sum with completely unrelated, other\nprotocols, which themselves may or may not use private key\nhandover, saving even more blockspace.</p>\n<p>Compare this to the complexity of Lightning Network splicing.\nEven initial implementations that have no intention of supporting\nRBF or batching, must be at least aware of the messages that are\nneeded if the counterparty has to RBF or batch.\nIndeed, initial implementation are forced to implement RBF, as\nmultiple versions of the splice transaction need to be signed in\nparallel until one of the versions is deeply confirmed (so you\nmight as well just go whole hog and be able to propose the RBF\nyourelf, since you need to keep track of multiple exclusive\ntransaction versions either way).</p>\n<h2><a name=\"p-6214-encrypted-handover-5\" class=\"anchor\" href=\"#p-6214-encrypted-handover-5\"></a>Encrypted Handover</h2>\n<p>We should be cautious about sending private keys across the\nnetwork.</p>\n<p>Of course, one layer of protection is to use BOLT8, or the less\nadvanced protocol TLS, to send messages containing the private\nkey.\nThis provides end-to-end encryption and message integrity.</p>\n<p>However, this is only <em>one</em> layer of protection.\nIn particular, the encryption and integrity <em><strong>ends</strong></em> at the\npoint in the software where the BOLT8 decryption and integrity\nvalidation is done.</p>\n<p>Modern software can be very complex and may send various\ninformation to various sub-components.\nPlaintexts of the messages after the end-to-end encrypted\nintegrity tunnel would be sent around and possibly have\nmultiple copies in transit from one part of the software to\nthe part which actually implements the protocol that uses\nprivate key handover.\nAdditional copies of private keys would be problematic as it\nincreases the surface area for private key exfiltration.</p>\n<p>As a concrete example, the C-Lightning (also known as CLN or\nCore Lightning) implementation will send out plaintexts of\nodd-numbered messages, via pipes, to any plugins that register\nfor notification of odd-numbered messages.\nPartial security breaches may allow hackers to get at in-pipe\ndata, and various ways of running CLN plugins remotely may\nallow the odd-numbered messages to be sent via JSON-RPC\nnotifications, in plaintext, over the network.</p>\n<p>To reduce this attack surface, our protocol can send over the\nencryption of the ephemeral private key, as follows:</p>\n<ul>\n<li>Suppose that participant Alice (HTLC-offeror in the HTLC\nuse-case) wants to hand over their ephemeral private key to\nparticipant Bob (HTLC-acceptor in the HTLC use-case).</li>\n<li>Alice takes the ECDH of the Alice ephemeral private key and\nthe Bob ephemeral public key:\n<ul>\n<li>Multiply Alice ephemeral private key (scalar) by Bob\nephemeral public key (point), resulting in a point.</li>\n<li>Format the point into the 33-byte DER format.</li>\n<li>Take the SHA256 hash of the above 33-byte DER format,\nresulting in 32-byte hash.</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>Alice XORs the 32-byte ECDH output with the Alice ephemeral\nprivate key.\n<ul>\n<li>This is best done using an in-place XOR where the result\noverwrites the plaintext Alice ephemeral private key, to\nfurther reduce the time the plaintext copy is available\nin-memory.</li>\n<li>After this step, Alice can safely free the memory for\nreuse in insecure code.</li>\n</ul>\n</li>\n<li>Alice sends the XORed result to Bob (preferably in an\nencrypted integrity tunnel, such as BOLT8).</li>\n<li>Bob receives the XORed encrypted result.</li>\n<li>Bob takes the ECDH of the Bob ephemeral private key and the\nAlice ephemeral public key.\n<ul>\n<li>This should give the same mask as above.</li>\n</ul>\n</li>\n<li>Bob XORs the 32-byte ECDH output with the encrypted private\nkey from Alice.\n<ul>\n<li>This results in the original Alice private key.</li>\n</ul>\n</li>\n</ul>\n<p>This scheme reduces the scope of where the plaintext private\nkey is available, providing extra layers of protection in\ncontexts where it would be desirable.</p>\n<p>(The proposed scheme is only safe under the random oracle\nmodel.)</p>\n<p>While many implementations would not need to have the\nprotection against internal breaches of data, putting it as\npart of the protocol allows the rare implementation that\n<em><strong>does</strong></em> need it to be safer.</p>\n<p>The encryption sub-protocol requires primitives (SECP256K1\nscalar by point multiplication, 33-byte DER formatting, SHA256)\nthat are likely to be commonly needed in Bitcoin software anyway,\nso the additional implementation complexity of using encrypted\nprivate key handover is expected to be low.</p>\n<h1><a name=\"p-6214-non-htlc-examples-6\" class=\"anchor\" href=\"#p-6214-non-htlc-examples-6\"></a>Non-HTLC Examples</h1>\n<p>Private key handover is a generic building block for protocols.\nIt can be used beyond HTLCs.</p>\n<p>For example, in the theoretical SuperScalar design, a client\nmay cooperatively exit from the LSP, by offering the entire\namount inside the SuperScalar for some equivalent onchain\namount.\nThe client can use private key handover for the keys it used\ninside the SuperScalar in the cooperative exit protocol; once\nthe server has given an onchain contract that the client can\nuse to atomically swap its in-SuperScalar funds for the\nonchain funds.</p>\n<p>In particular, with possession of the client key after the\nclient has exited, the LSP can now arbitrarily reallocate\nliqudiity towards other clients that happen to share part\nof the SuperScalar tree with the client that exited, giving\nthe LSP extra flexibility in its liquidity management.</p>\n<p>The only requirement is that the client use some kind of\nhardened derivation for the in-SuperScalar keys; because the\nkeys are handed over on exit, the client must ensure that\nthe handed-over private key cannot be used to derive their\nmaster private key.\nObviously, as the private key would need to be used across\nclient restarts, the client would need to store the\nderivation path for the in-SuperScalar key(s) in persistent\nstorage.</p>\n<p>Even outside of SuperScalar, a bespoke LSP-client protocol\ncan allow for a form of cooperative exit where the LSP can\nsign the channel output fund unilaterally, in exchange for\nthe equivalent amount of client funds in an onchain TXO.\nThis allows the LSP to batch multiple cooperative exits:</p>\n<ul>\n<li>The client that wants to exit offers the entire funds of\nthe channel with the LSP, swapping it for onchain funds\nfrom the LSP.\n<ul>\n<li>The LSP can batch the onchain funds it offers into the\nswap with other operations.</li>\n<li>After the swap, the client hands over their private key\nto the channel.\nThe LSP can now unilaterally sign for that channel, and\ncan batch the spend of the channel to recover its funds\nwith other operations.</li>\n</ul>\n</li>\n</ul>\n<p>If the LSP has enough onchain churn (e.g. if it is also\noperating other onchain businesses, such as a Lightning-onchain\nswap service, or operating as an exchange at enough scale to\nuse onchain operations), the ability to freely batch the above\noperations with others can provide actual blockspace savings.</p>\n<p>Again, the only requirement is that the client use some kind\nof hardened derivation for the channel signing keys.</p>\n<h1><a name=\"p-6214-non-taproot-usage-7\" class=\"anchor\" href=\"#p-6214-non-taproot-usage-7\"></a>Non-Taproot Usage</h1>\n<p>Of note is that while <em><strong>true</strong></em> MuSig2 signing, where there\nis no private key handover, is only possible with Schnorr\nsignatures, if private key handover is done, you can use a\nMuSig2 sum of public keys with ECDSA.</p>\n<p>After private key handover, the beneficiary can compute the\ncorresponding private key of the MuSig2 sum.\nThu, even if ECDSA is not linear, the beneficiary can still\ncompute the equivalent private key anyway.</p>\n<p>The major drawback for ECDSA usage is that there is no ECDSA\naddress that <em>also</em> has Taproot.\nThus, you would need to expose an additional public key in\nthe single SCRIPT, which may very well cancel out any\nblockspace savings.\nNevertheless, it is still quite possible to use private key\nhandover for additional flexibility and the ability to RBF\nand batch arbitrarily, even without blockspace savings.</p>\n<p>(It should be noted that the last example in the previous\nsection \u2014 bespoke LSP-client cooperative exit protocol\nwhere the LSP gets the flexibility to batch with other\noperations \u2014 would, today, be using ECDSA.)</p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 1,
  "updated_at": "2025-11-11T04:06:55.729Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 4,
  "reads": 9,
  "readers_count": 8,
  "score": 21.8,
  "yours": false,
  "topic_id": 2098,
  "topic_slug": "private-key-handover",
  "topic_title": "Private Key Handover",
  "topic_html_title": "Private Key Handover",
  "category_id": 7,
  "display_username": "ZmnSCPxj jxPCSnmZ",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Subject: Private Key Handover\n\nIntroduction\n============\n\nThere are protocols where, at the end of the protocol, semantically,\nsome lump fund which was previously shared by two or more\nparticipants, is now owned by only one of the participants.\n\nFor example, an onchain HTLC starts with two participants: the offeror\nand the acceptor.\nAssuming the \"happy path\" where the preimage is learned by the offeror,\nat the end of the protocol, the offeror semantically releases its claim\non the HTLC funds and the fund (should) now be singularly controlled by\nthe acceptor.\n\nWhen implementing such a protocol onchain, on a blockchain that supports\nTaproot, a possible optimization is for the protocol to always require\nephemeral public keys in the keyspend path, and for participant(s) that\nwant to release their claim on the fund to simply hand over the ephemeral\nprivate key to the final single beneficiary, which would allow the\nbeneficiary party to use the keyspend path to claim the funds without\nfurther participation of any other party.\n\nIn our HTLC motivating example, the keyspend path of the HTLC would be\nthe MuSig2 of the ephemeral keys of the offeror and acceptor, and in the\nhappy path, the acceptor gives the offeror the preimage directly (instead\nof onchain) and the offeror then hands over the ephemeral private key.\nThe acceptor, now in possession of both halves of the ephemeral private\nkey of the keyspend path, can now use the keyspend path unilaterally.\n\nBenefits And Limitations\n------------------------\n\nTo be very clear, in a world where MuSig2 exists and is implemented, the\nadvantage is:\n\n* The beneficiary party can RBF the transaction to claim the lump fund,\n  even if the protocol has no support for RBF.\n  - In particular, the transaction to claim the lump fund does ***not***\n    need to have anchor outputs (which require extra blockspace weight)\n    in order to freely (CPFP-)RBF after the termination of the protocol.\n  - This can simplify the design of the protocol, while allowing for\n    high-quality implementations to RBF the transaction that claims the\n    fund (simple proof-of-concept implementations need not implement\n    RBF, and are simplified by the absence of RBF support in the\n    protocol; the RBF support can be added later without changing the\n    protocol or requiring that the simple initial implementation has\n    RBF support).\n  - Without private key handover, we can still use MuSig2 to save\n    blockspace, but must select one of these options:\n    - Not have RBF, so you run the risk of sudden fee spikes after\n      completing the MuSig2, possibly allowing timeout branches to\n      become valid and risking funds loss.\n    - Support RBF in the protocol, so that all participants (not just\n      the beneficiary) need to stay online until the fund spend is\n      deeply confirmed onchain, with additional protocol messages and\n      state-tracking of multiple possible RBF candidates, needing to\n      be implemented by all participants.\n    - Support RBF-CPFP by adding an anchor output to the transaction\n      signed using MuSig2 in the protocol, which increases your\n      block space usage by that anchor output if RBF turns out to be\n      unnecessary.\n      This also ***requires*** exogenous fees and additional\n      blockspace usage if RBF ***does*** turn out to be necessary.\n* The beneficiary party can batch the transaction that claims the\n  lump fund with ***any*** other operations.\n  - The \"other operations\" here can be completely different\n    protocols that do not themselves have any additional support for\n    private key handover!\n\nWe should note the limitation as well:\n\n* The fund must be a lump fund, i.e. a single UTXO onchain, and the\n  fund must be transferred as a whole, at the end of the protocol, to\n  unilateral control of some single beneficiary party.\n  - In particular, this cannot be used to remove RBF support in the\n    Lightning splicing protocol, as after the end of the protocol, the\n    fund in the protocol --- the channel output --- must still be in\n    bilateral control of both parties.\n  - In particular, this cannot be used to create RBF support in the\n    Lightning cooperative close protocol, as after the end of the\n    cooperative close, the likelihood is very high that the single\n    fund --- the channel output --- must be split into ***two***\n    unilaterally-controlled funds; this optimization can only work on\n    single funds.\n\nPrivate Key Handover\n====================\n\nThe \"private key handover\" is a building block for Bitcoin protocols:\n\n* At the start of the protocol, each participant provides two public\n  keys:\n  - An ephemeral public key.\n    - This should be a fresh keypair from entropy.\n    - If using a keypair derived from some master private key,\n      should use the equivalent of hardened derivation (e.g.\n      derive using HMAC, where the key is the master private key,\n      and the message is some nonce tweak).\n    - Participants do not need to store the corresponding private\n      key in persistent storage, and it would probably be\n      undesirable to store it (or its derivation path) in\n      persistent storage.\n  - A permanent public key.\n    - This should be recoverable across restarts of the software.\n* The keyspend branch of the Taproot output is computed as the\n  MuSig2 of the ***ephemeral*** public keys of all participants.\n  - The participants MUST store the MuSig2 sum of the public keys\n    in persistent storage.\n  - Public keys are ***public*** and exfiltration of the public\n    keys only reduces privacy, but does not lead to loss of funds.\n* Individual leaves of the Taproot output use the ***permanent***\n  public keys as appropriate.\n* At the end of the protocol where a single beneficiary party is\n  selected, the other participants send the ephemeral private key\n  to the beneficiary.\n  - In case one or more of the other participants do not\n    cooperate by giving their ephemeral private key, the single\n    beneficiary can use the appropriate Taproot leaf.\n* On receiving all the ephemeral private keys of the other\n  parties, the beneficiary party can then repeat the MuSig2\n  calculation using the private keys, to generate the combined\n  private key.\n\nFor an HTLC protocol to be used as a building block for a swap\nprotocol:\n\n* When setting up the HTLC, the HTLC offeror and HTLC acceptor\n  exchange their public keys:\n  - Offeror ephemeral public key.\n  - Offeror permanent public key.\n  - Acceptor ephemeral public key.\n  - Acceptor permanent public key.\n* The HTLC Taproot output would have a keyspend branch that\n  is composed of the MuSig2 of the offeror ***ephemeral***\n  public key and the acceptor ***ephemeral*** public key.\n  - The participants MUST store the MuSig2 sum of the public\n    keys in persistent storage.\n* The HTLC Tapleaves would then be:\n  - Timeout branch: Signature from offeror ***permanent***\n    public key after a `CLTV` or `CSV` timeout.\n  - Preimage branch: Signature from acceptor ***permanent***\n    public key, and a preimage of a given hash.\n* At the end of the overall swap protocol, the acceptor then\n  provides the preimage to the offeror.\n  In response, the offeror hands over the offeror\n  ***ephemeral*** private key.\n* On receiving the offeror ephemeral private key, the acceptor\n  derives the combined private key for the MuSig2 sum of the\n  ephemeral public keys.\n  The acceptor then checks that the resulting sum private key\n  matches the stored sum public key, and if so, can then spend\n  the fund unilaterally.\n  - As mentioned, this allows the acceptor to RBF any spends of\n    the HTLC output without the protocol having to add special\n    messages for RBF, and without requiring CPFP-RBF support via\n    an anchor output.\n\nThe following fallback cases need to be handled:\n\n- In case the offeror does not hand over the offeror ephemeral\n  private key after a few seconds, or the offeror sends an private\n  key that causes the resulting combined private key to not match,\n  the acceptor can fall back by spending using the Tapleaf branch\n  where it has to sign and show the preimage of the hash.\n  - This requires that the acceptor know the public key of the\n    keyspend path.\n  - The acceptor can recover this public key as long as it can\n    recover the MuSig2 sum of the ephemeral public keys.\n- In case the acceptor software is restarted after it has sent the\n  preimage, but before it can receive the offeror ephemeral\n  private key, the acceptor can fall back by spending the Tapleaf\n  branch where it ahs to sign and show the preimage of the hash.\n  - The recommendation is to only store the ephemeral private keys\n    in memory, so if the acceptor software is stopped and\n    restarted, the acceptor ephemeral private key is lost and it\n    cannot calculate the sum of the ephemeral private keys.\n  - Thus, the requirement that the participants MUST store the\n    MuSig2 sum of the ephemeral public keys, which lets the\n    participants spend the funds using the Tapleaf branch by\n    showing the keyspend branch public key and the Merkle tree\n    proof of the corresponding Tapleaf.\n\nOf note is that, as the keys in the keyspend are ephemeral, and\nby \"ephemeral\" we mean \"will only be used for this run of the\nprotocol\", this gets forward security once the spend of the fund\nis deeply confirmed.\n\nGraceful Implementation\n-----------------------\n\nInitial implementations of a protocol that uses private key\nhandover need not ***immediately*** support RBF or batching.\n\nThus, initial implementations of the protocol can be simple,\nnaive implementations that ***just*** spend the lump sum\noutput to an address with unilateral control of the\nbeneficiary, in a simple one-input-one-output unbatched\ntransaction with a feerate slightly higher than prevailing\nfeerates.\n\nThe ability to add RBF or batching can be added later once the\nimplementors have enough confidence in their work for the\nsimple use-case, to pursue more ambitious sophistication.\n\nImportantly, implementations *with* RBF and/or batching\nsupport can talk seamlessly with simpler implementations\n*without* that support; the protocol remains the same, but\nthere is no need for the simple implementation to be aware of\nadditional messages or anything needed by the sophisticated\nimplementation.\n\nThis allows for \"graceful implementation\" where you can start\nwith a simple implementation and add features, without breaking\nprotocol compatibility, and also start off with a simpler\nprotocol that will work at both the \"proof-of-concept\" scale\nto \"mass adoption champagne problems\" scale.\n\nParticularly sophisticated implementations can even batch the\nspending of the lump sum with completely unrelated, other\nprotocols, which themselves may or may not use private key\nhandover, saving even more blockspace.\n\nCompare this to the complexity of Lightning Network splicing.\nEven initial implementations that have no intention of supporting\nRBF or batching, must be at least aware of the messages that are\nneeded if the counterparty has to RBF or batch.\nIndeed, initial implementation are forced to implement RBF, as\nmultiple versions of the splice transaction need to be signed in\nparallel until one of the versions is deeply confirmed (so you\nmight as well just go whole hog and be able to propose the RBF\nyourelf, since you need to keep track of multiple exclusive\ntransaction versions either way).\n\nEncrypted Handover\n------------------\n\nWe should be cautious about sending private keys across the\nnetwork.\n\nOf course, one layer of protection is to use BOLT8, or the less\nadvanced protocol TLS, to send messages containing the private\nkey.\nThis provides end-to-end encryption and message integrity.\n\nHowever, this is only *one* layer of protection.\nIn particular, the encryption and integrity ***ends*** at the\npoint in the software where the BOLT8 decryption and integrity\nvalidation is done.\n\nModern software can be very complex and may send various\ninformation to various sub-components.\nPlaintexts of the messages after the end-to-end encrypted\nintegrity tunnel would be sent around and possibly have\nmultiple copies in transit from one part of the software to\nthe part which actually implements the protocol that uses\nprivate key handover.\nAdditional copies of private keys would be problematic as it\nincreases the surface area for private key exfiltration.\n\nAs a concrete example, the C-Lightning (also known as CLN or\nCore Lightning) implementation will send out plaintexts of\nodd-numbered messages, via pipes, to any plugins that register\nfor notification of odd-numbered messages.\nPartial security breaches may allow hackers to get at in-pipe\ndata, and various ways of running CLN plugins remotely may\nallow the odd-numbered messages to be sent via JSON-RPC\nnotifications, in plaintext, over the network.\n\nTo reduce this attack surface, our protocol can send over the\nencryption of the ephemeral private key, as follows:\n\n* Suppose that participant Alice (HTLC-offeror in the HTLC\n  use-case) wants to hand over their ephemeral private key to\n  participant Bob (HTLC-acceptor in the HTLC use-case).\n* Alice takes the ECDH of the Alice ephemeral private key and\n  the Bob ephemeral public key:\n  - Multiply Alice ephemeral private key (scalar) by Bob\n    ephemeral public key (point), resulting in a point.\n  - Format the point into the 33-byte DER format.\n  - Take the SHA256 hash of the above 33-byte DER format,\n    resulting in 32-byte hash.\n- Alice XORs the 32-byte ECDH output with the Alice ephemeral\n  private key.\n  - This is best done using an in-place XOR where the result\n    overwrites the plaintext Alice ephemeral private key, to\n    further reduce the time the plaintext copy is available\n    in-memory.\n  - After this step, Alice can safely free the memory for\n    reuse in insecure code.\n- Alice sends the XORed result to Bob (preferably in an\n  encrypted integrity tunnel, such as BOLT8).\n- Bob receives the XORed encrypted result.\n- Bob takes the ECDH of the Bob ephemeral private key and the\n  Alice ephemeral public key.\n  - This should give the same mask as above.\n- Bob XORs the 32-byte ECDH output with the encrypted private\n  key from Alice.\n  - This results in the original Alice private key.\n\nThis scheme reduces the scope of where the plaintext private\nkey is available, providing extra layers of protection in\ncontexts where it would be desirable.\n\n(The proposed scheme is only safe under the random oracle\nmodel.)\n\nWhile many implementations would not need to have the\nprotection against internal breaches of data, putting it as\npart of the protocol allows the rare implementation that\n***does*** need it to be safer.\n\nThe encryption sub-protocol requires primitives (SECP256K1\nscalar by point multiplication, 33-byte DER formatting, SHA256)\nthat are likely to be commonly needed in Bitcoin software anyway,\nso the additional implementation complexity of using encrypted\nprivate key handover is expected to be low.\n\nNon-HTLC Examples\n=================\n\nPrivate key handover is a generic building block for protocols.\nIt can be used beyond HTLCs.\n\nFor example, in the theoretical SuperScalar design, a client\nmay cooperatively exit from the LSP, by offering the entire\namount inside the SuperScalar for some equivalent onchain\namount.\nThe client can use private key handover for the keys it used\ninside the SuperScalar in the cooperative exit protocol; once\nthe server has given an onchain contract that the client can\nuse to atomically swap its in-SuperScalar funds for the\nonchain funds.\n\nIn particular, with possession of the client key after the\nclient has exited, the LSP can now arbitrarily reallocate\nliqudiity towards other clients that happen to share part\nof the SuperScalar tree with the client that exited, giving\nthe LSP extra flexibility in its liquidity management.\n\nThe only requirement is that the client use some kind of\nhardened derivation for the in-SuperScalar keys; because the\nkeys are handed over on exit, the client must ensure that\nthe handed-over private key cannot be used to derive their\nmaster private key.\nObviously, as the private key would need to be used across\nclient restarts, the client would need to store the\nderivation path for the in-SuperScalar key(s) in persistent\nstorage.\n\nEven outside of SuperScalar, a bespoke LSP-client protocol\ncan allow for a form of cooperative exit where the LSP can\nsign the channel output fund unilaterally, in exchange for\nthe equivalent amount of client funds in an onchain TXO.\nThis allows the LSP to batch multiple cooperative exits:\n\n* The client that wants to exit offers the entire funds of\n  the channel with the LSP, swapping it for onchain funds\n  from the LSP.\n  - The LSP can batch the onchain funds it offers into the\n    swap with other operations.\n  - After the swap, the client hands over their private key\n    to the channel.\n    The LSP can now unilaterally sign for that channel, and\n    can batch the spend of the channel to recover its funds\n    with other operations.\n\nIf the LSP has enough onchain churn (e.g. if it is also\noperating other onchain businesses, such as a Lightning-onchain\nswap service, or operating as an exchange at enough scale to\nuse onchain operations), the ability to freely batch the above\noperations with others can provide actual blockspace savings.\n\nAgain, the only requirement is that the client use some kind\nof hardened derivation for the channel signing keys.\n\nNon-Taproot Usage\n=================\n\nOf note is that while ***true*** MuSig2 signing, where there\nis no private key handover, is only possible with Schnorr\nsignatures, if private key handover is done, you can use a\nMuSig2 sum of public keys with ECDSA.\n\nAfter private key handover, the beneficiary can compute the\ncorresponding private key of the MuSig2 sum.\nThu, even if ECDSA is not linear, the beneficiary can still\ncompute the equivalent private key anyway.\n\nThe major drawback for ECDSA usage is that there is no ECDSA\naddress that *also* has Taproot.\nThus, you would need to expose an additional public key in\nthe single SCRIPT, which may very well cancel out any\nblockspace savings.\nNevertheless, it is still quite possible to use private key\nhandover for additional flexibility and the ability to RBF\nand batch arbitrarily, even without blockspace savings.\n\n(It should be noted that the last example in the previous\nsection --- bespoke LSP-client cooperative exit protocol\nwhere the LSP gets the flexibility to batch with other\noperations --- would, today, be using ECDSA.)",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 104,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "Subject: Private Key Handover \n<a name=\"p-6214-introduction-1\" class=\"anchor\" href=\"#p-6214-introduction-1\"></a>Introduction\nThere are protocols where, at the end of the protocol, semantically,\nsome lump fund which was previously shared by two or more\nparticipants, is now owned by only one of the participants. \nFor example, an onchain HTLC starts with two participants: the offer&hellip;",
  "truncated": true,
  "post_url": "/t/private-key-handover/2098/1",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}