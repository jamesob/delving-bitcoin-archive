{
  "id": 6198,
  "name": "",
  "username": "Julian",
  "avatar_template": "/letter_avatar_proxy/v4/letter/j/74df32/{size}.png",
  "created_at": "2025-11-07T15:14:37.127Z",
  "cooked": "<p>Hello everyone interested in Great Script Restoration and the Varops Budget,</p>\n<p>The main concerns that led to the disabling of many opcodes in v0.3.1 were denial-of-service attacks through excessive computational time and memory usage in Bitcoin script execution. To mitigate these risks, we propose to generalize the sigops budget in a new Tapscript leaf version and apply it to all operations before attempting to restore any computationally expensive operations or lifting any other script limits.</p>\n<p>Similar to the sigops budget (which is applied to each input individually), the varops budget is based on transaction weight, a larger transaction has proportionally more compute units available. Currently, the budget is set to 5,200 units per weight unit of the transaction.</p>\n<p>To validate that this approach is working and that the free parameters are reasonable, we need to understand how it constrains script execution and what the worst-case scripts are.</p>\n<p>=== Benchmark Methodology ===</p>\n<p>For simplicity, we benchmark the script evaluation of block sized scripts with the goal of finding the slowest possible script to validate. This block sized script is limited by:</p>\n<p>- Size: 4M weight units</p>\n<p>- Varops budget: 20.8B compute units (4M \u00d7 5,200)</p>\n<p>To construct and execute such a large script, it must be looped until one of the two limits is exhausted. For example, a loop of OP_DUP OP_DROP would take an initial stack element and benchmark the copying and dropping repeatedly until either the maximum size or the varops budget is reached. Computationally intensive operations like arithmetic or hashing on large numbers are generally bound by the varops budget, while faster operations like stack manipulation or arithmetic on small numbers are bound by the block size limit.</p>\n<p>For simple operations like hashing (1 in \u2192 1 out), we create a loop like:</p>\n<pre><code>OP_SHA256 OP_DROP OP_DUP (repeated)\n</code></pre>\n<p>Other operations have different restoration patterns. For bit operations (2 in \u2192 1 out):</p>\n<pre><code>OP_DUP OP_AND OP_DROP OP_DUP (repeated)\n</code></pre>\n<p>These scripts act on initial stack elements of various sizes. The initial elements are placed onto the stack \u201cfor free\u201d for simplicity and to make the budget more conservative. In reality, these elements would need to be pushed onto the stack first, consuming additional space and varops budget.</p>\n<p>=== Baseline: Signature Validation ===</p>\n<p>Currently, the theoretical limit for sigops in one block is:</p>\n<pre><code>4M weight units / 50 weight units per sig = 80,000 signature checks per block\n</code></pre>\n<p>Using nanobench, we measure how long it takes to execute pubkey.VerifySchnorr(sighash, sig) 80,000 times. On a modern CPU, this takes between one and two seconds.</p>\n<p>If we want the varops budget to limit script execution time to be no slower than the worst case signature validation time, we need to collect benchmarks from various machines and architectures. This is especially important for hashing operations, where computational time does not scale linearly and depends on the implementation, which varies between chips and architectures.</p>\n<p>The varops cost of each opcode depends on the length of its arguments and how it acts on the data; whether it copies, compares, moves, performs hashing, or does arithmetic. More details can be found in the BIP: <a href=\"https://github.com/rustyrussell/bips/blob/guilt/varops/bip-unknown-varops-budget.mediawiki\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">bips/bip-unknown-varops-budget.mediawiki at guilt/varops \u00b7 rustyrussell/bips \u00b7 GitHub</a></p>\n<p>=== How to Help ===</p>\n<p>To collect more data, we would like to run benchmarks on various machines. You can run the benchmark by:</p>\n<p>1. Checking out the GSR prototype implementation branch:</p>\n<p><a href=\"https://github.com/jmoik/bitcoin/tree/gsr\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">GitHub - jmoik/bitcoin at gsr</a></p>\n<p>2. Compiling with benchmarks enabled (-DBUILD_BENCH=ON)</p>\n<p>3. Running the benchmark:</p>\n<p>./build/bin/bench_varops --file bench_varops_data.csv</p>\n<p>This will store the results in a csv and predict a maximum value for the varops budget specifically for your machine depending on your Schnorr checksig times and the slowest varops limited script. It would be very helpful if you shared your results so we can analyze the data across different systems and verify if the budget is working well or has to be adjusted!</p>\n<p>Cheers</p>\n<p>Julian</p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 1,
  "updated_at": "2025-11-07T15:14:37.127Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 1,
  "reads": 11,
  "readers_count": 10,
  "score": 6.6,
  "yours": false,
  "topic_id": 2094,
  "topic_slug": "benchmarking-bitcoin-script-evaluation-for-the-varops-budget-great-script-restoration",
  "topic_title": "Benchmarking Bitcoin Script Evaluation for the Varops Budget (Great Script Restoration)",
  "topic_html_title": "Benchmarking Bitcoin Script Evaluation for the Varops Budget (Great Script Restoration)",
  "category_id": 7,
  "display_username": "",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Hello everyone interested in Great Script Restoration and the Varops Budget,\n\nThe main concerns that led to the disabling of many opcodes in v0.3.1 were denial-of-service attacks through excessive computational time and memory usage in Bitcoin script execution. To mitigate these risks, we propose to generalize the sigops budget in a new Tapscript leaf version and apply it to all operations before attempting to restore any computationally expensive operations or lifting any other script limits.\n\nSimilar to the sigops budget (which is applied to each input individually), the varops budget is based on transaction weight, a larger transaction has proportionally more compute units available. Currently, the budget is set to 5,200 units per weight unit of the transaction.\n\nTo validate that this approach is working and that the free parameters are reasonable, we need to understand how it constrains script execution and what the worst-case scripts are.\n\n=== Benchmark Methodology ===\n\nFor simplicity, we benchmark the script evaluation of block sized scripts with the goal of finding the slowest possible script to validate. This block sized script is limited by:\n\n\\- Size: 4M weight units\n\n\\- Varops budget: 20.8B compute units (4M \u00d7 5,200)\n\nTo construct and execute such a large script, it must be looped until one of the two limits is exhausted. For example, a loop of OP_DUP OP_DROP would take an initial stack element and benchmark the copying and dropping repeatedly until either the maximum size or the varops budget is reached. Computationally intensive operations like arithmetic or hashing on large numbers are generally bound by the varops budget, while faster operations like stack manipulation or arithmetic on small numbers are bound by the block size limit.\n\nFor simple operations like hashing (1 in \u2192 1 out), we create a loop like:\n\n    OP_SHA256 OP_DROP OP_DUP (repeated)\n\nOther operations have different restoration patterns. For bit operations (2 in \u2192 1 out):\n\n    OP_DUP OP_AND OP_DROP OP_DUP (repeated)\n\nThese scripts act on initial stack elements of various sizes. The initial elements are placed onto the stack \"for free\" for simplicity and to make the budget more conservative. In reality, these elements would need to be pushed onto the stack first, consuming additional space and varops budget.\n\n=== Baseline: Signature Validation ===\n\nCurrently, the theoretical limit for sigops in one block is:\n\n    4M weight units / 50 weight units per sig = 80,000 signature checks per block\n\nUsing nanobench, we measure how long it takes to execute pubkey.VerifySchnorr(sighash, sig) 80,000 times. On a modern CPU, this takes between one and two seconds.\n\nIf we want the varops budget to limit script execution time to be no slower than the worst case signature validation time, we need to collect benchmarks from various machines and architectures. This is especially important for hashing operations, where computational time does not scale linearly and depends on the implementation, which varies between chips and architectures.\n\nThe varops cost of each opcode depends on the length of its arguments and how it acts on the data; whether it copies, compares, moves, performs hashing, or does arithmetic. More details can be found in the BIP: https://github.com/rustyrussell/bips/blob/guilt/varops/bip-unknown-varops-budget.mediawiki\n\n=== How to Help ===\n\nTo collect more data, we would like to run benchmarks on various machines. You can run the benchmark by:\n\n1\\. Checking out the GSR prototype implementation branch:\n\n   https://github.com/jmoik/bitcoin/tree/gsr\n\n2\\. Compiling with benchmarks enabled (-DBUILD_BENCH=ON)\n\n3\\. Running the benchmark:\n\n   ./build/bin/bench_varops --file bench_varops_data.csv\n\nThis will store the results in a csv and predict a maximum value for the varops budget specifically for your machine depending on your Schnorr checksig times and the slowest varops limited script. It would be very helpful if you shared your results so we can analyze the data across different systems and verify if the budget is working well or has to be adjusted!\n\nCheers\n\nJulian",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 962,
  "hidden": false,
  "trust_level": 0,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "Hello everyone interested in Great Script Restoration and the Varops Budget, \nThe main concerns that led to the disabling of many opcodes in v0.3.1 were denial-of-service attacks through excessive computational time and memory usage in Bitcoin script execution. To mitigate these risks, we propose to&hellip;",
  "truncated": true,
  "post_url": "/t/benchmarking-bitcoin-script-evaluation-for-the-varops-budget-great-script-restoration/2094/1",
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}