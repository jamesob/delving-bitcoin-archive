{
  "id": 6293,
  "name": "Jonathan Harvey-Buschel",
  "username": "jonhbit",
  "avatar_template": "/user_avatar/delvingbitcoin.org/jonhbit/{size}/1661_2.png",
  "created_at": "2025-11-19T22:31:51.685Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"gmaxwell\" data-post=\"3\" data-topic=\"2105\" data-full=\"true\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/letter_avatar_proxy/v4/letter/g/fbc32d/48.png\" class=\"avatar\"> gmaxwell:</div>\n<blockquote>\n<p>Minisketch has superlinear decoding costs, so decoding huge sketches will burn up a lot of CPU.   One could reconcile more often to try to fight this, but every reconcile will imply some communication overheads since you\u2019ll overshoot the unknown needed amount for a reconstruction.</p>\n<p>The flooding in the erlay has the advantage that takes the bulk of the load off the sketch and lets the sketch fill in the small omissions which it\u2019s good at doing.</p>\n</blockquote>\n</aside>\n<p>I missed that benefit of the flooding in Erlay on my previous reads of the paper; that makes sense.</p>\n<aside class=\"quote no-group\" data-username=\"gmaxwell\" data-post=\"3\" data-topic=\"2105\" data-full=\"true\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/letter_avatar_proxy/v4/letter/g/fbc32d/48.png\" class=\"avatar\"> gmaxwell:</div>\n<blockquote>\n<p>If you were to use reconciliation only you might be better off using iblt instead of minisketch (maybe plus a very small minisketch to unjam stuck IBLT decodes).   The overheads of iblt are much worse but that may be less significant if you\u2019re running all the traffic through it.</p>\n</blockquote>\n</aside>\n<p>This opened a rabbit hole that actually led me to a very recent paper proposing an IBLT-based set reconciliation protocol, that may be well-suited for this use case.</p>\n<p>Firstly, the CPISync implementation used for benchmarks in the Minisketch repo has moved and expanded to include some new protocols:</p>\n<aside class=\"onebox githubrepo\" data-onebox-src=\"https://github.com/nislab/gensync\">\n  <header class=\"source\">\n\n      <a href=\"https://github.com/nislab/gensync\" target=\"_blank\" rel=\"noopener nofollow ugc\">github.com</a>\n  </header>\n\n  <article class=\"onebox-body\">\n    <div class=\"github-row\" data-github-private-repo=\"false\">\n  <img width=\"690\" height=\"344\" src=\"https://delvingbitcoin.org/uploads/default/optimized/2X/f/f84b508b3e731292ae78eb381704ee2887037750_2_690x344.png\" class=\"thumbnail\" data-dominant-color=\"F7F6F7\">\n\n  <h3><a href=\"https://github.com/nislab/gensync\" target=\"_blank\" rel=\"noopener nofollow ugc\">GitHub - nislab/gensync: A new framework for benchmarking and optimizing...</a></h3>\n\n    <p><span class=\"github-repo-description\">A new framework for benchmarking and optimizing reconciliation of data.</span></p>\n</div>\n\n  </article>\n\n  <div class=\"onebox-metadata\">\n    \n    \n  </div>\n\n  <div style=\"clear: both\"></div>\n</aside>\n\n<p>There is a related paper that explores some of the tradeoffs of sync with Cuckoo filters vs. CPI vs. IBLT:</p>\n<aside class=\"onebox allowlistedgeneric\" data-onebox-src=\"https://arxiv.org/abs/2303.17530\">\n  <header class=\"source\">\n      <img src=\"https://delvingbitcoin.org/uploads/default/original/2X/7/7737f9c766957e34da6871902e1e7a9d2aca40f3.png\" class=\"site-icon\" alt=\"\" data-dominant-color=\"B36362\" width=\"32\" height=\"32\">\n\n      <a href=\"https://arxiv.org/abs/2303.17530\" target=\"_blank\" rel=\"noopener nofollow ugc\">arXiv.org</a>\n  </header>\n\n  <article class=\"onebox-body\">\n    <div class=\"aspect-image\" style=\"--aspect-ratio:690/402;\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/2X/c/cd49b65780faf86c14ed9761c9c522acfb73adde_2_500x500.png\" class=\"thumbnail\" alt=\"\" data-dominant-color=\"865F5C\" width=\"500\" height=\"500\"></div>\n\n<h3><a href=\"https://arxiv.org/abs/2303.17530\" target=\"_blank\" rel=\"noopener nofollow ugc\">Enabling Cost-Benefit Analysis of Data Sync Protocols</a></h3>\n\n  <p>The problem of data synchronization arises in networked applications that require some measure of consistency. Indeed data synchronization approaches have demonstrated a significant potential for improving performance in various applications ranging...</p>\n\n\n  </article>\n\n  <div class=\"onebox-metadata\">\n    \n    \n  </div>\n\n  <div style=\"clear: both\"></div>\n</aside>\n\n<p>Cuckoo filters looked interesting, but IIUC don\u2019t fit our use case well since a participant learns which elements their counterparty is missing, not the opposite (which elements they should request). The bandwidth used also seems to have a high floor. Outside of that, the benchmarks focus on much larger sets than what\u2019s relevant in the LN Gossip (or Erlay) setting.</p>\n<p>I never looked at the MET-IBLT paper; it seems like a better IBLT sync scheme, but with no benefits compared to RIBLT.</p>\n<p>Looking into cuckoo filters eventually led me to this paper, Rateless IBLT (RIBLT):</p>\n<aside class=\"onebox allowlistedgeneric\" data-onebox-src=\"https://arxiv.org/abs/2402.02668\">\n  <header class=\"source\">\n      <img src=\"https://delvingbitcoin.org/uploads/default/original/2X/7/7737f9c766957e34da6871902e1e7a9d2aca40f3.png\" class=\"site-icon\" alt=\"\" data-dominant-color=\"B36362\" width=\"32\" height=\"32\">\n\n      <a href=\"https://arxiv.org/abs/2402.02668\" target=\"_blank\" rel=\"noopener nofollow ugc\">arXiv.org</a>\n  </header>\n\n  <article class=\"onebox-body\">\n    <div class=\"aspect-image\" style=\"--aspect-ratio:690/402;\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/2X/c/cd49b65780faf86c14ed9761c9c522acfb73adde_2_500x500.png\" class=\"thumbnail\" alt=\"\" data-dominant-color=\"865F5C\" width=\"500\" height=\"500\"></div>\n\n<h3><a href=\"https://arxiv.org/abs/2402.02668\" target=\"_blank\" rel=\"noopener nofollow ugc\">Practical Rateless Set Reconciliation</a></h3>\n\n  <p>Set reconciliation, where two parties hold fixed-length bit strings and run a protocol to learn the strings they are missing from each other, is a fundamental task in many distributed systems. We present Rateless Invertible Bloom Lookup Tables...</p>\n\n\n  </article>\n\n  <div class=\"onebox-metadata\">\n    \n    \n  </div>\n\n  <div style=\"clear: both\"></div>\n</aside>\n\n<p>Which seems very promising. They even used the Minisketch library in their benchmarks! <em>And</em> there is a public implementation in Golang (+ impls in C++ and Rust linked in the README):</p>\n<aside class=\"onebox githubrepo\" data-onebox-src=\"https://github.com/yangl1996/riblt\">\n  <header class=\"source\">\n\n      <a href=\"https://github.com/yangl1996/riblt\" target=\"_blank\" rel=\"noopener nofollow ugc\">github.com</a>\n  </header>\n\n  <article class=\"onebox-body\">\n    <div class=\"github-row\" data-github-private-repo=\"false\">\n  <img width=\"690\" height=\"344\" src=\"https://delvingbitcoin.org/uploads/default/optimized/2X/3/368311ca9ec6a914c8ea57b960f91c56953f87ca_2_690x344.png\" class=\"thumbnail\" data-dominant-color=\"E9EEEF\">\n\n  <h3><a href=\"https://github.com/yangl1996/riblt\" target=\"_blank\" rel=\"noopener nofollow ugc\">GitHub - yangl1996/riblt: Go implementation of Rateless IBLTs.</a></h3>\n\n    <p><span class=\"github-repo-description\">Go implementation of Rateless IBLTs.</span></p>\n</div>\n\n  </article>\n\n  <div class=\"onebox-metadata\">\n    \n    \n  </div>\n\n  <div style=\"clear: both\"></div>\n</aside>\n\n<p>The main math &amp; explanation is in Section 4, with comparison to alternatives in Section 7.</p>\n<p>As a tl;dr:</p>\n<ul>\n<li>\n<p>To make an IBLT rateless / an infinite stream of coded symbols, we can extend a mostly-normal IBLT s.t. later coded symbols map to fewer and fewer inputs. If we have an efficient function to compute the indices of coded symbols an input must contribute to, we can encode our table efficiently even as the set size grows.</p>\n</li>\n<li>\n<ul>\n<li>We can also extend the table incrementally, and send extensions until decoding succeeds, so we don\u2019t need to estimate the set difference nor regenerate the IBLT if decode fails (similar to extending a Minisketch) (the paper doesn\u2019t comment much on partial recovery, but Figure 6 has some simulation results related to this).</li>\n</ul>\n</li>\n<li>\n<p>The bandwidth overhead seems to have a ceiling of ~1.75, even for sets with very few differences; it converges to ~1.35 as differences increase past 100, which seems significantly better than standard IBLT? (Figure 5).</p>\n</li>\n<li>\n<p>For both large and small set differences (1-1000), encoding cost grows linearly (Figure 8) This also holds for total set size (FIgure 10). Worth noting that the ratio (set_differences)/(set_size) is quite small in most of their benchmarks.</p>\n</li>\n<li>\n<p>Most of their benchmarks use an element size of 64 bits. IIUC the bandwidth overhead could be significantly reduced if an implementation was optimized for small sets and smaller elements; there are some relevant notes in Sections 7.1 and 7.2.</p>\n</li>\n</ul>\n<p>If these performance properties hold up, I agree that mixing frequent IBLT-based syncs + infrequent Minisketch usage is appealing. It may also be worth skipping Minisketch entirely and trade bandwidth overhead for the CPU savings; I\u2019m not sure how LN implementations feel about that tradeoff tbh.</p>\n<p>Another consideration is that the elements we want to exchange are very small (average message size &lt;275 bytes), so there isn\u2019t much room to add bandwidth overhead. These messages will still be small with gossip v2.</p>\n<p>Being able to have larger (64+ bit) elements with only a small increased CPU cost (FIgure 11) may be a very significant benefit; I\u2019ll take a look at these implementations soon and report back.</p>",
  "post_number": 4,
  "post_type": 1,
  "posts_count": 6,
  "updated_at": "2025-11-19T22:36:32.299Z",
  "reply_count": 1,
  "reply_to_post_number": 3,
  "quote_count": 1,
  "incoming_link_count": 0,
  "reads": 15,
  "readers_count": 14,
  "score": 7.8,
  "yours": false,
  "topic_id": 2105,
  "topic_slug": "gossip-observer-new-project-to-monitor-the-lightning-p2p-network",
  "topic_title": "Gossip Observer: New project to monitor the Lightning P2P network",
  "topic_html_title": "Gossip Observer: New project to monitor the Lightning P2P network",
  "category_id": 7,
  "display_username": "Jonathan Harvey-Buschel",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"gmaxwell, post:3, topic:2105, full:true\"]\nMinisketch has superlinear decoding costs, so decoding huge sketches will burn up a lot of CPU.   One could reconcile more often to try to fight this, but every reconcile will imply some communication overheads since you\u2019ll overshoot the unknown needed amount for a reconstruction.\n\nThe flooding in the erlay has the advantage that takes the bulk of the load off the sketch and lets the sketch fill in the small omissions which it\u2019s good at doing.\n[/quote]\n\nI missed that benefit of the flooding in Erlay on my previous reads of the paper; that makes sense.\n\n[quote=\"gmaxwell, post:3, topic:2105, full:true\"]\nIf you were to use reconciliation only you might be better off using iblt instead of minisketch (maybe plus a very small minisketch to unjam stuck IBLT decodes).   The overheads of iblt are much worse but that may be less significant if you\u2019re running all the traffic through it.\n[/quote]\n\nThis opened a rabbit hole that actually led me to a very recent paper proposing an IBLT-based set reconciliation protocol, that may be well-suited for this use case.\n\nFirstly, the CPISync implementation used for benchmarks in the Minisketch repo has moved and expanded to include some new protocols:\n\nhttps://github.com/nislab/gensync\n\nThere is a related paper that explores some of the tradeoffs of sync with Cuckoo filters vs. CPI vs. IBLT:\n\nhttps://arxiv.org/abs/2303.17530\n\nCuckoo filters looked interesting, but IIUC don't fit our use case well since a participant learns which elements their counterparty is missing, not the opposite (which elements they should request). The bandwidth used also seems to have a high floor. Outside of that, the benchmarks focus on much larger sets than what's relevant in the LN Gossip (or Erlay) setting.\n\nI never looked at the MET-IBLT paper; it seems like a better IBLT sync scheme, but with no benefits compared to RIBLT.\n\nLooking into cuckoo filters eventually led me to this paper, Rateless IBLT (RIBLT):\n\nhttps://arxiv.org/abs/2402.02668\n\nWhich seems very promising. They even used the Minisketch library in their benchmarks! _And_ there is a public implementation in Golang (+ impls in C++ and Rust linked in the README):\n\nhttps://github.com/yangl1996/riblt\n\nThe main math & explanation is in Section 4, with comparison to alternatives in Section 7.\n\nAs a tl;dr:\n\n- To make an IBLT rateless / an infinite stream of coded symbols, we can extend a mostly-normal IBLT s.t. later coded symbols map to fewer and fewer inputs. If we have an efficient function to compute the indices of coded symbols an input must contribute to, we can encode our table efficiently even as the set size grows.\n- - We can also extend the table incrementally, and send extensions until decoding succeeds, so we don't need to estimate the set difference nor regenerate the IBLT if decode fails (similar to extending a Minisketch) (the paper doesn't comment much on partial recovery, but Figure 6 has some simulation results related to this).\n\n- The bandwidth overhead seems to have a ceiling of ~1.75, even for sets with very few differences; it converges to ~1.35 as differences increase past 100, which seems significantly better than standard IBLT? (Figure 5).\n\n- For both large and small set differences (1-1000), encoding cost grows linearly (Figure 8) This also holds for total set size (FIgure 10). Worth noting that the ratio (set_differences)/(set_size) is quite small in most of their benchmarks.\n\n- Most of their benchmarks use an element size of 64 bits. IIUC the bandwidth overhead could be significantly reduced if an implementation was optimized for small sets and smaller elements; there are some relevant notes in Sections 7.1 and 7.2.\n\nIf these performance properties hold up, I agree that mixing frequent IBLT-based syncs + infrequent Minisketch usage is appealing. It may also be worth skipping Minisketch entirely and trade bandwidth overhead for the CPU savings; I'm not sure how LN implementations feel about that tradeoff tbh. \n\nAnother consideration is that the elements we want to exchange are very small (average message size <275 bytes), so there isn't much room to add bandwidth overhead. These messages will still be small with gossip v2.\n\nBeing able to have larger (64+ bit) elements with only a small increased CPU cost (FIgure 11) may be a very significant benefit; I'll take a look at these implementations soon and report back.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 982,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "I missed that benefit of the flooding in Erlay on my previous reads of the paper; that makes sense. \n\nThis opened a rabbit hole that actually led me to a very recent paper proposing an IBLT-based set reconciliation protocol, that may be well-suited for this use case. \nFirstly, the CPISync implement&hellip;",
  "truncated": true,
  "post_url": "/t/gossip-observer-new-project-to-monitor-the-lightning-p2p-network/2105/4",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}