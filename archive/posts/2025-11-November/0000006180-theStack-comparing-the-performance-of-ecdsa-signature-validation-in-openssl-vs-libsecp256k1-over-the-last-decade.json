{
  "id": 6180,
  "name": "Sebastian Falbesoner",
  "username": "theStack",
  "avatar_template": "/user_avatar/delvingbitcoin.org/thestack/{size}/420_2.png",
  "created_at": "2025-11-01T03:02:56.504Z",
  "cooked": "<h2><a name=\"p-6180-introduction-1\" class=\"anchor\" href=\"#p-6180-introduction-1\"></a>Introduction</h2>\n<p>With the upcoming release of v31.0 in spring next year, Bitcoin Core will celebrate its ten-year anniversary of replacing <a href=\"https://github.com/openssl/openssl\">OpenSSL</a> with <a href=\"https://github.com/bitcoin-core/secp256k1\">libsecp256k1</a> for ECDSA signature validation in consensus code. Having researched a bit on early history in this topic recently, I thought this might be a good moment to take a closer look on how the performance has evolved over time for these two libraries. At the time the corresponding patch (<a href=\"https://github.com/bitcoin/bitcoin/pull/6954\">#6954</a>) was merged in November 2015 (released in v0.12 a few months later), signature validation using libsecp256k1 was <em>\u201canywhere between 2.5 and 5.5 times faster\u201d</em> [than OpenSSL] according to its PR author and libsecp256k1 creator Pieter Wuille. That\u2019s very impressive already, but as we will see throughout the post, the libsecp256k1 wizards didn\u2019t stop there and continuously shipped incremental performance improvements over the years. In some sense one could claim that a comparison between the two projects is not a completely fair one to begin with, since the scope of OpenSSL is arguably quite different; with the library describing itself as being a \u201cfull-featured toolkit for general-purpose cryptography\u201d, it includes a large suite of cryptographic primitives, with support for a very wide range of applications. Still, it\u2019s not unreasonable to assume that OpenSSL might have caught up a bit and implemented some performance improvements for elliptic curve cryptography, and it\u2019s nevertheless interesting to know how the performance gap evolved over time. To the best of my knowledge, since the switchover to libsecp256k1, no concrete investigations have been done how fast ECDSA signature verification would be today, imagining a hypothetical scenario that we would have sticked to OpenSSL.</p>\n<h2><a name=\"p-6180-methodology-2\" class=\"anchor\" href=\"#p-6180-methodology-2\"></a>Methodology</h2>\n<p>In order to quantify speed improvements between versions and across different libraries, we need a proper method for benchmarking, ideally one that is as generic and extensible as possible. One idea I found compelling was to do this involving dynamic loading. In a first preparatory step that involves some light shell scripting, all the relevant versions of both OpenSSL and libsecp256k1 are fetched and built to emit a shared library (.so file) each. The actual benchmark is then done with a single binary, which would load in one shared library after another and resolve the corresponding library function addresses at run-time, using the interface functions of the dynamic loading linker (see <a href=\"https://man7.org/linux/man-pages/man3/dlopen.3.html\">dlopen(3)</a>, <a href=\"https://man7.org/linux/man-pages/man3/dlsym.3.html\">dlsym(3)</a>). Each loop iteration involves the following three steps for each (signature, 32-bytes msghash, 33-bytes compressed pubkey) input triplet:</p>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th>step description</th>\n<th>function in OpenSSL</th>\n<th>function in libsecp256k1</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>parse compressed public key</td>\n<td><code>o2i_ECPublicKey</code></td>\n<td><code>secp256k1_ec_pubkey_parse</code></td>\n<td></td>\n</tr>\n<tr>\n<td>parse DER-encoded signature</td>\n<td>(included in call below)</td>\n<td><code>secp256k1_ecdsa_signature_parse_der</code></td>\n<td></td>\n</tr>\n<tr>\n<td>verify ECDSA signature</td>\n<td><code>ECDSA_verify</code></td>\n<td><code>secp256k1_ecdsa_verify</code></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div><p>The benchmark input data, i.e. for this scenario a list of pseudo-random key pairs, messages, and signatures, is notably created with a <em>statically</em> linked version of libsecp256k1 with the same binary before the actual benchmarks are executed for each version.</p>\n<p>Implementing this was actually quite straight-forward and surprisingly painless, especially making things work on the OpenSSL side which\nI was less familiar with. Throughout all the OpenSSL versions since 0.9.8h [1] up to 3.5.0, doing a default build of a shared library involved the same commands (<code>./config shared &amp;&amp; make</code>), and the used\nAPI remained stable since the beginning (though being deprecated now for while), so no individual treatment for different versions was needed. Same for libsecp256k1. The most tedious part was probably finding out which concrete library commit was used in which Bitcoin Core release, considering that there were no tagged releases available <a href=\"https://gnusha.org/pi/bitcoindev/v-5cMoyHzxi0ZUUECBV_l_87TwzxBXr7-aIMrjC5taolnlKi256ZFnoH6EGw4MpvwVwAJkBwhPToRfSp1DFK314O7edTwjKndQ0azBRGfgI=@wuille.net/t/\">until December 2022</a>.</p>\n<h2><a name=\"p-6180-demo-3\" class=\"anchor\" href=\"#p-6180-demo-3\"></a>Demo</h2>\n<p>The source code is available on GitHub: <a href=\"https://github.com/theStack/secp256k1-plugbench\" class=\"inline-onebox\">GitHub - theStack/secp256k1-plugbench: Benchmarking different secp256k1 versions and implementations using dynamic loading</a>, you can see a quick demo of it being in action here:</p>\n<p><a href=\"https://asciinema.org/a/752929\"><img src=\"https://delvingbitcoin.org/uploads/default/original/2X/1/19ca9f7e97617fd01fc1e223f4c688d3309180a8.svg\" alt=\"asciicast\" data-base62-sha1=\"3Ga3nQyzyiTPaDEJ504LDV6PlXy\" width=\"80\" height=\"80\"></a></p>\n<p>(Note that building all the library versions took significantly longer than shown; that preparation part in the recording has been speed up by ~30x using <a href=\"https://asciinema-trim\">https://github.com/suzuki-shunsuke/asciinema-trim</a>).</p>\n<p>I\u2019d encourage everyone to give it a try on their machine (given they run Linux or a similar UNIX-like OS that works with .so files)</p>\n<pre><code class=\"lang-auto\">$ git clone https://github.com/theStack/secp256k1-plugbench\n$ cd secp256k1-plugbench\n$ ./build_libs.sh &amp;&amp; make &amp;&amp; ./secp-plugbench results.csv\n</code></pre>\n<p>and report the results, especially if they are somehow unexpected or much different and what my sample run yielded. Also, feel free to open an issue or pull request if something doesn\u2019t work as expected or could be improved.</p>\n<h2><a name=\"p-6180-results-and-analysis-4\" class=\"anchor\" href=\"#p-6180-results-and-analysis-4\"></a>Results and analysis</h2>\n<p>The following bar plot shows the benchmark results on my arm64 machine [2], using gcc 14.2.0  (some versions were skipped for better visibility):</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/2X/8/82628dac1cf446554e596ac687fdf6961f045311.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/82628dac1cf446554e596ac687fdf6961f045311\" title=\"openssl_libsecp256k1_bench_results\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/2X/8/82628dac1cf446554e596ac687fdf6961f045311_2_690x230.png\" alt=\"openssl_libsecp256k1_bench_results\" data-base62-sha1=\"iBrdGZ99e05OLPltOlfYeirKcP7\" width=\"690\" height=\"230\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/2X/8/82628dac1cf446554e596ac687fdf6961f045311_2_690x230.png, https://delvingbitcoin.org/uploads/default/optimized/2X/8/82628dac1cf446554e596ac687fdf6961f045311_2_1035x345.png 1.5x, https://delvingbitcoin.org/uploads/default/optimized/2X/8/82628dac1cf446554e596ac687fdf6961f045311_2_1380x460.png 2x\" data-dominant-color=\"E2D5D6\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">openssl_libsecp256k1_bench_results</span><span class=\"informations\">1800\u00d7600 26.6 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>It\u2019s clearly visible that in OpenSSL, the runtime for ECDSA signature verification on the\ncurve secp256k1 hasn\u2019t changed, while libsecp256k1 improved steadily,\nleading to an increasing performance gap over time between the two libraries.</p>\n<p>The two largest speedups between libsecp256k1 versions can be primarily attributed to the following changes in the implementation:</p>\n<ul>\n<li>bc-0.20 (~28% speedup to bc-0.19): enabling of the GLV endomorphism optimization (implemented very early in libsecp256k1 [3] since it was one of the motivations to start the project in the fist place, but disabled for many years due to potential patent violation issues, see\n<a href=\"https://patents.google.com/patent/US7110538B2/en\">US7110538B2</a>), <a href=\"https://github.com/bitcoin-core/secp256k1/pull/830\">PR #830</a></li>\n<li>bc-22.0 (~30% speedup to bc-0.20): introduction of safegcd-based\nmodular inverses (PRs <a href=\"https://github.com/bitcoin-core/secp256k1/pull/831\">#831</a>, <a href=\"https://github.com/bitcoin-core/secp256k1/pull/906\">#906</a>); this speedup is significantly higher than the stated 15-17% in the Core PR <a href=\"https://github.com/bitcoin/bitcoin/pull/21573\">#21573</a>, so there might have been other significant improvements as well?</li>\n</ul>\n<p>Note that the benchmarks only measure libsecp256k1 built with defaults,\nnot taking into account any potential special configuration settings or compile\nflags that Bitcoin Core might have set, so the numbers\nmight not fully reflect what went into a certain release.</p>\n<p>Having run this on three different machines with very similar results, I think it\u2019s safe to state that libsecp256k1 is more than 8x faster than OpenSSL for verifying ECDSA signatures on the\nsecp256k1 curve using the respective latest versions. Note that it would be misleading to conclude from these results that OpenSSL is slow in general and/or not open for performance improvements.\nFor example, the implementation of the curve secp256<strong>r1</strong> [4] seems to be heavily heavily optimized, according to <a href=\"https://github.com/openssl/openssl/issues/23524\">an issue mentioning the speed differences between secp256k1 and secp256r1</a>.  So a more proper conclusion might be here that\noutside of the Bitcoin ecosystem, the secp256k1 is just not that relevant and doesn\u2019t count as first-class citizen that would justify spending\na lot of labor hours in a general-purpose cryptographic library. That said, last year\nthere was actually a PR opened in the OpenSSL repository that aims to improve the speed\nof operations on the secp256k1 curve: <a href=\"https://github.com/openssl/openssl/pull/26097\">https://github.com/openssl/openssl/pull/26097</a>. The name mentioned in the PR title that the code is based on might sound familiar to you <img src=\"https://delvingbitcoin.org/images/emoji/twitter/slight_smile.png?v=14\" title=\":slight_smile:\" class=\"emoji\" alt=\":slight_smile:\" loading=\"lazy\" width=\"20\" height=\"20\"></p>\n<h2><a name=\"p-6180-outlook-5\" class=\"anchor\" href=\"#p-6180-outlook-5\"></a>Outlook</h2>\n<p>Doing this was a very interesting and fun mini project. I currently don\u2019t plan to put too much more effort into it, but I guess it\u2019s a good idea to\nrun the benchmark before each release of libsecp256k1 / Bitcoin Core (it\u2019s as simple as adding two lines), in order to quantify improvements and ensure\nwe don\u2019t have performance regressions. In that sense, it could even make sense to add Schnorr signature verification and functionalities from other\nmodules that are performance-critical as potential benchmarking scenarios, to comfortably track progress over the next years. Maybe someone is even motivated to add a benchmark scenario for signing.</p>\n<p>Cheers,\nSebastian</p>\n<p>[1] 0.9.8h is the first OpenSSL version explicitly mentioned in the Bitcoin Core <a href=\"https://github.com/bitcoin/bitcoin/commit/4405b78d6059e536c36974088a8ed4d9f0f29898#diff-9e6e4772050998a5c0dc3c61acf3dab0a7e594566171fa5746d6b62f9598efb6R38\">repository\u2019s first commit (having that exact subject) by sirius-m</a></p>\n<p>[2] note that calling into OpenSSL 0.9.8 and 1.0.0 led to a crash on my arm64 machine, so I skipped those; I don\u2019t know what the concrete issue is, I\u2019m assuming it could have to do with memory alignment. On x86-64, all the built versions could be benchmarked successfully.</p>\n<p>[3] see <a href=\"https://github.com/bitcoin-core/secp256k1/commit/949bea92624fbd65bfb21d773f1df6a115af71ff\" class=\"inline-onebox\">GLV optimization \u00b7 bitcoin-core/secp256k1@949bea9 \u00b7 GitHub</a> (that\u2019s only the 13th commit in the repository!)</p>\n<p>[4] the secp256r1 curve was recently discussed on the Bitcoin mailing list, see <a href=\"https://groups.google.com/g/bitcoindev/c/XSYL0gx0cDM\">https://groups.google.com/g/bitcoindev/c/XSYL0gx0cDM</a></p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 1,
  "updated_at": "2025-11-01T09:18:07.737Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 7,
  "reads": 7,
  "readers_count": 6,
  "score": 51.2,
  "yours": false,
  "topic_id": 2087,
  "topic_slug": "comparing-the-performance-of-ecdsa-signature-validation-in-openssl-vs-libsecp256k1-over-the-last-decade",
  "topic_title": "Comparing the performance of ECDSA signature validation in OpenSSL vs. libsecp256k1 over the last decade",
  "topic_html_title": "Comparing the performance of ECDSA signature validation in OpenSSL vs. libsecp256k1 over the last decade",
  "category_id": 8,
  "display_username": "Sebastian Falbesoner",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 3,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "## Introduction\n\nWith the upcoming release of v31.0 in spring next year, Bitcoin Core will celebrate its ten-year anniversary of replacing [OpenSSL](https://github.com/openssl/openssl) with [libsecp256k1](https://github.com/bitcoin-core/secp256k1) for ECDSA signature validation in consensus code. Having researched a bit on early history in this topic recently, I thought this might be a good moment to take a closer look on how the performance has evolved over time for these two libraries. At the time the corresponding patch ([#6954](https://github.com/bitcoin/bitcoin/pull/6954)) was merged in November 2015 (released in v0.12 a few months later), signature validation using libsecp256k1 was *\u201canywhere between 2.5 and 5.5 times faster\u201d* \\[than OpenSSL\\] according to its PR author and libsecp256k1 creator Pieter Wuille. That\u2019s very impressive already, but as we will see throughout the post, the libsecp256k1 wizards didn\u2019t stop there and continuously shipped incremental performance improvements over the years. In some sense one could claim that a comparison between the two projects is not a completely fair one to begin with, since the scope of OpenSSL is arguably quite different; with the library describing itself as being a \u201cfull-featured toolkit for general-purpose cryptography\u201d, it includes a large suite of cryptographic primitives, with support for a very wide range of applications. Still, it\u2019s not unreasonable to assume that OpenSSL might have caught up a bit and implemented some performance improvements for elliptic curve cryptography, and it\u2019s nevertheless interesting to know how the performance gap evolved over time. To the best of my knowledge, since the switchover to libsecp256k1, no concrete investigations have been done how fast ECDSA signature verification would be today, imagining a hypothetical scenario that we would have sticked to OpenSSL.\n\n## Methodology\n\nIn order to quantify speed improvements between versions and across different libraries, we need a proper method for benchmarking, ideally one that is as generic and extensible as possible. One idea I found compelling was to do this involving dynamic loading. In a first preparatory step that involves some light shell scripting, all the relevant versions of both OpenSSL and libsecp256k1 are fetched and built to emit a shared library (.so file) each. The actual benchmark is then done with a single binary, which would load in one shared library after another and resolve the corresponding library function addresses at run-time, using the interface functions of the dynamic loading linker (see [dlopen(3)](https://man7.org/linux/man-pages/man3/dlopen.3.html), [dlsym(3)](https://man7.org/linux/man-pages/man3/dlsym.3.html)). Each loop iteration involves the following three steps for each (signature, 32-bytes msghash, 33-bytes compressed pubkey) input triplet:\n\n| step description | function in OpenSSL | function in libsecp256k1 |  |\n|----|----|----|----|\n| parse compressed public key | `o2i_ECPublicKey` | `secp256k1_ec_pubkey_parse` |\n| parse DER-encoded signature | (included in call below) | `secp256k1_ecdsa_signature_parse_der` |  |\n| verify ECDSA signature | `ECDSA_verify` | `secp256k1_ecdsa_verify` |  |\n\nThe benchmark input data, i.e. for this scenario a list of pseudo-random key pairs, messages, and signatures, is notably created with a _statically_ linked version of libsecp256k1 with the same binary before the actual benchmarks are executed for each version.\n\nImplementing this was actually quite straight-forward and surprisingly painless, especially making things work on the OpenSSL side which\nI was less familiar with. Throughout all the OpenSSL versions since 0.9.8h [1] up to 3.5.0, doing a default build of a shared library involved the same commands (`./config shared && make`), and the used\nAPI remained stable since the beginning (though being deprecated now for while), so no individual treatment for different versions was needed. Same for libsecp256k1. The most tedious part was probably finding out which concrete library commit was used in which Bitcoin Core release, considering that there were no tagged releases available [until December 2022](https://gnusha.org/pi/bitcoindev/v-5cMoyHzxi0ZUUECBV_l_87TwzxBXr7-aIMrjC5taolnlKi256ZFnoH6EGw4MpvwVwAJkBwhPToRfSp1DFK314O7edTwjKndQ0azBRGfgI=@wuille.net/t/).\n\n## Demo\n\nThe source code is available on GitHub: https://github.com/theStack/secp256k1-plugbench, you can see a quick demo of it being in action here:\n\n[![asciicast](upload://3Ga3nQyzyiTPaDEJ504LDV6PlXy.svg)](https://asciinema.org/a/752929)\n\n(Note that building all the library versions took significantly longer than shown; that preparation part in the recording has been speed up by ~30x using [https://github.com/suzuki-shunsuke/asciinema-trim](https://asciinema-trim)).\n\nI'd encourage everyone to give it a try on their machine (given they run Linux or a similar UNIX-like OS that works with .so files)\n\n```\n$ git clone https://github.com/theStack/secp256k1-plugbench\n$ cd secp256k1-plugbench\n$ ./build_libs.sh && make && ./secp-plugbench results.csv\n```\n\nand report the results, especially if they are somehow unexpected or much different and what my sample run yielded. Also, feel free to open an issue or pull request if something doesn't work as expected or could be improved.\n\n## Results and analysis\n\nThe following bar plot shows the benchmark results on my arm64 machine [2], using gcc 14.2.0  (some versions were skipped for better visibility):\n\n![openssl_libsecp256k1_bench_results|690x230](upload://iBrdGZ99e05OLPltOlfYeirKcP7.png)\n\n\nIt\u2019s clearly visible that in OpenSSL, the runtime for ECDSA signature verification on the\ncurve secp256k1 hasn\u2019t changed, while libsecp256k1 improved steadily,\nleading to an increasing performance gap over time between the two libraries.\n\nThe two largest speedups between libsecp256k1 versions can be primarily attributed to the following changes in the implementation:\n *  bc-0.20 (~28% speedup to bc-0.19): enabling of the GLV endomorphism optimization (implemented very early in libsecp256k1 [3] since it was one of the motivations to start the project in the fist place, but disabled for many years due to potential patent violation issues, see\n[US7110538B2](https://patents.google.com/patent/US7110538B2/en)), [PR #830](https://github.com/bitcoin-core/secp256k1/pull/830)\n * bc-22.0 (~30% speedup to bc-0.20): introduction of safegcd-based\nmodular inverses (PRs [#831](https://github.com/bitcoin-core/secp256k1/pull/831), [#906](https://github.com/bitcoin-core/secp256k1/pull/906)); this speedup is significantly higher than the stated 15-17% in the Core PR [#21573](https://github.com/bitcoin/bitcoin/pull/21573), so there might have been other significant improvements as well?\n\nNote that the benchmarks only measure libsecp256k1 built with defaults,\nnot taking into account any potential special configuration settings or compile\nflags that Bitcoin Core might have set, so the numbers\nmight not fully reflect what went into a certain release.\n\nHaving run this on three different machines with very similar results, I think it's safe to state that libsecp256k1 is more than 8x faster than OpenSSL for verifying ECDSA signatures on the\nsecp256k1 curve using the respective latest versions. Note that it would be misleading to conclude from these results that OpenSSL is slow in general and/or not open for performance improvements.\nFor example, the implementation of the curve secp256**r1** [4] seems to be heavily heavily optimized, according to [an issue mentioning the speed differences between secp256k1 and secp256r1](https://github.com/openssl/openssl/issues/23524).  So a more proper conclusion might be here that\noutside of the Bitcoin ecosystem, the secp256k1 is just not that relevant and doesn\u2019t count as first-class citizen that would justify spending\na lot of labor hours in a general-purpose cryptographic library. That said, last year\nthere was actually a PR opened in the OpenSSL repository that aims to improve the speed\nof operations on the secp256k1 curve: https://github.com/openssl/openssl/pull/26097. The name mentioned in the PR title that the code is based on might sound familiar to you :) \n\n## Outlook\n\nDoing this was a very interesting and fun mini project. I currently don\u2019t plan to put too much more effort into it, but I guess it's a good idea to\nrun the benchmark before each release of libsecp256k1 / Bitcoin Core (it\u2019s as simple as adding two lines), in order to quantify improvements and ensure\nwe don\u2019t have performance regressions. In that sense, it could even make sense to add Schnorr signature verification and functionalities from other\nmodules that are performance-critical as potential benchmarking scenarios, to comfortably track progress over the next years. Maybe someone is even motivated to add a benchmark scenario for signing.\n\nCheers,\nSebastian\n\n[1] 0.9.8h is the first OpenSSL version explicitly mentioned in the Bitcoin Core [repository's first commit (having that exact subject) by sirius-m](https://github.com/bitcoin/bitcoin/commit/4405b78d6059e536c36974088a8ed4d9f0f29898#diff-9e6e4772050998a5c0dc3c61acf3dab0a7e594566171fa5746d6b62f9598efb6R38)\n\n[2] note that calling into OpenSSL 0.9.8 and 1.0.0 led to a crash on my arm64 machine, so I skipped those; I don't know what the concrete issue is, I'm assuming it could have to do with memory alignment. On x86-64, all the built versions could be benchmarked successfully.\n\n[3] see https://github.com/bitcoin-core/secp256k1/commit/949bea92624fbd65bfb21d773f1df6a115af71ff (that's only the 13th commit in the repository!)\n\n[4] the secp256r1 curve was recently discussed on the Bitcoin mailing list, see https://groups.google.com/g/bitcoindev/c/XSYL0gx0cDM",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 346,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "<a name=\"p-6180-introduction-1\" class=\"anchor\" href=\"#p-6180-introduction-1\"></a>Introduction\nWith the upcoming release of v31.0 in spring next year, Bitcoin Core will celebrate its ten-year anniversary of replacing <a href=\"https://github.com/openssl/openssl\">OpenSSL</a> with <a href=\"https://github.com/bitcoin-core/secp256k1\">libsecp256k1</a> for ECDSA signature validation in consensus code. Having researched a bit on early history in this topic recently, I thought this might be &hellip;",
  "truncated": true,
  "post_url": "/t/comparing-the-performance-of-ecdsa-signature-validation-in-openssl-vs-libsecp256k1-over-the-last-decade/2087/1",
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}