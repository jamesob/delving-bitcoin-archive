{
  "id": 6195,
  "name": "",
  "username": "rijndael",
  "avatar_template": "/letter_avatar_proxy/v4/letter/r/8797f3/{size}.png",
  "created_at": "2025-11-06T00:37:18.328Z",
  "cooked": "<p>Love to see this written up!</p>\n<p>As written, the proof doesnt seem to be bound to a specific transaction. This could be problematic if you wanted to build permissionless exits from a multiparty system where (for example) a participant in an L2 proves that they control some coins and havent exited yet, and are able to spend from a bridge-owned utxo with just the proof. As written, I think someone could re-use a proof in a different transaction with different outputs (either in-mempool replacing the same original transaction, or in a subsequent transaction, or against a different UTXO encumbered with the same script). I think you would want to have the public parameters of the proof include either the sighash of the transaction and then do some assertion that it matches the current transaction, or re-use the schnorr trick we do in CAT scripts: make a signature over the transaction using 1 as the private key, and then you can do <code>CHECKSIG</code> against the transaction using <code>G</code> as the pubkey. This would provide a generic way to cover the transaction with the STARK, so that proofs can\u2019t be use out of context to authorize unintended transactions.</p>\n<p><strong>edit</strong>: I missed moonsettlers comment: I think he\u2019s hitting the same point</p>",
  "post_number": 8,
  "post_type": 1,
  "posts_count": 8,
  "updated_at": "2025-11-06T00:44:27.038Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 8,
  "reads": 2,
  "readers_count": 1,
  "score": 50.4,
  "yours": false,
  "topic_id": 2056,
  "topic_slug": "proposal-op-stark-verify-native-stark-proof-verification-in-bitcoin-script",
  "topic_title": "Proposal: OP_STARK_VERIFY - Native STARK Proof Verification in Bitcoin Script",
  "topic_html_title": "Proposal: OP_STARK_VERIFY - Native STARK Proof Verification in Bitcoin Script",
  "category_id": 7,
  "display_username": "",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Love to see this written up!\n\nAs written, the proof doesnt seem to be bound to a specific transaction. This could be problematic if you wanted to build permissionless exits from a multiparty system where (for example) a participant in an L2 proves that they control some coins and havent exited yet, and are able to spend from a bridge-owned utxo with just the proof. As written, I think someone could re-use a proof in a different transaction with different outputs (either in-mempool replacing the same original transaction, or in a subsequent transaction, or against a different UTXO encumbered with the same script). I think you would want to have the public parameters of the proof include either the sighash of the transaction and then do some assertion that it matches the current transaction, or re-use the schnorr trick we do in CAT scripts: make a signature over the transaction using 1 as the private key, and then you can do `CHECKSIG` against the transaction using `G` as the pubkey. This would provide a generic way to cover the transaction with the STARK, so that proofs can't be use out of context to authorize unintended transactions.\n\n**edit**: I missed moonsettlers comment: I think he's hitting the same point",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 288,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "Love to see this written up! \nAs written, the proof doesnt seem to be bound to a specific transaction. This could be problematic if you wanted to build permissionless exits from a multiparty system where (for example) a participant in an L2 proves that they control some coins and havent exited yet, &hellip;",
  "truncated": true,
  "post_url": "/t/proposal-op-stark-verify-native-stark-proof-verification-in-bitcoin-script/2056/8",
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}