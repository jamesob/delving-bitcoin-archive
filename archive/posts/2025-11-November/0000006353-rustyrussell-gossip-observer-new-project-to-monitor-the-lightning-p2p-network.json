{
  "id": 6353,
  "name": "Rusty Russell",
  "username": "rustyrussell",
  "avatar_template": "/user_avatar/delvingbitcoin.org/rustyrussell/{size}/154_2.png",
  "created_at": "2025-11-27T21:01:18.494Z",
  "cooked": "<aside class=\"quote no-group quote-modified\" data-username=\"jonhbit\" data-post=\"10\" data-topic=\"2105\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/jonhbit/48/1661_2.png\" class=\"avatar\"> jonhbit:</div>\n<blockquote>\n<aside class=\"quote no-group\" data-username=\"rustyrussell\" data-post=\"7\" data-topic=\"2105\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/rustyrussell/48/154_2.png\" class=\"avatar\"> rustyrussell:</div>\n<blockquote>\n<p>If you cannot encode an scid compactly, just send it as a series of \u201craw\" entries. IIRC creating such an scid requires an exceptional number of txs in a block or exceptional output count.</p>\n</blockquote>\n</aside>\n<p>Not sure what you mean with the \u201craw entries\u201d part? Do you mean, send the underlying gossip message outside of the set reconciliation messaging flow?</p>\n</blockquote>\n</aside>\n<p>No, I meant, say you use 24 bits for blknum, 14 for txindex, 12 for output number, 1 for direction and 12 for blocknumber, that uniquely identifies each update in 64 bits.  But it someone uses the 4096th output of a tx for a channel, you can\u2019t encode it in the set.  For that, you simply encode it raw, outside the minisketch.</p>\n<aside class=\"quote no-group quote-modified\" data-username=\"jonhbit\" data-post=\"10\" data-topic=\"2105\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/jonhbit/48/1661_2.png\" class=\"avatar\"> jonhbit:</div>\n<blockquote>\n<aside class=\"quote no-group\" data-username=\"rustyrussell\" data-post=\"7\" data-topic=\"2105\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/rustyrussell/48/154_2.png\" class=\"avatar\"> rustyrussell:</div>\n<blockquote>\n<p>With this scheme, you simply send the sketches every 60 seconds (like now), and your peer sends you what you\u2019re missing.</p>\n<p>Note that you can truncate the set you send if you want to save bandwidth, but really the cost is in the set maintenance, so maybe this is silly. My memory is that minisketch is <em>fast</em> in practice though, even if you keep a 64k (8k element) set which is our max message size anyway.</p>\n</blockquote>\n</aside>\n<p>IIUC the cost is mostly in the final parts of decode; I think if you wanted to save bandwidth, you could create a sketch with an overestimate of the true set difference, and then send some portion of that. If your peer signals that decode would fail, you can send the rest / another chunk of the oversized set.</p>\n<p>I didn\u2019t consider the max message size at all; that sounds like an argument for using shorter (32-bit) set elements and using a per-peer salt <img src=\"https://delvingbitcoin.org/images/emoji/twitter/upside_down_face.png?v=14\" title=\":upside_down_face:\" class=\"emoji\" alt=\":upside_down_face:\" loading=\"lazy\" width=\"20\" height=\"20\"></p>\n</blockquote>\n</aside>\n<p>You don\u2019t need to signal.  When you get their sketch, it fails for you.  So you go larger, if you can.</p>\n<p>Per-peer salt penalizes scaling.  Now each peer costs you more than bandwidth.  If we can avoid this, we should, and I think we can.</p>\n<aside class=\"quote no-group quote-modified\" data-username=\"jonhbit\" data-post=\"10\" data-topic=\"2105\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/jonhbit/48/1661_2.png\" class=\"avatar\"> jonhbit:</div>\n<blockquote>\n<aside class=\"quote no-group\" data-username=\"rustyrussell\" data-post=\"7\" data-topic=\"2105\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/rustyrussell/48/154_2.png\" class=\"avatar\"> rustyrussell:</div>\n<blockquote>\n<p>If reconstruction fails, there are several things you can do:</p>\n<ol>\n<li>If block height differs, ignore. Time will sort it. Maybe include block hash here?</li>\n</ol>\n</blockquote>\n</aside>\n<p>Not sure I understand this bit; I figure you mean the block height you suggested sending alongside the channel announcement sketch. Is this the blockheight of the newest channel announcement you\u2019ve received, or something else?</p>\n</blockquote>\n</aside>\n<p>The current blockheight you are aware of.  This is important, because channel updates must be refreshed every 2048 blocks (IIRC in the new spec proposal), and you will accept new channel announcements on each block.  So you expect non-zero differences in this case.</p>\n<p>The block hash would allow you to see forks, if that happened.</p>\n<aside class=\"quote no-group quote-modified\" data-username=\"jonhbit\" data-post=\"10\" data-topic=\"2105\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/jonhbit/48/1661_2.png\" class=\"avatar\"> jonhbit:</div>\n<blockquote>\n<aside class=\"quote no-group\" data-username=\"rustyrussell\" data-post=\"7\" data-topic=\"2105\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/rustyrussell/48/154_2.png\" class=\"avatar\"> rustyrussell:</div>\n<blockquote>\n<ol start=\"3\">\n<li>Enlarge your own set (or, send more of your set). If this allows your peer to reconstruct, it will learn that you cannot reconstruct, and it knows to send its largest set if it wasn\u2019t already.</li>\n<li>Wait for other peers. You might close the gap.</li>\n<li>Existing gossip queries for recent changes (assuming a pile of old changes haven\u2019t suddenly appeared). You know if you need announcements, updates or node anns.</li>\n<li>Query for everything.</li>\n</ol>\n<p>Oh, we added a \u201ctotal entries\" counter to each message, which gives a clue as well: if your peer has far fewer entries, it\u2019s a cry for help <img src=\"https://delvingbitcoin.org/images/emoji/twitter/slight_smile.png?v=14\" title=\":slight_smile:\" class=\"emoji\" alt=\":slight_smile:\" loading=\"lazy\" width=\"20\" height=\"20\"></p>\n</blockquote>\n</aside>\n<p>Mm, I wonder if there are other values that would be useful to add in here.</p>\n<p>Re: your follow-up post - I agree on the napkin math working out, and it\u2019s even better if we\u2019re doing one set per message type. And having more peers should also help.</p>\n</blockquote>\n</aside>\n<p>Note that the long pole in the scaling tent is channel updates.  Node announcements only change when you change IP address or something, and there are far fewer nodes than channels x 2.  Channel announcements only happen once per channel.</p>\n<aside class=\"quote no-group\" data-username=\"jonhbit\" data-post=\"10\" data-topic=\"2105\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/jonhbit/48/1661_2.png\" class=\"avatar\"> jonhbit:</div>\n<blockquote>\n<p>Will think over the message ordering dependencies you mentioned in having three sketches vs. one. Fallback behavior <span class=\"hashtag-raw\">#4</span> could be promising, where you rebuild a sketch from the messages you received over the last n minutes vs. just 1 minute, reattempt a reconciliation, and hopefully catch up to that peer. I think I\u2019d like to avoid leaning too much on gossip queries if possible <img src=\"https://delvingbitcoin.org/images/emoji/twitter/sweat_smile.png?v=14\" title=\":sweat_smile:\" class=\"emoji\" alt=\":sweat_smile:\" loading=\"lazy\" width=\"20\" height=\"20\"></p>\n</blockquote>\n</aside>\n<p>I think in practice, implementations will fall back to asking for everything if reconciliation fails. It has the benefit of being simple, both to implement and test.</p>",
  "post_number": 11,
  "post_type": 1,
  "posts_count": 20,
  "updated_at": "2025-11-27T21:01:18.494Z",
  "reply_count": 1,
  "reply_to_post_number": 10,
  "quote_count": 2,
  "incoming_link_count": 1,
  "reads": 29,
  "readers_count": 28,
  "score": 15.8,
  "yours": false,
  "topic_id": 2105,
  "topic_slug": "gossip-observer-new-project-to-monitor-the-lightning-p2p-network",
  "topic_title": "Gossip Observer: New project to monitor the Lightning P2P network",
  "topic_html_title": "Gossip Observer: New project to monitor the Lightning P2P network",
  "category_id": 7,
  "display_username": "Rusty Russell",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"jonhbit, post:10, topic:2105\"]\n[quote=\"rustyrussell, post:7, topic:2105\"]\nIf you cannot encode an scid compactly, just send it as a series of \u201craw\" entries. IIRC creating such an scid requires an exceptional number of txs in a block or exceptional output count.\n\n[/quote]\n\nNot sure what you mean with the \u201craw entries\u201d part? Do you mean, send the underlying gossip message outside of the set reconciliation messaging flow?\n\n[/quote]\n\nNo, I meant, say you use 24 bits for blknum, 14 for txindex, 12 for output number, 1 for direction and 12 for blocknumber, that uniquely identifies each update in 64 bits.  But it someone uses the 4096th output of a tx for a channel, you can\u2019t encode it in the set.  For that, you simply encode it raw, outside the minisketch.\n\n[quote=\"jonhbit, post:10, topic:2105\"]\n[quote=\"rustyrussell, post:7, topic:2105\"]\nWith this scheme, you simply send the sketches every 60 seconds (like now), and your peer sends you what you\u2019re missing.\n\nNote that you can truncate the set you send if you want to save bandwidth, but really the cost is in the set maintenance, so maybe this is silly. My memory is that minisketch is *fast* in practice though, even if you keep a 64k (8k element) set which is our max message size anyway.\n\n[/quote]\n\nIIUC the cost is mostly in the final parts of decode; I think if you wanted to save bandwidth, you could create a sketch with an overestimate of the true set difference, and then send some portion of that. If your peer signals that decode would fail, you can send the rest / another chunk of the oversized set.\n\nI didn\u2019t consider the max message size at all; that sounds like an argument for using shorter (32-bit) set elements and using a per-peer salt :upside_down_face:\n\n[/quote]\n\nYou don\u2019t need to signal.  When you get their sketch, it fails for you.  So you go larger, if you can.\n\nPer-peer salt penalizes scaling.  Now each peer costs you more than bandwidth.  If we can avoid this, we should, and I think we can.\n\n[quote=\"jonhbit, post:10, topic:2105\"]\n\n[quote=\"rustyrussell, post:7, topic:2105\"]\nIf reconstruction fails, there are several things you can do:\n\n1. If block height differs, ignore. Time will sort it. Maybe include block hash here?\n\n[/quote]\n\nNot sure I understand this bit; I figure you mean the block height you suggested sending alongside the channel announcement sketch. Is this the blockheight of the newest channel announcement you\u2019ve received, or something else?\n\n[/quote]\n\nThe current blockheight you are aware of.  This is important, because channel updates must be refreshed every 2048 blocks (IIRC in the new spec proposal), and you will accept new channel announcements on each block.  So you expect non-zero differences in this case.\n\nThe block hash would allow you to see forks, if that happened.\n\n[quote=\"jonhbit, post:10, topic:2105\"]\n[quote=\"rustyrussell, post:7, topic:2105\"]\n3. Enlarge your own set (or, send more of your set). If this allows your peer to reconstruct, it will learn that you cannot reconstruct, and it knows to send its largest set if it wasn\u2019t already.\n4. Wait for other peers. You might close the gap.\n5. Existing gossip queries for recent changes (assuming a pile of old changes haven\u2019t suddenly appeared). You know if you need announcements, updates or node anns.\n6. Query for everything.\n\nOh, we added a \u201ctotal entries\" counter to each message, which gives a clue as well: if your peer has far fewer entries, it\u2019s a cry for help :slight_smile:\n\n[/quote]\n\nMm, I wonder if there are other values that would be useful to add in here.\n\nRe: your follow-up post - I agree on the napkin math working out, and it\u2019s even better if we\u2019re doing one set per message type. And having more peers should also help.\n\n[/quote]\n\nNote that the long pole in the scaling tent is channel updates.  Node announcements only change when you change IP address or something, and there are far fewer nodes than channels x 2.  Channel announcements only happen once per channel.\n\n[quote=\"jonhbit, post:10, topic:2105\"]\n\nWill think over the message ordering dependencies you mentioned in having three sketches vs. one. Fallback behavior #4 could be promising, where you rebuild a sketch from the messages you received over the last n minutes vs. just 1 minute, reattempt a reconciliation, and hopefully catch up to that peer. I think I\u2019d like to avoid leaning too much on gossip queries if possible :sweat_smile:\n\n[/quote]\n\nI think in practice, implementations will fall back to asking for everything if reconciliation fails. It has the benefit of being simple, both to implement and test.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 137,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "Not sure what you mean with the \u201craw entries\u201d part? Do you mean, send the underlying gossip message outside of the set reconciliation messaging flow? \n\n\nNo, I meant, say you use 24 bits for blknum, 14 for txindex, 12 for output number, 1 for direction and 12 for blocknumber, that uniquely identifie&hellip;",
  "truncated": true,
  "post_url": "/t/gossip-observer-new-project-to-monitor-the-lightning-p2p-network/2105/11",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}