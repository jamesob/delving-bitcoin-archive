{
  "id": 6190,
  "name": "",
  "username": "roconnor-blockstream",
  "avatar_template": "/user_avatar/delvingbitcoin.org/roconnor-blockstream/{size}/427_2.png",
  "created_at": "2025-11-03T18:53:45.961Z",
  "cooked": "<p>In <a href=\"https://delvingbitcoin.org/t/delving-simplicity-part-building-data-types/1956\">Part \u2162</a> of this series, we showed how to build some data structures and computations using Simplicity\u2019s core set of combinators. As we noted in <a href=\"https://delvingbitcoin.org/t/delving-simplicity-part-combinator-completeness-of-simplicity/1935\">Part \u2161</a>, the core combinators are enough to implement any finite pure computation. This raises the question: what more can be achieved? We can add additional side effects to our expressions.</p>\n<p>There are various kinds of possible side effects for expressions: state update, writing to a log, throwing an exception, reading from an environment, calling a continuation, etc.  The side effects available in Simplicity will depend on the application.</p>\n<p>For Bitcoin and Liquid applications, we currently have two side effects: the Failure effect, which is an exception effect where the exception has type <code>\ud835\udfd9</code>, and the Reader effect which allows data from the transaction environment to be accessed. Our core combinators are \u201cpure\u201d; they have no side effects. However, jets can introduce new primitives that do have side effects.</p>\n<h1><a name=\"p-6190-jets-with-effects-1\" class=\"anchor\" href=\"#p-6190-jets-with-effects-1\"></a>Jets with Effects</h1>\n<p>We will talk more about jets later in this series, but here we introduce a few example jets to illustrate their side effects.</p>\n<h2><a name=\"p-6190-bip0340-verify-2\" class=\"anchor\" href=\"#p-6190-bip0340-verify-2\"></a>Bip0340-verify</h2>\n<p><code>bip0340-verify : (\ud835\udfda\u00b2\u2075\u2076 \u00d7 \ud835\udfda\u00b2\u2075\u2076) \u00d7 \ud835\udfda\u2075\u00b9\u00b2 \u22a2 \ud835\udfd9</code> is a jet for an expression that takes an x-only pubkey, a 256-bit message, and a Schnorr signature, and returns nothing! According to its type, it ought to behave the same as a <code>unit</code>.  The difference lies in the jet\u2019s side effect: if the signature validation fails, then the entire computation is aborted by throwing an exception (of unit type). This is the Failure effect.</p>\n<h2><a name=\"p-6190-verify-3\" class=\"anchor\" href=\"#p-6190-verify-3\"></a>Verify</h2>\n<p><code>verify : \ud835\udfda \u22a2 \ud835\udfd9</code> is a barebones jet for expressing the Failure effect.  If <code>verify</code>\u2019s input is <code>false</code>, the entire computation is aborted, by throwing an exception. If the input is <code>true</code>, nothing is returned, but the computation can continue.</p>\n<h2><a name=\"p-6190-transaction-hashes-4\" class=\"anchor\" href=\"#p-6190-transaction-hashes-4\"></a>Transaction Hashes</h2>\n<p><code>sig-all-hash : \ud835\udfd9 \u22a2 \ud835\udfda\u00b2\u2075\u2076</code> appears to be a constant function, since there is only one possible input value: the empty tuple.  However, this jet reads from the transaction environment and produces a hash of transaction data that is analogous to the <code>SIGHASH_ALL</code> message digest used in Bitcoin Script\u2019s signature verification. This is an example of the Reader effect: the value returned depends on the transaction environment that the jet is executed within.  There are several other hashing jets that hash various subsets of the transaction environment data to help build custom message digests for signatures.</p>\n<h2><a name=\"p-6190-introspection-jets-5\" class=\"anchor\" href=\"#p-6190-introspection-jets-5\"></a>Introspection Jets</h2>\n<p><code>input-sequence : \ud835\udfda\u00b3\u00b2 \u22a2 \ud835\udfda\u00b3\u00b2?</code> is a function that takes an input index and returns the transaction\u2019s sequence number for that input, optionally returning nothing if the index is out of bounds.  Again, the output value is not a pure function of the input index, but rather, the operation uses the Reader effect to access the transaction environment in order to determine the output value.  There are several other introspection jets that return various fragments of the transaction environment data.</p>\n<h1><a name=\"p-6190-classifying-effects-6\" class=\"anchor\" href=\"#p-6190-classifying-effects-6\"></a>Classifying Effects</h1>\n<p>Not all side effects are created equal. Some side effects behave nicer than others. We can classify effects by how amenable they are to program transformations.</p>\n<h2><a name=\"p-6190-commutative-effects-7\" class=\"anchor\" href=\"#p-6190-commutative-effects-7\"></a>Commutative Effects</h2>\n<p>A commutative effect is one where, if you swap the outputs of two expressions, you can safely swap the expressions themselves without changing the expression\u2019s effect. Consider <code>swap = I H \u25b5 O H : A \u00d7 B \u22a2 B \u00d7 A</code>. If <code>f \u25b5 g \u2a3e swap = g \u25b5 f</code> for every expression <code>f</code> and <code>g</code> with side effects, then the effects are commutative.</p>\n<p>Reading transaction data from the environment is a commutative effect because the result of reading from the environment is the same, no matter what order we execute the reading in.</p>\n<p>In general, throwing an exception is not a commutative effect. If <code>f</code> throws some exception <code>e\u2081</code> and <code>g</code> throws some other exception <code>e\u2082</code>, then which exception is thrown from the pair of <code>f</code> and <code>g</code> depends on the order they are executed in.</p>\n<p>However, in the special case of the Failure effect, in which only a unit typed exception can be thrown, the effect is commutative.  No matter which of <code>f</code> or <code>g</code> throws an exception, the resulting exception will be the same, because there is only one possible exception value.</p>\n<h2><a name=\"p-6190-idempotent-effects-8\" class=\"anchor\" href=\"#p-6190-idempotent-effects-8\"></a>Idempotent Effects</h2>\n<p>An idempotent effect is one where, if you duplicate the output of an expression, you can safely duplicate the expression itself without changing the expression\u2019s effect.  Consider <code>dup = iden \u25b5 iden : A \u22a2 A x A</code>. If <code>f \u2a3e dup = dup \u2a3e f \u25b5 f</code> for every <code>f</code> with side effects, then the effects are idempotent.</p>\n<p>Reading transaction data from the environment is an idempotent effect. Throwing an exception is also an idempotent effect. Even though only one of the two duplicated expressions will be executed, any exception thrown by <code>dup \u2a3e f \u25b5 f</code> will be the same as the exception thrown by <code>f \u2a3e dup</code>.</p>\n<p>However, writing to a log may not be idempotent, as duplicating the effect would cause the log message to appear twice. However, if the log consists of a <em>set</em> of messages instead of a <em>list</em> of messages, then the effect would be idempotent (and commutative) because set insertion is itself an idempotent operation.</p>\n<h2><a name=\"p-6190-unitary-effects-9\" class=\"anchor\" href=\"#p-6190-unitary-effects-9\"></a>Unitary Effects</h2>\n<p>A unitary effect is one where, if you discard the output of an expression, you can safely discard the expression itself without changing the expression\u2019s effects. If it is always the case that <code>f \u2a3e unit = unit</code> for every <code>f</code> with side effects, then your effects are unitary.</p>\n<p>Reading data from the environment is one of the few types of unitary effects. If the result of reading transaction data from the environment is discarded, the whole expression performing the read may be discarded.</p>\n<p>The failure effect isn\u2019t unitary. If <code>f</code> throws an exception then so will <code>f \u2a3e unit</code>; execution will not even make it to the <code>unit</code> combinator before the computation is aborted.  On the other hand, <code>unit</code> obviously would not throw any exception, so the effects of <code>f \u2a3e unit</code> and <code>unit</code> would be different.</p>\n<h1><a name=\"p-6190-effects-allowed-in-simplicity-10\" class=\"anchor\" href=\"#p-6190-effects-allowed-in-simplicity-10\"></a>Effects Allowed in Simplicity</h1>\n<p>The more well-behaved properties that a type of effect has, the more room a Simplicity optimizer has for transforming programs that use those effects.  Ideally we would only allow effects that have all three properties: commutative, idempotent, and unitary.  This would allow an optimizer to perform any sort of program transformation it would like.  However, reading from an environment is the only effect that satisfies all three properties.</p>\n<p>Instead we demand that Simplicity effects are commutative and idempotent. Both the effects we use in Simplicity, the Failure effect and the Reader effect, are commutative and idempotent. This allows a large class of optimizations to be performed on Simplicity code.</p>\n<p>However, the \u201cdiscard\u201d transformation described above, attempting to replace <code>f \u2a3e unit</code> with <code>unit</code>, or any similar transformation is not allowed if <code>f</code> may produce a Failure effect. Indeed, imagine if <code>f</code> contained a <code>bip0340-verify</code> assertion. It would be disastrous to attempt to optimize that check away.</p>\n<h1><a name=\"p-6190-why-allow-side-effects-at-all-11\" class=\"anchor\" href=\"#p-6190-why-allow-side-effects-at-all-11\"></a>Why Allow Side Effects At All?</h1>\n<p>Why does Simplicity even allow side effects at all?  Wouldn\u2019t it be better if every program took the entire transaction as input and returned a Boolean output that decides if a transaction is valid or not?</p>\n<h2><a name=\"p-6190-batch-verification-12\" class=\"anchor\" href=\"#p-6190-batch-verification-12\"></a>Batch Verification</h2>\n<p>One reason we have the Failure effect is to support <a href=\"https://github.com/bitcoin/bips/blob/c9a6ca6297eb8de850f6b64dafb8e60ee9b64d66/bip-0340.mediawiki#batch-verification\" rel=\"noopener nofollow ugc\">batch verification</a> of Schnorr signatures.  In batch verification, many individual Schnorr signature checks are pooled together in such a way that if any single signature check fails, then the entire batch fails.</p>\n<p>This batching procedure improves efficiency over individually verifying each signature. The downside is that if the batch verification fails, then we do not learn which specific signature check or checks failed.</p>\n<p>By using the failure side effect, <code>bip0340-verify</code> ensures that if a signature check fails, the whole transaction fails.  If <code>bip0340-verify</code> were instead to return <code>\ud835\udfda</code>, a Boolean type, for success or failure, then a failing signature check could still lead to a branch where the script succeeds. In such a case we would need to know if the particular signature is valid or not, and thus we wouldn\u2019t be able to take advantage of batch verification.</p>\n<h2><a name=\"p-6190-precomputed-transaction-data-13\" class=\"anchor\" href=\"#p-6190-precomputed-transaction-data-13\"></a>Precomputed Transaction Data</h2>\n<p>A problem in early Bitcoin Script was that the hashing function used to create message digests for signatures was linear in the size of the transaction.  Typically every input creates at least one message digest for signature verification, so overall the amount of hashing was quadratic in the transaction size.</p>\n<p>This problem was fixed in Segwit and later iterations of Bitcoin Script by redefining the message digests so that they could be computed in constant time per signature check. This relies on having <code>PrecomputedTransactionData</code>, which precomputes hashes of transaction data once and is then shared by each input\u2019s sighash computations. Simplicity\u2019s transaction hashing jets rely on the same kind of precomputed transaction data in order to ensure the jets run in constant time.</p>\n<p>Suppose <code>sig-all-hash</code> didn\u2019t use the Reader effect.  Suppose we somehow managed to build a Simplicity type for the transaction environment.  Let\u2019s call it <code>TxEnv</code>, so that <code>sig-all-hash : TxEnv \u22a2 \ud835\udfda\u00b2\u2075\u2076</code> was the jet\u2019s type. Such a definition would require the <code>sig-all-hash</code> jet to be able to compute the hash of any transaction, not just the transaction it is involved with. Simplicity programs could copy the given `TxEnv` and pass a modified copy of it to <code>sig-all-hash</code>. In such a case <code>sig-all-hash</code> couldn\u2019t rely on <code>PrecomputedTransactionData</code>, and we would be back to requiring linear time in whatever transaction data was passed into this version of <code>sig-all-hash</code>.</p>\n<p>Because <code>sig-all-hash : \ud835\udfd9 \u22a2 \ud835\udfda\u00b2\u2075\u2076</code> uses the Reader effect to access the transaction data, it <em>only</em> gets access to a fixed  transaction environment. For that reason, the jet\u2019s implementation can safely use <code>PrecomputedTransactionData</code> and operate in constant time.</p>\n<h1><a name=\"p-6190-cross-input-signature-aggregation-14\" class=\"anchor\" href=\"#p-6190-cross-input-signature-aggregation-14\"></a>Cross-Input Signature Aggregation</h1>\n<p>While neither Liquid nor Bitcoin support <a href=\"https://hrf.org/latest/cisa-research-paper/\" rel=\"noopener nofollow ugc\">cross-input signature aggregation</a> at this point in time, we would like to check that Simplicity can be compatible with it when the time comes.</p>\n<p>While details haven\u2019t been worked out, we imagine half-aggregation being implemented using a Writer effect.  That is, a new jet with a type such as <code>half-agg-verify : (\ud835\udfda\u00b2\u2075\u2076 \u00d7 \ud835\udfda\u00b2\u2075\u2076) \u00d7 \ud835\udfda\u00b2\u2075\u2076 \u22a2 \ud835\udfd9</code> would take a public key, message digest, and the <code>r</code>-component of a Schnorr signature (a Schnorr signature consists of an <code>r</code>-component and an <code>s</code>-component) and write it to a transaction log before continuing on with execution. Then, elsewhere in the transaction or with the transaction, an aggregate <code>s</code>-component for all half-aggregated Schnorr signatures would be provided.  The transaction would only be valid when such an aggregate <code>s</code>-component is provided for all the logged keys, messages, and <code>r</code>-components.</p>\n<p>To meet Simplicity\u2019s requirements, this Writer effect needs to be idempotent and commutative.  This can be ensured by treating the writer log as a set of key, message, <code>r</code>-component tuples. This works because set operations are idempotent and commutative. Treating the log as a set of values would be compatible with the half-aggregation verification algorithm.</p>\n<h1><a name=\"p-6190-conclusion-15\" class=\"anchor\" href=\"#p-6190-conclusion-15\"></a>Conclusion</h1>\n<p>In this part we looked at adding side effects to the computations that Simplicity can do.  We classified various kinds of effects according to how well-behaved they are with respect to various kinds of program transformation.  We decided to restrict Simplicity\u2019s effects to those that are commutative and idempotent.</p>\n<p>The two effects we use for Bitcoin and Liquid applications are the Reader effect, for accessing the transaction environment, and the Failure effect, for aborting and failing the program. Some jets make use of primitive operations where these sorts of side effects can occur.</p>\n<p>The Failure effect determines the output of a Simplicity program: the program either fails, making the transaction invalid, or the program succeeds. The Reader effect provides one sort of input to a Simplicity program: the environment containing transaction data. But we also need to provide other inputs, such as digital signatures, to Simplicity programs.</p>\n<p>In the next part we will look at what Simplicity programs are, how they are turned into addresses, and how we add other inputs, such as signatures, to Simplicity programs.</p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 1,
  "updated_at": "2025-11-03T18:58:48.409Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 4,
  "reads": 18,
  "readers_count": 17,
  "score": 33.4,
  "yours": false,
  "topic_id": 2091,
  "topic_slug": "delving-simplicity-part-two-side-effects",
  "topic_title": "Delving Simplicity Part \u2163:Two Side Effects",
  "topic_html_title": "Delving Simplicity Part \u2163:Two Side Effects",
  "category_id": 7,
  "display_username": "",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "In [Part \u2162](https://delvingbitcoin.org/t/delving-simplicity-part-building-data-types/1956) of this series, we showed how to build some data structures and computations using Simplicity\u2019s core set of combinators. As we noted in [Part \u2161](https://delvingbitcoin.org/t/delving-simplicity-part-combinator-completeness-of-simplicity/1935), the core combinators are enough to implement any finite pure computation. This raises the question: what more can be achieved? We can add additional side effects to our expressions.\n\nThere are various kinds of possible side effects for expressions: state update, writing to a log, throwing an exception, reading from an environment, calling a continuation, etc.  The side effects available in Simplicity will depend on the application.\n\nFor Bitcoin and Liquid applications, we currently have two side effects: the Failure effect, which is an exception effect where the exception has type `\ud835\udfd9`, and the Reader effect which allows data from the transaction environment to be accessed. Our core combinators are \u201cpure\u201d; they have no side effects. However, jets can introduce new primitives that do have side effects.\n\n# Jets with Effects\n\nWe will talk more about jets later in this series, but here we introduce a few example jets to illustrate their side effects.\n\n## Bip0340-verify\n\n`bip0340-verify : (\ud835\udfda\u00b2\u2075\u2076 \u00d7 \ud835\udfda\u00b2\u2075\u2076) \u00d7 \ud835\udfda\u2075\u00b9\u00b2 \u22a2 \ud835\udfd9` is a jet for an expression that takes an x-only pubkey, a 256-bit message, and a Schnorr signature, and returns nothing! According to its type, it ought to behave the same as a `unit`.  The difference lies in the jet\u2019s side effect: if the signature validation fails, then the entire computation is aborted by throwing an exception (of unit type). This is the Failure effect.\n\n## Verify\n\n`verify : \ud835\udfda \u22a2 \ud835\udfd9` is a barebones jet for expressing the Failure effect.  If `verify`\u2019s input is `false`, the entire computation is aborted, by throwing an exception. If the input is `true`, nothing is returned, but the computation can continue.\n\n## Transaction Hashes\n\n`sig-all-hash : \ud835\udfd9 \u22a2 \ud835\udfda\u00b2\u2075\u2076` appears to be a constant function, since there is only one possible input value: the empty tuple.  However, this jet reads from the transaction environment and produces a hash of transaction data that is analogous to the `SIGHASH_ALL` message digest used in Bitcoin Script\u2019s signature verification. This is an example of the Reader effect: the value returned depends on the transaction environment that the jet is executed within.  There are several other hashing jets that hash various subsets of the transaction environment data to help build custom message digests for signatures.\n\n## Introspection Jets\n\n`input-sequence : \ud835\udfda\u00b3\u00b2 \u22a2 \ud835\udfda\u00b3\u00b2?` is a function that takes an input index and returns the transaction\u2019s sequence number for that input, optionally returning nothing if the index is out of bounds.  Again, the output value is not a pure function of the input index, but rather, the operation uses the Reader effect to access the transaction environment in order to determine the output value.  There are several other introspection jets that return various fragments of the transaction environment data.\n\n# Classifying Effects\n\nNot all side effects are created equal. Some side effects behave nicer than others. We can classify effects by how amenable they are to program transformations.\n\n## Commutative Effects\n\nA commutative effect is one where, if you swap the outputs of two expressions, you can safely swap the expressions themselves without changing the expression\u2019s effect. Consider `swap = I H \u25b5 O H : A \u00d7 B \u22a2 B \u00d7 A`. If `f \u25b5 g \u2a3e swap = g \u25b5 f` for every expression `f` and `g` with side effects, then the effects are commutative.\n\nReading transaction data from the environment is a commutative effect because the result of reading from the environment is the same, no matter what order we execute the reading in.\n\nIn general, throwing an exception is not a commutative effect. If `f` throws some exception `e\u2081` and `g` throws some other exception `e\u2082`, then which exception is thrown from the pair of `f` and `g` depends on the order they are executed in.\n\nHowever, in the special case of the Failure effect, in which only a unit typed exception can be thrown, the effect is commutative.  No matter which of `f` or `g` throws an exception, the resulting exception will be the same, because there is only one possible exception value.\n\n## Idempotent Effects\n\nAn idempotent effect is one where, if you duplicate the output of an expression, you can safely duplicate the expression itself without changing the expression\u2019s effect.  Consider `dup = iden \u25b5 iden : A \u22a2 A x A`. If `f \u2a3e dup = dup \u2a3e f \u25b5 f` for every `f` with side effects, then the effects are idempotent.\n\nReading transaction data from the environment is an idempotent effect. Throwing an exception is also an idempotent effect. Even though only one of the two duplicated expressions will be executed, any exception thrown by `dup \u2a3e f \u25b5 f` will be the same as the exception thrown by `f \u2a3e dup`.\n\nHowever, writing to a log may not be idempotent, as duplicating the effect would cause the log message to appear twice. However, if the log consists of a *set* of messages instead of a *list* of messages, then the effect would be idempotent (and commutative) because set insertion is itself an idempotent operation.\n\n## Unitary Effects\n\nA unitary effect is one where, if you discard the output of an expression, you can safely discard the expression itself without changing the expression\u2019s effects. If it is always the case that `f \u2a3e unit = unit` for every `f` with side effects, then your effects are unitary.\n\nReading data from the environment is one of the few types of unitary effects. If the result of reading transaction data from the environment is discarded, the whole expression performing the read may be discarded.\n\nThe failure effect isn\u2019t unitary. If `f` throws an exception then so will `f \u2a3e unit`; execution will not even make it to the `unit` combinator before the computation is aborted.  On the other hand, `unit` obviously would not throw any exception, so the effects of `f \u2a3e unit` and `unit` would be different.\n\n# Effects Allowed in Simplicity\n\nThe more well-behaved properties that a type of effect has, the more room a Simplicity optimizer has for transforming programs that use those effects.  Ideally we would only allow effects that have all three properties: commutative, idempotent, and unitary.  This would allow an optimizer to perform any sort of program transformation it would like.  However, reading from an environment is the only effect that satisfies all three properties.\n\nInstead we demand that Simplicity effects are commutative and idempotent. Both the effects we use in Simplicity, the Failure effect and the Reader effect, are commutative and idempotent. This allows a large class of optimizations to be performed on Simplicity code.\n\nHowever, the \u201cdiscard\u201d transformation described above, attempting to replace `f \u2a3e unit` with `unit`, or any similar transformation is not allowed if `f` may produce a Failure effect. Indeed, imagine if `f` contained a `bip0340-verify` assertion. It would be disastrous to attempt to optimize that check away.\n\n# Why Allow Side Effects At All?\n\nWhy does Simplicity even allow side effects at all?  Wouldn\u2019t it be better if every program took the entire transaction as input and returned a Boolean output that decides if a transaction is valid or not?\n\n## Batch Verification\n\nOne reason we have the Failure effect is to support [batch verification](https://github.com/bitcoin/bips/blob/c9a6ca6297eb8de850f6b64dafb8e60ee9b64d66/bip-0340.mediawiki#batch-verification) of Schnorr signatures.  In batch verification, many individual Schnorr signature checks are pooled together in such a way that if any single signature check fails, then the entire batch fails.\n\nThis batching procedure improves efficiency over individually verifying each signature. The downside is that if the batch verification fails, then we do not learn which specific signature check or checks failed.\n\nBy using the failure side effect, `bip0340-verify` ensures that if a signature check fails, the whole transaction fails.  If `bip0340-verify` were instead to return `\ud835\udfda`, a Boolean type, for success or failure, then a failing signature check could still lead to a branch where the script succeeds. In such a case we would need to know if the particular signature is valid or not, and thus we wouldn\u2019t be able to take advantage of batch verification.\n\n## Precomputed Transaction Data\n\nA problem in early Bitcoin Script was that the hashing function used to create message digests for signatures was linear in the size of the transaction.  Typically every input creates at least one message digest for signature verification, so overall the amount of hashing was quadratic in the transaction size.\n\nThis problem was fixed in Segwit and later iterations of Bitcoin Script by redefining the message digests so that they could be computed in constant time per signature check. This relies on having `PrecomputedTransactionData`, which precomputes hashes of transaction data once and is then shared by each input\u2019s sighash computations. Simplicity\u2019s transaction hashing jets rely on the same kind of precomputed transaction data in order to ensure the jets run in constant time.\n\nSuppose `sig-all-hash` didn\u2019t use the Reader effect.  Suppose we somehow managed to build a Simplicity type for the transaction environment.  Let\u2019s call it `TxEnv`, so that `sig-all-hash : TxEnv \u22a2 \ud835\udfda\u00b2\u2075\u2076` was the jet\u2019s type. Such a definition would require the `sig-all-hash` jet to be able to compute the hash of any transaction, not just the transaction it is involved with. Simplicity programs could copy the given \\`TxEnv\\` and pass a modified copy of it to `sig-all-hash`. In such a case `sig-all-hash` couldn't rely on `PrecomputedTransactionData`, and we would be back to requiring linear time in whatever transaction data was passed into this version of `sig-all-hash`.\n\nBecause `sig-all-hash : \ud835\udfd9 \u22a2 \ud835\udfda\u00b2\u2075\u2076` uses the Reader effect to access the transaction data, it *only* gets access to a fixed  transaction environment. For that reason, the jet\u2019s implementation can safely use `PrecomputedTransactionData` and operate in constant time.\n\n# Cross-Input Signature Aggregation\n\nWhile neither Liquid nor Bitcoin support [cross-input signature aggregation](https://hrf.org/latest/cisa-research-paper/) at this point in time, we would like to check that Simplicity can be compatible with it when the time comes.\n\nWhile details haven\u2019t been worked out, we imagine half-aggregation being implemented using a Writer effect.  That is, a new jet with a type such as `half-agg-verify : (\ud835\udfda\u00b2\u2075\u2076 \u00d7 \ud835\udfda\u00b2\u2075\u2076) \u00d7 \ud835\udfda\u00b2\u2075\u2076 \u22a2 \ud835\udfd9` would take a public key, message digest, and the `r`-component of a Schnorr signature (a Schnorr signature consists of an `r`-component and an `s`-component) and write it to a transaction log before continuing on with execution. Then, elsewhere in the transaction or with the transaction, an aggregate `s`-component for all half-aggregated Schnorr signatures would be provided.  The transaction would only be valid when such an aggregate `s`-component is provided for all the logged keys, messages, and `r`-components.\n\nTo meet Simplicity\u2019s requirements, this Writer effect needs to be idempotent and commutative.  This can be ensured by treating the writer log as a set of key, message, `r`-component tuples. This works because set operations are idempotent and commutative. Treating the log as a set of values would be compatible with the half-aggregation verification algorithm.\n\n# Conclusion\n\nIn this part we looked at adding side effects to the computations that Simplicity can do.  We classified various kinds of effects according to how well-behaved they are with respect to various kinds of program transformation.  We decided to restrict Simplicity\u2019s effects to those that are commutative and idempotent.\n\nThe two effects we use for Bitcoin and Liquid applications are the Reader effect, for accessing the transaction environment, and the Failure effect, for aborting and failing the program. Some jets make use of primitive operations where these sorts of side effects can occur.\n\nThe Failure effect determines the output of a Simplicity program: the program either fails, making the transaction invalid, or the program succeeds. The Reader effect provides one sort of input to a Simplicity program: the environment containing transaction data. But we also need to provide other inputs, such as digital signatures, to Simplicity programs.\n\nIn the next part we will look at what Simplicity programs are, how they are turned into addresses, and how we add other inputs, such as signatures, to Simplicity programs.",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 351,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": "Github link was replaced with a permanent link",
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "In <a href=\"https://delvingbitcoin.org/t/delving-simplicity-part-building-data-types/1956\">Part \u2162</a> of this series, we showed how to build some data structures and computations using Simplicity\u2019s core set of combinators. As we noted in <a href=\"https://delvingbitcoin.org/t/delving-simplicity-part-combinator-completeness-of-simplicity/1935\">Part \u2161</a>, the core combinators are enough to implement any finite pure computation. This raises the question: what more can be achieved? We can add addition&hellip;",
  "truncated": true,
  "post_url": "/t/delving-simplicity-part-two-side-effects/2091/1",
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}