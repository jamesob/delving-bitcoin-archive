{
  "id": 6285,
  "name": "David Gumberg",
  "username": "davidgumberg",
  "avatar_template": "/user_avatar/delvingbitcoin.org/davidgumberg/{size}/378_2.png",
  "created_at": "2025-11-19T06:15:19.334Z",
  "cooked": "<blockquote>\n<p>For the \u201cScatter plot of Missing Bytes/Reconstruction Time for a node whose peers don\u2019t prefill\u201d, some of the points have &gt; 1 MiB missing and have reconstruction times at ~100ms. Do you know if these points are with peers with large window sizes? I would think that if that much data has to be sent across and the window sizes are ~14480, reconstruction times would be a bit higher\u2026 I\u2019m wondering if you have any ideas on why the reconstruction times are low in those cases?</p>\n</blockquote>\n<p>Unfortunately congestion windows are computed by the sender of a TCP datagram. I think it\u2019s possible for the receiver to estimate the window size by looking at how many bytes are received before the sender stalls until a little bit after sender fires an ack. This would be good data to have for the next measurement, along with your other suggestion about locating the test nodes far apart from one another.</p>\n<blockquote>\n<p>Edit: For the latency formulas, should they include the cost of transmitted data needed to reconstruct in the failure case? I know they are just to form an intuition, but I was also curious about that.</p>\n</blockquote>\n<p>Definitely, thank you for catching this. Though, I don\u2019t think this would affect the criterion since I think the the term would appear in both the prefilling case and the not prefilling case, so it would cancel, but I have to think more about this.</p>\n<blockquote>\n<blockquote>\n<p>Within DoS limits (maybe a limit of 4 MiB per valid header), temporarily store a per-block cache of prefilled transactions you hear about, increasing the chances that you successfully reconstruct without having to wait for an RTT.</p>\n</blockquote>\n<p>Is this because we have 3 HB peers and we want to combine prefills across them to try and reconstruct?</p>\n</blockquote>\n<p>That\u2019s what I had in mind, my hypothesis is that in the scenario that reconstruction fails on the first announcement, you are likely to receive a second CMPCTBLOCK announcement from another peer <em>before</em> you complete a GETBLOCKTXN roundtrip with the first HB peer, so it would be nice if we could leverage this to increase our chances of reconstruction without a roundtrip.</p>\n<h2><a name=\"p-6285-random-strategy-1\" class=\"anchor\" href=\"#p-6285-random-strategy-1\"></a>Random strategy</h2>\n<p>I originally imagined that each node would prefill a random selection from their prefill set when they can\u2019t fit everything. But, assuming for simplicity that everyone has the same mempool, the probability of reconstructing from multiple prefills will be extremely low, where <span class=\"math\">d</span> is the number of draws (prefilled CMPCTBLOCKS received), <span class=\"math\">n</span> is the total number of missing transactions and <span class=\"math\">k</span> is the number of randomly prefilled transactions drawn in each CMPCTBLOCK, the probability of reconstruction is</p>\n<div class=\"math\">\nP_\\text{reconstruction}= 1 - P_{\\geq 1\\text{ tx missing}} = 1 - \\sum_{m=1}^{n-k} (-1)^{m+1} \\binom{n}{m} \\left[\\frac{\\binom{n-m}{k}}{\\binom{n}{k}}\\right]^d\n</div>\n<blockquote>\n<p>This formula, and every other formula in this post makes the following simplifying assumptions, all of which are false in practice, but I suspect that none of the conclusions here change once they are removed: All transactions are equal in size, all nodes will have the same prefill candidate set, all nodes will have the same prefill size.</p>\n</blockquote>\n<hr>\n<details>\n<summary>Derivation</summary>\n<h4><a name=\"p-6285-probability-of-missing-a-particular-set-of-transactions-2\" class=\"anchor\" href=\"#p-6285-probability-of-missing-a-particular-set-of-transactions-2\"></a>Probability of missing a particular set of transactions</h4>\n<p>To calculate the probability of <span class=\"math\">M_i</span>, the event where a given transaction with index <span class=\"math\">i</span> is missing after drawing <span class=\"math\">k</span> many transactions from a pool of <span class=\"math\">n</span> transactions we want to know the proportion of ways to choose <span class=\"math\">k</span> from <span class=\"math\">n</span> that exclude <span class=\"math\">1</span> transaction from <span class=\"math\">n</span>, and the number of ways to choose <span class=\"math\">k</span> from <span class=\"math\">n</span> that excludes some member of <span class=\"math\">n</span> is equal to the number of ways to choose <span class=\"math\">k</span> from <span class=\"math\">n-1</span>, so:</p>\n<div class=\"math\">\nP(M_i) = \\frac{\\binom{n-1}{k}}{\\binom{n}{k}}\n</div>\n<p>Likewise if you want to know the probability that two given transactions, <span class=\"math\">i</span>, <span class=\"math\">j</span>, are excluded:</p>\n<div class=\"math\">\nP(M_i \\cap M_j) = \\frac{\\binom{n-2}{k}}{\\binom{n}{k}}\n</div>\n<p>If we get to draw twice (<span class=\"math\">d=2</span>), the probability that <span class=\"math\">i</span>, <span class=\"math\">j</span> are missing after both draws is the probability that the event happens twice in a row, so:</p>\n<div class=\"math\">\nP(M_i \\cap M_j)^2 = [\\frac{\\binom{n-2}{k}}{\\binom{n}{k}}]^2\n</div>\n<p>And more generally:</p>\n<div class=\"math\">\nP(M_{i_1} \\cap M_{i_2} \\cap \\cdots \\cap M_{i_m}) = \\frac{\\binom{n-m}{k}} {\\binom{n}{k}}\n</div>\n<p>And with multiple draws:</p>\n<div class=\"math\">\nP(M_{i_1} \\cap M_{i_2} \\cap \\cdots \\cap M_{i_m})^d = [\\frac{\\binom{n-m}{k}} {\\binom{n}{k}}]^d\n</div>\n<h4><a name=\"p-6285-probability-of-missing-any-set-of-transactions-of-a-given-size-3\" class=\"anchor\" href=\"#p-6285-probability-of-missing-any-set-of-transactions-of-a-given-size-3\"></a>Probability of missing any set of transactions of a given size</h4>\n<p>In our case, all sets of single transactions are just as likely to be missing, and all sets of two transactions are just as likely to be missing, and so on.</p>\n<p>We can formulate the count of combinations where <em>any</em> 1 transaction is excluded (<span class=\"math\">\\sum _{i=1}^{n}|M_{i}|</span>) as the number of unique sets of one transaction, times the count of combinations where a given set of one is excluded:</p>\n<div class=\"math\">\n\\sum_{i=1}^{n}|M_i| = n\\binom{n-1}{k}\n</div>\n<p>As a probability:</p>\n<div class=\"math\">\n\\sum_{i=1}^{n}P(M_i) = n\\frac{\\binom{n-1}{k}}{\\binom{n}{k}}\n</div>\n<p>Having multiple draws, <span class=\"math\">d</span> the probability becomes:</p>\n<div class=\"math\">\n\\sum_{i=1}^{n}P(M_i) = n\\left[\\frac{\\binom{n-1}{k}}{\\binom{n}{k}}\\right]^d\n</div>\n<p>The count of combinations where <em>any</em> 2 transactions are excluded (<span class=\"math\">\\sum _{1\\leqslant i&lt;j\\leqslant n}|M_{i}\\cap M_{j}|</span>) is the number of unique sets of two transactions multiplied by the count of combinations where a given set of two is excluded:</p>\n<div class=\"math\">\n\\sum_{1 \\leqslant i&lt;j\\leqslant n}M_i\\cap M_{j} = \\binom{n}{2}\\binom{n-2}{k}\n</div>\n<p>Probability:</p>\n<div class=\"math\">\n\\sum_{1 \\leqslant i&lt;j\\leqslant n}P(M_i\\cap M_{j}) = \\binom{n}{2}\\frac{\\binom{n-2}{k}}{\\binom{n}{k}}\n</div>\n<p>More generally:</p>\n<div class=\"math\">\n\\sum_{i=1}^{n}P(M_{1}\\cap \\cdots \\cap M_{n}) = \\binom{n}{i}\\frac{\\binom{n-i}{k}}{\\binom{n}{k}}\n</div>\n<p>And with multiple draws <span class=\"math\">d</span>:</p>\n<div class=\"math\">\n\\sum_{i=1}^{n}P(M_{1}\\cap \\cdots \\cap M_{n}) = \\binom{n}{i}[\\frac{\\binom{n-i}{k}}{\\binom{n}{k}}]^d\n</div>\n<h4><a name=\"p-6285-probability-of-missing-any-set-of-transactions-of-any-size-4\" class=\"anchor\" href=\"#p-6285-probability-of-missing-any-set-of-transactions-of-any-size-4\"></a>Probability of missing any set of transactions of any size</h4>\n<p>The probability of missing any set of any size is equivalent to the sum of probabilities of missing sets of each size, minus the overlaps, since in some of the events where we\u2019re missing one transaction we\u2019ll also miss two or more, and etc. For a formula for this we can use the <a href=\"https://en.wikipedia.org/wiki/Inclusion%E2%80%93exclusion_principle\" rel=\"noopener nofollow ugc\">Inclusion-exclusion principle</a>:</p>\n<div class=\"math\">\nP(\\bigcup _{i=1}^{n}M_{i})=\\sum _{i=1}^{n}P(M_{i})-\\sum _{1\\leqslant i&lt;j\\leqslant n}P(M_{i}\\cap M_{j})+\\sum _{1\\leqslant i&lt;j&lt;k\\leqslant n}P(M_{i}\\cap M_{j}\\cap M_{k})-\\cdots +(-1)^{n+1}P(M_{1}\\cap \\cdots \\cap M_{n})\n</div>\n<hr>\n<details><summary>Inclusion/exclusion principle explanation\n</summary>\n<p>This explanation and the graphic below are equivalent.</p>\n<p>In plain speech, the count of events in <span class=\"math\">A</span> or <span class=\"math\">B</span> or <span class=\"math\">C</span> is the count of events in <span class=\"math\">A</span>, plus the count of events <span class=\"math\">B</span>, plus the count of events in <span class=\"math\">C</span>, so\u2026</p>\n<div class=\"math\">\n|A|+|B|+|C|\n</div>\n<p><strong>\u00a1But!</strong>, this overcounts, since any event that is in both <span class=\"math\">A</span> <em>and</em> <span class=\"math\">B</span> (<span class=\"math\">A \\cap B</span>) is counted twice, similarly with <span class=\"math\">A \\cap C</span> and <span class=\"math\">B \\cap C</span>, let\u2019s deal with the intersections of two\u2026</p>\n<div class=\"math\">\n|A|+|B|+|C| - (|A\\cap B|+|A\\cap C|+|B\\cap C|)\n</div>\n<p><strong>But</strong>, we undercounted, since <span class=\"math\">|A|+|B|+|C|</span> counts the events in <span class=\"math\">A\\cap B\\cap C</span> three times, but <span class=\"math\">|A\\cap B|+|A\\cap C|+|B\\cap C|</span> also counts them three times since any event in all three is in any two, so we have to add them back\u2026</p>\n<div class=\"math\">\n|A\\cup B\\cup C|=|A|+|B|+|C|-|A\\cap B|-|A\\cap C|-|B\\cap C|+|A\\cap B\\cap C|\n</div>\n<p>(No but\u2019s left.)</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/2X/c/cf4082119ddcd7812850895703208e61dcfabc14.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/cf4082119ddcd7812850895703208e61dcfabc14\" title=\"Inclusion-exclusion-3sets\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/2X/c/cf4082119ddcd7812850895703208e61dcfabc14_2_690x278.png\" alt=\"Inclusion-exclusion-3sets\" data-base62-sha1=\"tzr2KkfKBY1gK137WhuHXaqOco4\" width=\"690\" height=\"278\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/2X/c/cf4082119ddcd7812850895703208e61dcfabc14_2_690x278.png, https://delvingbitcoin.org/uploads/default/optimized/2X/c/cf4082119ddcd7812850895703208e61dcfabc14_2_1035x417.png 1.5x, https://delvingbitcoin.org/uploads/default/original/2X/c/cf4082119ddcd7812850895703208e61dcfabc14.png 2x\" data-dominant-color=\"F6F6F6\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">Inclusion-exclusion-3sets</span><span class=\"informations\">1200\u00d7484 39.9 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>More generally:</p>\n<div class=\"math\">\n\\left|\\bigcup _{i=1}^{n}M_{i}\\right|=\\sum _{i=1}^{n}|M_{i}|-\\sum _{1\\leqslant i&lt;j\\leqslant n}|M_{i}\\cap M_{j}|+\\sum _{1\\leqslant i&lt;j&lt;k\\leqslant n}|M_{i}\\cap M_{j}\\cap M_{k}|-\\cdots +(-1)^{n+1}\\left|M_{1}\\cap \\cdots \\cap M_{n}\\right|.\n</div>\n<p>And an almost identical expression for probabilities of events:</p>\n<div class=\"math\">\nP(\\bigcup _{i=1}^{n}M_{i})=\\sum _{i=1}^{n}P(M_{i})-\\sum _{1\\leqslant i&lt;j\\leqslant n}P(M_{i}\\cap M_{j})+\\sum _{1\\leqslant i&lt;j&lt;k\\leqslant n}P(M_{i}\\cap M_{j}\\cap M_{k})-\\cdots +(-1)^{n+1}P(M_{1}\\cap \\cdots \\cap M_{n})\n</div>\n<h4><a name=\"p-6285-end-derivation-5\" class=\"anchor\" href=\"#p-6285-end-derivation-5\"></a>End Derivation</h4>\n</details>\n<hr>\n<p>Applying the inclusion-exclusion formula to the result obtained above:</p>\n<div class=\"math\">\nP(\\geq 1\\text{ tx missing}) = P(\\bigcup _{i=1}^{n}M_{i}) = \\sum_{m=1}^{n} (-1)^{m+1} \\binom{n}{m} \\left[\\frac{\\binom{n-m}{k}}{\\binom{n}{k}}\\right]^d\n</div>\n</details>\n<hr>\n<p>Plugging in an example, if <span class=\"math\">n = 100</span>, <span class=\"math\">k = 80</span> and <span class=\"math\">d = 2</span>:</p>\n<p><span class=\"math\">P(\\text{reconstruction}) = 0.66\\%</span></p>\n<details><summary>Script for calculating</summary>\n<pre data-code-wrap=\"python\"><code class=\"lang-python\">import math\n\n# missing transactions needed for reconstruction\nn = 100\n# prefills per cmpctblock\nk = 80\n# number of cmpctblock messages received\nd = 2\n\ndef p_one_or_more_missing(n, k, d):\n    assert k &gt; 0 and n &gt; 0 and d &gt; 0 and k &lt; n\n\n    # the greatest m for which n - m &gt;= k\n    m_max = n - k\n\n    return sum(\n        (-1)**(m + 1) * math.comb(n, m) * (math.comb(n - m, k) / math.comb(n, k))**d\n        for m in range(1, m_max + 1)\n    )\n\np_reconstruction = 1 - p_one_or_more_missing(n, k, d)\nprint(f\"P(reconstruction) = {p_reconstruction * 100:.4f}%\")\n</code></pre>\n</details>\n<h2><a name=\"p-6285-sliding-window-strategy-6\" class=\"anchor\" href=\"#p-6285-sliding-window-strategy-6\"></a>Sliding window strategy</h2>\n<p>A better strategy was suggested in an offline discussion by <a class=\"mention\" href=\"/u/hodlinator\">@hodlinator</a> which the following is a variation of:</p>\n<p>Each prefiller selects a random offset <span class=\"math\">i</span> from the start of their prefill set, and prefills up to the window limit, looping around if they reach the end.</p>\n<h3><a name=\"p-6285-when-d-2-7\" class=\"anchor\" href=\"#p-6285-when-d-2-7\"></a>When d = 2</h3>\n<p>Assuming that all peers have the same prefill set <span class=\"math\">N</span>, for <span class=\"math\">d=2</span>, the probability of reconstruction is:</p>\n<p>(Where <span class=\"math\">m_1 = n-k</span>, the size of the missing transaction set after one draw.)</p>\n<div class=\"math\">\nP_{reconstruction} = 1 - \\frac{2m_1-1}{n} = \\frac{2k-n+1}{n}\n</div>\n<p>where</p>\n<div class=\"math\">\nk &lt; n \\leq 2k\n</div>\n<hr>\n<details>\n<summary>\nDerivation:\n</summary>\n<blockquote>\n<p><img src=\"https://delvingbitcoin.org/images/emoji/twitter/straight_ruler.png?v=14\" title=\":straight_ruler:\" class=\"emoji\" alt=\":straight_ruler:\" loading=\"lazy\" width=\"20\" height=\"20\">  Since we continue from the beginning (<span class=\"math\">N_1</span>) of the missing transaction set <span class=\"math\">N</span> when we reach the last transaction <span class=\"math\">N_n</span>: All subscripts <span class=\"math\">i</span> in <span class=\"math\">N_i</span> are <span class=\"math\">i \\mod{n}</span> as in <span class=\"math\">N_{(i \\mod{n})}</span>. So <span class=\"math\">N_n</span> might also be written <span class=\"math\">N_0</span>. <img src=\"https://delvingbitcoin.org/images/emoji/twitter/straight_ruler.png?v=14\" title=\":straight_ruler:\" class=\"emoji\" alt=\":straight_ruler:\" loading=\"lazy\" width=\"20\" height=\"20\"></p>\n</blockquote>\n<blockquote>\n<p><img src=\"https://delvingbitcoin.org/images/emoji/twitter/fingerprint.png?v=14\" title=\":fingerprint:\" class=\"emoji\" alt=\":fingerprint:\" loading=\"lazy\" width=\"20\" height=\"20\"> Note that if we start at some index <span class=\"math\">N_i</span> and take <span class=\"math\">x</span> transactions, we\u2019ll get up to <span class=\"math\">N_{i+x-1}</span> and not <span class=\"math\">N_{i+x}</span> since we have to count taking <span class=\"math\">N_i</span>. <img src=\"https://delvingbitcoin.org/images/emoji/twitter/fingerprint.png?v=14\" title=\":fingerprint:\" class=\"emoji\" alt=\":fingerprint:\" loading=\"lazy\" width=\"20\" height=\"20\"></p>\n</blockquote>\n<p>The \u201cmissing set\u201d is the transactions that a node is still missing after one or more prefills. If <span class=\"math\">n</span> (<span class=\"math\">|N</span>| or size of the prefill candidate set or number of transactions in the block missing from mempool) is greater than <span class=\"math\">k</span> (the prefill size measured in transactions), than the missing set has a size <span class=\"math\">m=n-k</span>.</p>\n<p>At any time, the missing set will be a continuous sequence of transactions from the prefill candidate set <span class=\"math\">N</span> uninterrupted by any prefilled transactions, as long as no prefiller\u2019s <span class=\"math\">k</span> is less than any other prefiller\u2019s <span class=\"math\">m=n-k</span>, since after the first draw the missing set is continuous, and the only way to create a gap in the continuous missing transaction sequence is to pick a transaction in the missing sequence, but not reach the end of the missing sequence, which is not possible if <span class=\"math\">k &gt; m</span>. This is fine to assume for now, since for this formula we are assuming that every node has the same <span class=\"math\">k</span> and the same <span class=\"math\">n</span>.</p>\n<p>As long as the missing set is continuous, and <span class=\"math\">k &lt; n</span> (if not, success is inevitable) and <span class=\"math\">k \\geq m</span> (if not, success is impossible) the size of the set <span class=\"math\">S</span> of initial transactions for our prefill that will succeed:</p>\n<div class=\"math\">\n|S| = k - m + 1\n</div>\n<p>Since:</p>\n<p>Beginning with the case when <span class=\"math\">k</span>, the prefill set size, and <span class=\"math\">m</span>, the missing set size, are equal, there is only one way to succeed (<span class=\"math\">|S| = 1</span>), by starting the prefill at the first member of the missing set (<span class=\"math\">N_i = M_1</span>): No other value of <span class=\"math\">i</span> will work as long as <span class=\"math\">k &lt; n</span>, since if we advance <span class=\"math\">i</span> one forward, we will miss the first member of the missing set (<span class=\"math\">M_1</span>). If we didn\u2019t miss the first member of the missing set, then we have just reached <span class=\"math\">N_i-1</span> starting from <span class=\"math\">N_i</span> and advancing to <span class=\"math\">N_{i+k-1}</span>, meaning that:</p>\n<div class=\"math\">\ni + k - 1 \\geq n +  i - 1 \n</div>\n<p>so</p>\n<div class=\"math\">\nk \\geq n\n</div>\n<p>But, we said that <span class=\"math\">k &lt; n</span>, so this is absurd.</p>\n<p>Likewise, if we retreat <span class=\"math\">i</span> one back, we will miss the last member of the missing set <span class=\"math\">M_m</span></p>\n<div class=\"math\">\nM_1 = N_i \n</div>\n<p>thus</p>\n<div class=\"math\">\nM_m = N_{i+m-1}\n</div>\n<p>If we start at <span class=\"math\">N_{i-1}</span> and draw <span class=\"math\">k == m</span> as supposed:</p>\n<div class=\"math\">\nN_{i-1+k-1} = N_{i+k-2} = N_{i+m+2}\n</div>\n<p>We will only reach <span class=\"math\">N_{i+m-2} = M_{m-1}</span>.</p>\n<p>Likewise, if <span class=\"math\">k = m + 1</span>, we still can not advance the starting transaction even one forward from <span class=\"math\">N_i = M_m</span>, for the same argument as put forth above, summarized: as long as <span class=\"math\">k &lt; n</span> (in which circumstance the prefill would succeed anyways), we will not reach the transaction just before the one we started with, so we will fail.</p>\n<p>But, we can now advance one further back, starting at <span class=\"math\">N_{i-1}</span> where <span class=\"math\">N_{i} = M_1</span>, since:</p>\n<p>If we start at <span class=\"math\">N_{i-1}</span> and draw <span class=\"math\">k</span> many transactions:</p>\n<div class=\"math\">\nN_{i-1+k-1} = N_{i+k-2}\n</div>\n<p>But, since:</p>\n<div class=\"math\">\nk = m + 1\n</div>\n<p>It follows that:</p>\n<div class=\"math\">\nN_{i+k-2} = N_{i+m+1-2} = N_{i+m-1}\n</div>\n<p>But,</p>\n<div class=\"math\">\nM_m = N_{i+m-1}\n</div>\n<p>So we reached <span class=\"math\">M_m</span> starting at <span class=\"math\">N_{i-1}</span> with <span class=\"math\">k = m + 1</span>.</p>\n<div class=\"math\">\n\\text{QED}\n</div>\n<p>For the same reasons, if we made <span class=\"math\">k = m + 2</span>, there would be one more way, (totalling three) to succeed.</p>\n<p>Since starting at <span class=\"math\">k=m</span>, <span class=\"math\">|S| = 1</span>, and for each increment <span class=\"math\">k</span> grows by 1, <span class=\"math\">|S|</span> grows by 1:</p>\n<div class=\"math\">\n|S| = k - m +1\n</div>\n<p>And since the probability of success <span class=\"math\">P_{\\text{reconstruction}} = \\frac{|S|}{n}</span>:</p>\n<div class=\"math\">\nP_{\\text{reconstruction}} = \\frac{k-m+1}{n }= \\frac{k-(n - k)+1}{n} = \\frac{2k-n+1}{n}\n</div>\n<p>And simplifying the bounds for this formula, for two draws, if <span class=\"math\">k &lt; m</span> on the second draw, then <span class=\"math\">n \\leq 2k</span>, so <span class=\"math\">k &lt; m</span> whenever:</p>\n<p><span class=\"math\">k &lt; n \\leq 2k</span></p>\n<p>Also:</p>\n<div class=\"math\">\n|S|=k - m + 1\n</div>\n<p>where <span class=\"math\">m</span> is the number of transactions missing after the previous prefills.\nFrom this we also know the size of the set of transaction indexes that result in failure <span class=\"math\">F</span>:</p>\n<div class=\"math\">\n|F| = n - (k - m + 1)\n</div>\n<h4><a name=\"p-6285-end-derivation-8\" class=\"anchor\" href=\"#p-6285-end-derivation-8\"></a>End derivation</h4>\n</details>\n<hr>\n<p>Taking the same example as above, where <span class=\"math\">n = 100</span>, <span class=\"math\">k = 80</span>, <span class=\"math\">d = 2</span>:</p>\n<div class=\"math\">\nP_{\\text{reconstruction}} = 61.00\\%\n</div>\n<hr>\n<h3><a name=\"p-6285-when-d-3-9\" class=\"anchor\" href=\"#p-6285-when-d-3-9\"></a>When d = 3</h3>\n<p>For <span class=\"math\">d = 3</span> (we receive a CMPCTBLOCK from all 3 of our HB peers), the formula is different:</p>\n<div class=\"math\">\nP_\\text{reconstruction} = 1 - \\frac{3m_1^2-3m_1 + 1}{n^2}\n</div>\n<p>where <span class=\"math\">m_1 = n-k</span>.</p>\n<hr>\n<details><summary>Derivation</summary>\n<p>Not very rigorous, but this is my argument, you probably need to read the derivation for <span class=\"math\">d=2</span> to follow,</p>\n<p>Looking up to what we proved in derivation of the previous formula:</p>\n<div class=\"math\">\n|S|=k - m + 1\n</div>\n<p>so</p>\n<div class=\"math\">\n|F| = n - (k - m +1) = n - k + m - 1 = m + m - 1 = 2m -1\n</div>\n<p>On the third draw, <span class=\"math\">m</span> varies depending on what was selected for the second draw. In the worst case, if the same <span class=\"math\">i</span> is selected as the starting index in the first prefill and the second, <span class=\"math\">m=n-k</span>. Similarly <span class=\"math\">|F|</span> is unchanged, the second draw has not reduced the number of ways to fail. But every other possible <span class=\"math\">i</span> on the 2nd prefill will remove some transactions from the missing set <span class=\"math\">M</span>, and <span class=\"math\">F</span> will shrink as a result, since <span class=\"math\">|F|=n - k + m - 1</span>. So, when <span class=\"math\">M</span> loses a member, <span class=\"math\">F</span> loses a member, and vice versa.</p>\n<p>Also note that after one draw, <span class=\"math\">|F| = 2m-1</span>, so <span class=\"math\">|F|</span> will always be an odd number after one draw.</p>\n<p>Let\u2019s take an example, <span class=\"math\">n = 10</span>, <span class=\"math\">k=7</span>, if the first prefill chooses <span class=\"math\">i=1</span>, then <span class=\"math\">M = \\{8, 9, 10\\}</span> will be missing, the set of <span class=\"math\">i</span> for which reconstruction will fail on the second draw are <span class=\"math\">F = \\{1, 2, 3, 9, 10\\}</span> (<span class=\"math\">|F|=2(3)-1=5</span>). If the second draw is the same as the first (<span class=\"math\">i=1</span>), the situation doesn\u2019t change, the missing set is unchanged, <span class=\"math\">M = \\{8, 9, 10\\}</span>.</p>\n<p>But, if the second draw was e.g. <span class=\"math\">i=2</span>, <span class=\"math\">8</span> is removed from <span class=\"math\">M</span>, so <span class=\"math\">9</span> (and only <span class=\"math\">9</span>) is removed from the failure set. Likewise, if the second draw was <span class=\"math\">10</span>, <span class=\"math\">3</span> would no longer be a failure condition. In both of these cases one transaction is removed from <span class=\"math\">M</span>, so <span class=\"math\">|F|</span> shrinks by 1.</p>\n<p>Similarly, for both <span class=\"math\">i=3</span> and <span class=\"math\">i=9</span>, two members of the missing set are removed (<span class=\"math\">\\{8, 9\\}</span> and <span class=\"math\">\\{9, 10\\}</span> respectively) so in each case, there are two fewer ways to fail.</p>\n<p>I think this could be made more rigorous, but I make the argument in a soft and squishy way:</p>\n<p>As argued above, the missing set will always be continuous. And if <span class=\"math\">m \\geq 2</span> there will be two ways to remove exactly <span class=\"math\">1</span> member from the missing set. Since, you can either start at the last missing transaction <span class=\"math\">M_m</span> and remove that transaction, or you pick some other index <span class=\"math\">i</span> which ends on the first transaction of the missing set <span class=\"math\">N_{i + k -1} = M_1</span>. Any other <span class=\"math\">i</span> will either remove more members from <span class=\"math\">M</span> than 1 or fail to remove <span class=\"math\">1</span>. If <span class=\"math\">m = 2</span>, then there are <span class=\"math\">|S|</span> as given above ways to remove <span class=\"math\">2</span> members.</p>\n<p>Likewise for <span class=\"math\">m \\geq 3</span> there are exactly two <span class=\"math\">N_i</span> in <span class=\"math\">N</span> that will remove two members from <span class=\"math\">M</span>, and so on.</p>\n<p>This is all with the notable exception stated above, that there is one way for the missing set to remain unchanged on the second draw if <span class=\"math\">n \\leq 2k</span>, which is to pick the same index as before.</p>\n<blockquote>\n<p>Please note, I am using <span class=\"math\">m_1</span> as shorthand for <span class=\"math\">n-k</span> OR <span class=\"math\">m</span> after 1 draw in the following formulas, this is because <span class=\"math\">m</span> is varying.</p>\n</blockquote>\n<p>And so, to count the total number of ways to fail that are removed (<span class=\"math\">r</span>) if the 2nd draw was favorable, there are two ways for it to be lesser by one, two ways for it to be less by two, and so on until <span class=\"math\">m-1</span>:</p>\n<div class=\"math\">\nr = \\sum_{i=1}^{i=m_1-1}{2i}\n</div>\n<p>If we assumed that the number of ways to fail was always maximally bad after the 2nd draw, no matter what it was, the number of ways to fail on the 3rd draw would be <span class=\"math\">(2m_1-1)^2</span>. But, if we take into account the fact that some ways to fail are removed:</p>\n<div class=\"math\">\n|F| = (2m_1-1)^2 - r = (2m_1-1)^2 -   \\sum_{i=1}^{i=m_1-1}{2i}\n</div>\n<p>And this can be simplified since <span class=\"math\">r</span> is the sum of an arithmetic series:</p>\n<div class=\"math\">\nr = \\sum_{i=1}^{i=m_1-1}{2i} = 2\\sum_{i=1}^{i=m_1-1}{i} =  2\\frac{m_1(m_1-1)}{2} = m_1(m_1-1)\n</div>\n<p>So (where <span class=\"math\">m_1 = n-k</span>)</p>\n<div class=\"math\">\n|F| = (2m_1-1)^2 - m_1(m_1-1) = 4m_1^2 - 4m_1 + 1 - m_1^2 + m_1 = 3m_1^2-3m_1 + 1\n</div>\n<p>and</p>\n<div class=\"math\">\nP_\\text{reconstruction} = \\frac{3m_1^2-3m_1 + 1}{n^2}\n</div>\n<div class=\"math\">\n\\text{QED}\n</div>\n<h4><a name=\"p-6285-end-derivation-10\" class=\"anchor\" href=\"#p-6285-end-derivation-10\"></a>End derivation</h4>\n</details>\n<hr>\n<p>Using the same example again, <span class=\"math\">n = 100</span>, <span class=\"math\">k = 80</span>, <span class=\"math\">d = 3</span>:</p>\n<div class=\"math\">\nP_{\\text{reconstruction}} = 88.59\\%\n</div>\n",
  "post_number": 45,
  "post_type": 1,
  "posts_count": 46,
  "updated_at": "2025-11-19T06:15:19.334Z",
  "reply_count": 1,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 3,
  "reads": 14,
  "readers_count": 13,
  "score": 22.8,
  "yours": false,
  "topic_id": 1052,
  "topic_slug": "stats-on-compact-block-reconstructions",
  "topic_title": "Stats on compact block reconstructions",
  "topic_html_title": "Stats on compact block reconstructions",
  "category_id": 7,
  "display_username": "David Gumberg",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": ">For the \u201cScatter plot of Missing Bytes/Reconstruction Time for a node whose peers don\u2019t prefill\u201d, some of the points have > 1 MiB missing and have reconstruction times at ~100ms. Do you know if these points are with peers with large window sizes? I would think that if that much data has to be sent across and the window sizes are ~14480, reconstruction times would be a bit higher\u2026 I\u2019m wondering if you have any ideas on why the reconstruction times are low in those cases?\n\nUnfortunately congestion windows are computed by the sender of a TCP datagram. I think it's possible for the receiver to estimate the window size by looking at how many bytes are received before the sender stalls until a little bit after sender fires an ack. This would be good data to have for the next measurement, along with your other suggestion about locating the test nodes far apart from one another.\n\n>Edit: For the latency formulas, should they include the cost of transmitted data needed to reconstruct in the failure case? I know they are just to form an intuition, but I was also curious about that.\n\nDefinitely, thank you for catching this. Though, I don't think this would affect the criterion since I think the the term would appear in both the prefilling case and the not prefilling case, so it would cancel, but I have to think more about this.\n\n>> Within DoS limits (maybe a limit of 4 MiB per valid header), temporarily store a per-block cache of prefilled transactions you hear about, increasing the chances that you successfully reconstruct without having to wait for an RTT.\n>\n> Is this because we have 3 HB peers and we want to combine prefills across them to try and reconstruct?\n\nThat's what I had in mind, my hypothesis is that in the scenario that reconstruction fails on the first announcement, you are likely to receive a second CMPCTBLOCK announcement from another peer *before* you complete a GETBLOCKTXN roundtrip with the first HB peer, so it would be nice if we could leverage this to increase our chances of reconstruction without a roundtrip.\n\n## Random strategy\n\nI originally imagined that each node would prefill a random selection from their prefill set when they can't fit everything. But, assuming for simplicity that everyone has the same mempool, the probability of reconstructing from multiple prefills will be extremely low, where $d$ is the number of draws (prefilled CMPCTBLOCKS received), $n$ is the total number of missing transactions and $k$ is the number of randomly prefilled transactions drawn in each CMPCTBLOCK, the probability of reconstruction is\n\n$$\nP_\\text{reconstruction}= 1 - P_{\\geq 1\\text{ tx missing}} = 1 - \\sum_{m=1}^{n-k} (-1)^{m+1} \\binom{n}{m} \\left[\\frac{\\binom{n-m}{k}}{\\binom{n}{k}}\\right]^d\n$$\n\n> This formula, and every other formula in this post makes the following simplifying assumptions, all of which are false in practice, but I suspect that none of the conclusions here change once they are removed: All transactions are equal in size, all nodes will have the same prefill candidate set, all nodes will have the same prefill size.\n\n\n---\n<details>\n\n<summary>Derivation</summary>\n\n\n#### Probability of missing a particular set of transactions\n\nTo calculate the probability of $M_i$, the event where a given transaction with index $i$ is missing after drawing $k$ many transactions from a pool of $n$ transactions we want to know the proportion of ways to choose $k$ from $n$ that exclude $1$ transaction from $n$, and the number of ways to choose $k$ from $n$ that excludes some member of $n$ is equal to the number of ways to choose $k$ from $n-1$, so:\n\n$$\nP(M_i) = \\frac{\\binom{n-1}{k}}{\\binom{n}{k}}\n$$\n\nLikewise if you want to know the probability that two given transactions, $i$, $j$, are excluded:\n\n$$\nP(M_i \\cap M_j) = \\frac{\\binom{n-2}{k}}{\\binom{n}{k}}\n$$\n\nIf we get to draw twice ($d=2$), the probability that $i$, $j$ are missing after both draws is the probability that the event happens twice in a row, so:\n\n\n$$\nP(M_i \\cap M_j)^2 = [\\frac{\\binom{n-2}{k}}{\\binom{n}{k}}]^2\n$$\n\nAnd more generally:\n\n$$\nP(M_{i_1} \\cap M_{i_2} \\cap \\cdots \\cap M_{i_m}) = \\frac{\\binom{n-m}{k}} {\\binom{n}{k}}\n$$\n\nAnd with multiple draws:\n$$\nP(M_{i_1} \\cap M_{i_2} \\cap \\cdots \\cap M_{i_m})^d = [\\frac{\\binom{n-m}{k}} {\\binom{n}{k}}]^d\n$$\n\n#### Probability of missing any set of transactions of a given size\n\nIn our case, all sets of single transactions are just as likely to be missing, and all sets of two transactions are just as likely to be missing, and so on.\n\nWe can formulate the count of combinations where *any* 1 transaction is excluded ($\\sum _{i=1}^{n}|M_{i}|$) as the number of unique sets of one transaction, times the count of combinations where a given set of one is excluded:\n\n$$\n\\sum_{i=1}^{n}|M_i| = n\\binom{n-1}{k}\n$$\n\nAs a probability:\n\n$$\n\\sum_{i=1}^{n}P(M_i) = n\\frac{\\binom{n-1}{k}}{\\binom{n}{k}}\n$$\n\nHaving multiple draws, $d$ the probability becomes:\n\n$$\n\\sum_{i=1}^{n}P(M_i) = n\\left[\\frac{\\binom{n-1}{k}}{\\binom{n}{k}}\\right]^d\n$$\n\nThe count of combinations where *any* 2 transactions are excluded ($\\sum _{1\\leqslant i<j\\leqslant n}|M_{i}\\cap M_{j}|$) is the number of unique sets of two transactions multiplied by the count of combinations where a given set of two is excluded:\n\n$$\n\\sum_{1 \\leqslant i<j\\leqslant n}M_i\\cap M_{j} = \\binom{n}{2}\\binom{n-2}{k}\n$$\n\nProbability:\n$$\n\\sum_{1 \\leqslant i<j\\leqslant n}P(M_i\\cap M_{j}) = \\binom{n}{2}\\frac{\\binom{n-2}{k}}{\\binom{n}{k}}\n$$\n\nMore generally:\n\n$$\n\\sum_{i=1}^{n}P(M_{1}\\cap \\cdots \\cap M_{n}) = \\binom{n}{i}\\frac{\\binom{n-i}{k}}{\\binom{n}{k}}\n$$\n\nAnd with multiple draws $d$:\n\n$$\n\\sum_{i=1}^{n}P(M_{1}\\cap \\cdots \\cap M_{n}) = \\binom{n}{i}[\\frac{\\binom{n-i}{k}}{\\binom{n}{k}}]^d\n$$\n\n#### Probability of missing any set of transactions of any size\n\nThe probability of missing any set of any size is equivalent to the sum of probabilities of missing sets of each size, minus the overlaps, since in some of the events where we're missing one transaction we'll also miss two or more, and etc. For a formula for this we can use the [Inclusion-exclusion principle](https://en.wikipedia.org/wiki/Inclusion%E2%80%93exclusion_principle): \n\n$$\nP(\\bigcup _{i=1}^{n}M_{i})=\\sum _{i=1}^{n}P(M_{i})-\\sum _{1\\leqslant i<j\\leqslant n}P(M_{i}\\cap M_{j})+\\sum _{1\\leqslant i<j<k\\leqslant n}P(M_{i}\\cap M_{j}\\cap M_{k})-\\cdots +(-1)^{n+1}P(M_{1}\\cap \\cdots \\cap M_{n})\n$$\n\n----\n<details><summary>Inclusion/exclusion principle explanation\n</summary>\n\nThis explanation and the graphic below are equivalent.\n\nIn plain speech, the count of events in $A$ or $B$ or $C$ is the count of events in $A$, plus the count of events $B$, plus the count of events in $C$, so...\n\n$$\n|A|+|B|+|C|\n$$\n\n**\u00a1But!**, this overcounts, since any event that is in both $A$ *and* $B$ ($A \\cap B$) is counted twice, similarly with $A \\cap C$ and $B \\cap C$, let's deal with the intersections of two...\n\n$$\n|A|+|B|+|C| - (|A\\cap B|+|A\\cap C|+|B\\cap C|)\n$$\n\n**But**, we undercounted, since $|A|+|B|+|C|$ counts the events in $A\\cap B\\cap C$ three times, but $|A\\cap B|+|A\\cap C|+|B\\cap C|$ also counts them three times since any event in all three is in any two, so we have to add them back...\n\n$$\n|A\\cup B\\cup C|=|A|+|B|+|C|-|A\\cap B|-|A\\cap C|-|B\\cap C|+|A\\cap B\\cap C|\n$$\n\n(No but's left.)\n\n![Inclusion-exclusion-3sets|690x278](upload://tzr2KkfKBY1gK137WhuHXaqOco4.png)\n\nMore generally: \n\n$$\n\\left|\\bigcup _{i=1}^{n}M_{i}\\right|=\\sum _{i=1}^{n}|M_{i}|-\\sum _{1\\leqslant i<j\\leqslant n}|M_{i}\\cap M_{j}|+\\sum _{1\\leqslant i<j<k\\leqslant n}|M_{i}\\cap M_{j}\\cap M_{k}|-\\cdots +(-1)^{n+1}\\left|M_{1}\\cap \\cdots \\cap M_{n}\\right|.\n$$\n\nAnd an almost identical expression for probabilities of events:\n$$\nP(\\bigcup _{i=1}^{n}M_{i})=\\sum _{i=1}^{n}P(M_{i})-\\sum _{1\\leqslant i<j\\leqslant n}P(M_{i}\\cap M_{j})+\\sum _{1\\leqslant i<j<k\\leqslant n}P(M_{i}\\cap M_{j}\\cap M_{k})-\\cdots +(-1)^{n+1}P(M_{1}\\cap \\cdots \\cap M_{n})\n$$\n\n#### End Derivation\n\n</details>\n\n---\n\nApplying the inclusion-exclusion formula to the result obtained above:\n\n$$\nP(\\geq 1\\text{ tx missing}) = P(\\bigcup _{i=1}^{n}M_{i}) = \\sum_{m=1}^{n} (-1)^{m+1} \\binom{n}{m} \\left[\\frac{\\binom{n-m}{k}}{\\binom{n}{k}}\\right]^d\n$$\n\n</details>\n\n---\n\nPlugging in an example, if $n = 100$, $k = 80$ and $d = 2$:\n\n$P(\\text{reconstruction}) = 0.66\\%$\n\n<details><summary>Script for calculating</summary>\n\n```python\nimport math\n\n# missing transactions needed for reconstruction\nn = 100\n# prefills per cmpctblock\nk = 80\n# number of cmpctblock messages received\nd = 2\n\ndef p_one_or_more_missing(n, k, d):\n    assert k > 0 and n > 0 and d > 0 and k < n\n\n    # the greatest m for which n - m >= k\n    m_max = n - k\n\n    return sum(\n        (-1)**(m + 1) * math.comb(n, m) * (math.comb(n - m, k) / math.comb(n, k))**d\n        for m in range(1, m_max + 1)\n    )\n\np_reconstruction = 1 - p_one_or_more_missing(n, k, d)\nprint(f\"P(reconstruction) = {p_reconstruction * 100:.4f}%\")\n```\n\n</details>\n\n## Sliding window strategy\n\nA better strategy was suggested in an offline discussion by @hodlinator which the following is a variation of:\n\nEach prefiller selects a random offset $i$ from the start of their prefill set, and prefills up to the window limit, looping around if they reach the end.\n\n\n### When d = 2\nAssuming that all peers have the same prefill set $N$, for $d=2$, the probability of reconstruction is:\n\n(Where $m_1 = n-k$, the size of the missing transaction set after one draw.)\n\n$$\nP_{reconstruction} = 1 - \\frac{2m_1-1}{n} = \\frac{2k-n+1}{n}\n$$\n\nwhere  \n\n$$\nk < n \\leq 2k\n$$\n\n\n---\n<details>\n<summary>\nDerivation:\n</summary>\n\n\n> :straight_ruler:  Since we continue from the beginning ($N_1$) of the missing transaction set $N$ when we reach the last transaction $N_n$: All subscripts $i$ in $N_i$ are $i \\mod{n}$ as in $N_{(i \\mod{n})}$. So $N_n$ might also be written $N_0$. :straight_ruler:\n\n> :fingerprint: Note that if we start at some index $N_i$ and take $x$ transactions, we'll get up to $N_{i+x-1}$ and not $N_{i+x}$ since we have to count taking $N_i$. :fingerprint:\n\nThe \"missing set\" is the transactions that a node is still missing after one or more prefills. If $n$ ($|N$| or size of the prefill candidate set or number of transactions in the block missing from mempool) is greater than $k$ (the prefill size measured in transactions), than the missing set has a size $m=n-k$.\n\nAt any time, the missing set will be a continuous sequence of transactions from the prefill candidate set $N$ uninterrupted by any prefilled transactions, as long as no prefiller's $k$ is less than any other prefiller's $m=n-k$, since after the first draw the missing set is continuous, and the only way to create a gap in the continuous missing transaction sequence is to pick a transaction in the missing sequence, but not reach the end of the missing sequence, which is not possible if $k > m$. This is fine to assume for now, since for this formula we are assuming that every node has the same $k$ and the same $n$.\n\nAs long as the missing set is continuous, and $k < n$ (if not, success is inevitable) and $k \\geq m$ (if not, success is impossible) the size of the set $S$ of initial transactions for our prefill that will succeed:\n\n$$\n|S| = k - m + 1\n$$\n\nSince: \n\nBeginning with the case when $k$, the prefill set size, and $m$, the missing set size, are equal, there is only one way to succeed ($|S| = 1$), by starting the prefill at the first member of the missing set ($N_i = M_1$): No other value of $i$ will work as long as $k < n$, since if we advance $i$ one forward, we will miss the first member of the missing set ($M_1$). If we didn't miss the first member of the missing set, then we have just reached $N_i-1$ starting from $N_i$ and advancing to $N_{i+k-1}$, meaning that:\n\n$$\ni + k - 1 \\geq n +  i - 1 \n$$\n\nso\n\n$$\nk \\geq n\n$$\n\nBut, we said that $k < n$, so this is absurd.\n\nLikewise, if we retreat $i$ one back, we will miss the last member of the missing set $M_m$\n\n$$\nM_1 = N_i \n$$\n\nthus\n\n$$\nM_m = N_{i+m-1}\n$$\n\nIf we start at $N_{i-1}$ and draw $k == m$ as supposed:\n\n$$\nN_{i-1+k-1} = N_{i+k-2} = N_{i+m+2}\n$$\n\nWe will only reach $N_{i+m-2} = M_{m-1}$.\n\nLikewise, if $k = m + 1$, we still can not advance the starting transaction even one forward from $N_i = M_m$, for the same argument as put forth above, summarized: as long as $k < n$ (in which circumstance the prefill would succeed anyways), we will not reach the transaction just before the one we started with, so we will fail. \n\nBut, we can now advance one further back, starting at $N_{i-1}$ where $N_{i} = M_1$, since:\n\nIf we start at $N_{i-1}$ and draw $k$ many transactions:\n$$\nN_{i-1+k-1} = N_{i+k-2}\n$$\nBut, since:\n$$\nk = m + 1\n$$\nIt follows that:\n$$\nN_{i+k-2} = N_{i+m+1-2} = N_{i+m-1}\n$$\n\nBut,\n\n$$\nM_m = N_{i+m-1}\n$$\n\nSo we reached $M_m$ starting at $N_{i-1}$ with $k = m + 1$.\n$$\n\\text{QED}\n$$\n\nFor the same reasons, if we made $k = m + 2$, there would be one more way, (totalling three) to succeed.\n\nSince starting at $k=m$, $|S| = 1$, and for each increment $k$ grows by 1, $|S|$ grows by 1:\n$$\n|S| = k - m +1\n$$\n\nAnd since the probability of success $P_{\\text{reconstruction}} = \\frac{|S|}{n}$:\n\n$$\nP_{\\text{reconstruction}} = \\frac{k-m+1}{n }= \\frac{k-(n - k)+1}{n} = \\frac{2k-n+1}{n}\n$$\n\nAnd simplifying the bounds for this formula, for two draws, if $k < m$ on the second draw, then $n \\leq 2k$, so $k < m$ whenever:\n\n$k < n \\leq 2k$\n\nAlso: \n\n$$\n|S|=k - m + 1\n$$\n\nwhere $m$ is the number of transactions missing after the previous prefills.\nFrom this we also know the size of the set of transaction indexes that result in failure $F$:\n\n$$\n|F| = n - (k - m + 1)\n$$\n\n#### End derivation\n</details>\n\n---\nTaking the same example as above, where $n = 100$, $k = 80$, $d = 2$:\n\n$$\nP_{\\text{reconstruction}} = 61.00\\%\n$$\n---\n### When d = 3\n\nFor $d = 3$ (we receive a CMPCTBLOCK from all 3 of our HB peers), the formula is different:\n$$\nP_\\text{reconstruction} = 1 - \\frac{3m_1^2-3m_1 + 1}{n^2}\n$$\n\nwhere $m_1 = n-k$.\n\n\n---\n<details><summary>Derivation</summary>\n\n\nNot very rigorous, but this is my argument, you probably need to read the derivation for $d=2$ to follow, \n\nLooking up to what we proved in derivation of the previous formula:\n$$\n|S|=k - m + 1\n$$\n\nso\n\n$$\n|F| = n - (k - m +1) = n - k + m - 1 = m + m - 1 = 2m -1\n$$\n\nOn the third draw, $m$ varies depending on what was selected for the second draw. In the worst case, if the same $i$ is selected as the starting index in the first prefill and the second, $m=n-k$. Similarly $|F|$ is unchanged, the second draw has not reduced the number of ways to fail. But every other possible $i$ on the 2nd prefill will remove some transactions from the missing set $M$, and $F$ will shrink as a result, since $|F|=n - k + m - 1$. So, when $M$ loses a member, $F$ loses a member, and vice versa.\n\nAlso note that after one draw, $|F| = 2m-1$, so $|F|$ will always be an odd number after one draw.\n\nLet's take an example, $n = 10$, $k=7$, if the first prefill chooses $i=1$, then $M = \\{8, 9, 10\\}$ will be missing, the set of $i$ for which reconstruction will fail on the second draw are $F = \\{1, 2, 3, 9, 10\\}$ ($|F|=2(3)-1=5$). If the second draw is the same as the first ($i=1$), the situation doesn't change, the missing set is unchanged, $M = \\{8, 9, 10\\}$. \n\nBut, if the second draw was e.g. $i=2$, $8$ is removed from $M$, so $9$ (and only $9$) is removed from the failure set. Likewise, if the second draw was $10$, $3$ would no longer be a failure condition. In both of these cases one transaction is removed from $M$, so $|F|$ shrinks by 1.\n\nSimilarly, for both $i=3$ and $i=9$, two members of the missing set are removed ($\\{8, 9\\}$ and $\\{9, 10\\}$ respectively) so in each case, there are two fewer ways to fail. \n\nI think this could be made more rigorous, but I make the argument in a soft and squishy way:\n\nAs argued above, the missing set will always be continuous. And if $m \\geq 2$ there will be two ways to remove exactly $1$ member from the missing set. Since, you can either start at the last missing transaction $M_m$ and remove that transaction, or you pick some other index $i$ which ends on the first transaction of the missing set $N_{i + k -1} = M_1$. Any other $i$ will either remove more members from $M$ than 1 or fail to remove $1$. If $m = 2$, then there are $|S|$ as given above ways to remove $2$ members. \n\nLikewise for $m \\geq 3$ there are exactly two $N_i$ in $N$ that will remove two members from $M$, and so on.\n\nThis is all with the notable exception stated above, that there is one way for the missing set to remain unchanged on the second draw if $n \\leq 2k$, which is to pick the same index as before.\n\n> Please note, I am using $m_1$ as shorthand for $n-k$ OR $m$ after 1 draw in the following formulas, this is because $m$ is varying.\n\nAnd so, to count the total number of ways to fail that are removed ($r$) if the 2nd draw was favorable, there are two ways for it to be lesser by one, two ways for it to be less by two, and so on until $m-1$:\n\n$$\nr = \\sum_{i=1}^{i=m_1-1}{2i}\n$$\n\nIf we assumed that the number of ways to fail was always maximally bad after the 2nd draw, no matter what it was, the number of ways to fail on the 3rd draw would be $(2m_1-1)^2$. But, if we take into account the fact that some ways to fail are removed:\n\n$$\n|F| = (2m_1-1)^2 - r = (2m_1-1)^2 -   \\sum_{i=1}^{i=m_1-1}{2i}\n$$\n\nAnd this can be simplified since $r$ is the sum of an arithmetic series:\n\n$$\nr = \\sum_{i=1}^{i=m_1-1}{2i} = 2\\sum_{i=1}^{i=m_1-1}{i} =  2\\frac{m_1(m_1-1)}{2} = m_1(m_1-1)\n$$\n\nSo (where $m_1 = n-k$)\n\n$$\n|F| = (2m_1-1)^2 - m_1(m_1-1) = 4m_1^2 - 4m_1 + 1 - m_1^2 + m_1 = 3m_1^2-3m_1 + 1\n$$\n\nand\n\n$$\nP_\\text{reconstruction} = \\frac{3m_1^2-3m_1 + 1}{n^2}\n$$\n\n$$\n\\text{QED}\n$$\n\n#### End derivation\n</details>\n\n---\n\nUsing the same example again, $n = 100$, $k = 80$, $d = 3$:\n\n$$\nP_{\\text{reconstruction}} = 88.59\\%\n$$",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 315,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "For the \u201cScatter plot of Missing Bytes/Reconstruction Time for a node whose peers don\u2019t prefill\u201d, some of the points have &gt; 1 MiB missing and have reconstruction times at ~100ms. Do you know if these points are with peers with large window sizes? I would think that if that much data has to be sent &hellip;",
  "truncated": true,
  "post_url": "/t/stats-on-compact-block-reconstructions/1052/45",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}