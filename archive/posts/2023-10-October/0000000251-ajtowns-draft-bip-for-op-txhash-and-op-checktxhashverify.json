{
  "id": 251,
  "name": "Anthony Towns",
  "username": "ajtowns",
  "avatar_template": "/user_avatar/delvingbitcoin.org/ajtowns/{size}/3_2.png",
  "created_at": "2023-10-02T09:26:11.173Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"stevenroose\" data-post=\"1\" data-topic=\"121\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/letter_avatar_proxy/v4/letter/s/8edcca/48.png\" class=\"avatar\"> stevenroose:</div>\n<blockquote>\n<p>Does the proposal sufficiently address concerns around resource usage and quadratic hashing?</p>\n</blockquote>\n</aside>\n<p>There\u2019s two good, general ways of addressing quadratic hashing with this sort of opcode that come to my mind:</p>\n<ol>\n<li>(a) break it up into two phases, the first where you do a constant number of hashes over each byte of the tx and cache the result which adds O(txsize) computation and either O(1) or O(txsize) storage for the cache; then (b) combine a constant number of those cached hashes at runtime to implement the new opcode, so that it\u2019s both O(1) time and quite fast. That\u2019s what CTV does, and there was a bit of concern about how costly the first step was, and, if doing it on-demand, how complicated it is to share the just-in-time cached data across different threads (when the cache needs to be shared across different inputs without being recalculated, and those inputs may or may not be be being handled by different threads).</li>\n<li>Allow the tx to waste time hashing things, but add that as additional \u201cvirtual weight\u201d via the taproot annex as <a href=\"https://github.com/bitcoin/bips/blob/e918b50731397872ad2922a1b08a5a4cd1d6d546/bip-0342.mediawiki#cite_note-13\">envisaged in bip 342</a>.</li>\n</ol>\n<p>I think either of those could be made to work fine.</p>\n<p>I think what you actually propose is more along the lines of \u201censure that OP_TXHASH only ever hashes a constant data size\u201d, but I don\u2019t think that quite works here \u2013 you\u2019re allowing a hash of random combinations of inputs\u2019 scriptSigs, which can be as large as a block, and I don\u2019t think (as specced) there\u2019s a decent way to cache and reuse those results.</p>\n<aside class=\"quote no-group\" data-username=\"stevenroose\" data-post=\"1\" data-topic=\"121\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/letter_avatar_proxy/v4/letter/s/8edcca/48.png\" class=\"avatar\"> stevenroose:</div>\n<blockquote>\n<p>The flexibility of selecting transaction fields and in/output (ranges), makes this construction way more useful</p>\n</blockquote>\n</aside>\n<p>Do you have specific/concrete examples of uses that this extra flexibility enables? Would you be up for doing a rough demo of what they\u2019d look like in action something like <a href=\"https://github.com/jamesob/opvault-demo/\" class=\"inline-onebox\">GitHub - jamesob/opvault-demo: An example wallet using OP_VAULT</a> ?</p>\n<aside class=\"quote no-group\" data-username=\"stevenroose\" data-post=\"1\" data-topic=\"121\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/letter_avatar_proxy/v4/letter/s/8edcca/48.png\" class=\"avatar\"> stevenroose:</div>\n<blockquote>\n<p>the other one could be left free (OP_SUCCESS) to potentially revisit later-on</p>\n</blockquote>\n</aside>\n<p>I thought someone had made a post about this sort of thing being somewhat annoying as far as analysing miniscript goes, if this feature were to be included in miniscript, but I can\u2019t find the reference now. In any event, it seems pretty risky to have a potentially user-provided stack element be able to turn a script into \u201calways succeed\u201d behaviour. I think it would be better for the upgrade path to just be \u201cif we want more txhash-y things, we\u2019ll introduce OP_TXHASH2\u201d.</p>\n<p>Note that this differs from the checksig upgradability behaviour \u2013 there we have <code>&lt;sig&gt; &lt;unknownpubkey&gt; CHECKSIG</code> be equivalent to <code>&lt;sig&gt; \"\" OP_NOTEQUAL</code>, and soft-fork in immediate script failure on invalid sig once we decide what \u201cinvalid\u201d means for <code>&lt;unknownpubkey&gt;</code>.</p>",
  "post_number": 2,
  "post_type": 1,
  "updated_at": "2023-10-02T09:31:12.808Z",
  "reply_count": 1,
  "reply_to_post_number": null,
  "quote_count": 1,
  "incoming_link_count": 0,
  "reads": 2,
  "readers_count": 1,
  "score": 15.4,
  "yours": false,
  "topic_id": 121,
  "topic_slug": "draft-bip-for-op-txhash-and-op-checktxhashverify",
  "topic_title": "Draft BIP for OP_TXHASH and OP_CHECKTXHASHVERIFY",
  "topic_html_title": "Draft BIP for OP_TXHASH and OP_CHECKTXHASHVERIFY",
  "category_id": 7,
  "display_username": "Anthony Towns",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"stevenroose, post:1, topic:121\"]\nDoes the proposal sufficiently address concerns around resource usage and quadratic hashing?\n[/quote]\n\nThere's two good, general ways of addressing quadratic hashing with this sort of opcode that come to my mind:\n1. (a) break it up into two phases, the first where you do a constant number of hashes over each byte of the tx and cache the result which adds O(txsize) computation and either O(1) or O(txsize) storage for the cache; then (b) combine a constant number of those cached hashes at runtime to implement the new opcode, so that it's both O(1) time and quite fast. That's what CTV does, and there was a bit of concern about how costly the first step was, and, if doing it on-demand, how complicated it is to share the just-in-time cached data across different threads (when the cache needs to be shared across different inputs without being recalculated, and those inputs may or may not be be being handled by different threads).\n2. Allow the tx to waste time hashing things, but add that as additional \"virtual weight\" via the taproot annex as [envisaged in bip 342](https://github.com/bitcoin/bips/blob/e918b50731397872ad2922a1b08a5a4cd1d6d546/bip-0342.mediawiki#cite_note-13).\n\nI think either of those could be made to work fine.\n\nI think what you actually propose is more along the lines of \"ensure that OP_TXHASH only ever hashes a constant data size\", but I don't think that quite works here -- you're allowing a hash of random combinations of inputs' scriptSigs, which can be as large as a block, and I don't think (as specced) there's a decent way to cache and reuse those results.\n\n[quote=\"stevenroose, post:1, topic:121\"]\nThe flexibility of selecting transaction fields and in/output (ranges), makes this construction way more useful\n[/quote]\n\nDo you have specific/concrete examples of uses that this extra flexibility enables? Would you be up for doing a rough demo of what they'd look like in action something like https://github.com/jamesob/opvault-demo/ ?\n\n[quote=\"stevenroose, post:1, topic:121\"]\nthe other one could be left free (OP_SUCCESS) to potentially revisit later-on\n[/quote]\n\nI thought someone had made a post about this sort of thing being somewhat annoying as far as analysing miniscript goes, if this feature were to be included in miniscript, but I can't find the reference now. In any event, it seems pretty risky to have a potentially user-provided stack element be able to turn a script into \"always succeed\" behaviour. I think it would be better for the upgrade path to just be \"if we want more txhash-y things, we'll introduce OP_TXHASH2\".\n\nNote that this differs from the checksig upgradability behaviour -- there we have `<sig> <unknownpubkey> CHECKSIG` be equivalent to `<sig> \"\" OP_NOTEQUAL`, and soft-fork in immediate script failure on invalid sig once we decide what \"invalid\" means for `<unknownpubkey>`.",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": true,
  "admin": true,
  "staff": true,
  "user_id": 3,
  "hidden": false,
  "trust_level": 4,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": "Github link was replaced with a permanent link",
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}