{
  "id": 268,
  "name": "Brandon Black",
  "username": "reardencode",
  "avatar_template": "/user_avatar/delvingbitcoin.org/reardencode/{size}/27_2.png",
  "created_at": "2023-10-02T17:21:19.512Z",
  "cooked": "<blockquote>\n<p>I see the benefits of introducing a key version (simple keyspends mostly)</p>\n</blockquote>\n<p>Sadly, APO (and other such ideas for new Tapscript key versions) don\u2019t enable key path spends because that would split the anonymity set of Taproot outputs <img src=\"https://delvingbitcoin.org/images/emoji/twitter/cry.png?v=12\" title=\":cry:\" class=\"emoji\" alt=\":cry:\" loading=\"lazy\" width=\"20\" height=\"20\"></p>\n<blockquote>\n<p>There might actually be semantic differences. With TXHASH+CSFS you can specify exactly what message each key has to sign. With sighashtypes (AFAIU), the sighashtype is added to the signature, so it can\u2019t be enforced by the script but is provided at sign-time by the signer.</p>\n</blockquote>\n<p>Exactly, it is semantically different. Which is more likely when a hash is going to be used with a signature: The signer may specify at signing time what parts of the transaction they want to hash and is the party best suited to make the decision on what hashing modes to use; or the creator of the output script knows exactly the single hashing mode appropriate for the signer to use at script creation time. Until we are enabling ~full introspection, I would argue that the former is much more useful and matches the expected semantics of bitcoin script better.</p>",
  "post_number": 6,
  "post_type": 1,
  "updated_at": "2023-10-02T17:21:19.512Z",
  "reply_count": 0,
  "reply_to_post_number": 5,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 4,
  "readers_count": 3,
  "score": 0.8,
  "yours": false,
  "topic_id": 125,
  "topic_slug": "catt-thoughts-about-an-alternative-covenant-softfork-proposal",
  "topic_title": "CATT: thoughts about an alternative covenant softfork proposal",
  "topic_html_title": "CATT: thoughts about an alternative covenant softfork proposal",
  "category_id": 7,
  "display_username": "Brandon Black",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "reply_to_user": {
    "username": "stevenroose",
    "name": "Steven Roose",
    "avatar_template": "/letter_avatar_proxy/v4/letter/s/8edcca/{size}.png"
  },
  "bookmarked": false,
  "raw": "> I see the benefits of introducing a key version (simple keyspends mostly)\n\nSadly, APO (and other such ideas for new Tapscript key versions) don't enable key path spends because that would split the anonymity set of Taproot outputs :cry:\n\n> There might actually be semantic differences. With TXHASH+CSFS you can specify exactly what message each key has to sign. With sighashtypes (AFAIU), the sighashtype is added to the signature, so it can\u2019t be enforced by the script but is provided at sign-time by the signer.\n\nExactly, it is semantically different. Which is more likely when a hash is going to be used with a signature: The signer may specify at signing time what parts of the transaction they want to hash and is the party best suited to make the decision on what hashing modes to use; or the creator of the output script knows exactly the single hashing mode appropriate for the signer to use at script creation time. Until we are enabling ~full introspection, I would argue that the former is much more useful and matches the expected semantics of bitcoin script better.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 30,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}