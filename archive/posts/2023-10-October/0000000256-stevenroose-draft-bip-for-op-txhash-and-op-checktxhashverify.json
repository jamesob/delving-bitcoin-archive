{
  "id": 256,
  "name": "Steven Roose",
  "username": "stevenroose",
  "avatar_template": "/letter_avatar_proxy/v4/letter/s/8edcca/{size}.png",
  "created_at": "2023-10-02T10:30:09.872Z",
  "cooked": "<aside class=\"quote no-group quote-modified\" data-username=\"ajtowns\" data-post=\"2\" data-topic=\"121\" data-full=\"true\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/ajtowns/48/3_2.png\" class=\"avatar\"> ajtowns:</div>\n<blockquote>\n<p>I think what you actually propose is more along the lines of \u201censure that OP_TXHASH only ever hashes a constant data size\u201d, but I don\u2019t think that quite works here \u2013 you\u2019re allowing a hash of random combinations of inputs\u2019 scriptSigs, which can be as large as a block, and I don\u2019t think (as spec\u2019ed) there\u2019s a decent way to cache and reuse those results.</p>\n</blockquote>\n</aside>\n<p>I\u2019m trying to do both, actually. I\u2019m also charging a fixed validation weight.</p>\n<p>For the prefix mode, the cache strategy would be to define some constant interval N (say 10) so that every N in/outputs the hash context for each field can be kept, making storage requirement O(<span class=\"hashtag-raw\">#in</span>/out) for the cache, while making the amount of data needed to hash on each occurrence be maximally N items.</p>\n<p>I didn\u2019t think about the scriptSigs specifically. They can indeed be of arbitrary size and that can be a problem. Are there any other fields that can realistically be set at arbitrary size within policy limits? For those, we could have a field-specific cache. For scriptSigs, this would mean we\u2019d have to store an extra 32-byte hash for each input, which isn\u2019t too bad. As most of scriptSigs are empty nowadays, the hash of the empty string can be cached so this would be free for anything segwitv0 and taproot.</p>\n<aside class=\"quote no-group\" data-username=\"ajtowns\" data-post=\"2\" data-topic=\"121\" data-full=\"true\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/ajtowns/48/3_2.png\" class=\"avatar\"> ajtowns:</div>\n<blockquote>\n<p>I thought someone had made a post about this sort of thing being somewhat annoying as far as analysing miniscript goes, if this feature were to be included in miniscript, but I can\u2019t find the reference now. In any event, it seems pretty risky to have a potentially user-provided stack element be able to turn a script into \u201calways succeed\u201d behaviour. I think it would be better for the upgrade path to just be \u201cif we want more txhash-y things, we\u2019ll introduce OP_TXHASH2\u201d.</p>\n</blockquote>\n</aside>\n<p>Yeah I also read this shortly after sending my e-mail. That would probably not be a good idea. But like Russell also replied in that thread, it could be remedied by just thinking long enough about what fields to expose so we don\u2019t need to redo them. This means that we might have one bit left in the current design to cover (or break up) something.</p>\n<aside class=\"quote no-group\" data-username=\"ajtowns\" data-post=\"2\" data-topic=\"121\" data-full=\"true\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/ajtowns/48/3_2.png\" class=\"avatar\"> ajtowns:</div>\n<blockquote>\n<p>Do you have specific/concrete examples of uses that this extra flexibility enables? Would you be up for doing a rough demo of what they\u2019d look like in action something like <a href=\"https://github.com/jamesob/opvault-demo/\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">GitHub - jamesob/opvault-demo: An example wallet using OP_VAULT</a> ?</p>\n</blockquote>\n</aside>\n<p>I could do that, yeah. I\u2019m thinking mostly of Ark atm, but almost anything CTV does, TXHASH can do with added flexibility to add fees. I can also do a version of <a href=\"https://github.com/stevenroose/doubletake\" rel=\"noopener nofollow ugc\">doubletake</a> using OP_CHECKTXHASHVERIFY (that use case could be moved entirely to Bitcoin if we had CAT+CSFS).</p>",
  "post_number": 3,
  "post_type": 1,
  "updated_at": "2023-10-02T10:30:09.872Z",
  "reply_count": 1,
  "reply_to_post_number": 2,
  "quote_count": 1,
  "incoming_link_count": 0,
  "reads": 3,
  "readers_count": 2,
  "score": 5.6,
  "yours": false,
  "topic_id": 121,
  "topic_slug": "draft-bip-for-op-txhash-and-op-checktxhashverify",
  "topic_title": "Draft BIP for OP_TXHASH and OP_CHECKTXHASHVERIFY",
  "topic_html_title": "Draft BIP for OP_TXHASH and OP_CHECKTXHASHVERIFY",
  "category_id": 7,
  "display_username": "Steven Roose",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"ajtowns, post:2, topic:121, full:true\"]\nI think what you actually propose is more along the lines of \"ensure that OP_TXHASH only ever hashes a constant data size\", but I don't think that quite works here -- you're allowing a hash of random combinations of inputs' scriptSigs, which can be as large as a block, and I don't think (as spec'ed) there's a decent way to cache and reuse those results.\n[/quote]\n\nI'm trying to do both, actually. I'm also charging a fixed validation weight.\n\nFor the prefix mode, the cache strategy would be to define some constant interval N (say 10) so that every N in/outputs the hash context for each field can be kept, making storage requirement O(#in/out) for the cache, while making the amount of data needed to hash on each occurrence be maximally N items.\n\nI didn't think about the scriptSigs specifically. They can indeed be of arbitrary size and that can be a problem. Are there any other fields that can realistically be set at arbitrary size within policy limits? For those, we could have a field-specific cache. For scriptSigs, this would mean we'd have to store an extra 32-byte hash for each input, which isn't too bad. As most of scriptSigs are empty nowadays, the hash of the empty string can be cached so this would be free for anything segwitv0 and taproot.\n\n[quote=\"ajtowns, post:2, topic:121, full:true\"]\nI thought someone had made a post about this sort of thing being somewhat annoying as far as analysing miniscript goes, if this feature were to be included in miniscript, but I can't find the reference now. In any event, it seems pretty risky to have a potentially user-provided stack element be able to turn a script into \"always succeed\" behaviour. I think it would be better for the upgrade path to just be \"if we want more txhash-y things, we'll introduce OP_TXHASH2\".\n[/quote]\n\nYeah I also read this shortly after sending my e-mail. That would probably not be a good idea. But like Russell also replied in that thread, it could be remedied by just thinking long enough about what fields to expose so we don't need to redo them. This means that we might have one bit left in the current design to cover (or break up) something.\n\n[quote=\"ajtowns, post:2, topic:121, full:true\"]\nDo you have specific/concrete examples of uses that this extra flexibility enables? Would you be up for doing a rough demo of what they'd look like in action something like https://github.com/jamesob/opvault-demo/ ?\n[/quote]\n\nI could do that, yeah. I'm thinking mostly of Ark atm, but almost anything CTV does, TXHASH can do with added flexibility to add fees. I can also do a version of [doubletake](https://github.com/stevenroose/doubletake) using OP_CHECKTXHASHVERIFY (that use case could be moved entirely to Bitcoin if we had CAT+CSFS).",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 76,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}