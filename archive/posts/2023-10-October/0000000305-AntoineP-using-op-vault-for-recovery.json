{
  "id": 305,
  "name": "Antoine Poinsot",
  "username": "AntoineP",
  "avatar_template": "/letter_avatar_proxy/v4/letter/a/8e8cbc/{size}.png",
  "created_at": "2023-10-12T15:06:22.229Z",
  "cooked": "<p>I was invited to give a talk about James\u2019 OP_VAULT in Amsterdam. Since he\u2019s done pretty extensive<br>\ncommunication around the vault usecase already, and since i\u2019ve been working on Liana for the past<br>\nyear, i decided to make the talk about (ab)using OP_VAULT for recovery. Figured a more in depth<br>\ninquiry than permitted by a talk would be worth sharing with people on this platform.</p>\n<h2><a name=\"whats-the-value-proposition-of-liana-1\" class=\"anchor\" href=\"#whats-the-value-proposition-of-liana-1\"></a>What\u2019s the value proposition of Liana?</h2>\n<p><a href=\"https://github.com/wizardsardine/liana\" rel=\"noopener nofollow ugc\">Liana</a> is a Bitcoin wallet which lets one specify<br>\ntimelocked spending path(s) to be used for recovery purposes.</p>\n<p>Here is a list of usecases:</p>\n<ul>\n<li>Third party safety net. The user has a non-timelocked key like for a regular wallet. But in<br>\naddition a third party has a timelocked key that\u2019s only available after -say- one year.\n<ul>\n<li>As long as they don\u2019t let the timelock expire, the user is entirely in control of their<br>\nfunds. The third party cannot steal their coins or censor their transactions.</li>\n<li>In case of a boating accident, they have the option of trusting the third party to send them<br>\nback their coins. (TTP can be an uncle Jim for instance.)</li>\n</ul>\n</li>\n<li>Inheritance. Essentially the same as the safety net, with possibly more than one heir. For<br>\ninstance, the user has their key, non-timelocked, like a regular wallet. Spouse, child and<br>\nnotary each have one key. Spouse and child can spend together after 1y. 2 of spourse, child and<br>\nnotary can spend after 1y3mo in case they couldn\u2019t come to an agreement.</li>\n<li>\u201cMore secure\u201d backups. The typical Bitcoin user would have one extended key, generated from<br>\nmnemonics. The key would be used through a signing device and the mnemonic backed up somehow.<br>\nThere is a tradeoff between accessibility and security for the backup. You don\u2019t want to put<br>\nthem in your kitchen\u2019s drawer but still want to be sure you can access them when shit hits the<br>\nfan. The issue here obviously is that one access to your backups and your funds are gone. No<br>\ntime to react.<br>\nInstead you could use a non-timelocked key that you <em>don\u2019t backup</em> in your signing device, and<br>\nbackup the timelocked key. If the backup is tamper-evident, regularly checking backups lets you<br>\ntime to react to a theft without risking your funds. It\u2019s not perfect but seems to be a strict<br>\nimprovement: worst case if your coins expire you\u2019re back to the current situation where the backup<br>\nlets you spend the coins immediately.</li>\n<li>Decaying multisig. As time passes, threshold for the required number of signature decreases, or<br>\nmore keys are introduced:\n<ul>\n<li>Instead of having to bake recovery in the primary, immediately available, spending path as<br>\ntoday\u2019s multisigs you can aim for a larger threshold and only decrease it as time passes (ie<br>\nonly if you lose access to one of the keys).</li>\n<li>You can reduce the threshold and introduce more keys as time passes, to make sure funds are<br>\nnever lost.</li>\n</ul>\n</li>\n</ul>\n<h2><a name=\"how-can-it-be-improved-by-leveraging-op_vault-2\" class=\"anchor\" href=\"#how-can-it-be-improved-by-leveraging-op_vault-2\"></a>How can it be improved by leveraging OP_VAULT?</h2>\n<p>Liana is an existing wallet for today\u2019s Bitcoin. As such it doesn\u2019t use any form of covenant, just a<br>\nsimple <code>OP_CSV</code>. This means time starts ticking for the recovery path when you receive a coin. This<br>\nin turn means user would have to use their wallet regularly or \u201crefresh\u201d their coins every so often<br>\nif they don\u2019t want (some of) the recovery path(s) to become available.</p>\n<p>Not a deal breaker, but it certainly does add some friction to the UX. It seems it would be better<br>\nto be able to trigger a \u201crecovery process\u201d and only then have the time start ticking. That\u2019s what<br>\nOP_VAULT permit. Roughly speaking just use an OP_VAULT in the script to receive coin with the \u201cleaf<br>\nscript\u201d (in OP_VAULT BIP terminology) being the recovery script.</p>\n<p>Another improvement over today\u2019s Liana is how the OP_VAULT recovery would presumably be triggered on<br>\nall coins at the same time and the recovery path would become available at the same time for all<br>\ncoins to be recovered. That\u2019s not the case in today\u2019s Liana since not all coins were received at the<br>\nsame time.</p>\n<p>It\u2019s not a silver bullet, since you still need to check every so often whether a recovery wasn\u2019t<br>\ntriggered. But you don\u2019t need to make a transaction when doing so. That\u2019s less burden, less cost and<br>\nless potential privacy footgun.</p>\n<p>Let\u2019s go through the use cases listed above to see how we would implement them using OP_VAULT.</p>\n<h2><a name=\"safety-net-more-secure-backups-3\" class=\"anchor\" href=\"#safety-net-more-secure-backups-3\"></a>Safety net / \u201cMore secure\u201d backups</h2>\n<p>This is the simplest case. 1 primary key (the owner of the coins), 1 recovery key (the backed up key<br>\nor the third party key).</p>\n<p>Today\u2019s Taproot tree:</p>\n<ul>\n<li>internal key is owner\u2019s</li>\n<li><code>&lt;recovery key&gt; CHECKSIGVERIFY &lt;365 * 144&gt; CSV</code></li>\n</ul>\n<p>OP_VAULT Taproot tree:</p>\n<ul>\n<li>internal key is owner\u2019s</li>\n<li><code>&lt;recovery key&gt; CHECKSIGVERIFY 0 0 &lt;&lt;recovery key&gt; CHECKSIGVERIFY &lt;365 * 144&gt; CSV&gt; OP_VAULT</code></li>\n</ul>\n<p>Note the owner of the coins can always clawback any triggered recovery attempt (within 1y of it<br>\nbeing triggered) since the internal key is retained.</p>\n<h2><a name=\"inheritance-4\" class=\"anchor\" href=\"#inheritance-4\"></a>Inheritance</h2>\n<p>This one\u2019s still pretty simple, but it\u2019s got a multisig and 2 different timelocks which raise<br>\ninteresting questions.</p>\n<p>Today\u2019s Taproot tree:</p>\n<ul>\n<li>internal key is owner\u2019s</li>\n<li><code>&lt;spouse key&gt; CHECKSIGVERIFY &lt;child key&gt; CHECKSIGVERIFY &lt;365 * 144&gt; CSV</code></li>\n<li><code>&lt;child key&gt; CHECKSIGVERIFY &lt;notary key&gt; CHECKSIGVERIFY &lt;455 * 144&gt; CSV</code></li>\n<li><code>&lt;notary key&gt; CHECKSIGVERIFY &lt;spouse key&gt; CHECKSIGVERIFY &lt;455 * 144&gt; CSV</code></li>\n</ul>\n<p>There is two ways this can be translated to using OP_VAULT. The first, simplest way would be to use<br>\n3 <code>OP_VAULT</code> branches like so:</p>\n<ul>\n<li>internal key is owner\u2019s</li>\n<li><code>&lt;spouse key&gt; CHECKSIGVERIFY &lt;child key&gt; CHECKSIGVERIFY 0 0 &lt;&lt;spouse key&gt; CHECKSIGVERIFY &lt;child key&gt; CHECKSIGVERIFY &lt;355 * 144&gt; CSV&gt; OP_VAULT</code></li>\n<li><code>&lt;child key&gt; CHECKSIGVERIFY &lt;notary key&gt; CHECKSIGVERIFY 0 0 &lt;&lt;child key&gt; CHECKSIGVERIFY &lt;notary key&gt; CHECKSIGVERIFY &lt;455 * 144&gt; CSV&gt; OP_VAULT</code></li>\n<li><code>&lt;notary key&gt; CHECKSIGVERIFY &lt;spouse key&gt; CHECKSIGVERIFY 0 0 &lt;&lt;notary key&gt; CHECKSIGVERIFY &lt;spouse key&gt; CHECKSIGVERIFY &lt;455 * 144&gt; CSV&gt; OP_VAULT</code></li>\n</ul>\n<p>However this has the downside that any party may continuously re-trigger the recovery, not letting<br>\nany timelock expire. In addition, one timelock expiring does not lead to the following expiring <code>tl2- tl1</code><br>\nblocks later. If the first timelock path is chosen, any attempt to use the second path needs to<br>\nrestart all over again.</p>\n<p>This can be fixed by using a clumsier Taproot tree:</p>\n<ul>\n<li>internal key is user\u2019s</li>\n<li>Let <code>recovery_script</code> be</li>\n</ul>\n<pre><code class=\"lang-auto\">&lt;spouse key&gt; OP_CHECKSIG OP_SWAP &lt;child key&gt; OP_CHECKSIG OP_ADD OP_SWAP OP_IF\n  0\nOP_ELSE\n  &lt;144 * 365&gt; OP_CHECKSEQUENCEVERIFY OP_0NOTEQUAL\nOP_ENDIF\nOP_ADD OP_SWAP OP_SIZE OP_0NOTEQUAL OP_IF\n  &lt;notary&gt; OP_CHECKSIGVERIFY &lt;144 * 455&gt; OP_CHECKSEQUENCEVERIFY OP_0NOTEQUAL\nOP_ENDIF\nOP_ADD 3 OP_EQUAL\n</code></pre>\n<ul>\n<li>Single tapleaf is <code>&lt;spouse key&gt; CHECKSIG &lt;child key&gt; CHECKSIGADD &lt;notary key&gt; CHECKSIGADD 2 EQUAL 0 0 &lt;recovery_script&gt; OP_VAULT</code></li>\n</ul>\n<p>Now there is a single shot so you want any two keys from the set of 3 to be able to trigger a<br>\nrecovery. There is no way to keep restarting it, if the spouse and the child don\u2019t get along it will<br>\nautomatically decay to including the notary as signatory.</p>\n<p>In this specific example it\u2019s probably fine to use the nicer version with multiple <code>OP_VAULT</code><br>\nleaves because there is no reason for any two parties to shoot themselves in the foot. It\u2019s not<br>\nalways the case however.</p>\n<h2><a name=\"decaying-multisig-5\" class=\"anchor\" href=\"#decaying-multisig-5\"></a>Decaying multisig</h2>\n<p>Now let\u2019s look at a decaying multisig for a 5-stakeholders organization. Start from a 3of5 multisig<br>\nbetween all the stakeholders. In case 1 of them loses their key, after 1 year it becomes a 3of6 with<br>\na notary. After a year and 3 months, it becomes a 2of6 between these same persons.</p>\n<p>The recovery script is then:</p>\n<pre><code class=\"lang-auto\">OP_IF\n  &lt;stk1&gt; CHECKISG &lt;stk2&gt; CHECKISGADD &lt;stk3&gt; CHECKISGADD &lt;stk4&gt; CHECKISGADD &lt;stk5&gt; CHECKISGADD &lt;notary&gt; CHECKISGADD 3 OP_EQUALVERIFY &lt;144 * 365&gt; OP_CHECKSEQUENCEVERIFY\nOP_ELSE\n  &lt;stk1&gt; CHECKISG &lt;stk2&gt; CHECKISGADD &lt;stk3&gt; CHECKISGADD &lt;stk4&gt; CHECKISGADD &lt;stk5&gt; CHECKISGADD &lt;notary&gt; CHECKISGADD 2 OP_EQUALVERIFY &lt;144 * 455&gt; OP_CHECKSEQUENCEVERIFY\nOP_ENDIF\n</code></pre>\n<p>(That\u2019s <code>or_i(and_v(v:multi(3,stk1,stk2,stk3,stk4,stk5,stk6),older(144 * 365)),and_v(v:multi(3,stk1,stk2,stk3,stk4,stk5,stk6),older(144 * 455)))</code>.)</p>\n<p>Which can be optimized to (while keeping miniscript compatibility):</p>\n<pre><code class=\"lang-auto\">&lt;stk1&gt; CHECKISG SWAP &lt;stk2&gt; CHECKSIG ADD SWAP &lt;stk3&gt; CHECKSIG ADD SWAP &lt;stk4&gt; CHECKSIG ADD SWAP &lt;stk5&gt; CHECKSIG ADD SWAP &lt;notary&gt; CHECKSIG ADD SWAP\nOP_CHECKSIG OP_ADD OP_SWAP OP_IF\n  0\nOP_ELSE\n  &lt;144 * 365&gt; OP_CHECKSEQUENCEVERIFY OP_0NOTEQUAL\nOP_ENDIF\nOP_ADD OP_SWAP OP_IF\n  0\nOP_ELSE\n  &lt;144 * 455&gt; OP_CHECKSEQUENCEVERIFY OP_0NOTEQUAL\nOP_ENDIF\n</code></pre>\n<p>(That\u2019s <code>thresh(4,pk(stk1),s:pk(stk2),s:pk(stk3),s:pk(stk4),s:pk(stk5),s:pk(stk6),sln:older(144 * 365),sln:older(144 * 455))</code>.)</p>\n<p>Taproot tree is:</p>\n<ul>\n<li>key path spend is a NUMS</li>\n<li><code>&lt;stk1&gt; CHECKISG &lt;stk2&gt; CHECKISGADD &lt;stk3&gt; CHECKISGADD &lt;stk4&gt; CHECKISGADD &lt;stk5&gt; CHECKISGADD &lt;notary&gt; CHECKISGADD 2 OP_EQUALVERIFY 0 0 &lt;recovery script&gt; OP_VAULT</code></li>\n</ul>\n<h2><a name=\"discussion-6\" class=\"anchor\" href=\"#discussion-6\"></a>Discussion</h2>\n<p>OP_VAULT seems like a good fit for this usecase, although a more Taprooty mechanism to add/remove<br>\nbranches from the tree would be preferable. It\u2019d avoid having to use bulk scripts in a single leaf<br>\nto avoid having to re-trigger a recovery simply to use another path, or avoid being stuck with a<br>\nperpetually re-triggered recovery. The latter may be mitigated by using longer timelocks than what\u2019s<br>\nin any the recovery script in every OP_VAULT leaf.</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2023-10-12T15:06:22.229Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 3,
  "readers_count": 2,
  "score": 15.6,
  "yours": false,
  "topic_id": 150,
  "topic_slug": "using-op-vault-for-recovery",
  "topic_title": "Using OP_VAULT for recovery",
  "topic_html_title": "Using OP_VAULT for recovery",
  "category_id": 8,
  "display_username": "Antoine Poinsot",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "I was invited to give a talk about James' OP_VAULT in Amsterdam. Since he's done pretty extensive\ncommunication around the vault usecase already, and since i've been working on Liana for the past\nyear, i decided to make the talk about (ab)using OP_VAULT for recovery. Figured a more in depth\ninquiry than permitted by a talk would be worth sharing with people on this platform.\n\n\n## What's the value proposition of Liana?\n\n[Liana](https://github.com/wizardsardine/liana) is a Bitcoin wallet which lets one specify\ntimelocked spending path(s) to be used for recovery purposes.\n\nHere is a list of usecases:\n  - Third party safety net. The user has a non-timelocked key like for a regular wallet. But in\n    addition a third party has a timelocked key that's only available after -say- one year.\n    - As long as they don't let the timelock expire, the user is entirely in control of their\n      funds. The third party cannot steal their coins or censor their transactions.\n    - In case of a boating accident, they have the option of trusting the third party to send them\n      back their coins. (TTP can be an uncle Jim for instance.)\n  - Inheritance. Essentially the same as the safety net, with possibly more than one heir. For\n    instance, the user has their key, non-timelocked, like a regular wallet. Spouse, child and\n    notary each have one key. Spouse and child can spend together after 1y. 2 of spourse, child and\n    notary can spend after 1y3mo in case they couldn't come to an agreement.\n  - \"More secure\" backups. The typical Bitcoin user would have one extended key, generated from\n    mnemonics. The key would be used through a signing device and the mnemonic backed up somehow.\n    There is a tradeoff between accessibility and security for the backup. You don't want to put\n    them in your kitchen's drawer but still want to be sure you can access them when shit hits the\n    fan. The issue here obviously is that one access to your backups and your funds are gone. No\n    time to react.\n    Instead you could use a non-timelocked key that you *don't backup* in your signing device, and\n    backup the timelocked key. If the backup is tamper-evident, regularly checking backups lets you\n    time to react to a theft without risking your funds. It's not perfect but seems to be a strict\n    improvement: worst case if your coins expire you're back to the current situation where the backup\n    lets you spend the coins immediately.\n  - Decaying multisig. As time passes, threshold for the required number of signature decreases, or\n    more keys are introduced:\n      - Instead of having to bake recovery in the primary, immediately available, spending path as\n        today's multisigs you can aim for a larger threshold and only decrease it as time passes (ie\n        only if you lose access to one of the keys).\n      - You can reduce the threshold and introduce more keys as time passes, to make sure funds are\n        never lost.\n\n\n## How can it be improved by leveraging OP_VAULT?\n\nLiana is an existing wallet for today's Bitcoin. As such it doesn't use any form of covenant, just a\nsimple `OP_CSV`. This means time starts ticking for the recovery path when you receive a coin. This\nin turn means user would have to use their wallet regularly or \"refresh\" their coins every so often\nif they don't want (some of) the recovery path(s) to become available.\n\nNot a deal breaker, but it certainly does add some friction to the UX. It seems it would be better\nto be able to trigger a \"recovery process\" and only then have the time start ticking. That's what\nOP_VAULT permit. Roughly speaking just use an OP_VAULT in the script to receive coin with the \"leaf\nscript\" (in OP_VAULT BIP terminology) being the recovery script.\n\nAnother improvement over today's Liana is how the OP_VAULT recovery would presumably be triggered on\nall coins at the same time and the recovery path would become available at the same time for all\ncoins to be recovered. That's not the case in today's Liana since not all coins were received at the\nsame time.\n\nIt's not a silver bullet, since you still need to check every so often whether a recovery wasn't\ntriggered. But you don't need to make a transaction when doing so. That's less burden, less cost and\nless potential privacy footgun.\n\nLet's go through the use cases listed above to see how we would implement them using OP_VAULT.\n\n## Safety net / \"More secure\" backups\n\nThis is the simplest case. 1 primary key (the owner of the coins), 1 recovery key (the backed up key\nor the third party key).\n\nToday's Taproot tree:\n  - internal key is owner's\n  - `<recovery key> CHECKSIGVERIFY <365 * 144> CSV`\n\nOP_VAULT Taproot tree:\n  - internal key is owner's\n  - `<recovery key> CHECKSIGVERIFY 0 0 <<recovery key> CHECKSIGVERIFY <365 * 144> CSV> OP_VAULT`\n\nNote the owner of the coins can always clawback any triggered recovery attempt (within 1y of it\nbeing triggered) since the internal key is retained.\n\n## Inheritance\n\nThis one's still pretty simple, but it's got a multisig and 2 different timelocks which raise\ninteresting questions.\n\nToday's Taproot tree:\n  - internal key is owner's\n  - `<spouse key> CHECKSIGVERIFY <child key> CHECKSIGVERIFY <365 * 144> CSV`\n  - `<child key> CHECKSIGVERIFY <notary key> CHECKSIGVERIFY <455 * 144> CSV`\n  - `<notary key> CHECKSIGVERIFY <spouse key> CHECKSIGVERIFY <455 * 144> CSV`\n\nThere is two ways this can be translated to using OP_VAULT. The first, simplest way would be to use\n3 `OP_VAULT` branches like so:\n  - internal key is owner's\n  - `<spouse key> CHECKSIGVERIFY <child key> CHECKSIGVERIFY 0 0 <<spouse key> CHECKSIGVERIFY <child key> CHECKSIGVERIFY <355 * 144> CSV> OP_VAULT`\n  - `<child key> CHECKSIGVERIFY <notary key> CHECKSIGVERIFY 0 0 <<child key> CHECKSIGVERIFY <notary key> CHECKSIGVERIFY <455 * 144> CSV> OP_VAULT`\n  - `<notary key> CHECKSIGVERIFY <spouse key> CHECKSIGVERIFY 0 0 <<notary key> CHECKSIGVERIFY <spouse key> CHECKSIGVERIFY <455 * 144> CSV> OP_VAULT`\n\nHowever this has the downside that any party may continuously re-trigger the recovery, not letting\nany timelock expire. In addition, one timelock expiring does not lead to the following expiring `tl2- tl1`\nblocks later. If the first timelock path is chosen, any attempt to use the second path needs to\nrestart all over again.\n\nThis can be fixed by using a clumsier Taproot tree:\n  - internal key is user's\n  - Let `recovery_script` be\n  ```\n  <spouse key> OP_CHECKSIG OP_SWAP <child key> OP_CHECKSIG OP_ADD OP_SWAP OP_IF\n    0\n  OP_ELSE\n    <144 * 365> OP_CHECKSEQUENCEVERIFY OP_0NOTEQUAL\n  OP_ENDIF\n  OP_ADD OP_SWAP OP_SIZE OP_0NOTEQUAL OP_IF\n    <notary> OP_CHECKSIGVERIFY <144 * 455> OP_CHECKSEQUENCEVERIFY OP_0NOTEQUAL\n  OP_ENDIF\n  OP_ADD 3 OP_EQUAL\n  ```\n  - Single tapleaf is `<spouse key> CHECKSIG <child key> CHECKSIGADD <notary key> CHECKSIGADD 2 EQUAL 0 0 <recovery_script> OP_VAULT`\n\nNow there is a single shot so you want any two keys from the set of 3 to be able to trigger a\nrecovery. There is no way to keep restarting it, if the spouse and the child don't get along it will\nautomatically decay to including the notary as signatory.\n\nIn this specific example it's probably fine to use the nicer version with multiple `OP_VAULT`\nleaves because there is no reason for any two parties to shoot themselves in the foot. It's not\nalways the case however.\n\n## Decaying multisig\n\nNow let's look at a decaying multisig for a 5-stakeholders organization. Start from a 3of5 multisig\nbetween all the stakeholders. In case 1 of them loses their key, after 1 year it becomes a 3of6 with\na notary. After a year and 3 months, it becomes a 2of6 between these same persons.\n\nThe recovery script is then:\n```\nOP_IF\n  <stk1> CHECKISG <stk2> CHECKISGADD <stk3> CHECKISGADD <stk4> CHECKISGADD <stk5> CHECKISGADD <notary> CHECKISGADD 3 OP_EQUALVERIFY <144 * 365> OP_CHECKSEQUENCEVERIFY\nOP_ELSE\n  <stk1> CHECKISG <stk2> CHECKISGADD <stk3> CHECKISGADD <stk4> CHECKISGADD <stk5> CHECKISGADD <notary> CHECKISGADD 2 OP_EQUALVERIFY <144 * 455> OP_CHECKSEQUENCEVERIFY\nOP_ENDIF\n```\n(That's `or_i(and_v(v:multi(3,stk1,stk2,stk3,stk4,stk5,stk6),older(144 * 365)),and_v(v:multi(3,stk1,stk2,stk3,stk4,stk5,stk6),older(144 * 455)))`.)\n\nWhich can be optimized to (while keeping miniscript compatibility):\n```\n<stk1> CHECKISG SWAP <stk2> CHECKSIG ADD SWAP <stk3> CHECKSIG ADD SWAP <stk4> CHECKSIG ADD SWAP <stk5> CHECKSIG ADD SWAP <notary> CHECKSIG ADD SWAP\nOP_CHECKSIG OP_ADD OP_SWAP OP_IF\n  0\nOP_ELSE\n  <144 * 365> OP_CHECKSEQUENCEVERIFY OP_0NOTEQUAL\nOP_ENDIF\nOP_ADD OP_SWAP OP_IF\n  0\nOP_ELSE\n  <144 * 455> OP_CHECKSEQUENCEVERIFY OP_0NOTEQUAL\nOP_ENDIF\n```\n(That's `thresh(4,pk(stk1),s:pk(stk2),s:pk(stk3),s:pk(stk4),s:pk(stk5),s:pk(stk6),sln:older(144 * 365),sln:older(144 * 455))`.)\n\nTaproot tree is:\n  - key path spend is a NUMS\n  - `<stk1> CHECKISG <stk2> CHECKISGADD <stk3> CHECKISGADD <stk4> CHECKISGADD <stk5> CHECKISGADD <notary> CHECKISGADD 2 OP_EQUALVERIFY 0 0 <recovery script> OP_VAULT`\n\n\n## Discussion\n\nOP_VAULT seems like a good fit for this usecase, although a more Taprooty mechanism to add/remove\nbranches from the tree would be preferable. It'd avoid having to use bulk scripts in a single leaf\nto avoid having to re-trigger a recovery simply to use another path, or avoid being stuck with a\nperpetually re-triggered recovery. The latter may be mitigated by using longer timelocks than what's\nin any the recovery script in every OP_VAULT leaf.",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 12,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}