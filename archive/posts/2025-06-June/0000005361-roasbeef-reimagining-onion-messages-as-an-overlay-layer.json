{
  "id": 5361,
  "name": "",
  "username": "roasbeef",
  "avatar_template": "/user_avatar/delvingbitcoin.org/roasbeef/{size}/160_2.png",
  "created_at": "2025-06-28T01:56:34.150Z",
  "cooked": "<h1><a name=\"p-5361-reimagining-onion-messages-as-an-overlay-layer-1\" class=\"anchor\" href=\"#p-5361-reimagining-onion-messages-as-an-overlay-layer-1\"></a>Reimagining Onion Messages as an Overlay Layer</h1>\n<h2><a name=\"p-5361-introduction-2\" class=\"anchor\" href=\"#p-5361-introduction-2\"></a>Introduction</h2>\n<p>Onion messaging as currently specified and deployed <em>embeds</em> the onion\nmessaging graph into the channel graph. This tight\ncoupling between the onion messaging graph and the channel graph is a poor\ndesign choice as it: necessitates a slow and brittle all-or-nothing adoption\npath, forces an unnecessarily large onion messaging graph diameter,\nintermingles distinct networking quality of service concerns, and misses an\nopportunity to support native key management.</p>\n<p>In this post we explore a deployment that addresses all of the drawbacks\nmentioned above, we propose an alternative development path that instead\ninstantiates onion messaging as an <em>overlay layer</em>, bootstrapped using the\nLN gossip layer. Compared to the embedded onion message networking of today,\nthe onion messaging overlay layer promotes rapid incremental deployment,\nseparates concerns, and may increase reliability and reach ability due to the\ndynamic nature of the overlay topology.</p>\n<h2><a name=\"p-5361-motivation-3\" class=\"anchor\" href=\"#p-5361-motivation-3\"></a>Motivation</h2>\n<p>The current onion messaging deployment path takes an all or nothing approach:\nonion messaging links can only be created via established channels links. Any\nsent onion messages therefore must flow over the exact same graph topology as\nthe channel graph. This tight coupling is fragile, as if a single node across a\nprospective onion messaging path opts to not support the protocol, then\nmessages can\u2019t be transmitted. For presentation layer use cases like BOLT 12,\nthis forces clients to frequently fall back to directly connecting to the\nmessage recipient (or penultimate node). This inevitable fall back sacrifices\nprivacy, and also damages the UX, as retries and re connections can significantly\ndelay the time to even first <em>payment attempt</em>.</p>\n<p>Additionally, the all-or-nothing approach has slowed down deployment timelines,\nas until nearly 100% of the nodes on the network support, clients must be\nprepared to fall back direct connecting to the receiver. As new onion messaging\nlinks can only be created by piggybacking on existing channels, the evolution\nof the onion messaging ground is hampered, as its bound to the block creation\nrate, and confirmation periods.</p>\n<p>As a decentralized payment network, in ideal conditions, payment latency on the\nLightning Network is a function of the network diameter. A longer path length\nrequires more cumulative iterative round trips between successive peers, which\nincrease payment latency. By bolting the onion messaging graph onto the channel\ngraph, we force the onion messaging graph to operate a graph of larger diameter\nthan the solution necessitates. If onion messaging were instead an overlay\nlayer, a more compact messaging graph would emerge. Reducing the amount of\nnodes that a BOLT 12 payment request must travel over, serves to reduce the\naggregate latency of the payment experience. Compared to the existing BOLT 11\nflow, which permits a user to immediately carry out a payment, BOLT 12 incurs a\ncumulative round trip latency over an unreliable messaging system over the\nentire path (stalled message delivery attempts may also further hamper UX).\nEnabling such invoice requests to travel over a smaller graph diameter can help\nto reduce the UX penalty BOLT 12 adoption.</p>\n<p>Current deployments of onion messaging re-use the node identified key of a\ngiven peer typically intended for onion payments, in the onion messaging\ndomain. The lack of domain separation couples concerns, and overloads the onion\npayment key. Additionally, as the BOLT protocol doesn\u2019t yet support a global\nnode identity rotation protocol, all onion messages effectively utilize a\nstatic key. This lack of a key rotation mechanism serves to degrade the privacy\nof onion messages overtime, due to lack of forward secrecy.</p>\n<p>Due to the embedded nature of the current deployment, onion messages travel\nover the same TCP connection between peers as gossip messages and channel\nupdates. By maintaining this tight coupling, the current deployment path isn\u2019t\nable to independently address quality of service concerns. Due to head-of-line\nblocking in TCP, any active gossip or channel update messages that remain\nunacked in the TCP window (or even an outbound application queue) will\nnecessarily <em>block</em> the processing of onion messages. This unnecessarily\nblocking once again hurts the payment experience, as it leads to increase\nlatency of the time-to-payment-attempt.</p>\n<p>As we\u2019ll see below, A deployment of onion messaging that instead utilizes an\noverlay addresses all of the shortcomings described above. The onion overlay\nlayer separates concerns, promotes rapid deployment and experimentation, paves\na way to key rotation, and results in a smaller diameter graph. Importantly the\ncreation and processing of onion messages remains unchanged.</p>\n<h2><a name=\"p-5361-proposal-4\" class=\"anchor\" href=\"#p-5361-proposal-4\"></a>Proposal</h2>\n<p>Instead of the current embedded approach, we instead propose an alternative\n(can even be concurrent!) onion messaging overlay. The overlay utilizes the\nexisting LN gossip network and long-term node identity keys to boostrap a\ndistinct onion messaging overlay.</p>\n<p>Onion messaging on the network won\u2019t require all 12k+ public nodes to function,\ninstead we\u2019d be able to get by with even just 1% of the amount of nodes.</p>\n<p>Beyond the immediate deployment advantages, the overlay architecture enables\nrapid experimentation with onion messaging primitives beyond\nBOLT 12. Examples of such proposals include: the addition of a payment level ACK to give immediate feedback to path finding iterations, and also safe retryable (stuckless) payments that rely on transmitting an extra preimage from sender to receiver.  These experiments can proceed in parallel w/o affecting the broader payment network, as early adopters can iterate on protocol designs, taking advantage of the swifter deployment path of the overlay network.</p>\n<h3><a name=\"p-5361-connection-establishment-5\" class=\"anchor\" href=\"#p-5361-connection-establishment-5\"></a>Connection Establishment</h3>\n<p>An existing active BOLT 9 connection is used to establish a new onion messaging\nlink. As we\u2019ll see below, link establishment produces a 3rd verifiable musig2\nsignature to prevent connection spoofing (claiming an onion messaging\nconnection exists when one doesn\u2019t).</p>\n<pre data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">sequenceDiagram\n    participant A as Initiator\n    participant B as Responder\n    \n    A-&gt;&gt;B: onion_link_req\n    \n    B-&gt;&gt;A: onion_link_resp\n    \n    A-&gt;&gt;B: onion_link_sign\n    \n    B-&gt;&gt;A: onion_link_sign\n    \n    A-&gt;&gt;B: onion_link_proof\n</code></pre>\n<h4><a name=\"p-5361-onion_link_req-6\" class=\"anchor\" href=\"#p-5361-onion_link_req-6\"></a><code>onion_link_req</code></h4>\n<p>The <code>onion_link_req</code> message is a pure TLV message that\u2019s sent from one peer to\nanother to request the establishment of a new onion messaging link. It carries\nthe sender\u2019s current <code>onion_key</code>, and an <code>onion_nonce</code> to use in the <code>musig2</code>\nsignature.</p>\n<p><strong>Message Type</strong>: <code>???</code></p>\n<h5><a name=\"p-5361-tlv-fields-7\" class=\"anchor\" href=\"#p-5361-tlv-fields-7\"></a>TLV Fields</h5>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Length</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>onion_key</code></td>\n<td>1</td>\n<td>33</td>\n<td>The sender\u2019s onion public key used for establishing the onion messaging link</td>\n</tr>\n<tr>\n<td><code>onion_nonce</code></td>\n<td>3</td>\n<td>66</td>\n<td>The sender\u2019s MuSig2 nonce for the link establishment signature</td>\n</tr>\n</tbody>\n</table>\n</div><h4><a name=\"p-5361-onion_link_resp-8\" class=\"anchor\" href=\"#p-5361-onion_link_resp-8\"></a><code>onion_link_resp</code></h4>\n<p>This message is sent in response to an <code>onion_link_req</code> message. It includes\nidentical field, but this time instead for the responded.</p>\n<p><strong>Message Type</strong>: <code>???</code></p>\n<h5><a name=\"p-5361-tlv-fields-9\" class=\"anchor\" href=\"#p-5361-tlv-fields-9\"></a>TLV Fields</h5>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Length</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>onion_key</code></td>\n<td>1</td>\n<td>33</td>\n<td>The responder\u2019s onion public key used for establishing the onion messaging link</td>\n</tr>\n<tr>\n<td><code>onion_nonce</code></td>\n<td>3</td>\n<td>66</td>\n<td>The responder\u2019s MuSig2 nonce for the link establishment signature</td>\n</tr>\n</tbody>\n</table>\n</div><h4><a name=\"p-5361-onion_link_sign-10\" class=\"anchor\" href=\"#p-5361-onion_link_sign-10\"></a><code>onion_link_sign</code></h4>\n<p>With the <code>onion_key</code> of both initiator and responded known, the initiator can\nnow generate the <code>musig2</code> partial signature that comprises of half the\n<code>onion_link_proof</code>.</p>\n<p>At this point, we assume that both initiator and responded already know the\nlong-term <code>node_identity</code> of each other. The generated signature will be\ncreated using an aggregated public key of the set of <code>onion_key</code> and\n<code>node_identity</code> key for both parties.</p>\n<p><code>aggregate_onion_proof_key = musig2_key_agg(onion_key_1, onion_key_2, node_key_1, node_key_2)</code></p>\n<p><strong>Message Type</strong>: <code>???</code></p>\n<h5><a name=\"p-5361-tlv-fields-11\" class=\"anchor\" href=\"#p-5361-tlv-fields-11\"></a>TLV Fields</h5>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Length</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>onion_proof_partial_sig</code></td>\n<td>5</td>\n<td>32</td>\n<td>The initiator\u2019s MuSig2 partial signature for the onion link establishment</td>\n</tr>\n</tbody>\n</table>\n</div><p>Upon receipt, the responder:</p>\n<ul>\n<li>Re derives the <code>aggregate_onion_proof_key</code></li>\n<li>Verifies the <code>onion_proof_partial_sig</code> from the sender</li>\n<li>Generates its own <code>onion_proof_partial_sig</code></li>\n<li>Proceeds to construct the <code>onion_link_proof</code> message`</li>\n</ul>\n<h4><a name=\"p-5361-onion_link_proof-12\" class=\"anchor\" href=\"#p-5361-onion_link_proof-12\"></a><code>onion_link_proof</code></h4>\n<p>A proof of mutual agreement to establish an onion messaging link between two\nnodes. This serves to allow 3rd party nodes to verify that an advertised\nconnection actually exists.</p>\n<p>The initiator constructs this message, and sends to the responded.</p>\n<h5><a name=\"p-5361-tlv-fields-13\" class=\"anchor\" href=\"#p-5361-tlv-fields-13\"></a>TLV Fields</h5>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Length</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>onion_key_1</code></td>\n<td>7</td>\n<td>33</td>\n<td>The initiator\u2019s onion public key</td>\n</tr>\n<tr>\n<td><code>onion_key_2</code></td>\n<td>9</td>\n<td>33</td>\n<td>The responder\u2019s onion public key</td>\n</tr>\n<tr>\n<td><code>node_key_1</code></td>\n<td>11</td>\n<td>33</td>\n<td>The initiator\u2019s node identity public key</td>\n</tr>\n<tr>\n<td><code>node_key_2</code></td>\n<td>13</td>\n<td>33</td>\n<td>The responder\u2019s node identity public key</td>\n</tr>\n<tr>\n<td><code>onion_link_sig</code></td>\n<td>15</td>\n<td>64</td>\n<td>The complete MuSig2 signature proving mutual agreement to establish the link</td>\n</tr>\n</tbody>\n</table>\n</div><p>Once the both parties have the <code>onion_link_proof</code> message, they\u2019ll create a new\nTCP connection that uses a distinct port, using their the new <code>onion_key</code> pair\nto establish the encrypted p2p connection.</p>\n<h3><a name=\"p-5361-onion-link-discovery-14\" class=\"anchor\" href=\"#p-5361-onion-link-discovery-14\"></a>Onion Link Discovery</h3>\n<p>Now onto onion link discovery. As mentioned, node the existing LN gossip\nnetwork is used to bootstrap the new onion overlay network.</p>\n<h4><a name=\"p-5361-node_announcement-extension-15\" class=\"anchor\" href=\"#p-5361-node_announcement-extension-15\"></a><code>node_announcement</code> Extension</h4>\n<p>A new TLV field is added to the existing <code>node_announcement</code> message. This\nfield contains a series of repeated <code>onion_link_proof</code> messages. In aggregate\nhis new field can be seen as an authenticated agency list, that can be used to\nbuild up the latest view of the onion overlay network.</p>\n<h4><a name=\"p-5361-new-tlv-field-16\" class=\"anchor\" href=\"#p-5361-new-tlv-field-16\"></a>New TLV Field</h4>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Length</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>onion_link_proofs</code></td>\n<td>17</td>\n<td>variable</td>\n<td>A list of onion link proofs for this node</td>\n</tr>\n</tbody>\n</table>\n</div><h4><a name=\"p-5361-nested-onion_link_proofs-17\" class=\"anchor\" href=\"#p-5361-nested-onion_link_proofs-17\"></a>Nested <code>onion_link_proofs</code></h4>\n<p>The value of this TLV field contains:</p>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Length</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>num_proofs</code></td>\n<td>2</td>\n<td>The number of onion link proofs that follow</td>\n</tr>\n<tr>\n<td><code>proofs</code></td>\n<td>variable</td>\n<td><code>num_proofs</code> encoded <code>onion_link_proof</code> structures</td>\n</tr>\n</tbody>\n</table>\n</div><h3><a name=\"p-5361-onion-graph-assembly-18\" class=\"anchor\" href=\"#p-5361-onion-graph-assembly-18\"></a>Onion Graph Assembly</h3>\n<p>To construct the onion graph, a node syncs the LN graph as normal. They then\nfilter through all the nodes that advertise the onion messaging feature bit\n(likely a new one is used for the overlay variant), verify all the\n<code>onion_link_proofs</code>, then reconstruct the current onion message graph from the\nauthenticated adjacency list.</p>\n<h3><a name=\"p-5361-routine-operation-19\" class=\"anchor\" href=\"#p-5361-routine-operation-19\"></a>Routine Operation</h3>\n<p>After boostrap, onion messaging functions pretty much as normal. Each member of\nthe overlay network has an authenticated mapping between a node\u2019s long term\nidentity key, and their latest ephemeral onion key. Using either, they can\nperform path finding as normal to send and receive messages (blinded paths is\nutilized as normal).</p>\n<p>To rotate an onion public key, nodes can simply restart the flow to obtain a\nnew <code>onion_link_proof</code>, then advertise that once again in the network. Rotating\n<code>node_key</code> pairs also necessitates reconnecting with a fresh BOLT 8 brontide\nhandshake.</p>\n<h2><a name=\"p-5361-interoperability-with-existing-infrastructure-20\" class=\"anchor\" href=\"#p-5361-interoperability-with-existing-infrastructure-20\"></a>Interoperability with Existing Infrastructure</h2>\n<p>The proposal as described above doesn\u2019t disrupt the existing embedded onion message deployment. Instead, the embedded and overlay messagign networks can actually <em>co exist</em>. Nodes can simultaneously maintain connections to both the embedded messaging network and the overlay network, treating them as complementary transport mechanisms.</p>\n<p>The onion packet construction remains identical regardless of the underlying transport. As a result, any existing deployed applications that use onion messaging can seamless utilize both the overlay and embedded network. The overlay network can be more rapidly deployed and utilized, while also avoiding fragmentation which may hamper the primary use cases.</p>\n<h2><a name=\"p-5361-conclusion-21\" class=\"anchor\" href=\"#p-5361-conclusion-21\"></a>Conclusion</h2>\n<p>In this post, we\u2019ve proposed an alternative (and even parallel!) deployment of onion messaging. As an overlay, the onion messaging network can be decoupled from the existing channel graph. With as few as 100 nodes using this overlay, higher level applications using onion messaging can immediately begin to seamlessly utilize this new overlay, which allows application developers to hone in on the last 20% of work to truly polish user experience. The overlay approach supports loosely synchronized deployment, which embraces permissionless innovation and rapid experimentation.</p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 1,
  "updated_at": "2025-06-28T01:56:34.150Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 9,
  "reads": 3,
  "readers_count": 2,
  "score": 15.6,
  "yours": false,
  "topic_id": 1799,
  "topic_slug": "reimagining-onion-messages-as-an-overlay-layer",
  "topic_title": "Reimagining Onion Messages as an Overlay Layer",
  "topic_html_title": "Reimagining Onion Messages as an Overlay Layer",
  "category_id": 7,
  "display_username": "",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "# Reimagining Onion Messages as an Overlay Layer\n\n## Introduction\n\nOnion messaging as currently specified and deployed _embeds_ the onion\nmessaging graph into the channel graph. This tight\ncoupling between the onion messaging graph and the channel graph is a poor\ndesign choice as it: necessitates a slow and brittle all-or-nothing adoption\npath, forces an unnecessarily large onion messaging graph diameter,\nintermingles distinct networking quality of service concerns, and misses an\nopportunity to support native key management.\n\nIn this post we explore a deployment that addresses all of the drawbacks\nmentioned above, we propose an alternative development path that instead\ninstantiates onion messaging as an _overlay layer_, bootstrapped using the\nLN gossip layer. Compared to the embedded onion message networking of today,\nthe onion messaging overlay layer promotes rapid incremental deployment,\nseparates concerns, and may increase reliability and reach ability due to the\ndynamic nature of the overlay topology.\n\n## Motivation\n\nThe current onion messaging deployment path takes an all or nothing approach:\nonion messaging links can only be created via established channels links. Any\nsent onion messages therefore must flow over the exact same graph topology as\nthe channel graph. This tight coupling is fragile, as if a single node across a\nprospective onion messaging path opts to not support the protocol, then\nmessages can't be transmitted. For presentation layer use cases like BOLT 12,\nthis forces clients to frequently fall back to directly connecting to the\nmessage recipient (or penultimate node). This inevitable fall back sacrifices\nprivacy, and also damages the UX, as retries and re connections can significantly\ndelay the time to even first _payment attempt_.\n\nAdditionally, the all-or-nothing approach has slowed down deployment timelines,\nas until nearly 100% of the nodes on the network support, clients must be\nprepared to fall back direct connecting to the receiver. As new onion messaging\nlinks can only be created by piggybacking on existing channels, the evolution\nof the onion messaging ground is hampered, as its bound to the block creation\nrate, and confirmation periods.\n\nAs a decentralized payment network, in ideal conditions, payment latency on the\nLightning Network is a function of the network diameter. A longer path length\nrequires more cumulative iterative round trips between successive peers, which\nincrease payment latency. By bolting the onion messaging graph onto the channel\ngraph, we force the onion messaging graph to operate a graph of larger diameter\nthan the solution necessitates. If onion messaging were instead an overlay\nlayer, a more compact messaging graph would emerge. Reducing the amount of\nnodes that a BOLT 12 payment request must travel over, serves to reduce the\naggregate latency of the payment experience. Compared to the existing BOLT 11\nflow, which permits a user to immediately carry out a payment, BOLT 12 incurs a\ncumulative round trip latency over an unreliable messaging system over the\nentire path (stalled message delivery attempts may also further hamper UX).\nEnabling such invoice requests to travel over a smaller graph diameter can help\nto reduce the UX penalty BOLT 12 adoption.\n\nCurrent deployments of onion messaging re-use the node identified key of a\ngiven peer typically intended for onion payments, in the onion messaging\ndomain. The lack of domain separation couples concerns, and overloads the onion\npayment key. Additionally, as the BOLT protocol doesn't yet support a global\nnode identity rotation protocol, all onion messages effectively utilize a\nstatic key. This lack of a key rotation mechanism serves to degrade the privacy\nof onion messages overtime, due to lack of forward secrecy.\n\nDue to the embedded nature of the current deployment, onion messages travel\nover the same TCP connection between peers as gossip messages and channel\nupdates. By maintaining this tight coupling, the current deployment path isn't\nable to independently address quality of service concerns. Due to head-of-line\nblocking in TCP, any active gossip or channel update messages that remain\nunacked in the TCP window (or even an outbound application queue) will\nnecessarily _block_ the processing of onion messages. This unnecessarily\nblocking once again hurts the payment experience, as it leads to increase\nlatency of the time-to-payment-attempt.\n\nAs we'll see below, A deployment of onion messaging that instead utilizes an\noverlay addresses all of the shortcomings described above. The onion overlay\nlayer separates concerns, promotes rapid deployment and experimentation, paves\na way to key rotation, and results in a smaller diameter graph. Importantly the\ncreation and processing of onion messages remains unchanged.\n\n## Proposal\n\nInstead of the current embedded approach, we instead propose an alternative\n(can even be concurrent!) onion messaging overlay. The overlay utilizes the\nexisting LN gossip network and long-term node identity keys to boostrap a\ndistinct onion messaging overlay.\n\nOnion messaging on the network won't require all 12k+ public nodes to function,\ninstead we'd be able to get by with even just 1% of the amount of nodes.\n\nBeyond the immediate deployment advantages, the overlay architecture enables\nrapid experimentation with onion messaging primitives beyond\nBOLT 12. Examples of such proposals include: the addition of a payment level ACK to give immediate feedback to path finding iterations, and also safe retryable (stuckless) payments that rely on transmitting an extra preimage from sender to receiver.  These experiments can proceed in parallel w/o affecting the broader payment network, as early adopters can iterate on protocol designs, taking advantage of the swifter deployment path of the overlay network. \n\n### Connection Establishment\n\nAn existing active BOLT 9 connection is used to establish a new onion messaging\nlink. As we'll see below, link establishment produces a 3rd verifiable musig2\nsignature to prevent connection spoofing (claiming an onion messaging\nconnection exists when one doesn't).\n\n```mermaid\nsequenceDiagram\n    participant A as Initiator\n    participant B as Responder\n    \n    A->>B: onion_link_req\n    \n    B->>A: onion_link_resp\n    \n    A->>B: onion_link_sign\n    \n    B->>A: onion_link_sign\n    \n    A->>B: onion_link_proof\n```\n\n#### `onion_link_req`\n\nThe `onion_link_req` message is a pure TLV message that's sent from one peer to\nanother to request the establishment of a new onion messaging link. It carries\nthe sender's current `onion_key`, and an `onion_nonce` to use in the `musig2`\nsignature.\n\n**Message Type**: `???`\n\n##### TLV Fields\n\n| Field | Type | Length | Description |\n|-------|------|--------|-------------|\n| `onion_key` | 1 | 33 | The sender's onion public key used for establishing the onion messaging link |\n| `onion_nonce` | 3 | 66 | The sender's MuSig2 nonce for the link establishment signature |\n\n#### `onion_link_resp`\n\nThis message is sent in response to an `onion_link_req` message. It includes\nidentical field, but this time instead for the responded.\n\n**Message Type**: `???`\n\n##### TLV Fields\n\n| Field | Type | Length | Description |\n|-------|------|--------|-------------|\n| `onion_key` | 1 | 33 | The responder's onion public key used for establishing the onion messaging link |\n| `onion_nonce` | 3 | 66 | The responder's MuSig2 nonce for the link establishment signature |\n\n#### `onion_link_sign`\n\nWith the `onion_key` of both initiator and responded known, the initiator can\nnow generate the `musig2` partial signature that comprises of half the\n`onion_link_proof`.\n\nAt this point, we assume that both initiator and responded already know the\nlong-term `node_identity` of each other. The generated signature will be\ncreated using an aggregated public key of the set of `onion_key` and\n`node_identity` key for both parties.\n\n`aggregate_onion_proof_key = musig2_key_agg(onion_key_1, onion_key_2, node_key_1, node_key_2)`\n\n**Message Type**: `???`\n\n##### TLV Fields\n\n| Field | Type | Length | Description |\n|-------|------|--------|-------------|\n| `onion_proof_partial_sig` | 5 | 32 | The initiator's MuSig2 partial signature for the onion link establishment |\n\n\nUpon receipt, the responder:\n  * Re derives the `aggregate_onion_proof_key`\n  * Verifies the `onion_proof_partial_sig` from the sender\n  * Generates its own `onion_proof_partial_sig`\n  * Proceeds to construct the `onion_link_proof` message`\n\n#### `onion_link_proof`\n\nA proof of mutual agreement to establish an onion messaging link between two\nnodes. This serves to allow 3rd party nodes to verify that an advertised\nconnection actually exists.\n\nThe initiator constructs this message, and sends to the responded.\n\n##### TLV Fields\n\n| Field | Type | Length | Description |\n|-------|------|--------|-------------|\n| `onion_key_1` | 7 | 33 | The initiator's onion public key |\n| `onion_key_2` | 9 | 33 | The responder's onion public key |\n| `node_key_1` | 11 | 33 | The initiator's node identity public key |\n| `node_key_2` | 13 | 33 | The responder's node identity public key |\n| `onion_link_sig` | 15 | 64 | The complete MuSig2 signature proving mutual agreement to establish the link |\n\nOnce the both parties have the `onion_link_proof` message, they'll create a new\nTCP connection that uses a distinct port, using their the new `onion_key` pair\nto establish the encrypted p2p connection.\n\n\n### Onion Link Discovery\n\nNow onto onion link discovery. As mentioned, node the existing LN gossip\nnetwork is used to bootstrap the new onion overlay network.\n\n#### `node_announcement` Extension\n\nA new TLV field is added to the existing `node_announcement` message. This\nfield contains a series of repeated `onion_link_proof` messages. In aggregate\nhis new field can be seen as an authenticated agency list, that can be used to\nbuild up the latest view of the onion overlay network.\n\n#### New TLV Field\n\n| Field | Type | Length | Description |\n|-------|------|--------|-------------|\n| `onion_link_proofs` | 17 | variable | A list of onion link proofs for this node |\n\n#### Nested `onion_link_proofs` \n\nThe value of this TLV field contains:\n\n| Field | Length | Description |\n|-------|--------|-------------|\n| `num_proofs` | 2 | The number of onion link proofs that follow |\n| `proofs` | variable | `num_proofs` encoded `onion_link_proof` structures |\n\n### Onion Graph Assembly\n\nTo construct the onion graph, a node syncs the LN graph as normal. They then\nfilter through all the nodes that advertise the onion messaging feature bit\n(likely a new one is used for the overlay variant), verify all the\n`onion_link_proofs`, then reconstruct the current onion message graph from the\nauthenticated adjacency list.\n\n### Routine Operation\n\nAfter boostrap, onion messaging functions pretty much as normal. Each member of\nthe overlay network has an authenticated mapping between a node's long term\nidentity key, and their latest ephemeral onion key. Using either, they can\nperform path finding as normal to send and receive messages (blinded paths is\nutilized as normal).\n\nTo rotate an onion public key, nodes can simply restart the flow to obtain a\nnew `onion_link_proof`, then advertise that once again in the network. Rotating\n`node_key` pairs also necessitates reconnecting with a fresh BOLT 8 brontide\nhandshake.\n\n## Interoperability with Existing Infrastructure\n\nThe proposal as described above doesn't disrupt the existing embedded onion message deployment. Instead, the embedded and overlay messagign networks can actually _co exist_. Nodes can simultaneously maintain connections to both the embedded messaging network and the overlay network, treating them as complementary transport mechanisms. \n\nThe onion packet construction remains identical regardless of the underlying transport. As a result, any existing deployed applications that use onion messaging can seamless utilize both the overlay and embedded network. The overlay network can be more rapidly deployed and utilized, while also avoiding fragmentation which may hamper the primary use cases. \n\n## Conclusion \n\nIn this post, we've proposed an alternative (and even parallel!) deployment of onion messaging. As an overlay, the onion messaging network can be decoupled from the existing channel graph. With as few as 100 nodes using this overlay, higher level applications using onion messaging can immediately begin to seamlessly utilize this new overlay, which allows application developers to hone in on the last 20% of work to truly polish user experience. The overlay approach supports loosely synchronized deployment, which embraces permissionless innovation and rapid experimentation.",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 143,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "<a name=\"p-5361-reimagining-onion-messages-as-an-overlay-layer-1\" class=\"anchor\" href=\"#p-5361-reimagining-onion-messages-as-an-overlay-layer-1\"></a>Reimagining Onion Messages as an Overlay Layer\n<a name=\"p-5361-introduction-2\" class=\"anchor\" href=\"#p-5361-introduction-2\"></a>Introduction\nOnion messaging as currently specified and deployed embeds the onion\nmessaging graph into the channel graph. This tight\ncoupling between the onion messaging graph and the channel graph is a poor\ndesign choice as it: necessitates a slow and &hellip;",
  "truncated": true,
  "post_url": "/t/reimagining-onion-messages-as-an-overlay-layer/1799/1",
  "reactions": [
    {
      "id": "heart",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}