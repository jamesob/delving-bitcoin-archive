{
  "id": 5291,
  "name": "Johan T. Halseth",
  "username": "halseth",
  "avatar_template": "/user_avatar/delvingbitcoin.org/halseth/{size}/198_2.png",
  "created_at": "2025-06-13T11:11:19.444Z",
  "cooked": "<p>Thanks for demonstrating the two different implementations <a class=\"mention\" href=\"/u/salvatoshi\">@salvatoshi</a> and <a class=\"mention\" href=\"/u/antoinep\">@AntoineP</a>. It has gotten me thinking about what would be the best approach, and I see both having their tradeoffs.</p>\n<p>I tried implementing both methods in <code>btcd</code>, and similar to <code>bitcoind</code> the difference in complexity of the two methods is a result of the attempt of doing input script validation in parallell during tx/block processing (maybe even more so in btcd because of how easy it is to distribute work across goroutines: <a href=\"https://github.com/btcsuite/btcd/blob/1eb974aab6ef11097571f9517b4b6b0c639ab63b/blockchain/scriptval.go#L148-L170\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">btcd/blockchain/scriptval.go at 1eb974aab6ef11097571f9517b4b6b0c639ab63b \u00b7 btcsuite/btcd \u00b7 GitHub</a>)</p>\n<p>Similar to the bitcoind implementations it comes down to either (1) introducing a shared mutable state across the threads, or (2) doing a pre-check of the intended amount flows and then have <code>CCV</code> assert this data (like in the annex) during script execution.</p>\n<p>Or (3) having a deferred check framework in place, performing  extra checks after a group of dependent inputs have been validated. The deferred checks framework would actually fit nicely (my hunch, I haven\u2019t actually implemented it) with the btcd implementation.</p>\n<p><em><strong>Shared state (1)</strong></em></p>\n<p>The various alternatives all have their downsides, but generally I would be skeptical to introducing a shared state guarded by a mutex, and \u201cgive up\u201d on parallel input validation.</p>\n<p>I think it is definitely worth asking the question whether parallel input validation actually has a practical effect in real life (and benchmarks), but at the same time I think <em>Why change it? There be dragons.</em></p>\n<p><em><strong>Annex hints (2)</strong></em></p>\n<p>The annex approach is nice in the sense that it doesn\u2019t need that much plumbing into the script engine, and the separation of concerns. With this approach you would reduce the CCV opcode to just do \u201cannex assertion\u201d not really caring what the annex means. I believe that would make it easier to add more meaning to the annex at a later point (via a soft fork) and immediately have it available for assertion by CCV without touching the script engine.</p>\n<p>I am curios to explore whether the annex hint approach would be useful together with other (future) script primitives. If you can specify for each input how you expect the funds will flow, that feels like it could be useful in itself. If you combine this with SIGHASH_NONE (only sign inputs), maybe that could be used to built partially signed transactions where flow of funds are pre-determined, but outputs are left unspecified (not sure if this is useful at all though).</p>\n<p><em><strong>Batch validation</strong></em></p>\n<p>Cross-input (batch) signature validation is definitely something we should think about supporting down the road, and accompany for that being practical to implement. To me neither of these approaches seems to be in the way of that (though something like deferred checks might be more aligned with that vision).</p>",
  "post_number": 12,
  "post_type": 1,
  "posts_count": 13,
  "updated_at": "2025-06-13T11:11:19.444Z",
  "reply_count": 1,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 21,
  "readers_count": 20,
  "score": 54.2,
  "yours": false,
  "topic_id": 1527,
  "topic_slug": "op-checkcontractverify-and-its-amount-semantic",
  "topic_title": "OP_CHECKCONTRACTVERIFY and its amount semantic",
  "topic_html_title": "OP_CHECKCONTRACTVERIFY and its amount semantic",
  "category_id": 7,
  "display_username": "Johan T. Halseth",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Thanks for demonstrating the two different implementations @salvatoshi and @AntoineP. It has gotten me thinking about what would be the best approach, and I see both having their tradeoffs.\n\nI tried implementing both methods in `btcd`, and similar to `bitcoind` the difference in complexity of the two methods is a result of the attempt of doing input script validation in parallell during tx/block processing (maybe even more so in btcd because of how easy it is to distribute work across goroutines: https://github.com/btcsuite/btcd/blob/1eb974aab6ef11097571f9517b4b6b0c639ab63b/blockchain/scriptval.go#L148-L170) \n\nSimilar to the bitcoind implementations it comes down to either (1) introducing a shared mutable state across the threads, or (2) doing a pre-check of the intended amount flows and then have `CCV` assert this data (like in the annex) during script execution. \n\nOr (3) having a deferred check framework in place, performing  extra checks after a group of dependent inputs have been validated. The deferred checks framework would actually fit nicely (my hunch, I haven't actually implemented it) with the btcd implementation.\n\n***Shared state (1)***\n\nThe various alternatives all have their downsides, but generally I would be skeptical to introducing a shared state guarded by a mutex, and \"give up\" on parallel input validation. \n\nI think it is definitely worth asking the question whether parallel input validation actually has a practical effect in real life (and benchmarks), but at the same time I think *Why change it? There be dragons.*\n\n***Annex hints (2)***\n\nThe annex approach is nice in the sense that it doesn't need that much plumbing into the script engine, and the separation of concerns. With this approach you would reduce the CCV opcode to just do \"annex assertion\" not really caring what the annex means. I believe that would make it easier to add more meaning to the annex at a later point (via a soft fork) and immediately have it available for assertion by CCV without touching the script engine.\n\nI am curios to explore whether the annex hint approach would be useful together with other (future) script primitives. If you can specify for each input how you expect the funds will flow, that feels like it could be useful in itself. If you combine this with SIGHASH_NONE (only sign inputs), maybe that could be used to built partially signed transactions where flow of funds are pre-determined, but outputs are left unspecified (not sure if this is useful at all though).\n\n***Batch validation***\n\nCross-input (batch) signature validation is definitely something we should think about supporting down the road, and accompany for that being practical to implement. To me neither of these approaches seems to be in the way of that (though something like deferred checks might be more aligned with that vision).",
  "actions_summary": [
    {
      "id": 2,
      "count": 3
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 163,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "Thanks for demonstrating the two different implementations <a class=\"mention\" href=\"/u/salvatoshi\">@salvatoshi</a> and <a class=\"mention\" href=\"/u/antoinep\">@AntoineP</a>. It has gotten me thinking about what would be the best approach, and I see both having their tradeoffs. \nI tried implementing both methods in btcd, and similar to bitcoind the difference in complexity of the two me&hellip;",
  "truncated": true,
  "post_url": "/t/op-checkcontractverify-and-its-amount-semantic/1527/12",
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 3
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 3,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}