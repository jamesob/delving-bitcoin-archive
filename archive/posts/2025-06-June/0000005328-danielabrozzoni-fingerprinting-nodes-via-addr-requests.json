{
  "id": 5328,
  "name": "Daniela",
  "username": "danielabrozzoni",
  "avatar_template": "/user_avatar/delvingbitcoin.org/danielabrozzoni/{size}/1300_2.png",
  "created_at": "2025-06-23T13:13:58.714Z",
  "cooked": "<p>This blog post comes from the research of <a class=\"mention\" href=\"/u/naiyoma\">@naiyoma</a> and me.</p>\n<p>It is currently possible to identify nodes running on multiple networks by analyzing their <code>ADDR</code> responses. Below, we\u2019ll share highlights from our attack attempts - while deliberately avoiding too much detail about the methodology - and discuss some possible solutions.</p>\n<p>This fingerprint attack can hurt network privacy and enable more critical scenarios; for example, it could expose network bridges then to be targeted in partitioning attacks or to gather sensitive metadata.</p>\n<p>This attack is not outstanding; for instance, <a href=\"https://github.com/bitcoin/bitcoin/issues/28760\" rel=\"noopener nofollow ugc\">#28760</a> outlines a different approach with the same objective, and a separate <a href=\"https://www.cs.umd.edu/projects/coinscope/coinscope.pdf\" rel=\"noopener nofollow ugc\">research paper</a> demonstrates how <code>ADDR</code> timestamps can be exploited to infer network topology. However, we believe that addressing the attack would make a reasonable incremental step towards network security.</p>\n<p><strong>Our primary goal in publishing this post is to gather feedback on the proposed solutions.</strong> If you have thoughts on potential mitigations, concerns about the trade-offs involved, or ideas we haven\u2019t considered, we\u2019d very much appreciate hearing from you.</p>\n<h1><a name=\"p-5328-background-1\" class=\"anchor\" href=\"#p-5328-background-1\"></a>Background</h1>\n<p>To discover other peers in the network, nodes rely on an address-sharing mechanism. One node can ask another for known peer addresses by sending a <code>GETADDR</code> message. In response, the receiving node returns an <code>ADDR</code> message, which contains 1000 network addresses (e.g. IP 1.2.3.4) along with their associated timestamps. This helps new or reconnecting nodes to find peers.</p>\n<p>When a node is connected to multiple networks (e.g., clearnet and Tor), it maintains separate caches of <code>ADDR</code> responses for each network of request origin. These caches are refreshed about once per day (randomized to last between 21 and 27 hours). The caching was introduced in Bitcoin Core 0.21, PR <a href=\"https://github.com/bitcoin/bitcoin/pull/18991\" rel=\"noopener nofollow ugc\">#18991</a>.</p>\n<p>For example, imagine a node\u2019s addrman contains the following entries:</p>\n<pre><code class=\"lang-auto\">{\n    \"1.1.1.1\": 1700000001,\n    \"2.2.2.2\": 1700000002,\n    \"abc.xyz\": 1700000003,\n    \"9.9.9.9\": 1700000004,\n    ...\n}\n</code></pre>\n<p>Its network-specific caches might look like:</p>\n<p>IPv4: <code>{\"1.1.1.1\": 1700000001, \"2.2.2.2\": 1700000002, ...}</code></p>\n<p>Tor: <code>{\"abc.xyz\": 1700000003, \"2.2.2.2\": 1700000002, ...}</code></p>\n<h1><a name=\"p-5328-the-attack-2\" class=\"anchor\" href=\"#p-5328-the-attack-2\"></a>The attack</h1>\n<p>The attack works as follows: a spy node looks at <code>ADDR</code> messages from \u201cdifferent\u201d nodes, matches them up based on the timestamps returned to observe the overlap. Nodes that appear to be on separate networks but have high overlap in their address/timestamp responses are likely the same node.</p>\n<h1><a name=\"p-5328-research-highlights-3\" class=\"anchor\" href=\"#p-5328-research-highlights-3\"></a>Research highlights</h1>\n<p>This data was collected in January 2025, and this post focuses on IPv4 &lt;&gt; Tor nodes.</p>\n<p>We connected to a total of 20595 reachable nodes running on IPv4 and Tor networks, and recorded the <code>GETADDR</code> responses of each node. We filtered our data to only include nodes running Bitcoin Core version 0.21 or later, since version 0.21 introduced an address cache (see <a href=\"https://github.com/bitcoin/bitcoin/pull/18991\" rel=\"noopener nofollow ugc\">#18991</a>).</p>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th>Network</th>\n<th>Number of nodes</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>IPv4</td>\n<td>7249</td>\n</tr>\n<tr>\n<td>Tor</td>\n<td>13346</td>\n</tr>\n</tbody>\n</table>\n</div><p>While analyzing the node responses, we noticed that 85% of the IPv4 nodes and 30% of Tor nodes only returned addresses from their own network - for example, IPv4 nodes responding exclusively with IPv4 addresses. We are assuming that these nodes are operating on a single network, and as such, we excluded them from further analysis. This filtering greatly reduced the number of nodes involved:</p>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th>Network</th>\n<th>Number of nodes after filtering</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>IPv4</td>\n<td>1034 (15% of initial nodes)</td>\n</tr>\n<tr>\n<td>Tor</td>\n<td>9271 (70% of initial nodes)</td>\n</tr>\n</tbody>\n</table>\n</div><p>We examined all possible IPv4\u2013Tor node pairs by first coupling each IPv4 node with every Tor node (1034 \u00d7 9271 = ~9.5M pairs). We then filtered out pairs with mismatched version or service fields, yielding 515,155 valid pairs for comparison.</p>\n<p>Each node\u2019s ADDR response contains 1,000 pairs of (address, timestamp). To identify nodes that might actually be the same, we use two metrics for each node pair:</p>\n<ul>\n<li>Number of Addresses Matching</li>\n<li>Number of Addresses and Timestamps Matching</li>\n</ul>\n<p>It is also useful to consider the ratio between the two metrics above, which we\u2019ll refer to as the \u201ctimestamp match ratio\u201d:</p>\n<ul>\n<li>(Addresses + Timestamps Matching) / (Addresses Matching)</li>\n</ul>\n<p>For example, consider two nodes, A and B, with the following ADDR responses:</p>\n<p>Node A:</p>\n<pre><code class=\"lang-auto\">{\n    \"1.1.1.1\": 1700000001, \n    \"2.2.2.2\": 1700000002,\n    \"abc.xyz\": 1700000003,\n    \"9.9.9.9\": 1700000004,\n}\n</code></pre>\n<p>Node B:</p>\n<pre><code class=\"lang-auto\">{\n    \"2.2.2.2\": 1700000002,\n    \"5.5.5.5\": 1700000005,\n    \"abc.xyz\": 1700000006,\n    \"9.9.9.9\": 1700000007,\n}\n</code></pre>\n<p>In this scenario:</p>\n<ul>\n<li>Node A and Node B have three address matches (<code>2.2.2.2</code>, <code>abc.xyz</code>, <code>9.9.9.9</code>)</li>\n<li>They have one Address and Timestamp Match (<code>2.2.2.2</code> with timestamp <code>1700000002</code>)</li>\n<li>The Timestamp match ratio is 33% (1 out of 3 address matches also match timestamps)</li>\n</ul>\n<p>We classified every considered node pair into one of the following categories based on their <code>GETADDR</code> responses overlap:</p>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th>Category</th>\n<th>Number of pairs</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>zero addresses in common</td>\n<td>9,843 (1.91%)</td>\n</tr>\n<tr>\n<td>1\u201310 addresses in common with zero matching timestamps</td>\n<td>142,634 (27.69%)</td>\n</tr>\n<tr>\n<td>more than 10 addresses in common with zero matching timestamps</td>\n<td>46,408 (9.01%)</td>\n</tr>\n<tr>\n<td>at least one address in common with all timestamps matching</td>\n<td>257 (0,05%)</td>\n</tr>\n<tr>\n<td>at least one address in common with some (but not all) timestamps matching</td>\n<td>316,013 (61.34%)</td>\n</tr>\n</tbody>\n</table>\n</div><p><strong>Category 1</strong>: it\u2019s highly unlikely that two nodes don\u2019t share any addresses, but we still observed some pairs fall into this category. They might involve nodes with fresh address managers or even fake address managers. We can\u2019t draw any meaningful conclusion from these pairs at this point.</p>\n<p><strong>Category 2 and 3</strong>: if two nodes share few (&lt;10) addresses, or even if the share more than 10 but none of them have matching timestamps, they\u2019re probably not the same node.</p>\n<p><strong>Category 4</strong>: If two nodes share several addresses and all of them have the same timestamp, that\u2019s a strong signal they\u2019re actually the same node on different networks.</p>\n<p><strong>Category 5</strong>: Node pairs in category 5 might still trace back to the same node: one interesting edge case we found is that even when two interfaces belong to the same node, they don\u2019t always have a 100% timestamp match ratio.</p>\n<p>For example, we looked at the data gathered from a node we control that runs on both I2P and Tor, and observed the following results:</p>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th>Node A Address</th>\n<th>Node B Address</th>\n<th>Address, timestamp matches</th>\n<th>Address matches</th>\n<th>% timestamp matches over address matches</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&lt;I2P address [redacted]&gt;</td>\n<td>&lt;Tor address [redacted]&gt;</td>\n<td>5</td>\n<td>6</td>\n<td>83%</td>\n</tr>\n</tbody>\n</table>\n</div><p>One possible explanation for this behavior is that <code>GETADDR</code> caches for different interfaces are refreshed at different times. The refresh timing is <a href=\"https://github.com/bitcoin/bitcoin/blob/af65fd1a333011137dafd3df9a51704fd319feb4/src/net.cpp#L3550\" rel=\"noopener nofollow ugc\">randomized</a>, and a cache is only updated when a <code>GETADDR</code> request is received. Since each cache acts as a \u201csnapshot\u201d of the node\u2019s addrman at the moment it\u2019s refreshed, differences in refresh time can lead to discrepancies between caches for different interfaces.</p>\n<p>Based on this broader network analysis, we selected a set of candidate IPv4\u2013Tor node pairs to monitor more closely over a six-week period, during which we contacted each pair daily to gather <code>ADDR</code> data. Our selection process was based on a few practical but ultimately arbitrary choices:</p>\n<ul>\n<li>Select pairs with at least 10 matching addresses</li>\n<li>Require a timestamp match ratio of at least 60%</li>\n<li>Monitor the selected pairs daily over a six-week period</li>\n</ul>\n<p>This filtering gave us 664 candidate node pairs for further analysis. However, due to the delay between the initial data collection and this follow-up phase (spanning a few weeks), 216 of those pairs were no longer usable because at least one node had become unreachable.</p>\n<p>We proceeded to monitor the remaining 448 pairs, with the following results:</p>\n<ul>\n<li>369 pairs (about 82%) exhibited a timestamp match ratio of &gt;=90% at least once</li>\n<li>79 pairs (about 18%) never reached &gt;=90% match ratio</li>\n</ul>\n<p>The 369 pairs that exhibited a timestamp match ratio of &gt;=90% at least once during the six weeks strongly suggest they correspond to the same nodes observed across two different networks.</p>\n<p>We managed to confirm several of our hits through personal contacts with node operators.</p>\n<p>While our method was a rough first pass and didn\u2019t cover all the edge cases - so it may include both missed matches and some incorrect ones - the results still show how easy it is to extract metadata that reveals the state of the network.</p>\n<h1><a name=\"p-5328-potential-mitigations-4\" class=\"anchor\" href=\"#p-5328-potential-mitigations-4\"></a>Potential mitigations</h1>\n<p>We began investigating potential solutions and would appreciate feedback on these approaches. The most straightforward direction is to break the fingerprint by manipulating timestamps. There are essentially two approaches to achieve this - one more drastic than the other - but both aim to reduce the usefulness of timestamps for attackers.</p>\n<h2><a name=\"p-5328-randomizing-timestamps-5\" class=\"anchor\" href=\"#p-5328-randomizing-timestamps-5\"></a>Randomizing timestamps</h2>\n<p>One idea is to slightly randomize timestamps before inserting them into each <code>ADDR</code> cache. This would result in addresses across multiple interfaces carrying slightly different timestamps, making cross-network comparisons less accurate.</p>\n<p>The side effect is that we\u2019re degrading the quality of the timestamps, and we should consider whether this can impact the ability of the network to propagate addresses.</p>\n<h2><a name=\"p-5328-removing-timestamps-6\" class=\"anchor\" href=\"#p-5328-removing-timestamps-6\"></a>Removing timestamps</h2>\n<p>Another potential solution is to eliminate timestamps entirely. This idea was <a href=\"https://github.com/bitcoin-core/bitcoin-devwiki/wiki/P2P-IRC-meetings#topic-remove-timestamps-from-addr-messages-it-seems-like-the-timestamp-is-only-used-to-leak-information-about-our-recent-connectivity-it-doesnt-look-like-we-use-it-to-make-decisions-about-who-to-connect-to-sdaftuarjnewbery\" rel=\"noopener nofollow ugc\">previously discussed</a> during an IRC meeting about block relay connections, where it was noted that <code>GETADDR</code> messages can leak connection times; additionally, some attacks can use timestamps to infer network topology, as described <a href=\"https://www.cs.umd.edu/projects/coinscope/coinscope.pdf\" rel=\"noopener nofollow ugc\">here</a>.</p>\n<p>Bitcoin Core uses timestamps to filter out responses to <code>GETADDR</code> requests and sometimes to evict addresses from addrman, but they\u2019re unverifiable and not used to decide who to connect to. In the places where they are used, they could likely be replaced without much trouble using <code>nlasttry</code> and <code>nlastsuccess</code>.</p>\n<h1><a name=\"p-5328-acknowledgments-7\" class=\"anchor\" href=\"#p-5328-acknowledgments-7\"></a>Acknowledgments</h1>\n<p>Much of this process was shaped by the mentorship and feedback of <a class=\"mention\" href=\"/u/naumenkogs\">@naumenkogs</a> and <a class=\"mention\" href=\"/u/amiti\">@amiti</a>, and our approach was strongly influenced by earlier work and tools from <a class=\"mention\" href=\"/u/virtu\">@virtu</a>.</p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 12,
  "updated_at": "2025-06-30T10:13:52.151Z",
  "reply_count": 3,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 305,
  "reads": 83,
  "readers_count": 82,
  "score": 1801.4,
  "yours": false,
  "topic_id": 1786,
  "topic_slug": "fingerprinting-nodes-via-addr-requests",
  "topic_title": "Fingerprinting nodes via addr requests",
  "topic_html_title": "Fingerprinting nodes via addr requests",
  "category_id": 7,
  "display_username": "Daniela",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "This blog post comes from the research of @naiyoma and me.\n\nIt is currently possible to identify nodes running on multiple networks by analyzing their `ADDR` responses. Below, we\u2019ll share highlights from our attack attempts - while deliberately avoiding too much detail about the methodology - and discuss some possible solutions.\n\nThis fingerprint attack can hurt network privacy and enable more critical scenarios; for example, it could expose network bridges then to be targeted in partitioning attacks or to gather sensitive metadata.\n\nThis attack is not outstanding; for instance, [#28760](https://github.com/bitcoin/bitcoin/issues/28760) outlines a different approach with the same objective, and a separate [research paper](https://www.cs.umd.edu/projects/coinscope/coinscope.pdf) demonstrates how `ADDR` timestamps can be exploited to infer network topology. However, we believe that addressing the attack would make a reasonable incremental step towards network security.\n\n**Our primary goal in publishing this post is to gather feedback on the proposed solutions.** If you have thoughts on potential mitigations, concerns about the trade-offs involved, or ideas we haven\u2019t considered, we\u2019d very much appreciate hearing from you.\n\n# Background\n\nTo discover other peers in the network, nodes rely on an address-sharing mechanism. One node can ask another for known peer addresses by sending a `GETADDR` message. In response, the receiving node returns an `ADDR` message, which contains 1000 network addresses (e.g. IP 1.2.3.4) along with their associated timestamps. This helps new or reconnecting nodes to find peers.\n\nWhen a node is connected to multiple networks (e.g., clearnet and Tor), it maintains separate caches of `ADDR` responses for each network of request origin. These caches are refreshed about once per day (randomized to last between 21 and 27 hours). The caching was introduced in Bitcoin Core 0.21, PR [#18991](https://github.com/bitcoin/bitcoin/pull/18991).\n\nFor example, imagine a node\u2019s addrman contains the following entries:\n```\n{\n    \"1.1.1.1\": 1700000001,\n    \"2.2.2.2\": 1700000002,\n    \"abc.xyz\": 1700000003,\n    \"9.9.9.9\": 1700000004,\n    ...\n}\n```\nIts network-specific caches might look like:\n\nIPv4: `{\"1.1.1.1\": 1700000001, \"2.2.2.2\": 1700000002, ...}`\n\nTor: `{\"abc.xyz\": 1700000003, \"2.2.2.2\": 1700000002, ...}`\n\n# The attack\n\nThe attack works as follows: a spy node looks at `ADDR` messages from \u201cdifferent\u201d nodes, matches them up based on the timestamps returned to observe the overlap. Nodes that appear to be on separate networks but have high overlap in their address/timestamp responses are likely the same node.\n\n# Research highlights\n\nThis data was collected in January 2025, and this post focuses on IPv4 <> Tor nodes.\n\nWe connected to a total of 20595 reachable nodes running on IPv4 and Tor networks, and recorded the `GETADDR` responses of each node. We filtered our data to only include nodes running Bitcoin Core version 0.21 or later, since version 0.21 introduced an address cache (see [#18991](https://github.com/bitcoin/bitcoin/pull/18991)).\n\n|Network|Number of nodes|\n| --- | --- |\n|IPv4|7249|\n|Tor|13346|\n\nWhile analyzing the node responses, we noticed that 85% of the IPv4 nodes and 30% of Tor nodes only returned addresses from their own network - for example, IPv4 nodes responding exclusively with IPv4 addresses. We are assuming that these nodes are operating on a single network, and as such, we excluded them from further analysis. This filtering greatly reduced the number of nodes involved:\n\n|Network|Number of nodes after filtering|\n| --- | --- |\n|IPv4|1034 (15% of initial nodes)|\n|Tor|9271 (70% of initial nodes)|\n\nWe examined all possible IPv4\u2013Tor node pairs by first coupling each IPv4 node with every Tor node (1034 \u00d7 9271 = ~9.5M pairs). We then filtered out pairs with mismatched version or service fields, yielding 515,155 valid pairs for comparison.\n\nEach node\u2019s ADDR response contains 1,000 pairs of (address, timestamp). To identify nodes that might actually be the same, we use two metrics for each node pair:\n\n* Number of Addresses Matching\n* Number of Addresses and Timestamps Matching\n\nIt is also useful to consider the ratio between the two metrics above, which we'll refer to as the \u201ctimestamp match ratio\u201d:\n\n* (Addresses + Timestamps Matching) / (Addresses Matching)\n\nFor example, consider two nodes, A and B, with the following ADDR responses:\n\nNode A: \n```\n{\n    \"1.1.1.1\": 1700000001, \n    \"2.2.2.2\": 1700000002,\n    \"abc.xyz\": 1700000003,\n    \"9.9.9.9\": 1700000004,\n}\n```\n\nNode B:\n```\n{\n    \"2.2.2.2\": 1700000002,\n    \"5.5.5.5\": 1700000005,\n    \"abc.xyz\": 1700000006,\n    \"9.9.9.9\": 1700000007,\n}\n```\n\nIn this scenario:\n\n* Node A and Node B have three address matches (`2.2.2.2`, `abc.xyz`, `9.9.9.9`)\n* They have one Address and Timestamp Match (`2.2.2.2` with timestamp `1700000002`)\n* The Timestamp match ratio is 33% (1 out of 3 address matches also match timestamps)\n\nWe classified every considered node pair into one of the following categories based on their `GETADDR` responses overlap:\n\n|Category|Number of pairs|\n| --- | --- |\n|zero addresses in common|9,843 (1.91%)|\n|1\u201310 addresses in common with zero matching timestamps|142,634 (27.69%)|\n|more than 10 addresses in common with zero matching timestamps|46,408 (9.01%)|\n|at least one address in common with all timestamps matching|257 (0,05%)|\n|at least one address in common with some (but not all) timestamps matching|316,013 (61.34%)|\n\n\n**Category 1**: it\u2019s highly unlikely that two nodes don\u2019t share any addresses, but we still observed some pairs fall into this category. They might involve nodes with fresh address managers or even fake address managers. We can\u2019t draw any meaningful conclusion from these pairs at this point.\n\n**Category 2 and 3**: if two nodes share few (<10) addresses, or even if the share more than 10 but none of them have matching timestamps, they\u2019re probably not the same node.\n\n**Category 4**: If two nodes share several addresses and all of them have the same timestamp, that\u2019s a strong signal they\u2019re actually the same node on different networks.\n\n**Category 5**: Node pairs in category 5 might still trace back to the same node: one interesting edge case we found is that even when two interfaces belong to the same node, they don\u2019t always have a 100% timestamp match ratio.\n\nFor example, we looked at the data gathered from a node we control that runs on both I2P and Tor, and observed the following results:\n\n|Node A Address|Node B Address|Address, timestamp matches|Address matches|% timestamp matches over address matches|\n| --- | --- | --- | --- | --- |\n|<I2P address [redacted]>|<Tor address [redacted]>|5|6|83%|\n\nOne possible explanation for this behavior is that `GETADDR` caches for different interfaces are refreshed at different times. The refresh timing is [randomized](https://github.com/bitcoin/bitcoin/blob/af65fd1a333011137dafd3df9a51704fd319feb4/src/net.cpp#L3550), and a cache is only updated when a `GETADDR` request is received. Since each cache acts as a \"snapshot\" of the node\u2019s addrman at the moment it's refreshed, differences in refresh time can lead to discrepancies between caches for different interfaces.\n\nBased on this broader network analysis, we selected a set of candidate IPv4\u2013Tor node pairs to monitor more closely over a six-week period, during which we contacted each pair daily to gather `ADDR` data. Our selection process was based on a few practical but ultimately arbitrary choices:\n\n* Select pairs with at least 10 matching addresses\n* Require a timestamp match ratio of at least 60%\n* Monitor the selected pairs daily over a six-week period\n\nThis filtering gave us 664 candidate node pairs for further analysis. However, due to the delay between the initial data collection and this follow-up phase (spanning a few weeks), 216 of those pairs were no longer usable because at least one node had become unreachable.\n\nWe proceeded to monitor the remaining 448 pairs, with the following results:\n\n* 369 pairs (about 82%) exhibited a timestamp match ratio of >=90% at least once\n* 79 pairs (about 18%) never reached >=90% match ratio\n\nThe 369 pairs that exhibited a timestamp match ratio of >=90% at least once during the six weeks strongly suggest they correspond to the same nodes observed across two different networks.\n\nWe managed to confirm several of our hits through personal contacts with node operators.\n\nWhile our method was a rough first pass and didn\u2019t cover all the edge cases - so it may include both missed matches and some incorrect ones - the results still show how easy it is to extract metadata that reveals the state of the network.\n\n# Potential mitigations\n\nWe began investigating potential solutions and would appreciate feedback on these approaches. The most straightforward direction is to break the fingerprint by manipulating timestamps. There are essentially two approaches to achieve this - one more drastic than the other - but both aim to reduce the usefulness of timestamps for attackers.\n\n## Randomizing timestamps\n\nOne idea is to slightly randomize timestamps before inserting them into each `ADDR` cache. This would result in addresses across multiple interfaces carrying slightly different timestamps, making cross-network comparisons less accurate.\n\nThe side effect is that we\u2019re degrading the quality of the timestamps, and we should consider whether this can impact the ability of the network to propagate addresses.\n\n## Removing timestamps\n\nAnother potential solution is to eliminate timestamps entirely. This idea was [previously discussed](https://github.com/bitcoin-core/bitcoin-devwiki/wiki/P2P-IRC-meetings#topic-remove-timestamps-from-addr-messages-it-seems-like-the-timestamp-is-only-used-to-leak-information-about-our-recent-connectivity-it-doesnt-look-like-we-use-it-to-make-decisions-about-who-to-connect-to-sdaftuarjnewbery) during an IRC meeting about block relay connections, where it was noted that `GETADDR` messages can leak connection times; additionally, some attacks can use timestamps to infer network topology, as described [here](https://www.cs.umd.edu/projects/coinscope/coinscope.pdf).\n\nBitcoin Core uses timestamps to filter out responses to `GETADDR` requests and sometimes to evict addresses from addrman, but they\u2019re unverifiable and not used to decide who to connect to. In the places where they are used, they could likely be replaced without much trouble using `nlasttry` and `nlastsuccess`.\n\n# Acknowledgments\n\nMuch of this process was shaped by the mentorship and feedback of @naumenkogs and @amiti, and our approach was strongly influenced by earlier work and tools from @virtu.",
  "actions_summary": [
    {
      "id": 2,
      "count": 19
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 186,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "This blog post comes from the research of <a class=\"mention\" href=\"/u/naiyoma\">@naiyoma</a> and me. \nIt is currently possible to identify nodes running on multiple networks by analyzing their ADDR responses. Below, we\u2019ll share highlights from our attack attempts - while deliberately avoiding too much detail about the methodology - and disc&hellip;",
  "truncated": true,
  "post_url": "/t/fingerprinting-nodes-via-addr-requests/1786/1",
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 13
    },
    {
      "id": "heart",
      "type": "emoji",
      "count": 4
    },
    {
      "id": "eyes",
      "type": "emoji",
      "count": 2
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 19,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}