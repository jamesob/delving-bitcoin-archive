{
  "id": 5205,
  "name": "",
  "username": "josh",
  "avatar_template": "/user_avatar/delvingbitcoin.org/josh/{size}/95_2.png",
  "created_at": "2025-06-03T22:56:58.839Z",
  "cooked": "<h2><a name=\"p-5205-tldr-1\" class=\"anchor\" href=\"#p-5205-tldr-1\"></a>Tldr</h2>\n<p><a href=\"https://github.com/joshdoman/descriptor-encrypt\" rel=\"noopener nofollow ugc\">descriptor-encrypt</a> is a rust library that deterministically encrypts wallet descriptors so that they can only be decrypted by a set of keys that can spend the funds. This enables secure public backups where sensitive wallet information needs to remain hidden from unauthorized parties.</p>\n<h2><a name=\"p-5205-intro-2\" class=\"anchor\" href=\"#p-5205-intro-2\"></a>Intro</h2>\n<p>For the B25 hackathon, I built a rust library, <a href=\"https://github.com/joshdoman/descriptor-encrypt\" rel=\"noopener nofollow ugc\">descriptor-encrypt</a>, which can deterministically encrypt any wallet descriptor such that it can only be decrypted by a set of keys that can spend the funds.</p>\n<p>It supports all descriptors types and miniscript, and it can encrypt the descriptor such that no information is revealed about key inclusion unless enough keys are present to fully decrypt. It also uses a tag-based variable-length encoding scheme to minimize the amount of data that needs to be stored.</p>\n<p>This project is a follow-up to a proof-of-concept I shared <a href=\"https://delvingbitcoin.org/t/multisigbackup-com-backup-and-recover-a-k-of-n-descriptor-using-only-n-seeds/1430\">earlier this year</a>, which only supports standard non-taproot multisigs. I\u2019d like to thank <a class=\"mention\" href=\"/u/notmandatory\">@notmandatory</a>, who suggested I create a rust library to make it easier for wallets to support.</p>\n<h2><a name=\"p-5205-how-it-works-3\" class=\"anchor\" href=\"#p-5205-how-it-works-3\"></a>How it works</h2>\n<p>This library encrypts any Bitcoin wallet descriptor in a way that mirrors the descriptor\u2019s spending policy:</p>\n<ul>\n<li>If your wallet requires 2-of-3 keys to spend, it will require exactly 2-of-3 keys to decrypt.</li>\n<li>If your wallet uses a complex miniscript policy like \u201cEither 2 keys OR (a timelock AND another key)\u201d, encryption follows the same structure, as if all timelocks and hash-locks are satisfied.</li>\n</ul>\n<p>To do this, the descriptor\u2019s spending policy is analyzed and transformed into a tree-like structure, where each node is a threshold and each leaf is either a key or a keyless condition. Keyless leaves are then pruned and each threshold is updated to reflect a tree where all satisfiable keyless conditions are satisfied.</p>\n<p>Next, a master encryption key (derived deterministically from the descriptor) is sharded using recursive Shamir secret sharing into an identical tree-like structure, and each leaf is encrypted using the corresponding key. As a result, decryption requires access to enough keys to spend the funds.</p>\n<p>In the default mode, shares are encrypted using Chacha20-Poly1305 and the payload is encrypted using ChaCha20. This enables fast decryption for arbitrarily large descriptors, but it leaks information about key inclusion, which is not ideal for setups where encrypted backups are stored in public.</p>\n<p>For maximum privacy, <code>full-secrecy</code> mode can be used, which encrypts shares using ChaCha20 and encrypts the payload using ChaCha20-Poly1305. This reveals no information about key inclusion unless the payload can be decrypted, but it\u2019s slower to decrypt, as we must try all possible combination of shares and keys. This has a running time of <span class=\"math\">O((N+1)^K)</span>, where <span class=\"math\">N</span> is the number of decryption keys and <span class=\"math\">K</span> is the number of shares in the descriptor. This takes milliseconds for typical descriptors but can be computationally slow for extremely large ones.</p>\n<h2><a name=\"p-5205-encoding-4\" class=\"anchor\" href=\"#p-5205-encoding-4\"></a>Encoding</h2>\n<p>Prior to encryption, the descriptor is encoded using a tag-based encoding scheme (see <a href=\"https://github.com/joshdoman/descriptor-encrypt/blob/269e8eeb91362900fb5c4f8ccd521a54eb2dd3b7/src/template/tag.rs\" rel=\"noopener nofollow ugc\">tag.rs</a>). Variable-length encoding is used for integers in derivation paths, timelocks, thresholds, etc.</p>\n<p>This encoding splits the descriptor into two byte arrays, a \u201ctemplate\u201d and a \u201cpayload.\u201d The template contains the structure of the descriptor and the derivation paths, and the payload contains the sensitive data, such as the public keys, xpubs, master fingerprints, hash-locks, and time-locks. Only the payload is encrypted, while the template remains visible in plaintext, so that users know how to derive the necessary keys and recover the descriptor.</p>\n<p>The final scheme has the following format:</p>\n<pre><code class=\"lang-auto\">[version][template][encrypted shares][encrypted payload]\n</code></pre>\n<h2><a name=\"p-5205-alternatives-5\" class=\"anchor\" href=\"#p-5205-alternatives-5\"></a>Alternatives</h2>\n<p>In <a href=\"https://delvingbitcoin.org/t/a-simple-backup-scheme-for-wallet-accounts/1607/20\">this post</a>, <a class=\"mention\" href=\"/u/salvatoshi\">@salvatoshi</a> proposed an alternative scheme, which only requires a single key in order to decrypt. The simplicity of this scheme is its best property, and it could be suitable for users that want to backup their descriptor via email or the cloud without a hacker or cloud provider being able to see their balance.</p>\n<p>This library has a different objective, as it aims to provide maximum privacy to wallet backups, so that no information is revealed about balances, transaction history, or key inclusion except to users authorized to spend the funds. This degree of privacy is advisable if we want to use a public blockchain or another public forum (i.e. social media) to store encrypted backups.</p>\n<p>There are several benefits to storing encrypted backups in public instead of via email or in the cloud:</p>\n<ol>\n<li><strong>Simplified inheritance</strong>: Heirs can scan the public database for descriptors they can decrypt and recover the funds.</li>\n<li><strong>Better privacy</strong>: A hacker that gains access to Gmail or cloud storage learns nothing about the existence of a Bitcoin wallet, making users less susceptible to wrench attacks.</li>\n<li><strong>Decoy support</strong>: With full secrecy mode, an attacker who steals one seed cannot determine whether that seed is part of a larger descriptor.</li>\n</ol>\n<p>The encoding scheme is designed to support public backups, by minimizing the amount of data that needs to be stored. For example, an encrypted standard 2-of-3 descriptor (with fingerprints and derivation paths) is only 402 bytes. This is ~100vb if stored as witness data on Bitcoin, which becomes fairly cost effective if the taproot annex becomes standard.</p>\n<h2><a name=\"p-5205-demo-6\" class=\"anchor\" href=\"#p-5205-demo-6\"></a>Demo</h2>\n<p>This <a href=\"https://github.com/joshdoman/descriptor-encrypt/tree/main\" rel=\"noopener nofollow ugc\">GitHub repo</a> contains a command-line tool, where the library can be run locally. In addition, I have used Web Assembly to port it to the browser, where it can be demo\u2019d at <a href=\"http://descriptorencrypt.org\" rel=\"noopener nofollow ugc\">descriptorencrypt.org</a>.</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/2X/5/526fc7e7aafef1c20ebea8510ce9808769661bd5.jpeg\" data-download-href=\"https://delvingbitcoin.org/uploads/default/526fc7e7aafef1c20ebea8510ce9808769661bd5\" title=\"\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/2X/5/526fc7e7aafef1c20ebea8510ce9808769661bd5_2_676x500.jpeg\" alt=\"\" data-base62-sha1=\"bLgDNRLaUBqAl1s6no3XhqdzmpT\" role=\"presentation\" width=\"676\" height=\"500\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/2X/5/526fc7e7aafef1c20ebea8510ce9808769661bd5_2_676x500.jpeg, https://delvingbitcoin.org/uploads/default/optimized/2X/5/526fc7e7aafef1c20ebea8510ce9808769661bd5_2_1014x750.jpeg 1.5x, https://delvingbitcoin.org/uploads/default/optimized/2X/5/526fc7e7aafef1c20ebea8510ce9808769661bd5_2_1352x1000.jpeg 2x\" data-dominant-color=\"F8F8F8\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\"></span><span class=\"informations\">1764\u00d71304 59.1 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<h2><a name=\"p-5205-further-work-7\" class=\"anchor\" href=\"#p-5205-further-work-7\"></a>Further work</h2>\n<p>This library aims to provide a robust foundation for encoding and encrypting Bitcoin descriptors, with maximum privacy guarantees. While more complex than other schemes, it\u2019s built as a rust library to make it easy to port to other languages and integrate into wallets.</p>\n<p>The library is intentionally un-opinionated about <em>where</em> descriptors are stored. If stored on a public blockchain or another public database, it\u2019s advisable to append a short hash of each combination of fingerprints, corresponding to seeds that can be used to decrypt. This would facilitate indexing and rapid lookup during the recovery process.</p>\n<p>I hope the community finds this interesting. If there\u2019s interest, I can flesh out the implementation in a formal specification.</p>\n<h3><a name=\"p-5205-links-8\" class=\"anchor\" href=\"#p-5205-links-8\"></a>Links</h3>\n<p>Github: <a href=\"https://github.com/joshdoman/descriptor-encrypt\" rel=\"noopener nofollow ugc\">https://github.com/joshdoman/descriptor-encrypt</a></p>\n<p>Docs: <a href=\"https://docs.rs/descriptor-encrypt/latest/descriptor_encrypt/\" rel=\"noopener nofollow ugc\">https://docs.rs/descriptor-encrypt/latest/descriptor_encrypt/</a></p>\n<p>Demo: <a href=\"https://descriptorencrypt.org\" rel=\"noopener nofollow ugc\">https://descriptorencrypt.org</a></p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 2,
  "updated_at": "2025-06-04T01:43:19.881Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 110,
  "reads": 46,
  "readers_count": 45,
  "score": 599.2,
  "yours": false,
  "topic_id": 1750,
  "topic_slug": "rust-descriptor-encrypt-encrypt-any-descriptor-such-that-only-authorized-spenders-can-decrypt",
  "topic_title": "[Rust] descriptor-encrypt: Encrypt any descriptor such that only authorized spenders can decrypt",
  "topic_html_title": "[Rust] descriptor-encrypt: Encrypt any descriptor such that only authorized spenders can decrypt",
  "category_id": 8,
  "display_username": "",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 3,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "## Tldr\n\n[descriptor-encrypt](https://github.com/joshdoman/descriptor-encrypt) is a rust library that deterministically encrypts wallet descriptors so that they can only be decrypted by a set of keys that can spend the funds. This enables secure public backups where sensitive wallet information needs to remain hidden from unauthorized parties.\n\n## Intro\n\nFor the B25 hackathon, I built a rust library, [descriptor-encrypt](https://github.com/joshdoman/descriptor-encrypt), which can deterministically encrypt any wallet descriptor such that it can only be decrypted by a set of keys that can spend the funds.\n\nIt supports all descriptors types and miniscript, and it can encrypt the descriptor such that no information is revealed about key inclusion unless enough keys are present to fully decrypt. It also uses a tag-based variable-length encoding scheme to minimize the amount of data that needs to be stored.\n\nThis project is a follow-up to a proof-of-concept I shared [earlier this year](https://delvingbitcoin.org/t/multisigbackup-com-backup-and-recover-a-k-of-n-descriptor-using-only-n-seeds/1430), which only supports standard non-taproot multisigs. I'd like to thank @notmandatory, who suggested I create a rust library to make it easier for wallets to support. \n\n## How it works\n\nThis library encrypts any Bitcoin wallet descriptor in a way that mirrors the descriptor's spending policy:\n\n- If your wallet requires 2-of-3 keys to spend, it will require exactly 2-of-3 keys to decrypt.\n- If your wallet uses a complex miniscript policy like \"Either 2 keys OR (a timelock AND another key)\", encryption follows the same structure, as if all timelocks and hash-locks are satisfied.\n\nTo do this, the descriptor's spending policy is analyzed and transformed into a tree-like structure, where each node is a threshold and each leaf is either a key or a keyless condition. Keyless leaves are then pruned and each threshold is updated to reflect a tree where all satisfiable keyless conditions are satisfied.\n\nNext, a master encryption key (derived deterministically from the descriptor) is sharded using recursive Shamir secret sharing into an identical tree-like structure, and each leaf is encrypted using the corresponding key. As a result, decryption requires access to enough keys to spend the funds.\n\nIn the default mode, shares are encrypted using Chacha20-Poly1305 and the payload is encrypted using ChaCha20. This enables fast decryption for arbitrarily large descriptors, but it leaks information about key inclusion, which is not ideal for setups where encrypted backups are stored in public.\n\nFor maximum privacy, `full-secrecy` mode can be used, which encrypts shares using ChaCha20 and encrypts the payload using ChaCha20-Poly1305. This reveals no information about key inclusion unless the payload can be decrypted, but it's slower to decrypt, as we must try all possible combination of shares and keys. This has a running time of $O((N+1)^K)$, where $N$ is the number of decryption keys and $K$ is the number of shares in the descriptor. This takes milliseconds for typical descriptors but can be computationally slow for extremely large ones.\n\n## Encoding\n\nPrior to encryption, the descriptor is encoded using a tag-based encoding scheme (see [tag.rs](https://github.com/joshdoman/descriptor-encrypt/blob/269e8eeb91362900fb5c4f8ccd521a54eb2dd3b7/src/template/tag.rs)). Variable-length encoding is used for integers in derivation paths, timelocks, thresholds, etc.\n\nThis encoding splits the descriptor into two byte arrays, a \"template\" and a \"payload.\" The template contains the structure of the descriptor and the derivation paths, and the payload contains the sensitive data, such as the public keys, xpubs, master fingerprints, hash-locks, and time-locks. Only the payload is encrypted, while the template remains visible in plaintext, so that users know how to derive the necessary keys and recover the descriptor.\n\nThe final scheme has the following format:\n```\n[version][template][encrypted shares][encrypted payload]\n```\n\n## Alternatives\n\nIn [this post](https://delvingbitcoin.org/t/a-simple-backup-scheme-for-wallet-accounts/1607/20), @salvatoshi proposed an alternative scheme, which only requires a single key in order to decrypt. The simplicity of this scheme is its best property, and it could be suitable for users that want to backup their descriptor via email or the cloud without a hacker or cloud provider being able to see their balance.\n\nThis library has a different objective, as it aims to provide maximum privacy to wallet backups, so that no information is revealed about balances, transaction history, or key inclusion except to users authorized to spend the funds. This degree of privacy is advisable if we want to use a public blockchain or another public forum (i.e. social media) to store encrypted backups.\n\nThere are several benefits to storing encrypted backups in public instead of via email or in the cloud:\n1) **Simplified inheritance**: Heirs can scan the public database for descriptors they can decrypt and recover the funds.\n2) **Better privacy**: A hacker that gains access to Gmail or cloud storage learns nothing about the existence of a Bitcoin wallet, making users less susceptible to wrench attacks.\n3) **Decoy support**: With full secrecy mode, an attacker who steals one seed cannot determine whether that seed is part of a larger descriptor.\n\nThe encoding scheme is designed to support public backups, by minimizing the amount of data that needs to be stored. For example, an encrypted standard 2-of-3 descriptor (with fingerprints and derivation paths) is only 402 bytes. This is ~100vb if stored as witness data on Bitcoin, which becomes fairly cost effective if the taproot annex becomes standard.\n\n## Demo\n\nThis [GitHub repo](https://github.com/joshdoman/descriptor-encrypt/tree/main) contains a command-line tool, where the library can be run locally. In addition, I have used Web Assembly to port it to the browser, where it can be demo'd at descriptorencrypt.org.\n\n![](upload://bLgDNRLaUBqAl1s6no3XhqdzmpT.jpeg)\n\n\n## Further work\n\nThis library aims to provide a robust foundation for encoding and encrypting Bitcoin descriptors, with maximum privacy guarantees. While more complex than other schemes, it's built as a rust library to make it easy to port to other languages and integrate into wallets.\n\nThe library is intentionally un-opinionated about *where* descriptors are stored. If stored on a public blockchain or another public database, it's advisable to append a short hash of each combination of fingerprints, corresponding to seeds that can be used to decrypt. This would facilitate indexing and rapid lookup during the recovery process.\n\nI hope the community finds this interesting. If there's interest, I can flesh out the implementation in a formal specification.\n\n### Links\n\nGithub: [https://github.com/joshdoman/descriptor-encrypt](https://github.com/joshdoman/descriptor-encrypt)\n\nDocs: [https://docs.rs/descriptor-encrypt/latest/descriptor_encrypt/](https://docs.rs/descriptor-encrypt/latest/descriptor_encrypt/)\n\nDemo: https://descriptorencrypt.org",
  "actions_summary": [
    {
      "id": 2,
      "count": 3
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 98,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "<a name=\"p-5205-tldr-1\" class=\"anchor\" href=\"#p-5205-tldr-1\"></a>Tldr\n<a href=\"https://github.com/joshdoman/descriptor-encrypt\" rel=\"noopener nofollow ugc\">descriptor-encrypt</a> is a rust library that deterministically encrypts wallet descriptors so that they can only be decrypted by a set of keys that can spend the funds. This enables secure public backups where sensitive wallet information needs to remain hidden from unauthorized parties. \n<a name=\"p-5205-intro-2\" class=\"anchor\" href=\"#p-5205-intro-2\"></a>Intro\nFo&hellip;",
  "truncated": true,
  "post_url": "/t/rust-descriptor-encrypt-encrypt-any-descriptor-such-that-only-authorized-spenders-can-decrypt/1750/1",
  "reactions": [
    {
      "id": "clap",
      "type": "emoji",
      "count": 2
    },
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 3,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}