{
  "id": 1095,
  "name": "David A. Harding",
  "username": "harding",
  "avatar_template": "/user_avatar/delvingbitcoin.org/harding/{size}/6_2.png",
  "created_at": "2024-01-12T18:04:39.566Z",
  "cooked": "<p>The idea described below in this post doesn\u2019t work.  I tried to find a way to make carveout compatible with cluster mempool and failed.  Normally I wouldn\u2019t advertise my failures, but I think it could be useful to future discussions to show several people tried working this problem and couldn\u2019t find a solution.</p>\n<aside class=\"quote no-group\" data-username=\"sdaftuar\" data-post=\"3\" data-topic=\"393\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/letter_avatar_proxy/v4/letter/s/0ea827/48.png\" class=\"avatar\"> sdaftuar:</div>\n<blockquote>\n<p>the current carveout rule (which just checks that the incoming transaction have exactly 1 ancestor and be below some size limit).</p>\n</blockquote>\n</aside>\n<p>Your description and diagram match how carveout works (AIUI) but I think it\u2019s worth noting that LN anchor channels only have exactly 2 outputs that can be spent in the same block as the parent transaction (see BOLT3).  This is necessary to prevent a malicious counterparty who controls &gt;1 output from using the carveout themselves and preventing its use by the honest counterparty, so I think we can safely assume that any other thoughtful users of carveouts are doing something similar.  An implication of this is that your diagram\u2019s P2 to P5 could not have a carveout attached because both immediately-spendable outputs have already been spent.</p>\n<p>I think we can reformulate carveout\u2019s rules as used by LN:</p>\n<ol>\n<li>A carveout is 1,000 vbytes or less</li>\n<li>A carveout has exactly one unconfirmed ancestor (it\u2019s parent)</li>\n<li>A carveout\u2019s parent has no unconfirmed ancestors</li>\n<li>A carveout is either the first or second spent output of a transaction that has fewer than three of its outputs spent so far</li>\n</ol>\n<p>Checking whether a newly received transaction obeys rule <span class=\"hashtag-raw\">#1</span> is obviously easy. Checking that it obeys rule <span class=\"hashtag-raw\">#2</span> is also easy because we have to look up each of a transaction\u2019s inputs anyway.  When we find the carveout\u2019s exactly one unconfirmed ancestor, we can check that it obeys rule <span class=\"hashtag-raw\">#3</span> using the same mechanism (no special traits or caching required).  Now to check rule <span class=\"hashtag-raw\">#4</span> we need only determine how many spends of the parent transaction\u2019s outputs are currently in the mempool; if it\u2019s currently 0 or 1, and all the previous rules were satisfied, we tag this transaction as a carveout and allow it to exceed the cluster size limit.</p>\n<p>Using free CPU cycles, we can periodically check every transaction tagged as a carveout to see if its parent now has three or more spends, in which case we can clear the carveout flag.</p>\n<p>When writing the above, I thought my proposed scheme meant a cluster could never have more than two carveouts.  However, here\u2019s a case where there can be many more:</p>\n<pre data-code-height=\"200\" data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">graph TD;\n  P1 --&gt; CO1;\n  P2 --&gt; CO2;\n  P3 --&gt; CO3;\n  P1 &amp; P2 &amp; P3 --&gt; C1[Regular child];\n\n</code></pre>",
  "post_number": 5,
  "post_type": 1,
  "updated_at": "2024-01-12T18:04:39.566Z",
  "reply_count": 2,
  "reply_to_post_number": 3,
  "quote_count": 1,
  "incoming_link_count": 0,
  "reads": 8,
  "readers_count": 7,
  "score": 26.6,
  "yours": false,
  "topic_id": 393,
  "topic_slug": "an-overview-of-the-cluster-mempool-proposal",
  "topic_title": "An overview of the cluster mempool proposal",
  "topic_html_title": "An overview of the cluster mempool proposal",
  "category_id": 8,
  "display_username": "David A. Harding",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "The idea described below in this post doesn't work.  I tried to find a way to make carveout compatible with cluster mempool and failed.  Normally I wouldn't advertise my failures, but I think it could be useful to future discussions to show several people tried working this problem and couldn't find a solution.\n\n[quote=\"sdaftuar, post:3, topic:393\"]\nthe current carveout rule (which just checks that the incoming transaction have exactly 1 ancestor and be below some size limit).\n[/quote]\n\nYour description and diagram match how carveout works (AIUI) but I think it's worth noting that LN anchor channels only have exactly 2 outputs that can be spent in the same block as the parent transaction (see BOLT3).  This is necessary to prevent a malicious counterparty who controls >1 output from using the carveout themselves and preventing its use by the honest counterparty, so I think we can safely assume that any other thoughtful users of carveouts are doing something similar.  An implication of this is that your diagram's P2 to P5 could not have a carveout attached because both immediately-spendable outputs have already been spent.\n\nI think we can reformulate carveout's rules as used by LN:\n\n1. A carveout is 1,000 vbytes or less\n2. A carveout has exactly one unconfirmed ancestor (it's parent)\n3. A carveout's parent has no unconfirmed ancestors\n4. A carveout is either the first or second spent output of a transaction that has fewer than three of its outputs spent so far\n\nChecking whether a newly received transaction obeys rule #1 is obviously easy. Checking that it obeys rule #2 is also easy because we have to look up each of a transaction's inputs anyway.  When we find the carveout's exactly one unconfirmed ancestor, we can check that it obeys rule #3 using the same mechanism (no special traits or caching required).  Now to check rule #4 we need only determine how many spends of the parent transaction's outputs are currently in the mempool; if it's currently 0 or 1, and all the previous rules were satisfied, we tag this transaction as a carveout and allow it to exceed the cluster size limit.\n\nUsing free CPU cycles, we can periodically check every transaction tagged as a carveout to see if its parent now has three or more spends, in which case we can clear the carveout flag.\n\nWhen writing the above, I thought my proposed scheme meant a cluster could never have more than two carveouts.  However, here's a case where there can be many more:\n\n```mermaid height=200\ngraph TD;\n  P1 --> CO1;\n  P2 --> CO2;\n  P3 --> CO3;\n  P1 & P2 & P3 --> C1[Regular child];\n\n```",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 6,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}