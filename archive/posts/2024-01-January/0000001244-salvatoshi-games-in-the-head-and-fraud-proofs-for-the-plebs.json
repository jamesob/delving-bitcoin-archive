{
  "id": 1244,
  "name": "salvatoshi",
  "username": "salvatoshi",
  "avatar_template": "/user_avatar/delvingbitcoin.org/salvatoshi/{size}/72_2.png",
  "created_at": "2024-01-20T12:25:51.865Z",
  "cooked": "<p>While thinking about how to optimize fraud proofs implemented using MATT contracts, I came up with a quite neat approach that applies more generally to any multiple-round, 2-party game. The idea is very simple, so I wouldn\u2019t be surprised if it\u2019s not really novel, and would appreciate any literature reference.</p>\n<p><strong>TL;DR:</strong> any two party game played in a MATT contract, with arbitrarily complex game rules, can be turned into a protocol where the data overhead of each move is only about 2 hashes.</p>\n<p><strong>TL;DR2:</strong> it\u2019s possible to implement fully general fraud proofs that with an estimated cost of around 7000 vbytes and 17 total transactions. Fraud proofs applied to CoinPools of 256 user should cost 2000 vbytes and only 5 transactions.</p>\n<h1><a name=\"h-2-party-games-1\" class=\"anchor\" href=\"#h-2-party-games-1\"></a>2-party games</h1>\n<p>Imagine an n-step, 2-party protocol where players take turns making their \u201cmove\u201d (for example, a fraud proof).\nSuch games can be represented as a sequence of <span class=\"math\">2n</span> transactions that update the \u201cstate\u201d of the contract:</p>\n<ul>\n<li><span class=\"math\">s_1 = f_0(s_0, x_0)</span></li>\n<li><span class=\"math\">s_2 = f_1(s_1, x_1)</span></li>\n<li>\u2026</li>\n<li><span class=\"math\">s_{2n} = f_{2n-1}(s_{2n-1}, x_{n-1})</span></li>\n</ul>\n<p>where the state of the final transaction would be used to decide a winner.</p>\n<p>That is, each step is revealing the current player\u2019s next move (where Alice plays all the even <span class=\"math\">f_{2i}</span> moves, and Bob all the odd <span class=\"math\">f_{2i+1}</span> ones). The protocol verifies that the given input <span class=\"math\">x_i</span> is valid according to the rules, and the state is updated correctly.</p>\n<h2><a name=\"direct-implementation-2\" class=\"anchor\" href=\"#direct-implementation-2\"></a>Direct implementation</h2>\n<p>Such protocols can be easily implemented with MATT contracts as a chain of UTXOs; each UTXO would contain a commitment to the current state <span class=\"math\">s_i</span> (and is already programmed with the function <span class=\"math\">f_i</span>); the witness would be given the state <span class=\"math\">s_i</span> (all the content, not just the commitment!), and the player\u2019s move <span class=\"math\">x_i</span>; the script would then verify that <span class=\"math\">x_i</span> is valid, and compute the commitment to the next state <span class=\"math\">s_{i+1}</span>. Therefore, the witness would contain:</p>\n<ul>\n<li>the entire state <span class=\"math\">s_i</span></li>\n<li>the content of <span class=\"math\">x_i</span></li>\n<li>the control block, and a script with size proportional to the complexity of <span class=\"math\">f_i</span></li>\n</ul>\n<p>That\u2019s quite a bit of overhead if compared with just the size of <span class=\"math\">x_i</span>, which is the only new information revealed in a step of the protocol.</p>\n<h2><a name=\"games-in-the-head-3\" class=\"anchor\" href=\"#games-in-the-head-3\"></a>Games in the head</h2>\n<p>We can do better: the idea is to <em>not</em> check the current player\u2019s move at all. The move becomes just \"I declare that my move is <span class=\"math\">x_i</span>, and the hash of the next state is <span class=\"math\">H(s_{i+1})</span>. The output of the UTXO commits to the previous state <span class=\"math\">s_i</span>, the input <span class=\"math\">x_i</span>, and the new state <span class=\"math\">s_{i+1}</span>. If the current player did the move incorrectly, then on the next move, the other player can immediately prove that and win the game!</p>\n<p>More formally, define the initial state-in-the-head <span class=\"math\">h_0 = H(s_0)</span> (where <span class=\"math\">H</span> is a hash function, or any other constant-size commitment). Then, at each step, the next state-in-the-head (stored in the UTXO) is computed as:</p>\n<p><span class=\"math\">h_{i+1} = H((h_i || H(x_i)) || H(s_{i+1}))</span></p>\n<p>If a move is executed incorrectly (that is, either <span class=\"math\">x_i</span> is invalid or it\u2019s not true that <span class=\"math\">f(s_i, x_i) = s_{i+1}</span>, then the other player can prove it by opening the commitment <span class=\"math\">h_{i+1}</span> on its next move (that is, proving that the computation <span class=\"math\">f_{i+1}</span> was incorrectly executed), immediately winning the game.</p>\n<p>Otherwise, each moves just amounts to revealing <span class=\"math\">h_i</span> (a hash), <span class=\"math\">x_i</span>, and <span class=\"math\">H(s_{i+1})</span>. All the Script does is to compute <span class=\"math\">h_{i+1}</span> (a tiny Script!) and make sure that it\u2019s committed to in the next output. Therefore, the overhead amounts to just two hashes (other than the usual 65 bytes taproot control block, and other fixed transaction costs).</p>\n<h2><a name=\"conclusions-4\" class=\"anchor\" href=\"#conclusions-4\"></a>Conclusions</h2>\n<p>Playing games in the head allows each transaction of the protocol to have size <span class=\"math\">|x_i| + O(1)</span>, independently from the complexity of the state transitions <span class=\"math\">f_i</span>, and the size of <span class=\"math\">s_i</span>.</p>\n<p>The increase in code complexity is moderate, while it can bring noticeable savings in the total transaction size.</p>\n<p>This could be generalized to some <span class=\"math\">k</span>-party games.</p>\n<h1><a name=\"application-to-fraud-proofs-5\" class=\"anchor\" href=\"#application-to-fraud-proofs-5\"></a>Application to fraud proofs</h1>\n<p>While fraud proofs are never expected on-chain, the total cost of a fraud proof (vbytes needed, times the fee rate) should be roughly proportional to the size of the <em>bond</em>, that is, the amount that a wannabe-cheater will lose at the end of the game.</p>\n<p>How large is this cost?</p>\n<h2><a name=\"direct-implementation-6\" class=\"anchor\" href=\"#direct-implementation-6\"></a>Direct implementation</h2>\n<p>I implemented the raw version of the bisection protocol in <a href=\"https://github.com/Merkleize/pymatt\" rel=\"noopener nofollow ugc\">pymatt</a>, the Python framework I\u2019m working on:</p>\n<ul>\n<li>Fraud proof <a href=\"https://github.com/Merkleize/pymatt/blob/bc374a805cfa065179281202a774441100c6e253/matt/hub/fraud.py\" rel=\"noopener nofollow ugc\">contracts</a></li>\n<li><a href=\"https://github.com/Merkleize/pymatt/blob/bc374a805cfa065179281202a774441100c6e253/tests/test_fraud.py\" rel=\"noopener nofollow ugc\">Pytest demo</a> of the <a href=\"https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-November/021205.html\" rel=\"noopener nofollow ugc\">256-game toy example</a></li>\n<li><a href=\"https://gist.github.com/bigspider/82394963f74b4151b453778fa143e8a9\" rel=\"noopener nofollow ugc\">Example transactions</a> from the above pytest demo</li>\n</ul>\n<p>The size of each bisection step (Alice + Bob transactions) is around 500 vbytes.\nTaking <span class=\"math\">2^{32}</span> steps as a plausible upper bound for the number of computational steps one could ever need, that would lead to around 32*500 = 16000 vbytes over 65 transactions.</p>\n<p>Note that this cost is independent from <em>what</em> computation is performed, so it could for example be composed with the work that Johan\u2019s work on <a href=\"https://delvingbitcoin.org/t/verification-of-risc-v-execution-using-op-ccv/313\">elftrace</a> towards fraud proofs for a a Risc-V VM without any substantial impact on the cost estimates (as only the Script in the leaves is different for different computations).</p>\n<h2><a name=\"bisection-in-the-head-7\" class=\"anchor\" href=\"#bisection-in-the-head-7\"></a>Bisection in the head</h2>\n<p>Applying the game-in-the-head approach to the bisection protocol, some napkin math makes me estimate a total worst case cost, for <span class=\"math\">2^{32}</span> operations, around 14000 vbytes.</p>\n<p>A modest saving. That\u2019s because the saving does not affect the fixed per-transaction costs, that were already the dominant cost.</p>\n<h2><a name=\"further-optimizations-8\" class=\"anchor\" href=\"#further-optimizations-8\"></a>Further optimizations</h2>\n<p>Improving this further requires reducing the total number of transactions. That has the added benefit of a smaller number of rounds, which is highly beneficial in practical protocols.</p>\n<p>The key observation is that we can generalize the bisection protocol to a <span class=\"math\">k</span>-section protocol, building a <span class=\"math\">k</span>-ary Merkle tree instead of a binary tree of the computation trace. The number of <span class=\"math\">k</span>-section rounds for <span class=\"math\">N</span> steps is <span class=\"math\">\\log_k N</span>.</p>\n<p>The complexity of the <span class=\"math\">f_i</span> increases linearly in <span class=\"math\">k</span>, but thanks to the game-in-the-head approach, this cost is not paid on-chain (or it\u2019s paid at most once).</p>\n<p>I did not yet implement this, but from some napkin math, I expect the total cost for <span class=\"math\">k = 16</span> and <span class=\"math\">N = 2^{32}</span> to be around 7000 vbytes, and since <span class=\"math\">log_{16} N = 8</span>, a total of 17 transactions for the complete fraud proof.</p>\n<h2><a name=\"round-efficient-fraud-proofs-in-pools-9\" class=\"anchor\" href=\"#round-efficient-fraud-proofs-in-pools-9\"></a>Round-efficient fraud proofs in pools</h2>\n<p>I\u2019m particularly interested in the applications to fraud proofs in pool-like constructions, for example for <a href=\"https://delvingbitcoin.org/t/aggregate-delegated-exit-for-l2-pools/297\">affordable exit strategies</a>.</p>\n<p>For a pool of up to 256 users, I estimated that <span class=\"math\">k = 16</span> would bring the total cost below 2000 vbytes (compared to &gt;4000 vbytes of the unoptimized bisection).</p>\n<p>Most importantly: in this version <em><strong>a fraud proof requires just 5 transactions, instead of the initial 17</strong></em>. Only 2 of them are made by the attacker (who might purposedly delay its response as much as possible), contrary to 8 in the unoptimized protocol.</p>\n<p>7 transactions would support fraud proofs for pools up to 4096 users.</p>\n<p>The reduction in the number of rounds would likely be of high practical value, especially when these pool constructions are composed with the Lightning Network (see the \u201cprotocol uplifting\u201d of <a href=\"https://coinpool.dev/\" rel=\"noopener nofollow ugc\">CoinPool</a>).</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2024-01-20T17:00:20.236Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 45,
  "reads": 12,
  "readers_count": 11,
  "score": 227.4,
  "yours": false,
  "topic_id": 446,
  "topic_slug": "games-in-the-head-and-fraud-proofs-for-the-plebs",
  "topic_title": "Games in the head (and fraud proofs for the plebs)",
  "topic_html_title": "Games in the head (and fraud proofs for the plebs)",
  "category_id": 7,
  "display_username": "salvatoshi",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 3,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "While thinking about how to optimize fraud proofs implemented using MATT contracts, I came up with a quite neat approach that applies more generally to any multiple-round, 2-party game. The idea is very simple, so I wouldn't be surprised if it's not really novel, and would appreciate any literature reference.\n\n**TL;DR:** any two party game played in a MATT contract, with arbitrarily complex game rules, can be turned into a protocol where the data overhead of each move is only about 2 hashes.\n\n**TL;DR2:** it's possible to implement fully general fraud proofs that with an estimated cost of around 7000 vbytes and 17 total transactions. Fraud proofs applied to CoinPools of 256 user should cost 2000 vbytes and only 5 transactions.\n\n# 2-party games\n\nImagine an n-step, 2-party protocol where players take turns making their \"move\" (for example, a fraud proof).\nSuch games can be represented as a sequence of $2n$ transactions that update the \"state\" of the contract:\n\n- $s_1 = f_0(s_0, x_0)$\n- $s_2 = f_1(s_1, x_1)$\n- ...\n- $s_{2n} = f_{2n-1}(s_{2n-1}, x_{n-1})$\n\nwhere the state of the final transaction would be used to decide a winner.\n\nThat is, each step is revealing the current player's next move (where Alice plays all the even $f_{2i}$ moves, and Bob all the odd $f_{2i+1}$ ones). The protocol verifies that the given input $x_i$ is valid according to the rules, and the state is updated correctly.\n\n## Direct implementation\n\nSuch protocols can be easily implemented with MATT contracts as a chain of UTXOs; each UTXO would contain a commitment to the current state $s_i$ (and is already programmed with the function $f_i$); the witness would be given the state $s_i$ (all the content, not just the commitment!), and the player's move $x_i$; the script would then verify that $x_i$ is valid, and compute the commitment to the next state $s_{i+1}$. Therefore, the witness would contain:\n\n- the entire state $s_i$\n- the content of $x_i$\n- the control block, and a script with size proportional to the complexity of $f_i$\n\nThat's quite a bit of overhead if compared with just the size of $x_i$, which is the only new information revealed in a step of the protocol.\n\n## Games in the head\n\nWe can do better: the idea is to _not_ check the current player's move at all. The move becomes just \"I declare that my move is $x_i$, and the hash of the next state is $H(s_{i+1})$. The output of the UTXO commits to the previous state $s_i$, the input $x_i$, and the new state $s_{i+1}$. If the current player did the move incorrectly, then on the next move, the other player can immediately prove that and win the game!\n\nMore formally, define the initial state-in-the-head $h_0 = H(s_0)$ (where $H$ is a hash function, or any other constant-size commitment). Then, at each step, the next state-in-the-head (stored in the UTXO) is computed as:\n\n$h_{i+1} = H((h_i || H(x_i)) || H(s_{i+1}))$\n\nIf a move is executed incorrectly (that is, either $x_i$ is invalid or it's not true that $f(s_i, x_i) = s_{i+1}$, then the other player can prove it by opening the commitment $h_{i+1}$ on its next move (that is, proving that the computation $f_{i+1}$ was incorrectly executed), immediately winning the game.\n\nOtherwise, each moves just amounts to revealing $h_i$ (a hash), $x_i$, and $H(s_{i+1})$. All the Script does is to compute $h_{i+1}$ (a tiny Script!) and make sure that it's committed to in the next output. Therefore, the overhead amounts to just two hashes (other than the usual 65 bytes taproot control block, and other fixed transaction costs).\n\n## Conclusions\n\nPlaying games in the head allows each transaction of the protocol to have size $|x_i| + O(1)$, independently from the complexity of the state transitions $f_i$, and the size of $s_i$.\n\nThe increase in code complexity is moderate, while it can bring noticeable savings in the total transaction size.\n\nThis could be generalized to some $k$-party games.\n\n# Application to fraud proofs\n\nWhile fraud proofs are never expected on-chain, the total cost of a fraud proof (vbytes needed, times the fee rate) should be roughly proportional to the size of the *bond*, that is, the amount that a wannabe-cheater will lose at the end of the game.\n\nHow large is this cost?\n\n## Direct implementation\nI implemented the raw version of the bisection protocol in [pymatt](https://github.com/Merkleize/pymatt), the Python framework I'm working on:\n- Fraud proof [contracts](https://github.com/Merkleize/pymatt/blob/bc374a805cfa065179281202a774441100c6e253/matt/hub/fraud.py)\n- [Pytest demo](https://github.com/Merkleize/pymatt/blob/bc374a805cfa065179281202a774441100c6e253/tests/test_fraud.py) of the [256-game toy example](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-November/021205.html)\n- [Example transactions](https://gist.github.com/bigspider/82394963f74b4151b453778fa143e8a9) from the above pytest demo\n\nThe size of each bisection step (Alice + Bob transactions) is around 500 vbytes.\nTaking $2^{32}$ steps as a plausible upper bound for the number of computational steps one could ever need, that would lead to around 32*500 = 16000 vbytes over 65 transactions.\n\nNote that this cost is independent from *what* computation is performed, so it could for example be composed with the work that Johan's work on [elftrace](https://delvingbitcoin.org/t/verification-of-risc-v-execution-using-op-ccv/313) towards fraud proofs for a a Risc-V VM without any substantial impact on the cost estimates (as only the Script in the leaves is different for different computations).\n\n## Bisection in the head\n\nApplying the game-in-the-head approach to the bisection protocol, some napkin math makes me estimate a total worst case cost, for $2^{32}$ operations, around 14000 vbytes. \n\nA modest saving. That's because the saving does not affect the fixed per-transaction costs, that were already the dominant cost.\n\n## Further optimizations\n\nImproving this further requires reducing the total number of transactions. That has the added benefit of a smaller number of rounds, which is highly beneficial in practical protocols.\n\nThe key observation is that we can generalize the bisection protocol to a $k$-section protocol, building a $k$-ary Merkle tree instead of a binary tree of the computation trace. The number of $k$-section rounds for $N$ steps is $\\log_k N$.\n\nThe complexity of the $f_i$ increases linearly in $k$, but thanks to the game-in-the-head approach, this cost is not paid on-chain (or it's paid at most once).\n\nI did not yet implement this, but from some napkin math, I expect the total cost for $k = 16$ and $N = 2^{32}$ to be around 7000 vbytes, and since $log_{16} N = 8$, a total of 17 transactions for the complete fraud proof.\n\n## Round-efficient fraud proofs in pools\n\nI'm particularly interested in the applications to fraud proofs in pool-like constructions, for example for [affordable exit strategies](https://delvingbitcoin.org/t/aggregate-delegated-exit-for-l2-pools/297).\n\nFor a pool of up to 256 users, I estimated that $k = 16$ would bring the total cost below 2000 vbytes (compared to >4000 vbytes of the unoptimized bisection).\n\nMost importantly: in this version ***a fraud proof requires just 5 transactions, instead of the initial 17***. Only 2 of them are made by the attacker (who might purposedly delay its response as much as possible), contrary to 8 in the unoptimized protocol.\n\n7 transactions would support fraud proofs for pools up to 4096 users.\n\nThe reduction in the number of rounds would likely be of high practical value, especially when these pool constructions are composed with the Lightning Network (see the \"protocol uplifting\" of [CoinPool](https://coinpool.dev/)).",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 81,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "thinking",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}