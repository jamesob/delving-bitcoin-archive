{
  "id": 1321,
  "name": "Gloria Zhao",
  "username": "glozow",
  "avatar_template": "/user_avatar/delvingbitcoin.org/glozow/{size}/261_2.png",
  "created_at": "2024-01-24T14:28:56.454Z",
  "cooked": "<p>When we receive a transaction that would bust a mempool transaction\u2019s descendant limits, we usually reject it (unless it is eligible for CPFP carve out).</p>\n<p>An alternative approach (e.g. when this transaction is very high feerate and it\u2019d be a shame to let it go) is to consider evicting the least incentive compatible descendant in favor of this new transaction. That way we don\u2019t compromise on our anti-DoS-motivated descendant limit (like we do with CPFP carve out), but don\u2019t need to be stuck with the one we received earlier.</p>\n<p>Ephemeral Anchors emulates sibling eviction by having a \u201cmust spend\u201d anchor to basically force all children to conflict with each other (general idea credit to instagibbs who suggested this at that LN meeting in 2022).</p>\n<p>A few concerns then were:\n(1) This is full-rbf-y (what if the sibling didn\u2019t signal RBF? What if wallets aren\u2019t expecting any possible replacements?)\n(2) It\u2019s very complex to choose which descendant(s) to evict. There are many possible combinations especially if the problem is that we hit the descendant vsize limit. This transaction might also have multiple ancestors. Short of cluster mempool / feerate diagram tools, this problem seemed intractable.\n(3) Is this incentive compatible?</p>\n<p>Problems (1) and (2) are easy to fix with v3. V3 transactions all signal replaceability, so the \u201cfull-rbf-iness\u201d shouldn\u2019t be a concern. And (2) is trivial in v3, since there is only 1 possible descendant and this child cannot have multiple ancestors (credit to sdaftuar for pointing this out to me, leading me to try to implement it).</p>\n<p>One way of looking at (3) is that if we had just received these two descendants in the opposite order, we would have kept the other one. With the framework that our descendant limit is the maximum we can handle before we have DoS and pinning problems, we should just be trying to get the most incentive compatible set of transactions that fits in that limit.</p>\n<p>An implementation: <a href=\"https://github.com/bitcoin/bitcoin/pull/29306\" class=\"inline-onebox\">policy: enable sibling eviction for v3 transactions by glozow \u00b7 Pull Request #29306 \u00b7 bitcoin/bitcoin \u00b7 GitHub</a></p>\n<p>We apply the RBF rules to these sibling evictions, not just because we get to reuse all the code, but because there are similar requirements wrt incentive compatibility increase and limiting the bandwidth/validation cost. For example, we don\u2019t want to allow 2 siblings to evict each other over and over again with 1 additional sat each time.</p>\n<h3><a name=\"benefits-1\" class=\"anchor\" href=\"#benefits-1\"></a>Benefits:</h3>\n<p>(1) We can easily do the imbued v3 logic for existing LN commitment transactions, even though they have 2 anchors.</p>\n<p>There was a <a href=\"https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418/2\">suggestion</a> to pattern-match LN commitment transactions and automatically enroll them under the v3 policy rules if it takes a while for LN to switch to using v3.</p>\n<p>One obstacle is the fact that, currently, commitment transactions have two anchors, while v3 only supports a 1-parent-1-child topology. What about implementations that try to bump remote transactions in mempool? Even if everyone stops doing that, what if your remote broadcasts and spends your tx with a low-feerate child (thus blocking you from bumping yours)?</p>\n<p>With sibling eviction, local and remote\u2019s CPFPs (each no more than 1000vB) can evict each other. We wouldn\u2019t need to roll a new 1p2c or v3+carveout topology.</p>\n<p>(2) It makes v3 work nicely for transactions shared between n&gt;2 parties who might want to CPFP without a dedicated anchor. Imagine e.g. a v3 coinjoin - if somebody wants to CPFP, they can do so using their output, evicting somebody else\u2019s child if they lowballed their bump.</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2024-01-24T14:31:36.227Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 2,
  "reads": 4,
  "readers_count": 3,
  "score": 10.8,
  "yours": false,
  "topic_id": 472,
  "topic_slug": "sibling-eviction-for-v3-transactions",
  "topic_title": "Sibling Eviction for v3 transactions",
  "topic_html_title": "Sibling Eviction for v3 transactions",
  "category_id": 8,
  "display_username": "Gloria Zhao",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": "",
  "bookmarked": false,
  "raw": "When we receive a transaction that would bust a mempool transaction's descendant limits, we usually reject it (unless it is eligible for CPFP carve out).\n\nAn alternative approach (e.g. when this transaction is very high feerate and it'd be a shame to let it go) is to consider evicting the least incentive compatible descendant in favor of this new transaction. That way we don't compromise on our anti-DoS-motivated descendant limit (like we do with CPFP carve out), but don't need to be stuck with the one we received earlier.\n\nEphemeral Anchors emulates sibling eviction by having a \"must spend\" anchor to basically force all children to conflict with each other (general idea credit to instagibbs who suggested this at that LN meeting in 2022).\n\nA few concerns then were:\n(1) This is full-rbf-y (what if the sibling didn't signal RBF? What if wallets aren't expecting any possible replacements?)\n(2) It's very complex to choose which descendant(s) to evict. There are many possible combinations especially if the problem is that we hit the descendant vsize limit. This transaction might also have multiple ancestors. Short of cluster mempool / feerate diagram tools, this problem seemed intractable.\n(3) Is this incentive compatible?\n\nProblems (1) and (2) are easy to fix with v3. V3 transactions all signal replaceability, so the \"full-rbf-iness\" shouldn't be a concern. And (2) is trivial in v3, since there is only 1 possible descendant and this child cannot have multiple ancestors (credit to sdaftuar for pointing this out to me, leading me to try to implement it).\n\nOne way of looking at (3) is that if we had just received these two descendants in the opposite order, we would have kept the other one. With the framework that our descendant limit is the maximum we can handle before we have DoS and pinning problems, we should just be trying to get the most incentive compatible set of transactions that fits in that limit.\n\nAn implementation: https://github.com/bitcoin/bitcoin/pull/29306\n\nWe apply the RBF rules to these sibling evictions, not just because we get to reuse all the code, but because there are similar requirements wrt incentive compatibility increase and limiting the bandwidth/validation cost. For example, we don't want to allow 2 siblings to evict each other over and over again with 1 additional sat each time.\n\n### Benefits:\n\n(1) We can easily do the imbued v3 logic for existing LN commitment transactions, even though they have 2 anchors.\n\nThere was a [suggestion](https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418/2?u=glozow) to pattern-match LN commitment transactions and automatically enroll them under the v3 policy rules if it takes a while for LN to switch to using v3.\n\nOne obstacle is the fact that, currently, commitment transactions have two anchors, while v3 only supports a 1-parent-1-child topology. What about implementations that try to bump remote transactions in mempool? Even if everyone stops doing that, what if your remote broadcasts and spends your tx with a low-feerate child (thus blocking you from bumping yours)?\n\nWith sibling eviction, local and remote's CPFPs (each no more than 1000vB) can evict each other. We wouldn't need to roll a new 1p2c or v3+carveout topology.\n\n(2) It makes v3 work nicely for transactions shared between n>2 parties who might want to CPFP without a dedicated anchor. Imagine e.g. a v3 coinjoin - if somebody wants to CPFP, they can do so using their output, evicting somebody else's child if they lowballed their bump.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 7,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}