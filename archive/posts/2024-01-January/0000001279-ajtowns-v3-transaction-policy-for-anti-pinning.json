{
  "id": 1279,
  "name": "Anthony Towns",
  "username": "ajtowns",
  "avatar_template": "/user_avatar/delvingbitcoin.org/ajtowns/{size}/3_2.png",
  "created_at": "2024-01-22T10:53:08.317Z",
  "cooked": "<p>In my head, the idea here is that opting into v3 is a collaboration between (some) node operators and transaction creators to ignore potentially valid transactions in order to more readily relay high feerate alternatives.</p>\n<p>So currently you might see txs:</p>\n<ul>\n<li><img src=\"https://delvingbitcoin.org/images/emoji/twitter/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"> P = small parent, low feerate</li>\n<li><img src=\"https://delvingbitcoin.org/images/emoji/twitter/white_check_mark.png?v=12\" title=\":white_check_mark:\" class=\"emoji\" alt=\":white_check_mark:\" loading=\"lazy\" width=\"20\" height=\"20\"> C1 = huge child, low feerate, high fee</li>\n<li><img src=\"https://delvingbitcoin.org/images/emoji/twitter/x.png?v=12\" title=\":x:\" class=\"emoji\" alt=\":x:\" loading=\"lazy\" width=\"20\" height=\"20\"> C2 = small child, high feerate, modest fee, conflicts with C1</li>\n</ul>\n<p>and end up with P and C1 stuck in your mempool and refuse to accept or relay C2, even though due to its high fee, it might well even be included in the next block. That remains a reasonable decision by individual nodes, as simply replacing C1 by C2 would make nodes vulnerable to relay spam: broadcast many C1\u2019s with lots of data, get that distributed across the network for free, then replace those txs with C2\u2019s, making sure that you\u2019re only actually paying a small amount in fees for all that relay spam. This is known as the \u201cfree relay\u201d problem.</p>\n<p>The workaround that v3 makes available is simply that C1 is now rejected in the first place in many cases. This prevents free relay (C1 isn\u2019t relayed at all), and solves the incentive compatibility problem where a tx that would be acceptable in the next block (C2) isn\u2019t relayed at all.</p>\n<p>This works okay even if only adopted by a proportion of the network: C2 is still able to propagate over the subgraph of nodes that implement this policy eventually reach miners that run a policy compatible with this policy, who will eventually mine it.</p>\n<p>It is in no way a perfect solution to pinning \u2013 some systems will be designed in a way that a large child is sometimes necessary and those systems won\u2019t be able to opt-in to v3 rules. Also, even relatively small children can create a fee amount/rate pin, and there are other pinning vectors than high-fee/low-feerate. That\u2019s fine: making things incrementally better for some people is still making things better.</p>\n<p>The limitations with v3 are quite annoying: one ancestor / one descendant means you can only have a pair of related v3 txs in the mempool, and nothing more complicated. In particular you can\u2019t do batch CPFP where a single v3 child pays for a bunch of v3 parents. But again, slightly better is still better, and relaxing policy rules if we figure out better ways of doing things is less problematic than restricting policy rules.</p>\n<p>With just the v3 constraints, I think you\u2019d want to design your protocol such that either parent transactions only have a single output that\u2019s spendable immediately \u2013 that way any CPFP spends will naturally conflict with each other and RBF rules will apply, and the size limits applying to the child tx will limit the maximum fees those children will need to pay. However if there are multiple immediately spendable outputs that all have an n-of-n multisig arrangement, and all the txs that spend those outputs spend some common output, that could work as well. That approach seems unlikely to be useful in practice though?</p>\n<p>When you add the ephemeral anchor rule, in particular that the EA output must be spent for the tx that creates the EA output to remain in the mempool, it becomes okay to allow other outputs to be immediately spendable: each child must spend the EA output, so they must conflict with each other, and RBF rules are applied. That seems to me like a significant bonus in flexibility \u2013 allowing lightning commitment tx balance outputs to be spent unilaterally by the same tx that spends the EA output, which I think would be problematic otherwise.</p>",
  "post_number": 33,
  "post_type": 1,
  "updated_at": "2024-01-22T10:53:08.317Z",
  "reply_count": 1,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 14,
  "readers_count": 13,
  "score": 37.8,
  "yours": false,
  "topic_id": 340,
  "topic_slug": "v3-transaction-policy-for-anti-pinning",
  "topic_title": "V3 transaction policy for anti-pinning",
  "topic_html_title": "V3 transaction policy for anti-pinning",
  "category_id": 7,
  "display_username": "Anthony Towns",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "In my head, the idea here is that opting into v3 is a collaboration between (some) node operators and transaction creators to ignore potentially valid transactions in order to more readily relay high feerate alternatives.\n\nSo currently you might see txs:\n\n * :white_check_mark: P = small parent, low feerate\n * :white_check_mark: C1 = huge child, low feerate, high fee\n * :x: C2 = small child, high feerate, modest fee, conflicts with C1\n\nand end up with P and C1 stuck in your mempool and refuse to accept or relay C2, even though due to its high fee, it might well even be included in the next block. That remains a reasonable decision by individual nodes, as simply replacing C1 by C2 would make nodes vulnerable to relay spam: broadcast many C1's with lots of data, get that distributed across the network for free, then replace those txs with C2's, making sure that you're only actually paying a small amount in fees for all that relay spam. This is known as the \"free relay\" problem.\n\nThe workaround that v3 makes available is simply that C1 is now rejected in the first place in many cases. This prevents free relay (C1 isn't relayed at all), and solves the incentive compatibility problem where a tx that would be acceptable in the next block (C2) isn't relayed at all.\n\nThis works okay even if only adopted by a proportion of the network: C2 is still able to propagate over the subgraph of nodes that implement this policy eventually reach miners that run a policy compatible with this policy, who will eventually mine it.\n\nIt is in no way a perfect solution to pinning -- some systems will be designed in a way that a large child is sometimes necessary and those systems won't be able to opt-in to v3 rules. Also, even relatively small children can create a fee amount/rate pin, and there are other pinning vectors than high-fee/low-feerate. That's fine: making things incrementally better for some people is still making things better.\n\nThe limitations with v3 are quite annoying: one ancestor / one descendant means you can only have a pair of related v3 txs in the mempool, and nothing more complicated. In particular you can't do batch CPFP where a single v3 child pays for a bunch of v3 parents. But again, slightly better is still better, and relaxing policy rules if we figure out better ways of doing things is less problematic than restricting policy rules.\n\nWith just the v3 constraints, I think you'd want to design your protocol such that either parent transactions only have a single output that's spendable immediately -- that way any CPFP spends will naturally conflict with each other and RBF rules will apply, and the size limits applying to the child tx will limit the maximum fees those children will need to pay. However if there are multiple immediately spendable outputs that all have an n-of-n multisig arrangement, and all the txs that spend those outputs spend some common output, that could work as well. That approach seems unlikely to be useful in practice though?\n\nWhen you add the ephemeral anchor rule, in particular that the EA output must be spent for the tx that creates the EA output to remain in the mempool, it becomes okay to allow other outputs to be immediately spendable: each child must spend the EA output, so they must conflict with each other, and RBF rules are applied. That seems to me like a significant bonus in flexibility -- allowing lightning commitment tx balance outputs to be spent unilaterally by the same tx that spends the EA output, which I think would be problematic otherwise.",
  "actions_summary": [
    {
      "id": 2,
      "count": 2
    }
  ],
  "moderator": true,
  "admin": true,
  "staff": true,
  "user_id": 3,
  "hidden": false,
  "trust_level": 4,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 2
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 2,
  "current_user_used_main_reaction": false
}