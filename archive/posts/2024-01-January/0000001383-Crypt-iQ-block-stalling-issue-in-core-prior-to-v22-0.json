{
  "id": 1383,
  "name": "Eugene",
  "username": "Crypt-iQ",
  "avatar_template": "/user_avatar/delvingbitcoin.org/crypt-iq/{size}/306_2.png",
  "created_at": "2024-01-30T16:51:22.864Z",
  "cooked": "<p>In May 2021, I reported a block-stalling issue to the Bitcoin Core security email. Master at the\ntime of writing was <code>6b254814c076054eedc4311698d16c8971937814</code>. While the majority of the network has upgraded to at least v22.0, there are still a few thousand stragglers so hopefully this disclosure will motivate those running lightning nodes to upgrade to a safer version. Additionally, I think it\u2019s informative to let the broader community know about historical attacks on lightning.</p>\n<h2><a name=\"background-1\" class=\"anchor\" href=\"#background-1\"></a>Background</h2>\n<p>Some background on bitcoind (circa May 2021):</p>\n<ul>\n<li>bitcoind selects three of its peers to relay compact blocks to it. A peer is chosen if it is the first\nto relay a non-compact block. An attacker was able to replace the victim\u2019s three compact-block slots\nwith attacker-controlled peers by providing blocks before the honest nodes could. This logic was in the\n<a href=\"https://github.com/bitcoin/bitcoin/blob/6b254814c076054eedc4311698d16c8971937814/src/net_processing.cpp#L818\" rel=\"noopener nofollow ugc\">PeerManagerImpl::MaybeSetPeerAsAnnouncingHeaderAndIDs</a>\nfunction.</li>\n<li>When bitcoind requests a block, an entry is added to <code>mapBlocksInFlight</code> and the relevant node has 10\nor more minutes to reply with the requested block: <a href=\"https://github.com/bitcoin/bitcoin/blob/6b254814c076054eedc4311698d16c8971937814/src/net_processing.cpp#L4715\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">bitcoin/src/net_processing.cpp at 6b254814c076054eedc4311698d16c8971937814 \u00b7 bitcoin/bitcoin \u00b7 GitHub</a></li>\n<li>bitcoind will evict peers via the <code>AttemptToEvictConnection</code> logic. If this function is called during\nthe attack, it will make it harder to pull off. However, the attacker may be able to counteract this by\nsimply adding more connections in the setup phase.</li>\n</ul>\n<h2><a name=\"the-attack-2\" class=\"anchor\" href=\"#the-attack-2\"></a>The Attack</h2>\n<p>The attacker performs the following steps:</p>\n<ul>\n<li>Replace victim node\u2019s compact block connections by providing blocks before the honest connections can.\nThe attacker should then have 3 compact block connections with the victim.</li>\n<li>Connect to the victim node with N different connections. If the CLTV delta is 40, then let N be 50. These\nconnections should be sequential in the connection manager\u2019s <code>vNodes</code> vector.</li>\n<li>When a new block is mined, the first connection of the N races with the victim\u2019s honest connections to\nannounce via headers-first announcement. If successful, the victim should add an entry to <code>mapBlocksInFlight</code>\nfor this connection. The connection then has a lower bound of 10 minutes to announce the block via a\n<code>NetMsgType::BLOCK</code> message.</li>\n<li>The 3 attacker-controlled compact block connections do not announce the block via compact block.</li>\n<li>The other N-1 connections can announce the block via headers-first relay, and they will not be selected to\ndownload the block from by the victim. This ensures that the victim later sees these connections as viable\nfor requesting the delayed block from.</li>\n<li>Just before the timeout for the first connection elapses (say at the 9m45s mark), the first connection sends\nan invalid <code>NetMsgType::BLOCK</code> which deletes the entry from <code>mapBlocksInFlight</code> via <code>MarkBlockAsReceived</code>. This\ncan be done by mutating the block without invalidating the hash for example. The first connection should get\ndisconnected due to the invalid block. I believe it\u2019s also possible to simply disconnect instead of sending\na mutated block, but I did not test this.</li>\n<li>At this point, the 3 attacker-controlled compact block connections can be replaced by honest ones. They don\u2019t\nmatter anymore. Stale blocks should not be announced via compact block connections unless explicitly requested.</li>\n<li>The connection manager will choose the next connection in <code>vNodes</code> and call <code>SendMessages</code> on it. Since the\nattacker has stacked up 49 more connections, this chosen connection should be attacker controlled.</li>\n<li><code>SendMessages</code> logic will select the chosen connection to request the delayed block via <code>FindNextBlocksToDownload</code>.</li>\n<li>Before the relay timer is activated at the 10-minute mark, the connection relays a bad <code>NetMsgType::BLOCK</code>, to\ndelete the entry from <code>mapBlocksInFlight</code>, and trigger the next connection in <code>vNodes</code> being selected to relay\nthe block.</li>\n<li>This process completes until all sequential attacker-controlled connections are used up.  This should result in\nrelay for this specific block being delayed for the time it takes to mine roughly 50 blocks.</li>\n</ul>\n<h2><a name=\"implications-for-ln-3\" class=\"anchor\" href=\"#implications-for-ln-3\"></a>Implications for LN</h2>\n<p>Let\u2019s assume the topology M1 \u2194 B \u2194 M2 where each node is using a CLTV delta of 40. M1 and M2 are both\nmalicious.</p>\n<ul>\n<li>M1 routes an HTLC through B to M2. It will time out on the B \u2194 M2 channel at t+40 and time out on the\nM1 \u2194 B channel at t+80.</li>\n<li>At t+38 (or earlier for higher chances of success), M1/M2 start delaying blocks to B\u2019s bitcoind node.</li>\n<li>M2 broadcasts a force close tx (if B hasn\u2019t already) and it confirms at, say, t+39.</li>\n<li>M2 broadcasts a tx that spends via the preimage-claim path and it confirms at t+40.\n<ul>\n<li>B can learn of the preimage by watching the mempool, but this doesn\u2019t help.</li>\n</ul>\n</li>\n<li>M1 force closes their channel at t+40. It confirms at t+41.</li>\n<li>At t+80, M1 relays the 2nd-level timeout claim tx. At t+81 it confirms.</li>\n<li>M1/M2 can stop delaying blocks as they have stolen the value of an HTLC.</li>\n</ul>\n<p>In this example with a CLTV delta of 40, the attacker needs to delay for the CLTV delta + X where X is small.\nA larger X value gives better chances of attack success. By default, bitcoind has an upper bound of 117\ninbound connections. Implementations may not be affected if the minimum allowable CLTV value is high.</p>\n<h2><a name=\"patch-4\" class=\"anchor\" href=\"#patch-4\"></a>Patch</h2>\n<p>This was fixed with two PR\u2019s that landed in 22.0:</p>\n<ul>\n<li>\n<p><a href=\"https://github.com/bitcoin/bitcoin/pull/22144\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">Randomize message processing peer order by sipa \u00b7 Pull Request #22144 \u00b7 bitcoin/bitcoin \u00b7 GitHub</a></p>\n<ul>\n<li>This randomized the message processing order and pretty much guarantees that an honest peer will be\nsandwiched in between two malicious block-delaying peers.</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://github.com/bitcoin/bitcoin/pull/22147\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">p2p: Protect last outbound HB compact block peer by sdaftuar \u00b7 Pull Request #22147 \u00b7 bitcoin/bitcoin \u00b7 GitHub</a></p>\n<ul>\n<li>This prevents the last outbound high-bandwidth compact-block relaying peer from being demoted by an\ninbound attacker.</li>\n</ul>\n</li>\n</ul>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2024-01-30T16:51:22.864Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 3,
  "reads": 18,
  "readers_count": 17,
  "score": 78.6,
  "yours": false,
  "topic_id": 499,
  "topic_slug": "block-stalling-issue-in-core-prior-to-v22-0",
  "topic_title": "Block-stalling issue in Core prior to v22.0",
  "topic_html_title": "Block-stalling issue in Core prior to v22.0",
  "category_id": 8,
  "display_username": "Eugene",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "In May 2021, I reported a block-stalling issue to the Bitcoin Core security email. Master at the\ntime of writing was `6b254814c076054eedc4311698d16c8971937814`. While the majority of the network has upgraded to at least v22.0, there are still a few thousand stragglers so hopefully this disclosure will motivate those running lightning nodes to upgrade to a safer version. Additionally, I think it's informative to let the broader community know about historical attacks on lightning.\n\n## Background ##\nSome background on bitcoind (circa May 2021):\n\n* bitcoind selects three of its peers to relay compact blocks to it. A peer is chosen if it is the first\n  to relay a non-compact block. An attacker was able to replace the victim's three compact-block slots\n  with attacker-controlled peers by providing blocks before the honest nodes could. This logic was in the\n  [PeerManagerImpl::MaybeSetPeerAsAnnouncingHeaderAndIDs](https://github.com/bitcoin/bitcoin/blob/6b254814c076054eedc4311698d16c8971937814/src/net_processing.cpp#L818)\n  function.\n* When bitcoind requests a block, an entry is added to `mapBlocksInFlight` and the relevant node has 10\n  or more minutes to reply with the requested block: https://github.com/bitcoin/bitcoin/blob/6b254814c076054eedc4311698d16c8971937814/src/net_processing.cpp#L4715\n* bitcoind will evict peers via the `AttemptToEvictConnection` logic. If this function is called during\n  the attack, it will make it harder to pull off. However, the attacker may be able to counteract this by\n  simply adding more connections in the setup phase.\n\n## The Attack ##\n\nThe attacker performs the following steps:\n* Replace victim node's compact block connections by providing blocks before the honest connections can.\n  The attacker should then have 3 compact block connections with the victim.\n* Connect to the victim node with N different connections. If the CLTV delta is 40, then let N be 50. These\n  connections should be sequential in the connection manager's `vNodes` vector.\n* When a new block is mined, the first connection of the N races with the victim's honest connections to\n  announce via headers-first announcement. If successful, the victim should add an entry to `mapBlocksInFlight`\n  for this connection. The connection then has a lower bound of 10 minutes to announce the block via a\n  `NetMsgType::BLOCK` message.\n* The 3 attacker-controlled compact block connections do not announce the block via compact block.\n* The other N-1 connections can announce the block via headers-first relay, and they will not be selected to\n  download the block from by the victim. This ensures that the victim later sees these connections as viable\n  for requesting the delayed block from.\n* Just before the timeout for the first connection elapses (say at the 9m45s mark), the first connection sends\n  an invalid `NetMsgType::BLOCK` which deletes the entry from `mapBlocksInFlight` via `MarkBlockAsReceived`. This\n  can be done by mutating the block without invalidating the hash for example. The first connection should get\n  disconnected due to the invalid block. I believe it's also possible to simply disconnect instead of sending\n  a mutated block, but I did not test this.\n* At this point, the 3 attacker-controlled compact block connections can be replaced by honest ones. They don't\n  matter anymore. Stale blocks should not be announced via compact block connections unless explicitly requested.\n* The connection manager will choose the next connection in `vNodes` and call `SendMessages` on it. Since the\n  attacker has stacked up 49 more connections, this chosen connection should be attacker controlled.\n* `SendMessages` logic will select the chosen connection to request the delayed block via `FindNextBlocksToDownload`.\n* Before the relay timer is activated at the 10-minute mark, the connection relays a bad `NetMsgType::BLOCK`, to\n  delete the entry from `mapBlocksInFlight`, and trigger the next connection in `vNodes` being selected to relay\n  the block.\n* This process completes until all sequential attacker-controlled connections are used up.  This should result in\n  relay for this specific block being delayed for the time it takes to mine roughly 50 blocks.\n\n## Implications for LN ##\n\nLet's assume the topology M1 <-> B <-> M2 where each node is using a CLTV delta of 40. M1 and M2 are both\nmalicious.\n\n* M1 routes an HTLC through B to M2. It will time out on the B <-> M2 channel at t+40 and time out on the\n  M1 <-> B channel at t+80.\n* At t+38 (or earlier for higher chances of success), M1/M2 start delaying blocks to B's bitcoind node.\n* M2 broadcasts a force close tx (if B hasn't already) and it confirms at, say, t+39.\n* M2 broadcasts a tx that spends via the preimage-claim path and it confirms at t+40.\n  * B can learn of the preimage by watching the mempool, but this doesn't help.\n* M1 force closes their channel at t+40. It confirms at t+41.\n* At t+80, M1 relays the 2nd-level timeout claim tx. At t+81 it confirms.\n* M1/M2 can stop delaying blocks as they have stolen the value of an HTLC.\n\nIn this example with a CLTV delta of 40, the attacker needs to delay for the CLTV delta + X where X is small.\nA larger X value gives better chances of attack success. By default, bitcoind has an upper bound of 117\ninbound connections. Implementations may not be affected if the minimum allowable CLTV value is high.\n\n## Patch ##\n\nThis was fixed with two PR's that landed in 22.0:\n* https://github.com/bitcoin/bitcoin/pull/22144\n  * This randomized the message processing order and pretty much guarantees that an honest peer will be\n    sandwiched in between two malicious block-delaying peers.\n\n* https://github.com/bitcoin/bitcoin/pull/22147\n  * This prevents the last outbound high-bandwidth compact-block relaying peer from being demoted by an\n    inbound attacker.",
  "actions_summary": [
    {
      "id": 2,
      "count": 4
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 253,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 4
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 4,
  "current_user_used_main_reaction": false
}