{
  "id": 1079,
  "name": "ProofOfKeags",
  "username": "ProofOfKeags",
  "avatar_template": "/user_avatar/delvingbitcoin.org/proofofkeags/{size}/156_2.png",
  "created_at": "2024-01-11T16:46:12.669Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"sipa\" data-post=\"8\" data-topic=\"397\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/sipa/48/102_2.png\" class=\"avatar\"> sipa:</div>\n<blockquote>\n<p>One possibility is having an <code>OP_ENABLE64BIT</code>, which has no effect on the stack when executed, but its presence in a script makes all arithmetic opcodes accept up to 8-byte inputs for example</p>\n</blockquote>\n</aside>\n<p>I\u2019m generally skeptical of increasing the surface area of the state variable of the script VM. I\u2019ll admit I don\u2019t know script backwards and forwards but all of my experience with it so far points me to the fact that the only thing opcodes operate over is the main and alt stacks as well as halting execution of the VM. As such it <em>seems</em> that the existing VM <em>can</em> be modeled by a state transition function:</p>\n<pre><code class=\"lang-auto\">exec_op : (MainStack, AltStack) -&gt; (MainStack, AltStack)\n</code></pre>\n<p>Doing something like <code>OP_ENABLE64BIT</code> would introduce some third <code>VMInterpreterState</code> and I think that will dramatically increase the surface area of potential consensus issues. Correct me if I\u2019m wrong but this would be a fundamentally new structural change to the VM formalism.</p>",
  "post_number": 10,
  "post_type": 1,
  "updated_at": "2024-01-11T16:46:12.669Z",
  "reply_count": 1,
  "reply_to_post_number": 8,
  "quote_count": 1,
  "incoming_link_count": 0,
  "reads": 10,
  "readers_count": 9,
  "score": 6.6,
  "yours": false,
  "topic_id": 397,
  "topic_slug": "64-bit-arithmetic-soft-fork",
  "topic_title": "64 bit arithmetic soft fork",
  "topic_html_title": "64 bit arithmetic soft fork",
  "category_id": 7,
  "display_username": "ProofOfKeags",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"sipa, post:8, topic:397\"]\nOne possibility is having an `OP_ENABLE64BIT`, which has no effect on the stack when executed, but its presence in a script makes all arithmetic opcodes accept up to 8-byte inputs for example\n[/quote]\n\nI'm generally skeptical of increasing the surface area of the state variable of the script VM. I'll admit I don't know script backwards and forwards but all of my experience with it so far points me to the fact that the only thing opcodes operate over is the main and alt stacks as well as halting execution of the VM. As such it *seems* that the existing VM *can* be modeled by a state transition function:\n\n```\nexec_op : (MainStack, AltStack) -> (MainStack, AltStack)\n```\n\nDoing something like `OP_ENABLE64BIT` would introduce some third `VMInterpreterState` and I think that will dramatically increase the surface area of potential consensus issues. Correct me if I'm wrong but this would be a fundamentally new structural change to the VM formalism.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 138,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}