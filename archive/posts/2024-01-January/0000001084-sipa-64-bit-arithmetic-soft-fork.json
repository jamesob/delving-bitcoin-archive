{
  "id": 1084,
  "name": "Pieter Wuille",
  "username": "sipa",
  "avatar_template": "/user_avatar/delvingbitcoin.org/sipa/{size}/102_2.png",
  "created_at": "2024-01-11T20:40:26.242Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"ajtowns\" data-post=\"13\" data-topic=\"397\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/ajtowns/48/3_2.png\" class=\"avatar\"> ajtowns:</div>\n<blockquote>\n<p>The semantics proposed here copy those from liquid/elements \u2013 that is maths opcodes like ADD and SUB tend to leave two two values to the stack, on the top, a boolean TRUE/FALSE indicating whether the operands were in range, and if they were, underneath that, the actual result of the operation. That\u2019s pretty different to the way bitcoin\u2019s existing operations work, so I\u2019m not sure modifying the existing opcodes to such a different new behaviour makes sense.</p>\n</blockquote>\n</aside>\n<p>I was suggesting not changing any semantics at all; only changing the acceptable range of inputs to existing opcodes. If <code>OP_MUL</code> or a variant thereof is added, I can see why detecting/dealing with overflows becomes an issue that the existing interface doesn\u2019t deal well with.</p>\n<p>If the different semantics are actually desirable, then I agree it shouldn\u2019t reuse the existing opcodes. Even if so, I don\u2019t see the benefit of introducing a different encoding.</p>\n<aside class=\"quote no-group\" data-username=\"Chris_Stewart_5\" data-post=\"9\" data-topic=\"397\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/letter_avatar_proxy/v4/letter/c/da6949/48.png\" class=\"avatar\"> Chris_Stewart_5:</div>\n<blockquote>\n<p>Simple rules like things like inputs are always 8 bytes in length (not variable) make it much easier to reason about. If you would prefer big endian to be used rather than little endian I can see the value if that - although little endian is used elsewhere in the protocol.</p>\n</blockquote>\n</aside>\n<p>Ok, I\u2019ll accept that the variable-length approach complicates things a bit, but I also think having two different encodings is even worse. All things being equal, I prefer little-endian over big-endian, but again, two encodings is worse than one.</p>\n<aside class=\"quote no-group\" data-username=\"Chris_Stewart_5\" data-post=\"9\" data-topic=\"397\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/letter_avatar_proxy/v4/letter/c/da6949/48.png\" class=\"avatar\"> Chris_Stewart_5:</div>\n<blockquote>\n<p>My understanding is the alternative implementation you are suggesting means modifying <code>CScriptNum</code> to support 64 bits.</p>\n</blockquote>\n</aside>\n<p>It\u2019s a wrapper around <code>int64_t</code> with serialization, deserialization, and arithmetic operations that assert on overflow. I think you\u2019d want to add overflow-detecting versions for your use, but otherwise it already does everything. I don\u2019t think there would be a need to touch any of the existing functions/operators on <code>CScriptNum</code>.</p>\n<p>There is a restriction on the input length when converting a Script stack element to a <code>CScriptNum</code>; my suggesting was to just relax that restriction from 4 bytes to 8 bytes when in 64-bit mode (whether that\u2019s through an <code>OP_SUCCESSx</code>, through a leaf version, or through a separate opcode). Note that <code>OP_CHECKLOCKTIMEVERIFY</code> also uses <code>CScriptNum</code>, but permits arguments up to 5 bytes rather than 4.</p>\n<aside class=\"quote no-group\" data-username=\"Chris_Stewart_5\" data-post=\"9\" data-topic=\"397\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/letter_avatar_proxy/v4/letter/c/da6949/48.png\" class=\"avatar\"> Chris_Stewart_5:</div>\n<blockquote>\n<p>IIUC - you do not have malleability concerns with this 8 byte proposal as 8 byte sizes would be required.</p>\n</blockquote>\n</aside>\n<p>Fair point. So far, I have seen few use cases for integer values that are script <em>inputs</em>, but if you envision that changing, that would be a point in favor of a strict encoding (that could still be minimally-encoded integers in a variable-length regine, which is effectively already a policy rule).</p>\n<aside class=\"quote no-group\" data-username=\"Chris_Stewart_5\" data-post=\"9\" data-topic=\"397\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/letter_avatar_proxy/v4/letter/c/da6949/48.png\" class=\"avatar\"> Chris_Stewart_5:</div>\n<blockquote>\n<p>Just to make sure we are talking about the same thing, by literals you mean <code>OP_1,OP_2..</code> etc right? I think this is a fair critique as \u2013 IIUC \u2013 now you would have to have <code>OP_1</code> and <code>OP_1_64</code> or something like that I believe?</p>\n</blockquote>\n</aside>\n<p>Yeah, the <code>OP_n</code> opcodes, plus direct pushes of integer encodings (e.g. the stack element for encoding the number 20 has no <code>OP_n</code>, but you can push the 0x14 byte using a direct push instruction). Duplicating all the <code>OP_n</code> opcodes seems like a pain, so a conversion opcode after the literal would make more sense. Alternatively, don\u2019t introduce a separate encoding, so the semantics of <code>OP_n</code> remains the same in both worlds.</p>\n<aside class=\"quote no-group\" data-username=\"ProofOfKeags\" data-post=\"10\" data-topic=\"397\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/proofofkeags/48/156_2.png\" class=\"avatar\"> ProofOfKeags:</div>\n<blockquote>\n<p>As such it <em>seems</em> that the existing VM <em>can</em> be modeled by a state transition function:</p>\n</blockquote>\n</aside>\n<p>It cannot. There are at least also:</p>\n<ul>\n<li>The position of the last executed <code>OP_CODESEPARATOR</code>, as it affects the sighashes.</li>\n<li>The if/then/else conditional stack (which branches are we in)</li>\n<li>In tapscript, the remaining checksig budget</li>\n</ul>\n<aside class=\"quote no-group\" data-username=\"ProofOfKeags\" data-post=\"10\" data-topic=\"397\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/proofofkeags/48/156_2.png\" class=\"avatar\"> ProofOfKeags:</div>\n<blockquote>\n<p>Doing something like <code>OP_ENABLE64BIT</code> would introduce some third <code>VMInterpreterState</code> and I think that will dramatically increase the surface area of potential consensus issues. Correct me if I\u2019m wrong but this would be a fundamentally new structural change to the VM formalism.</p>\n</blockquote>\n</aside>\n<p>It\u2019s certainly an increase; I don\u2019t think it is dramatic at all. But fair enough, I\u2019m convinced that a separate leaf version is cleaner than an <code>OP_ENABLE64BIT</code> here.</p>",
  "post_number": 15,
  "post_type": 1,
  "updated_at": "2024-01-11T20:40:26.242Z",
  "reply_count": 2,
  "reply_to_post_number": 13,
  "quote_count": 3,
  "incoming_link_count": 0,
  "reads": 12,
  "readers_count": 11,
  "score": 27.4,
  "yours": false,
  "topic_id": 397,
  "topic_slug": "64-bit-arithmetic-soft-fork",
  "topic_title": "64 bit arithmetic soft fork",
  "topic_html_title": "64 bit arithmetic soft fork",
  "category_id": 7,
  "display_username": "Pieter Wuille",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"ajtowns, post:13, topic:397\"]\nThe semantics proposed here copy those from liquid/elements \u2013 that is maths opcodes like ADD and SUB tend to leave two two values to the stack, on the top, a boolean TRUE/FALSE indicating whether the operands were in range, and if they were, underneath that, the actual result of the operation. That\u2019s pretty different to the way bitcoin\u2019s existing operations work, so I\u2019m not sure modifying the existing opcodes to such a different new behaviour makes sense.\n[/quote]\n\nI was suggesting not changing any semantics at all; only changing the acceptable range of inputs to existing opcodes. If `OP_MUL` or a variant thereof is added, I can see why detecting/dealing with overflows becomes an issue that the existing interface doesn't deal well with.\n\nIf the different semantics are actually desirable, then I agree it shouldn't reuse the existing opcodes. Even if so, I don't see the benefit of introducing a different encoding.\n\n[quote=\"Chris_Stewart_5, post:9, topic:397\"]\nSimple rules like things like inputs are always 8 bytes in length (not variable) make it much easier to reason about. If you would prefer big endian to be used rather than little endian I can see the value if that - although little endian is used elsewhere in the protocol.\n[/quote]\n\nOk, I'll accept that the variable-length approach complicates things a bit, but I also think having two different encodings is even worse. All things being equal, I prefer little-endian over big-endian, but again, two encodings is worse than one.\n\n[quote=\"Chris_Stewart_5, post:9, topic:397\"]\nMy understanding is the alternative implementation you are suggesting means modifying `CScriptNum` to support 64 bits.\n[/quote]\n\nIt's a wrapper around `int64_t` with serialization, deserialization, and arithmetic operations that assert on overflow. I think you'd want to add overflow-detecting versions for your use, but otherwise it already does everything. I don't think there would be a need to touch any of the existing functions/operators on `CScriptNum`.\n\nThere is a restriction on the input length when converting a Script stack element to a `CScriptNum`; my suggesting was to just relax that restriction from 4 bytes to 8 bytes when in 64-bit mode (whether that's through an `OP_SUCCESSx`, through a leaf version, or through a separate opcode). Note that `OP_CHECKLOCKTIMEVERIFY` also uses `CScriptNum`, but permits arguments up to 5 bytes rather than 4.\n\n[quote=\"Chris_Stewart_5, post:9, topic:397\"]\nIIUC - you do not have malleability concerns with this 8 byte proposal as 8 byte sizes would be required.\n[/quote]\n\nFair point. So far, I have seen few use cases for integer values that are script *inputs*, but if you envision that changing, that would be a point in favor of a strict encoding (that could still be minimally-encoded integers in a variable-length regine, which is effectively already a policy rule).\n\n[quote=\"Chris_Stewart_5, post:9, topic:397\"]\nJust to make sure we are talking about the same thing, by literals you mean `OP_1,OP_2..` etc right? I think this is a fair critique as \u2013 IIUC \u2013 now you would have to have `OP_1` and `OP_1_64` or something like that I believe?\n[/quote]\n\nYeah, the `OP_n` opcodes, plus direct pushes of integer encodings (e.g. the stack element for encoding the number 20 has no `OP_n`, but you can push the 0x14 byte using a direct push instruction). Duplicating all the `OP_n` opcodes seems like a pain, so a conversion opcode after the literal would make more sense. Alternatively, don't introduce a separate encoding, so the semantics of `OP_n` remains the same in both worlds.\n\n[quote=\"ProofOfKeags, post:10, topic:397\"]\nAs such it *seems* that the existing VM *can* be modeled by a state transition function:\n[/quote]\n\nIt cannot. There are at least also:\n* The position of the last executed `OP_CODESEPARATOR`, as it affects the sighashes.\n* The if/then/else conditional stack (which branches are we in)\n* In tapscript, the remaining checksig budget\n\n[quote=\"ProofOfKeags, post:10, topic:397\"]\nDoing something like `OP_ENABLE64BIT` would introduce some third `VMInterpreterState` and I think that will dramatically increase the surface area of potential consensus issues. Correct me if I\u2019m wrong but this would be a fundamentally new structural change to the VM formalism.\n[/quote]\n\nIt's certainly an increase; I don't think it is dramatic at all. But fair enough, I'm convinced that a separate leaf version is cleaner than an `OP_ENABLE64BIT` here.",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 96,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}