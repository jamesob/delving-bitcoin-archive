{
  "id": 1006,
  "name": "Anthony Towns",
  "username": "ajtowns",
  "avatar_template": "/user_avatar/delvingbitcoin.org/ajtowns/{size}/3_2.png",
  "created_at": "2024-01-08T02:10:16.971Z",
  "cooked": "<p>Copypasta:</p>\n<hr>\n<blockquote>\n<h1>OP_CAT Enables Scalar Multiplication for EC Points</h1>\n<p>CAT can reduce curve point scalar multiplication to a subtraction in the scalar field.</p>\n<p>Subtraction of field elements can probably be emulated in less than 250 (?) opcodes. For now, let\u2019s assume we had an (emulated) opcode, <code>op_scalar_sub</code>, for subtracting two elements of the scalar field of secp256k1.</p>\n<p>Given secp\u2019s generator <code>G</code>, we want to compute for some scalar <code>r</code> the point <code>R = rG</code></p>\n<p>That is possible by hacking it into a Schnorr signature <code>(R,s)</code> for the key <code>P = xG = 1G = G</code></p>\n<p>The Script performs the following steps:</p>\n<ol>\n<li>Verify the signature <code>(R,s)</code> for the committed key <code>P = G</code>. That\u2019s possible with op_checksig.</li>\n<li>Get the sighash <code>M</code> onto the stack using the Schnorr+CAT trick (requires a second signature)</li>\n<li>Compute <code>c = Hash(R | P | M)</code> using op_cat, op_sha256</li>\n<li>Compute <code>r' = s - c</code> using op_scalar_sub\n<ul>\n<li>this works because <code>s = r + c * x</code>, and <code>x = 1</code></li>\n</ul>\n</li>\n<li>Verify <code>r == r'</code></li>\n</ol>\n<p>This proves that <code>R</code> is <code>r * G</code>, which is as good as computing the scalar multiplication ourselves. However, unfortunately, this works only for scalar multiplications with the generator point <code>G</code>. Still, that\u2019s useful.</p>\n</blockquote>\n<hr>\n<p>I don\u2019t think that works though? If I want to falsely claim that <code>r*G = X</code>, then I create a valid signature using <code>s*G = x + H(X,G,m)*1</code>, then I make up a random value <code>z</code> that differs from <code>m</code>, calculate <code>c = Hash(X,G,z)</code>, and <code>r = s-c</code> and tell you that <code>r*G = X</code>. Without some way of verifying that the <code>z</code> I give you matches the tx msg hash used by the CHECKSIG operation, I don\u2019t think your procedure gives you any way to tell you that I\u2019m lying? On the other hand, it doesn\u2019t give me a way of choosing the value of <code>z</code>, so perhaps that\u2019s good enough in some situations?</p>\n<p>If you had CSFS you could force <code>m=z</code> directly; if you had both CTV and APO and they had a common tx msg hash function between them, you could use that to indirectly force <code>m=z</code> (<code>m DUP CTV DROP</code> checks <code>m</code> is correct and leaves <code>m</code> on the stack).</p>\n<p>(If you\u2019re introducing a new secp256k1-specific 256 bit opcode <code>op_secp256k1_scalar_sub</code> anyway, I don\u2019t see why you wouldn\u2019t just introduce an <code>secp256k1_mul</code> opcode directly, though)</p>",
  "post_number": 2,
  "post_type": 1,
  "updated_at": "2024-01-08T02:10:16.971Z",
  "reply_count": 1,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 11,
  "readers_count": 10,
  "score": 7.2,
  "yours": false,
  "topic_id": 370,
  "topic_slug": "emulating-curve-point-scalar-multiplication-with-op-cat",
  "topic_title": "Emulating curve point scalar multiplication with OP_CAT",
  "topic_html_title": "Emulating curve point scalar multiplication with OP_CAT",
  "category_id": 7,
  "display_username": "Anthony Towns",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Copypasta:\n\n---\n> \n> # OP_CAT Enables Scalar Multiplication for EC Points\n> CAT can reduce curve point scalar multiplication to a subtraction in the scalar field. \n> \n> Subtraction of field elements can probably be emulated in less than 250 (?) opcodes. For now, let's assume we had an (emulated) opcode, `op_scalar_sub`, for subtracting two elements of the scalar field of secp256k1.\n> \n> \n> Given secp's generator `G`, we want to compute for some scalar `r` the point `R = rG`\n> \n> That is possible by hacking it into a Schnorr signature `(R,s)` for the key `P = xG = 1G = G`\n> \n> The Script performs the following steps:\n> 1. Verify the signature `(R,s)` for the committed key `P = G`. That's possible with op_checksig.\n> 2. Get the sighash `M` onto the stack using the Schnorr+CAT trick (requires a second signature)\n> 3. Compute `c = Hash(R | P | M)` using op_cat, op_sha256\n> 4. Compute `r' = s - c` using op_scalar_sub \n> \t  - this works because `s = r + c * x`, and `x = 1`\n> 5. Verify `r == r'`\n> \n> This proves that `R` is `r * G`, which is as good as computing the scalar multiplication ourselves. However, unfortunately, this works only for scalar multiplications with the generator point `G`. Still, that's useful.\n\n---\n\nI don't think that works though? If I want to falsely claim that `r*G = X`, then I create a valid signature using `s*G = x + H(X,G,m)*1`, then I make up a random value `z` that differs from `m`, calculate `c = Hash(X,G,z)`, and `r = s-c` and tell you that `r*G = X`. Without some way of verifying that the `z` I give you matches the tx msg hash used by the CHECKSIG operation, I don't think your procedure gives you any way to tell you that I'm lying? On the other hand, it doesn't give me a way of choosing the value of `z`, so perhaps that's good enough in some situations?\n\nIf you had CSFS you could force `m=z` directly; if you had both CTV and APO and they had a common tx msg hash function between them, you could use that to indirectly force `m=z` (`m DUP CTV DROP` checks `m` is correct and leaves `m` on the stack).\n\n(If you're introducing a new secp256k1-specific 256 bit opcode `op_secp256k1_scalar_sub` anyway, I don't see why you wouldn't just introduce an `secp256k1_mul` opcode directly, though)",
  "actions_summary": [],
  "moderator": true,
  "admin": true,
  "staff": true,
  "user_id": 3,
  "hidden": false,
  "trust_level": 4,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}