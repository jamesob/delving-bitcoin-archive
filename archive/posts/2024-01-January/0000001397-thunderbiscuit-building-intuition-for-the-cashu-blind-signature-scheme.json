{
  "id": 1397,
  "name": "",
  "username": "thunderbiscuit",
  "avatar_template": "/user_avatar/delvingbitcoin.org/thunderbiscuit/{size}/32_2.png",
  "created_at": "2024-01-31T15:07:20.658Z",
  "cooked": "<p>This post unpacks the workflow of the ecash blind signature scheme used in <a href=\"https://github.com/cashubtc/nuts\" rel=\"noopener nofollow ugc\">Cashu</a> and explained <a href=\"https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406\" rel=\"noopener nofollow ugc\">here (Ruben Somsen)</a> and <a href=\"https://cypherpunks.venona.com/date/1996/03/msg01848.html\" rel=\"noopener nofollow ugc\">here (David Wagner)</a> in a more approachable way.</p>\n<h1><a name=\"part-1-1\" class=\"anchor\" href=\"#part-1-1\"></a>Part 1</h1>\n<h2><a name=\"prerequisites-2\" class=\"anchor\" href=\"#prerequisites-2\"></a>Prerequisites</h2>\n<p><strong>Prereq 1: Diffie-Hellman Points</strong>. Given two users Alice and Bob, each with a private/public key pair (<span class=\"math\">A = aG</span> and <span class=\"math\">B = bG</span> respectively), an elliptic curve Diffie-Hellman point is a point on the curve which both parties can derive independently using each others\u2019 public keys. Assuming Alice knows Bob\u2019s public key and Bob knows Alice\u2019s, both of them can arrive at a shared, common point (public key) <span class=\"math\">C</span> on the curve using the following:</p>\n<div class=\"math\">\n\\begin{align*}\nC &amp;= aB = bA \\\\\nC &amp;= a(bG) = b(aG) = abG\n\\end{align*}\n</div>\n<p>The equations above state that Alice can arrive at point <span class=\"math\">C</span> by multiplying Bob\u2019s public key <span class=\"math\">B</span> with her private key <span class=\"math\">a</span>, and that Bob can arrive at <em>the exact same point</em> <span class=\"math\">C</span> by multiplying Alice\u2019s public key with his private key <span class=\"math\">b</span>.</p>\n<p>This ability to derive a shared common secret <span class=\"math\">C</span> is used everywhere in modern day networking, where parties can, simply by exchanging public keys across a potentially unsecured communication layer, arrive at a common secret <em>known only to them</em>, which they can then use to encrypt further communication between each other.</p>\n<p>Note that to separately arrive at this common point, both parties need access to these 2 things:</p>\n<ol>\n<li>Each other\u2019s public keys</li>\n<li>Their individual private keys</li>\n</ol>\n<p>You can think of the Diffie-Hellman point as something you can arrive at from two sides, as long as each side has its private key:</p>\n<pre data-code-wrap=\"txt\"><code class=\"lang-txt\">Alice's private key   ---&gt;   D-H Point   &lt;---   Bob's private key\n</code></pre>\n<p>If either party does not have its own private key, they cannot access this D-H point by themselves.</p>\n<br>\n<p><strong>Prereq 2: You can \u201cprove\u201d you don\u2019t know the private key to a point</strong>. You can prove that you don\u2019t know the private key to a given point on the curve by showing how the coordinates of the point were derived from the hash of a given message. To help us in this \u201cproof\u201d, we\u2019ll use a function</p>\n<pre data-code-wrap=\"python\"><code class=\"lang-python\">hash_to_curve(message) = PointCoordinates\n</code></pre>\n<p>A user who created a point on the curve starting from a private key (multiplying that private key with the generator point and using the resulting point, e.g. <span class=\"math\">A = aG</span>) would end up with coordinates to that point, say <code>Coord1</code>. Finding a message that hashed to those same coordinates, e.g.</p>\n<pre><code class=\"lang-auto\">hash(message) = Coord1\n</code></pre>\n<p>would require breaking the preimage resistance property<sup class=\"footnote-ref\"><a href=\"#footnote-1397-1\" id=\"footnote-ref-1397-1\">[1]</a></sup> of the hash function (finding an input given a target output). Relying on the assumption that this is not feasible, we can assume that a user who knows the private key to a point would not be able to <em>also</em> know a message that hashed to the point\u2019s coordinates. We also know that one of the property of elliptic curves is that given a point on the curve, one cannot feasibly compute its corresponding private key, and together these two mean that:</p>\n<p><strong><em>If you know the private key to a point, you don\u2019t know the preimage that would hash to this point\u2019s coordinates, and alternatively, if you know the preimage (message) to a set of coordinates, you don\u2019t know the private key to that point.</em></strong></p>\n<h1><a name=\"part-2-naive-non-blinded-tokens-3\" class=\"anchor\" href=\"#part-2-naive-non-blinded-tokens-3\"></a>Part 2: Naive, non-blinded tokens</h1>\n<p>Let us start with the \u201cnaive\u201d version of the protocol, one where no blinding happens on the tokens. This is simply a description of how you could do a token system with a mint and users (we\u2019ll add privacy in Part 3).</p>\n<p>Imagine a mint, <code>Mike</code>, who agrees to give users tokens they can use to interact with his API service. To keep things simple, we\u2019ll assume Mike only offers tokens that are worth $10 each. You can buy a token from Mike (we\u2019ll say that Mike \u201cmints\u201d a token) by transferring him $10 out-of-band. What would these tokens look like and how could Mike create them?</p>\n<p>One way Mike can achieve this is by publishing his public key <span class=\"math\">K</span>. He needs a way to create tokens that he can prove were issued by him, and makes his scheme public on his website by saying:</p>\n<p><em>If you send me a public key for which you don\u2019t know the private key, I will know that I alone can produce the Diffie-Hellman point <span class=\"math\">C</span> between my public key and yours. I will only give out this point <span class=\"math\">C</span> once I have received a $10 payment. Each of those Diffie-Hellman points is then worth $10, which you can redeem with me at any time.</em>\n<br></p>\n<p>The important part here is that anyone can produce a Diffie-Hellman point between Mike and a public key they have if they know the private key for that point (this is done using <span class=\"math\">aK = C</span>, where <span class=\"math\">C</span> is the Diffie-Hellman point, see prerequisite 1 above). Mike knows this, and so can\u2019t accept <em>just any</em> Diffie-Hellman point between his <span class=\"math\">K</span> and any given public key. For Mike to consider a point <span class=\"math\">C</span> valid as a token, a user has to prove to him that they don\u2019t know the private key to their point used in the D-H point <span class=\"math\">C</span>. If that is the case, Mike knows they could not have derived point <span class=\"math\">C</span> by themselves, and therefore that <em>he must have been the one to give it to them</em> (and since he never gives out D-H points without payments, the point is a valid proof that a payment of $10 was made to him sometime in the past).</p>\n<p>The scheme can be thought of as the following steps:</p>\n<ol>\n<li>Alice creates a public key she provably doesn\u2019t know the private key to:</li>\n</ol>\n<pre data-code-wrap=\"python\"><code class=\"lang-python\">hash_to_curve(message) = PointA\n</code></pre>\n<ol start=\"2\">\n<li>She shares it with Mike, and sends $10</li>\n<li>Mike sees the payment and the public key (point), and issues the associated Diffie-Hellman point <span class=\"math\">C</span>:</li>\n</ol>\n<div class=\"math\">\nkA = C\n</div>\n<ol start=\"4\">\n<li>Alice now has point <span class=\"math\">C</span> in her pocket.</li>\n<li>When she needs to redeem the token, she shows Mike point <span class=\"math\">C</span> and point <span class=\"math\">A</span>. Mike says \u201csure but can you prove that I gave you that point and you didn\u2019t just derive it yourself?\u201d. Alice proves that she could not have derived point <span class=\"math\">C</span> by herself by providing the secret <code>message</code> she used to create point <code>A</code>.</li>\n<li>Mike computes:</li>\n</ol>\n<div class=\"math\">\n\\begin{align}\nhash\\_to\\_curve(message) &amp;= PointA \\\\\nkA &amp;= C\n\\end{align}\n</div>\n<p>and knows that Alice could not have found point <span class=\"math\">C</span> by herself, and he therefore must have been the one to give it to her. He considers the token valid, and Alice can purchase what she needs with the token.</p>\n<p>From the steps described above, we find that what Alice needs to redeem her token are two pieces of data:</p>\n<ol>\n<li>The point <span class=\"math\">C</span></li>\n<li>The secret <span class=\"math\">message</span></li>\n</ol>\n<p>In this sense, a token can be thought of as the pair <span class=\"math\">(C, ~message)</span>.</p>\n<p>As is, this system allows Mike to offer electronic tokens that are then redeemable to him at a later time. He does, however, know exactly which tokens (and who paid for them) get redeemed when, because to issue point <span class=\"math\">C</span> he needs to know point <span class=\"math\">A</span>, and he can associate that point <span class=\"math\">A</span> with Alice when she makes the initial payment to him. This means that when Alice redeems the token, he\u2019ll know she\u2019s the one redeeming it. Part 3 explores how Alice can gain privacy against Mike the mint by slightly altering the points <span class=\"math\">C</span> and <span class=\"math\">A</span>, but in a way that still allows Mike to know he was the one to issue the token.</p>\n<p>To recap, the \u201cnaive\u201d token scheme is basically this:</p>\n<p><em>Alice goes to Mike the mint and says \u201chere is $10, please give me the D-H point between your public key and this other public key. I can\u2019t generate this D-H point myself because I don\u2019t know the private key to this public key\u201d. The next week, Alice goes back to Mike and says \u201chere\u2019s a D-H point between your public key and this other public key I have. You can verify that you were the one to give this D-H point to me because I can prove that I don\u2019t know the private key to mine, and therefore the D-H point must have been created by you.\u201d</em></p>\n<h1><a name=\"part-3-4\" class=\"anchor\" href=\"#part-3-4\"></a>Part 3</h1>\n<p>In Part 2 we outlined the general scheme used by Mike the mint and Alice the user to create and redeem tokens. Our scheme so far, however, suffers a serious flaw: all tokens are associated with the user who requested them, and therefore Mike can tell:</p>\n<ol>\n<li><em>When</em> a user redeems <em>which</em> of their tokens</li>\n<li>If a <em>different</em> user redeems a token that they had not originally requested (say Bob redeems token A, which Mike knows was coming from Alice), Mike can infer that the token was used as payment in a transaction between Alice and Bob.</li>\n</ol>\n<p>Together, these are severe privacy concern for users of the tokens, and render the \u201cnaive\u201d scheme unusable in practice.</p>\n<h2><a name=\"goal-5\" class=\"anchor\" href=\"#goal-5\"></a>Goal</h2>\n<p>A better version of this would be one in which anyone can redeem any of Mike\u2019s tokens without Mike knowing who requested them in the first place, if they have been exchanged in between, and how long it has been since their creation. This poses a problem because when Alice comes to redeem her token (the DH point given to her by Mike), he remembers giving her that specific point!</p>\n<p>What we need is a way for Alice to cryptographically \u201cfiddle\u201d with the DH point in such a way that the token is still valid when she brings it back to Mike (i.e. Mike can recognize that she could only have gotten that point from him), but is different than the original so that Mike can\u2019t associate the original from the modified, making it impossible for him to tell when and to whom the token was issued in the first place.</p>\n<h2><a name=\"blinding-and-un-blinding-tokens-6\" class=\"anchor\" href=\"#blinding-and-un-blinding-tokens-6\"></a>Blinding and Un-Blinding Tokens</h2>\n<p>In practice, the way Alice achieves this is by sending Mike for signature (computation of the DH point) a key she has <em>blinded</em>, and later on is able to <em>unblind</em> it.</p>\n<p>We call this key a <code>BlindedMessage</code>, and the notation for is is <code>B_</code>. It consists of the actual public key she wishes to use <em>added</em> to a random other public key (remember that we can add points on elliptic curves). Alice can use the key she used in Part 2 (<code>A = hash_to_curve(x)</code>) and add key <code>R</code>, (<code>R = rG</code>). Point <code>R</code> here is simply a point Alice creates by choosing a random private key <code>r</code> and saving it. The <code>BlindedMessage</code> is therefore defined as the addition of those two points:</p>\n<pre data-code-wrap=\"txt\"><code class=\"lang-txt\">BlindedMessage = A + R\nBlindedMessage = A + rG\n</code></pre>\n<p>She sends that BlindedMessage (again just a point on the curve) to Mike, who produces the DH point between this public key and his (<code>K</code>) like so:</p>\n<pre data-code-wrap=\"txt\"><code class=\"lang-txt\">C_ = k(BlindedMessage)\n</code></pre>\n<p>We call this <code>C_</code> point the <em>blinded signature</em>, and he sends it back to Alice, who can now unblind it by performing the following steps:</p>\n<pre data-code-wrap=\"txt\"><code class=\"lang-txt\">C_ = k(A + rG)\nC_ = kA + krG\nC_ = kA + rK\nC_ - rK = kA + rK - rK\nC = kA\n</code></pre>\n<p>Note that in Part 2, the DH point Mike provides Alice is simply his private key <code>k</code> multiplied by her public key <code>A</code>, i.e. (<code>D-H = kA</code>). In the steps outlined above, she can get to <code>kA</code> through a roundabout way that involves her not providing <code>A</code> <em>directly</em> to Mike, which means when she redeems it later on, Mike will have never seen point <code>A</code> and cannot associate it with her.</p>\n<p>This point <code>C</code> is called the <em>unblinded key</em>, and is the key she would have gotten if she just provided Mike with her key <code>A</code> in the first place.</p>\n<p>Alice can, later on, go to Mike and present the pair <code>(C, x)</code>. Mike can attest that x produces point <code>A</code> by doing <code>hash_to_curve(x) == A</code> (confirming that Alice doesn\u2019t know the private key to this particular point), and that <code>C</code> is indeed the D-H point between <code>A</code> and his public key <code>K</code> (<code>C == kA</code>). Given these two facts, he could only be the one having provided this point to Alice at a prior time. He verifies that this particular point <code>C</code> has not been redeemed by anyone else before, and if it has not, considers the token valid!</p>\n<h2><a name=\"tokens-as-payments-between-users-7\" class=\"anchor\" href=\"#tokens-as-payments-between-users-7\"></a>Tokens as payments between users</h2>\n<p>Because this token is valid and has good privacy propeties, it might be accepted as payment by others. Alice can pay Bob with the token <code>(C, message)</code> and Bob can redeem the token with Mike, who has no idea an exchange was made between the two.</p>\n<hr class=\"footnotes-sep\">\n\n<ol class=\"footnotes-list\">\n<li id=\"footnote-1397-1\" class=\"footnote-item\"><p><em>Premiage resistance</em> is the property that a hash function is hard to invert, that is, given an output of the hash function it should be computationally infeasible to find an input that maps to that element. <a href=\"#footnote-ref-1397-1\" class=\"footnote-backref\">\u21a9\ufe0e</a></p>\n</li>\n</ol>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2024-01-31T15:07:20.658Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 6,
  "reads": 10,
  "readers_count": 9,
  "score": 32.0,
  "yours": false,
  "topic_id": 506,
  "topic_slug": "building-intuition-for-the-cashu-blind-signature-scheme",
  "topic_title": "Building Intuition for the Cashu Blind Signature Scheme",
  "topic_html_title": "Building Intuition for the Cashu Blind Signature Scheme",
  "category_id": 7,
  "display_username": "",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "This post unpacks the workflow of the ecash blind signature scheme used in [Cashu](https://github.com/cashubtc/nuts) and explained [here (Ruben Somsen)](https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406) and [here (David Wagner)](https://cypherpunks.venona.com/date/1996/03/msg01848.html) in a more approachable way.\n\n# Part 1\n## Prerequisites\n**Prereq 1: Diffie-Hellman Points**. Given two users Alice and Bob, each with a private/public key pair ($A = aG$ and $B = bG$ respectively), an elliptic curve Diffie-Hellman point is a point on the curve which both parties can derive independently using each others' public keys. Assuming Alice knows Bob's public key and Bob knows Alice's, both of them can arrive at a shared, common point (public key) $C$ on the curve using the following:\n$$\n\\begin{align*}\nC &= aB = bA \\\\\nC &= a(bG) = b(aG) = abG\n\\end{align*}\n$$\n\nThe equations above state that Alice can arrive at point $C$ by multiplying Bob's public key $B$ with her private key $a$, and that Bob can arrive at _the exact same point_ $C$ by multiplying Alice's public key with his private key $b$.\n\nThis ability to derive a shared common secret $C$ is used everywhere in modern day networking, where parties can, simply by exchanging public keys across a potentially unsecured communication layer, arrive at a common secret _known only to them_, which they can then use to encrypt further communication between each other.\n\nNote that to separately arrive at this common point, both parties need access to these 2 things:\n1. Each other's public keys\n2. Their individual private keys\n\nYou can think of the Diffie-Hellman point as something you can arrive at from two sides, as long as each side has its private key:\n```txt\nAlice's private key   --->   D-H Point   <---   Bob's private key\n```\n\nIf either party does not have its own private key, they cannot access this D-H point by themselves.\n\n<br>\n\n**Prereq 2: You can \"prove\" you don't know the private key to a point**. You can prove that you don't know the private key to a given point on the curve by showing how the coordinates of the point were derived from the hash of a given message. To help us in this \"proof\", we'll use a function\n```python\nhash_to_curve(message) = PointCoordinates\n```\n\nA user who created a point on the curve starting from a private key (multiplying that private key with the generator point and using the resulting point, e.g. $A = aG$) would end up with coordinates to that point, say `Coord1`. Finding a message that hashed to those same coordinates, e.g.\n```\nhash(message) = Coord1\n```\nwould require breaking the preimage resistance property[^1] of the hash function (finding an input given a target output). Relying on the assumption that this is not feasible, we can assume that a user who knows the private key to a point would not be able to _also_ know a message that hashed to the point's coordinates. We also know that one of the property of elliptic curves is that given a point on the curve, one cannot feasibly compute its corresponding private key, and together these two mean that:\n\n**_If you know the private key to a point, you don't know the preimage that would hash to this point's coordinates, and alternatively, if you know the preimage (message) to a set of coordinates, you don't know the private key to that point._**\n\n# Part 2: Naive, non-blinded tokens\nLet us start with the \"naive\" version of the protocol, one where no blinding happens on the tokens. This is simply a description of how you could do a token system with a mint and users (we'll add privacy in Part 3).\n\nImagine a mint, `Mike`, who agrees to give users tokens they can use to interact with his API service. To keep things simple, we'll assume Mike only offers tokens that are worth $10 each. You can buy a token from Mike (we'll say that Mike \"mints\" a token) by transferring him $10 out-of-band. What would these tokens look like and how could Mike create them?\n\nOne way Mike can achieve this is by publishing his public key $K$. He needs a way to create tokens that he can prove were issued by him, and makes his scheme public on his website by saying:\n\n_If you send me a public key for which you don't know the private key, I will know that I alone can produce the Diffie-Hellman point $C$ between my public key and yours. I will only give out this point $C$ once I have received a $10 payment. Each of those Diffie-Hellman points is then worth $10, which you can redeem with me at any time._\n<br>\n\nThe important part here is that anyone can produce a Diffie-Hellman point between Mike and a public key they have if they know the private key for that point (this is done using $aK = C$, where $C$ is the Diffie-Hellman point, see prerequisite 1 above). Mike knows this, and so can't accept _just any_ Diffie-Hellman point between his $K$ and any given public key. For Mike to consider a point $C$ valid as a token, a user has to prove to him that they don't know the private key to their point used in the D-H point $C$. If that is the case, Mike knows they could not have derived point $C$ by themselves, and therefore that _he must have been the one to give it to them_ (and since he never gives out D-H points without payments, the point is a valid proof that a payment of $10 was made to him sometime in the past).\n\nThe scheme can be thought of as the following steps:\n1. Alice creates a public key she provably doesn't know the private key to:\n```python\nhash_to_curve(message) = PointA\n```\n2. She shares it with Mike, and sends $10\n3. Mike sees the payment and the public key (point), and issues the associated Diffie-Hellman point $C$:\n$$\nkA = C\n$$\n4. Alice now has point $C$ in her pocket.\n5. When she needs to redeem the token, she shows Mike point $C$ and point $A$. Mike says \"sure but can you prove that I gave you that point and you didn't just derive it yourself?\". Alice proves that she could not have derived point $C$ by herself by providing the secret `message` she used to create point `A`.\n6. Mike computes:\n$$\n\\begin{align}\nhash\\_to\\_curve(message) &= PointA \\\\\nkA &= C\n\\end{align}\n$$\n\nand knows that Alice could not have found point $C$ by herself, and he therefore must have been the one to give it to her. He considers the token valid, and Alice can purchase what she needs with the token.\n\nFrom the steps described above, we find that what Alice needs to redeem her token are two pieces of data: \n1. The point $C$\n2. The secret $message$\n\nIn this sense, a token can be thought of as the pair $(C, ~message)$.\n\nAs is, this system allows Mike to offer electronic tokens that are then redeemable to him at a later time. He does, however, know exactly which tokens (and who paid for them) get redeemed when, because to issue point $C$ he needs to know point $A$, and he can associate that point $A$ with Alice when she makes the initial payment to him. This means that when Alice redeems the token, he'll know she's the one redeeming it. Part 3 explores how Alice can gain privacy against Mike the mint by slightly altering the points $C$ and $A$, but in a way that still allows Mike to know he was the one to issue the token.\n\nTo recap, the \"naive\" token scheme is basically this:\n\n_Alice goes to Mike the mint and says \"here is $10, please give me the D-H point between your public key and this other public key. I can't generate this D-H point myself because I don't know the private key to this public key\". The next week, Alice goes back to Mike and says \"here's a D-H point between your public key and this other public key I have. You can verify that you were the one to give this D-H point to me because I can prove that I don't know the private key to mine, and therefore the D-H point must have been created by you.\"_\n\n[^1]: *Premiage resistance* is the property that a hash function is hard to invert, that is, given an output of the hash function it should be computationally infeasible to find an input that maps to that element.\n\n# Part 3\nIn Part 2 we outlined the general scheme used by Mike the mint and Alice the user to create and redeem tokens. Our scheme so far, however, suffers a serious flaw: all tokens are associated with the user who requested them, and therefore Mike can tell:\n1. _When_ a user redeems _which_ of their tokens\n2. If a _different_ user redeems a token that they had not originally requested (say Bob redeems token A, which Mike knows was coming from Alice), Mike can infer that the token was used as payment in a transaction between Alice and Bob.\n\nTogether, these are severe privacy concern for users of the tokens, and render the \"naive\" scheme unusable in practice.\n\n## Goal\nA better version of this would be one in which anyone can redeem any of Mike's tokens without Mike knowing who requested them in the first place, if they have been exchanged in between, and how long it has been since their creation. This poses a problem because when Alice comes to redeem her token (the DH point given to her by Mike), he remembers giving her that specific point!\n\nWhat we need is a way for Alice to cryptographically \"fiddle\" with the DH point in such a way that the token is still valid when she brings it back to Mike (i.e. Mike can recognize that she could only have gotten that point from him), but is different than the original so that Mike can't associate the original from the modified, making it impossible for him to tell when and to whom the token was issued in the first place.\n\n## Blinding and Un-Blinding Tokens\nIn practice, the way Alice achieves this is by sending Mike for signature (computation of the DH point) a key she has _blinded_, and later on is able to _unblind_ it.\n\nWe call this key a `BlindedMessage`, and the notation for is is `B_`. It consists of the actual public key she wishes to use _added_ to a random other public key (remember that we can add points on elliptic curves). Alice can use the key she used in Part 2 (`A = hash_to_curve(x)`) and add key `R`, (`R = rG`). Point `R` here is simply a point Alice creates by choosing a random private key `r` and saving it. The `BlindedMessage` is therefore defined as the addition of those two points:\n```txt\nBlindedMessage = A + R\nBlindedMessage = A + rG\n```\n\nShe sends that BlindedMessage (again just a point on the curve) to Mike, who produces the DH point between this public key and his (`K`) like so:\n```txt\nC_ = k(BlindedMessage)\n```\n\nWe call this `C_` point the _blinded signature_, and he sends it back to Alice, who can now unblind it by performing the following steps:\n```txt\nC_ = k(A + rG)\nC_ = kA + krG\nC_ = kA + rK\nC_ - rK = kA + rK - rK\nC = kA\n```\n\nNote that in Part 2, the DH point Mike provides Alice is simply his private key `k` multiplied by her public key `A`, i.e. (`D-H = kA`). In the steps outlined above, she can get to `kA` through a roundabout way that involves her not providing `A` _directly_ to Mike, which means when she redeems it later on, Mike will have never seen point `A` and cannot associate it with her.\n\nThis point `C` is called the _unblinded key_, and is the key she would have gotten if she just provided Mike with her key `A` in the first place.\n\nAlice can, later on, go to Mike and present the pair `(C, x)`. Mike can attest that x produces point `A` by doing `hash_to_curve(x) == A` (confirming that Alice doesn't know the private key to this particular point), and that `C` is indeed the D-H point between `A` and his public key `K` (`C == kA`). Given these two facts, he could only be the one having provided this point to Alice at a prior time. He verifies that this particular point `C` has not been redeemed by anyone else before, and if it has not, considers the token valid!\n\n## Tokens as payments between users\nBecause this token is valid and has good privacy propeties, it might be accepted as payment by others. Alice can pay Bob with the token `(C, message)` and Bob can redeem the token with Mike, who has no idea an exchange was made between the two.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 36,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}