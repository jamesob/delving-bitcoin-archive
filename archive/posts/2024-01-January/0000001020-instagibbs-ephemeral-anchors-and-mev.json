{
  "id": 1020,
  "name": "Gregory Sanders",
  "username": "instagibbs",
  "avatar_template": "/user_avatar/delvingbitcoin.org/instagibbs/{size}/28_2.png",
  "created_at": "2024-01-08T17:11:16.906Z",
  "cooked": "<h1><a name=\"setting-and-initial-solution-1\" class=\"anchor\" href=\"#setting-and-initial-solution-1\"></a>Setting and initial solution</h1>\n<p>This has been something I\u2019ve been considering since the start of my work, and was echoed by <a class=\"mention\" href=\"/u/ariard\">@ariard</a> here: <a href=\"https://github.com/bitcoin/bips/pull/1524#issuecomment-1865322320\" class=\"inline-onebox\">Ephemeral anchors by instagibbs \u00b7 Pull Request #1524 \u00b7 bitcoin/bips \u00b7 GitHub</a></p>\n<p>To quote:</p>\n<blockquote>\n<p>As of today, Bob could do the same attack by routing the HTLCs, however as the trimmed HTLCs are committed as miner fees, if Bob does not have low-hashrate capabilities, he cannot steal from Alice. Moving trimmed HTLC amounts from miners fees to a anyone-can-spend amount changes notably the threat model, in my opinion\"</p>\n</blockquote>\n<p>In other words, if an ephemeral anchor has non-0 value, depending on other factors, it may be in the best interest of a counter-party to try and claim the ephemeral anchor funds for themselves, giving only enough fees to get the transaction package in the block.</p>\n<p>This is also a potential MEV: Miners should probably intercede and simply burn the funds to fees in that case.</p>\n<p>Rather than proactively require miners to do the work for us, it may make sense to essentially do an RBF incentive compatibility check: Should the ephemeral spend transaction just have burned funds to fees? This fee burn, at relay minimums, would be 65 vbytes: An ephemeral anchor spend, and a minimal size OP_RETURN to reach the relay minimum stripped size sending all the ephemeral value to fees. (Note a miner could do batching, or go even smaller, or redirect funds to a key they control to spend it faster; for reducing MEV this seems like a good place to start.)</p>\n<p>At first, this meant to me that we should do normal incentives checks against this minimal burn: Is the spender of equal or higher feerate than a relay-minimal direct to miner burn? If it is &gt;=, we accept it. This should in theory make it not useful to inflate the ephemeral anchor value and try to claim it themselves, unless your smart contract adversary is a miner themselves(can\u2019t fix that clearly).</p>\n<h1><a name=\"problem-with-first-solution-2\" class=\"anchor\" href=\"#problem-with-first-solution-2\"></a>Problem with first solution</h1>\n<p>Doing a bit of analysis, I realized that a minimal relay burn of funds is actually a pin! If an adversary front-runs the child spend with a pure burn to fees, the fees are large enough to get into the mempool but not into a block, then there\u2019s a potential RBF pin. Example:</p>\n<p>\u201cTrimmed\u201d value in channel: 50k satoshis(default max of many implementations of LN)</p>\n<p>Mempool minfee: 1 sat/vbyte<br>\nGoing rate for block inclusion: 2 sat/vbyte<br>\nEphemeral Parent: 40k vbytes, 0 fees<br>\nPure ephemeral burn to fees child: 65 vbytes, 50k fees , feerate of 769 sat/vbyte<br>\n \u2192 Package feerate of 1.24 sat/vbyte</p>\n<p>To replace this child to increase package feerate, it requires we exceed the existing child feerate:</p>\n<p>RBF\u2019ing CPFP child size: 65 + 58(taproot input for more fees) + 30(delta size to taproot output for change) = 153 \u2190 key ratio is this vs pure burn size\nFinal CPFP child stats: 153 vbytes, 40,153*2= 80,306 fees, feerate of 524 sat/vbyte<br>\n \u2192 Package feerate of 2 sat/vbyte</p>\n<p>So to get the RBF into the mempool, you\u2019ll need to increase the child feerate by a factor of 769/524=1.46, even though incentive-wise speaking, we should have accepted it as long as package feerate exceeds 1.2 sat/vbytes.</p>\n<p>The pin can get larger with larger in-mempool unconfirmed parent, as well as the difference in \u201cpure burn\u201d feerate and the \u201cgoing rate\u201d for block inclusion, multiplied by the required size of the \u201chonest\u201d CPFP which can grow without the best utxo discipline.</p>\n<p>This is pretty ugly and problematic for wallets, as there is a potentially large step function from \u201cephemeral anchor burn is sufficient\u201d to \u201cwe need to bring in more funds\u201d. Can we do better?</p>\n<h1><a name=\"diagram-checks-fix-this-3\" class=\"anchor\" href=\"#diagram-checks-fix-this-3\"></a>Diagram Checks Fix This</h1>\n<p>We can do better. Similar to the strategy in <a href=\"https://github.com/bitcoin/bitcoin/pull/28984\">https://github.com/bitcoin/bitcoin/pull/28984</a> , we can check if a cluster-size-1 tx RBF is conflicting only with clusters of size two, and do a cluster mempool-like diagram check. The diagram check would allow the scenario\u2019s 524 sat/vbyte replacement, as the transaction is incentive compatible, and also brings in more total fees.</p>\n<p>This change would require the new RBF rule, and then applying that RBF rule additionally against every ephemeral anchor spend.</p>\n<p>With this check, it should blunt any incentives for smart contract counter-parties to attempt to steal the ephemeral anchor value, and reduce MEV potential greatly.</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2024-01-08T17:39:30.609Z",
  "reply_count": 1,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 15,
  "reads": 23,
  "readers_count": 22,
  "score": 84.6,
  "yours": false,
  "topic_id": 383,
  "topic_slug": "ephemeral-anchors-and-mev",
  "topic_title": "Ephemeral Anchors and MEV",
  "topic_html_title": "Ephemeral Anchors and MEV",
  "category_id": 7,
  "display_username": "Gregory Sanders",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "# Setting and initial solution\n\nThis has been something I've been considering since the start of my work, and was echoed by @ariard here: https://github.com/bitcoin/bips/pull/1524#issuecomment-1865322320\n\nTo quote:\n\n> As of today, Bob could do the same attack by routing the HTLCs, however as the trimmed HTLCs are committed as miner fees, if Bob does not have low-hashrate capabilities, he cannot steal from Alice. Moving trimmed HTLC amounts from miners fees to a anyone-can-spend amount changes notably the threat model, in my opinion\"\n\nIn other words, if an ephemeral anchor has non-0 value, depending on other factors, it may be in the best interest of a counter-party to try and claim the ephemeral anchor funds for themselves, giving only enough fees to get the transaction package in the block.\n\nThis is also a potential MEV: Miners should probably intercede and simply burn the funds to fees in that case.\n\nRather than proactively require miners to do the work for us, it may make sense to essentially do an RBF incentive compatibility check: Should the ephemeral spend transaction just have burned funds to fees? This fee burn, at relay minimums, would be 65 vbytes: An ephemeral anchor spend, and a minimal size OP_RETURN to reach the relay minimum stripped size sending all the ephemeral value to fees. (Note a miner could do batching, or go even smaller, or redirect funds to a key they control to spend it faster; for reducing MEV this seems like a good place to start.)\n\nAt first, this meant to me that we should do normal incentives checks against this minimal burn: Is the spender of equal or higher feerate than a relay-minimal direct to miner burn? If it is >=, we accept it. This should in theory make it not useful to inflate the ephemeral anchor value and try to claim it themselves, unless your smart contract adversary is a miner themselves(can't fix that clearly).\n\n# Problem with first solution\n\nDoing a bit of analysis, I realized that a minimal relay burn of funds is actually a pin! If an adversary front-runs the child spend with a pure burn to fees, the fees are large enough to get into the mempool but not into a block, then there's a potential RBF pin. Example:\n\n\"Trimmed\" value in channel: 50k satoshis(default max of many implementations of LN)  \n\nMempool minfee: 1 sat/vbyte  \nGoing rate for block inclusion: 2 sat/vbyte  \nEphemeral Parent: 40k vbytes, 0 fees  \nPure ephemeral burn to fees child: 65 vbytes, 50k fees , feerate of 769 sat/vbyte  \n-> Package feerate of 1.24 sat/vbyte  \n\nTo replace this child to increase package feerate, it requires we exceed the existing child feerate:\n\nRBF'ing CPFP child size: 65 + 58(taproot input for more fees) + 30(delta size to taproot output for change) = 153 <-- key ratio is this vs pure burn size\nFinal CPFP child stats: 153 vbytes, 40,153*2= 80,306 fees, feerate of 524 sat/vbyte  \n-> Package feerate of 2 sat/vbyte\n\nSo to get the RBF into the mempool, you'll need to increase the child feerate by a factor of 769/524=1.46, even though incentive-wise speaking, we should have accepted it as long as package feerate exceeds 1.2 sat/vbytes.\n\nThe pin can get larger with larger in-mempool unconfirmed parent, as well as the difference in \"pure burn\" feerate and the \"going rate\" for block inclusion, multiplied by the required size of the \"honest\" CPFP which can grow without the best utxo discipline.\n\nThis is pretty ugly and problematic for wallets, as there is a potentially large step function from \"ephemeral anchor burn is sufficient\" to \"we need to bring in more funds\". Can we do better?\n\n# Diagram Checks Fix This\n\nWe can do better. Similar to the strategy in https://github.com/bitcoin/bitcoin/pull/28984 , we can check if a cluster-size-1 tx RBF is conflicting only with clusters of size two, and do a cluster mempool-like diagram check. The diagram check would allow the scenario's 524 sat/vbyte replacement, as the transaction is incentive compatible, and also brings in more total fees.\n\nThis change would require the new RBF rule, and then applying that RBF rule additionally against every ephemeral anchor spend.\n\nWith this check, it should blunt any incentives for smart contract counter-parties to attempt to steal the ephemeral anchor value, and reduce MEV potential greatly.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 31,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "rocket",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}