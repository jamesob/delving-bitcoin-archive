{
  "id": 3365,
  "name": "/dev/fd0",
  "username": "1440000bytes",
  "avatar_template": "/user_avatar/delvingbitcoin.org/1440000bytes/{size}/301_2.png",
  "created_at": "2024-10-15T09:48:28.550Z",
  "cooked": "<p><img src=\"https://delvingbitcoin.org/uploads/default/original/1X/9cf1dcfcc22ff8dd6d80e1a043e6db563a9635b5.jpeg\" alt=\"image\" data-base62-sha1=\"mooFQBgZrIszLihZUQz0EVP7iU5\" width=\"651\" height=\"383\"></p>\n<p>There were 2 talks in recent bitcoin++ conference about use of ecash protocol for other stuff and not money. Blind signatures have been used in coinjoin by Wabisabi for coordination and I think they can be useful for discount coupons as well.</p>\n<blockquote>\n<p>More complicated implementations are possible where even the server doesn\u2019t learn the mapping.</p>\n</blockquote>\n<blockquote>\n<p>E.g. Using chaum blind signatures: The users connect and provide inputs (and change addresses) and a cryptographically-blinded version of the address they want their private coins to go to; the server signs the tokens and returns them. The users anonymously reconnect, unblind their output addresses, and return them to the server. The server can see that all the outputs were signed by it and so all the outputs had to come from valid participants. Later people reconnect and sign.</p>\n</blockquote>\n<aside class=\"onebox allowlistedgeneric\" data-onebox-src=\"https://bitcointalk.org/?topic=279249\">\n  <header class=\"source\">\n\n      <a href=\"https://bitcointalk.org/?topic=279249\" target=\"_blank\" rel=\"noopener nofollow ugc\">bitcointalk.org</a>\n  </header>\n\n  <article class=\"onebox-body\">\n    \n\n<h3><a href=\"https://bitcointalk.org/?topic=279249\" target=\"_blank\" rel=\"noopener nofollow ugc\">CoinJoin: Bitcoin privacy for the real world</a></h3>\n\n  <p>CoinJoin: Bitcoin privacy for the real world</p>\n\n\n  </article>\n\n  <div class=\"onebox-metadata\">\n    \n    \n  </div>\n\n  <div style=\"clear: both\"></div>\n</aside>\n\n<p>In open source projects, incentivizing users and contributors with discount coupons could be useful. Example: Paid <a href=\"https://legacy.nostr.watch/relays/find\" rel=\"noopener nofollow ugc\">nostr relays</a></p>\n<p><strong>Proof of Concept</strong></p>\n<pre><code class=\"lang-auto\">import os\nimport hashlib\nfrom dataclasses import dataclass\nfrom typing import Dict, Tuple\n\nfrom ecdsa import SECP256k1, SigningKey, VerifyingKey\nfrom ecdsa.ellipticcurve import Point\n\nDOMAIN_SEPARATOR = b\"Secp256k1_HashToCurve_Relay_\"\n\ndef int_to_bytes(x: int) -&gt; bytes:\n    return x.to_bytes((x.bit_length() + 7) // 8, byteorder='big')\n\ndef int_from_bytes(xbytes: bytes) -&gt; int:\n    return int.from_bytes(xbytes, byteorder='big')\n\ndef hash_to_curve(x: bytes) -&gt; Point:\n    msg_hash = hashlib.sha256(DOMAIN_SEPARATOR + x).digest()\n    x = int_from_bytes(msg_hash)\n    \n    curve = SECP256k1.curve\n    p = curve.p()\n    \n    while True:\n        x = x % p\n        y_squared = (pow(x, 3, p) + 7) % p\n        y = pow(y_squared, (p + 1) // 4, p)\n        \n        if pow(y, 2, p) == y_squared:\n            return Point(curve, x, y)\n        \n        x += 1\n\n@dataclass\nclass BlindedMessage:\n    amount: int\n    id: str\n    B_: str\n\n@dataclass\nclass BlindSignature:\n    amount: int\n    id: str\n    C_: str\n\n@dataclass\nclass Proof:\n    amount: int\n    id: str\n    secret: str\n    C: str\n\nclass Relay:\n    def __init__(self):\n        self.private_keys = {}\n        self.public_keys = {}\n        self.spent_secrets = set()\n\n    def generate_keypair(self, amount: int):\n        private_key = SigningKey.generate(curve=SECP256k1)\n        public_key = private_key.get_verifying_key()\n        key_id = hashlib.sha256(public_key.to_string()).hexdigest()[:8]\n        self.private_keys[amount] = private_key\n        self.public_keys[amount] = public_key\n        return key_id, public_key.to_string().hex()\n\n    def sign(self, blinded_message: BlindedMessage) -&gt; BlindSignature:\n        private_key = self.private_keys[blinded_message.amount]\n        B_ = VerifyingKey.from_string(bytes.fromhex(blinded_message.B_), curve=SECP256k1).pubkey.point\n        C_ = private_key.privkey.secret_multiplier * B_\n        return BlindSignature(\n            amount=blinded_message.amount,\n            id=blinded_message.id,\n            C_=C_.to_bytes().hex()\n        )\n\n    def verify(self, proof: Proof) -&gt; bool:\n        if proof.secret in self.spent_secrets:\n            return False\n        public_key = self.public_keys[proof.amount]\n        Y = hash_to_curve(proof.secret.encode())\n        C = VerifyingKey.from_string(bytes.fromhex(proof.C), curve=SECP256k1).pubkey.point\n        \n        private_key = self.private_keys[proof.amount]\n        expected_C = private_key.privkey.secret_multiplier * Y\n        \n        return C.x() == expected_C.x() and C.y() == expected_C.y()\n\n    def redeem(self, proof: Proof):\n        if self.verify(proof):\n            self.spent_secrets.add(proof.secret)\n            return True\n        return False\n\nclass User:\n    def __init__(self):\n        self.blinding_factors: Dict[str, Tuple[int, str]] = {}\n\n    def blind(self, amount: int, key_id: str, public_key_hex: str) -&gt; BlindedMessage:\n        x = os.urandom(32).hex()\n        Y = hash_to_curve(x.encode())\n        r = int.from_bytes(os.urandom(32), byteorder='big') % SECP256k1.order\n        B_ = Y + SECP256k1.generator * r\n        B_hex = B_.to_bytes().hex()\n        self.blinding_factors[B_hex] = (r, x, public_key_hex)\n        return BlindedMessage(amount=amount, id=key_id, B_=B_hex)\n\n    def unblind(self, blind_signature: BlindSignature, B_: str) -&gt; Proof:\n        r, x, public_key_hex = self.blinding_factors.pop(B_)\n        C_ = VerifyingKey.from_string(bytes.fromhex(blind_signature.C_), curve=SECP256k1).pubkey.point\n        K = VerifyingKey.from_string(bytes.fromhex(public_key_hex), curve=SECP256k1).pubkey.point\n        \n        C_ = Point(C_.curve(), C_.x(), C_.y())\n        K = Point(K.curve(), K.x(), K.y())\n        \n        C = C_ + (SECP256k1.order - r) * K\n        return Proof(\n            amount=blind_signature.amount,\n            id=blind_signature.id,\n            secret=x,\n            C=C.to_bytes().hex()\n        )\n\ndef main():\n    relay = Relay()\n    user = User()\n    amount = 100\n    key_id, public_key_hex = relay.generate_keypair(amount)\n    print(f\"Relay generated keypair for amount {amount} with ID {key_id}\")\n\n    blinded_message = None\n    blind_signature = None\n    proof = None\n\n    while True:\n        print(\"\\n1. Blind\")\n        print(\"2. Sign\")\n        print(\"3. Unblind\")\n        print(\"4. Verify\")\n        print(\"5. Redeem\")\n        print(\"6. Exit\")\n        choice = input(\"Enter your choice: \")\n\n        if choice == '1':\n            blinded_message = user.blind(amount, key_id, public_key_hex)\n            print(f\"Blinded message: {blinded_message}\")\n        elif choice == '2':\n            if blinded_message is None:\n                print(\"Please blind a message first.\")\n            else:\n                blind_signature = relay.sign(blinded_message)\n                print(f\"Blind signature: {blind_signature}\")\n        elif choice == '3':\n            if blind_signature is None:\n                print(\"Please get a blind signature first.\")\n            else:\n                proof = user.unblind(blind_signature, blinded_message.B_)\n                print(f\"Proof: {proof}\")\n        elif choice == '4':\n            if proof is None:\n                print(\"Please unblind the signature first.\")\n            else:\n                is_valid = relay.verify(proof)\n                print(f\"Proof is valid: {is_valid}\")\n        elif choice == '5':\n            if proof is None:\n                print(\"Please unblind the signature first.\")\n            else:\n                is_spent = relay.redeem(proof)\n                print(f\"Token redeemed successfully: {is_spent}\")\n        elif choice == '6':\n            break\n        else:\n            print(\"Invalid choice. Please try again.\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>\n<p>This does not involve any custodians and users do not depsosit bitcoin for minting ecash. It can be gifted to other users. I plan to use it for incentivizing users and <a href=\"https://uncensoredtech.substack.com/p/market-makers-in-joinstr\" rel=\"noopener nofollow ugc\">market makers</a> in joinstr can also offer discounts for regular users.</p>\n<p><strong>Alternative</strong></p>\n<p>Normal discount and promo codes can be used to achieve the same thing but ecash protocol improves privacy.</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2024-10-15T09:50:03.068Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 44,
  "reads": 20,
  "readers_count": 19,
  "score": 187.8,
  "yours": false,
  "topic_id": 1197,
  "topic_slug": "anonymous-discount-coupons-using-chaumian-ecash",
  "topic_title": "Anonymous discount coupons using chaumian ecash",
  "topic_html_title": "Anonymous discount coupons using chaumian ecash",
  "category_id": 8,
  "display_username": "/dev/fd0",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "![image|651x383, 100%](upload://mooFQBgZrIszLihZUQz0EVP7iU5.jpeg)\n\nThere were 2 talks in recent bitcoin++ conference about use of ecash protocol for other stuff and not money. Blind signatures have been used in coinjoin by Wabisabi for coordination and I think they can be useful for discount coupons as well.\n\n> More complicated implementations are possible where even the server doesn't learn the mapping.\n\n> E.g. Using chaum blind signatures: The users connect and provide inputs (and change addresses) and a cryptographically-blinded version of the address they want their private coins to go to; the server signs the tokens and returns them. The users anonymously reconnect, unblind their output addresses, and return them to the server. The server can see that all the outputs were signed by it and so all the outputs had to come from valid participants. Later people reconnect and sign.\n\nhttps://bitcointalk.org/?topic=279249\n\nIn open source projects, incentivizing users and contributors with discount coupons could be useful. Example: Paid [nostr relays](https://legacy.nostr.watch/relays/find) \n\n\n**Proof of Concept**\n\n```\nimport os\nimport hashlib\nfrom dataclasses import dataclass\nfrom typing import Dict, Tuple\n\nfrom ecdsa import SECP256k1, SigningKey, VerifyingKey\nfrom ecdsa.ellipticcurve import Point\n\nDOMAIN_SEPARATOR = b\"Secp256k1_HashToCurve_Relay_\"\n\ndef int_to_bytes(x: int) -> bytes:\n    return x.to_bytes((x.bit_length() + 7) // 8, byteorder='big')\n\ndef int_from_bytes(xbytes: bytes) -> int:\n    return int.from_bytes(xbytes, byteorder='big')\n\ndef hash_to_curve(x: bytes) -> Point:\n    msg_hash = hashlib.sha256(DOMAIN_SEPARATOR + x).digest()\n    x = int_from_bytes(msg_hash)\n    \n    curve = SECP256k1.curve\n    p = curve.p()\n    \n    while True:\n        x = x % p\n        y_squared = (pow(x, 3, p) + 7) % p\n        y = pow(y_squared, (p + 1) // 4, p)\n        \n        if pow(y, 2, p) == y_squared:\n            return Point(curve, x, y)\n        \n        x += 1\n\n@dataclass\nclass BlindedMessage:\n    amount: int\n    id: str\n    B_: str\n\n@dataclass\nclass BlindSignature:\n    amount: int\n    id: str\n    C_: str\n\n@dataclass\nclass Proof:\n    amount: int\n    id: str\n    secret: str\n    C: str\n\nclass Relay:\n    def __init__(self):\n        self.private_keys = {}\n        self.public_keys = {}\n        self.spent_secrets = set()\n\n    def generate_keypair(self, amount: int):\n        private_key = SigningKey.generate(curve=SECP256k1)\n        public_key = private_key.get_verifying_key()\n        key_id = hashlib.sha256(public_key.to_string()).hexdigest()[:8]\n        self.private_keys[amount] = private_key\n        self.public_keys[amount] = public_key\n        return key_id, public_key.to_string().hex()\n\n    def sign(self, blinded_message: BlindedMessage) -> BlindSignature:\n        private_key = self.private_keys[blinded_message.amount]\n        B_ = VerifyingKey.from_string(bytes.fromhex(blinded_message.B_), curve=SECP256k1).pubkey.point\n        C_ = private_key.privkey.secret_multiplier * B_\n        return BlindSignature(\n            amount=blinded_message.amount,\n            id=blinded_message.id,\n            C_=C_.to_bytes().hex()\n        )\n\n    def verify(self, proof: Proof) -> bool:\n        if proof.secret in self.spent_secrets:\n            return False\n        public_key = self.public_keys[proof.amount]\n        Y = hash_to_curve(proof.secret.encode())\n        C = VerifyingKey.from_string(bytes.fromhex(proof.C), curve=SECP256k1).pubkey.point\n        \n        private_key = self.private_keys[proof.amount]\n        expected_C = private_key.privkey.secret_multiplier * Y\n        \n        return C.x() == expected_C.x() and C.y() == expected_C.y()\n\n    def redeem(self, proof: Proof):\n        if self.verify(proof):\n            self.spent_secrets.add(proof.secret)\n            return True\n        return False\n\nclass User:\n    def __init__(self):\n        self.blinding_factors: Dict[str, Tuple[int, str]] = {}\n\n    def blind(self, amount: int, key_id: str, public_key_hex: str) -> BlindedMessage:\n        x = os.urandom(32).hex()\n        Y = hash_to_curve(x.encode())\n        r = int.from_bytes(os.urandom(32), byteorder='big') % SECP256k1.order\n        B_ = Y + SECP256k1.generator * r\n        B_hex = B_.to_bytes().hex()\n        self.blinding_factors[B_hex] = (r, x, public_key_hex)\n        return BlindedMessage(amount=amount, id=key_id, B_=B_hex)\n\n    def unblind(self, blind_signature: BlindSignature, B_: str) -> Proof:\n        r, x, public_key_hex = self.blinding_factors.pop(B_)\n        C_ = VerifyingKey.from_string(bytes.fromhex(blind_signature.C_), curve=SECP256k1).pubkey.point\n        K = VerifyingKey.from_string(bytes.fromhex(public_key_hex), curve=SECP256k1).pubkey.point\n        \n        C_ = Point(C_.curve(), C_.x(), C_.y())\n        K = Point(K.curve(), K.x(), K.y())\n        \n        C = C_ + (SECP256k1.order - r) * K\n        return Proof(\n            amount=blind_signature.amount,\n            id=blind_signature.id,\n            secret=x,\n            C=C.to_bytes().hex()\n        )\n\ndef main():\n    relay = Relay()\n    user = User()\n    amount = 100\n    key_id, public_key_hex = relay.generate_keypair(amount)\n    print(f\"Relay generated keypair for amount {amount} with ID {key_id}\")\n\n    blinded_message = None\n    blind_signature = None\n    proof = None\n\n    while True:\n        print(\"\\n1. Blind\")\n        print(\"2. Sign\")\n        print(\"3. Unblind\")\n        print(\"4. Verify\")\n        print(\"5. Redeem\")\n        print(\"6. Exit\")\n        choice = input(\"Enter your choice: \")\n\n        if choice == '1':\n            blinded_message = user.blind(amount, key_id, public_key_hex)\n            print(f\"Blinded message: {blinded_message}\")\n        elif choice == '2':\n            if blinded_message is None:\n                print(\"Please blind a message first.\")\n            else:\n                blind_signature = relay.sign(blinded_message)\n                print(f\"Blind signature: {blind_signature}\")\n        elif choice == '3':\n            if blind_signature is None:\n                print(\"Please get a blind signature first.\")\n            else:\n                proof = user.unblind(blind_signature, blinded_message.B_)\n                print(f\"Proof: {proof}\")\n        elif choice == '4':\n            if proof is None:\n                print(\"Please unblind the signature first.\")\n            else:\n                is_valid = relay.verify(proof)\n                print(f\"Proof is valid: {is_valid}\")\n        elif choice == '5':\n            if proof is None:\n                print(\"Please unblind the signature first.\")\n            else:\n                is_spent = relay.redeem(proof)\n                print(f\"Token redeemed successfully: {is_spent}\")\n        elif choice == '6':\n            break\n        else:\n            print(\"Invalid choice. Please try again.\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis does not involve any custodians and users do not depsosit bitcoin for minting ecash. It can be gifted to other users. I plan to use it for incentivizing users and [market makers](https://uncensoredtech.substack.com/p/market-makers-in-joinstr) in joinstr can also offer discounts for regular users. \n\n**Alternative**\n\nNormal discount and promo codes can be used to achieve the same thing but ecash protocol improves privacy.",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 247,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}