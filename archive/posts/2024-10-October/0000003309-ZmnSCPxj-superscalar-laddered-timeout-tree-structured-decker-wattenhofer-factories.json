{
  "id": 3309,
  "name": "ZmnSCPxj jxPCSnmZ",
  "username": "ZmnSCPxj",
  "avatar_template": "/letter_avatar_proxy/v4/letter/z/ee7513/{size}.png",
  "created_at": "2024-10-02T16:41:04.524Z",
  "cooked": "<h1><a name=\"p-3309-wide-leaves-with-pseudo-spilman-multiparty-n2-channel-factories-1\" class=\"anchor\" href=\"#p-3309-wide-leaves-with-pseudo-spilman-multiparty-n2-channel-factories-1\"></a>Wide Leaves With Pseudo-Spilman Multiparty (N&gt;2) Channel Factories</h1>\n<p>Consider the following sub-tree:</p>\n<pre><code>                                    nSequence\n                                     +-----+---+\n                                     |     |A&amp;L| LN channel\n                        +--+-----+   |     +---+\n  nSequence           +&gt;|  |A&amp;B&amp;L|--&gt;| 432 |B&amp;L| LN channel\n   +-----+----------+ | +--+-----+   |     +---+\n   |     |  (A&amp;B&amp;L) |-+              |     | L | Liquidity stock\n   |     |or(L&amp;CLTV)|                +-----+---+\n--&gt;| 432 +----------+               nSequence\n   |     |  (C&amp;D&amp;L) |                +-----+---+\n   |     |or(L&amp;CLTV)|-+              |     |C&amp;L| LN channel\n   +-----+----------+ | +--+-----+   |     +---+\n                      +&gt;|  |C&amp;D&amp;L|--&gt;| 432 |D&amp;L| LN channel\n                        +--+-----+   |     +---+\n                                     |     | L | Liquidity stock\n                                     +-----+---+\n</code></pre>\n<p>The above is not quite what I showed earlier, but the only real\nchange is that the kickoff hosting the leaves have an arity of 1\nrather than 2, which I suggested earlier to provide better isolation\nof the pair <code>C</code> <code>D</code> from the pair <code>A</code> <code>B</code>.\nWe do have the option of having the kickoff transactions have an\narity of 2 or more for higher up in the tree, just as we might have\nhigher arities for state transactions at nodes higher up the tree.</p>\n<p>For the above sub-tree, we have the following operations that can\nbe done without touching the blockchain:</p>\n<ul>\n<li><code>A</code> can buy liquidity from the LSP if <code>B</code> and <code>L</code> are online.</li>\n<li><code>B</code> can buy liquidity from the LSP if <code>A</code> and <code>L</code> are online.</li>\n<li><code>C</code> can buy liquidity from the LSP if <code>D</code> and <code>L</code> are online.</li>\n<li><code>D</code> can buy liquidity from the LSP if <code>C</code> and <code>L</code> are online.</li>\n</ul>\n<p>Now, let me present an alternative implementation of the above\nsub-tree, that also allows the above operations, again without\ntouching the blockchain.\nThe advantage of the below is <em>the removal of one Decker-Wattenhofer\nlayer</em>, which translates to a reduction in the maximum total\nrelative locktime (<code>nSequence</code>).</p>\n<pre><code>   +-----+----------+\n   |     |    A&amp;L   | LN channel\n   |     +----------+\n   |     |    B&amp;L   | LN channel\n   |     +----------+\n   |     |  (A&amp;B&amp;L) | Liquidity stock (A&amp;B)\n   |     |or(L&amp;CLTV)|\n--&gt;| 432 +----------+\n   |     |    C&amp;L   | LN channel\n   |     +----------+\n   |     |    D&amp;L   | LN channel\n   |     +----------+\n   |     |  (C&amp;D&amp;L) | Liquidity stock (C&amp;D)\n   |     |or(L&amp;CLTV)|\n   +-----+----------+\n</code></pre>\n<p>How does <code>A</code> (<code>B</code> <code>C</code> <code>D</code>) buy liquidity from <code>L</code> in the above\nscheme?\nLike so:</p>\n<pre><code>   +-----+----------+\n   |     |    A&amp;L   |\n   |     +----------+\n   |     |    B&amp;L   |   +--+----------+\n   |     +----------+   |  |    A&amp;L   |\n   |     |  (A&amp;B&amp;L) |--&gt;|  +----------+\n   |     |or(L&amp;CLTV)|   |  |  (A&amp;B&amp;L) |\n--&gt;| 432 +----------+   |  |or(L&amp;CLTV)|\n   |     |    C&amp;L   |   +--+----------+\n   |     +----------+\n   |     |    D&amp;L   |\n   |     +----------+\n   |     |  (C&amp;D&amp;L) |\n   |     |or(L&amp;CLTV)|\n   +-----+----------+\n</code></pre>\n<p>The new transaction takes the <code>A &amp; B &amp; L</code> branch.\n(In the case that the LSP incentivizes <code>B</code> to join the signing\nsession by providing a small amount of free inbound liquidity,\nwe \u201csimply\u201d add another <code>B &amp; L</code> output as an extra channel.)</p>\n<p>The above is remniscient of Spilman channels; the output here is\nsemantically owned by <code>L</code>, and <code>L</code> may reduce its allocation of\nfunds to give more funds (or in this use-case, inbound liquidity)\nto the other participants.</p>\n<p>However, a difference with the above vs <em><strong>real</strong></em> Spilman channels\nis when <code>A</code> buys liquidity again:</p>\n<pre><code>   +-----+----------+\n   |     |    A&amp;L   |\n   |     +----------+\n   |     |    B&amp;L   |   +--+----------+\n   |     +----------+   |  |    A&amp;L   |   +--+----------+\n   |     |  (A&amp;B&amp;L) |--&gt;|  +----------+   |  |    A&amp;L   |\n   |     |or(L&amp;CLTV)|   |  |  (A&amp;B&amp;L) |--&gt;|  +----------+\n--&gt;| 432 +----------+   |  |or(L&amp;CLTV)|   |  |  (A&amp;B&amp;L) |\n   |     |    C&amp;L   |   +--+----------+   |  |or(L&amp;CLTV)|\n   |     +----------+                     +--+----------+\n   |     |    D&amp;L   |\n   |     +----------+\n   |     |  (C&amp;D&amp;L) |\n   |     |or(L&amp;CLTV)|\n   +-----+----------+\n</code></pre>\n<p>In a <em><strong>real</strong></em> Spilman channel, <code>L</code> would have simply replaced\nthe previous transaction with a new one.\nHowever, direct replacement is unsafe when there are more than 2\nparticipants, because the other participants could actually be\nsockpuppets of <code>L</code>.\nIn that case, <code>L</code> can get a complete set of signatures for all\nversions of the transaction, including older versions of the\ntransaction, and can bribe a miner to confirm the older version.\nThus, this scheme is not a true Spilman channel factory.</p>\n<p>Instead, the above scheme forces the LSP to only spend\neach of the liquidity stock UTXOs at most once, and protects\nagainst double-spending by clients simply refusing to sign for a\ntransaction that spends an already-used liquidity stock UTXO.\nEven if the other participants are sockpuppets of <code>L</code>, as long\nas the buying participant is a signatory, it can ensure the\ncorrect operation of the scheme.</p>\n<p>The major advantage of this wide leaf is that it provides the\nsame basic liquidity purchase operations as the first sub-tree\nshown earlier, but with one less Decker-Wattenhofer layer.\nEach layer of Decker-Wattenhofer is a liability even if the\nconstruction never hits the blockchain, because each\nDecker-Wattenhofer layer adds more relative locktimes.\nAny hosted HTLCs or PTLCs would need a CLTV-delta that is at\nleast the total maximum Decker-Wattenhofer locktime, plus any\nmargin deemed necessary by the receiving side;\nif the remaining time in a pending HTLC or PTLC is less than\nthe current Decker-Wattenhofer locktime plus margin, participants\n<em><strong>MUST</strong></em> drop the construction onchain, which is expensive and\ntime-consuming due to the larger participant set.\nThus, reducing the worst-case Decker-Wattenhofer locktime\nis always an advantage, as it helps avoid unilateral closes.</p>\n<p>If a client has ever bought liquidity, then its unilateral\nclose involves more bytes on the blockchain.\nThis is a distinct disadvantage over the original sub-tree.\nIn addition, because the new inbound liquidity is in a new\nchannel, forwarded HTLCs from the LSP to client may need to\nbe split at that hop (i.e. local multipath).</p>\n<p>Further, this additional complexity with managing liquidity\ncompounds.\nIf the wide leaf is replaced entirely (for instance, if the\nliquidity stock for <code>A</code> and <code>B</code> runs out and the LSP wants to\nmove some of the stock from <code>C</code> and <code>D</code>), it would be advantageous\nto cut-through all the dependent transactions that give\nadditional channels to the buying client <code>A</code>, creating just a\nsingle channel.\nThis means that any hosted HTLCs would need to be put in the\nsame single new channel in the new state, effectively merging\nthe pending HTLC sets.</p>\n<h2><a name=\"p-3309-against-internal-splicing-2\" class=\"anchor\" href=\"#p-3309-against-internal-splicing-2\"></a>Against Internal Splicing</h2>\n<p>In this scheme, as noted, the LSP creates a new channel to the\nclient instead of increasing the capacity of the existing channel\ninside the construction.\nThis adds complications, in that HTLCs forwarded from the LSP to\nthe client may need to be split among the multiple channels.\nWe might wonder if we could instead splice, so that there is only\none liquidity \u201cbag\u201d for the HTLCs.</p>\n<p>Suppose that the LSP has the policy that incentivizes <code>B</code> to\nparticipate in signing sessions by giving <code>B</code> a small amount of\nfree inbound liquidity whenever it is online to assist the\npurchase of <code>A</code> of inbound liquidity.\nIn that case, the splice transaction would spend the <code>A &amp; L</code> and\n<code>B &amp; L</code> outputs.</p>\n<p>However, suppose in addition that <code>B</code> is actually a sockpuppet of\nthe LSP.\nIn that case, the LSP can trivially invalidate the splice transaction\nby simply spending from the <code>B &amp; L</code> output, as it is actually in\npossession of both keys.</p>\n<p>The same may happen even if the LSP does <em><strong>not</strong></em> have a policy\nof incentivizing signing sessions by offering free inbound\nliquidity.\nIf <code>B</code> purchases inbound liquidity first (or rather, the LSP emulates\n<code>B</code> purchasing inbound liquidity) and <em>then</em> <code>A</code> buys inbound\nliquidity, then again the splice of the <code>A &amp; L</code> channel is dependent\non the <code>B &amp; L</code> output, and if <code>B</code> is actually a sockpuppet of the LSP,\nthen this is still a way for the LSP to clawback the sold liquidity.</p>\n<p>Thus, it is not safe to use internal splicing inside offchain\nmechanisms; we should use cut-through instead when transaction\nreplacement is possible (which is not true in this scheme; it is\ndependent on a parent node being able to perform replacement).\nSplicing in general is only safe if confirmed onchain.</p>\n<h2><a name=\"p-3309-incentivizing-lsp-pays-mining-fee-3\" class=\"anchor\" href=\"#p-3309-incentivizing-lsp-pays-mining-fee-3\"></a>Incentivizing LSP-pays-mining-fee</h2>\n<p>An important model here is that clients may not have onchain\nUTXOs with which to pay for unilateral exit.\nOne may consider this scheme, as well as related schemes, as ways\nfor a client to build up their Bitcoin HODLings without having an\nonchain UTXO, but with an assurance that the service provider has\nno incentive to rug their funds until they have accumulated enough\nto own their own unique UTXO.</p>\n<p>The unilateral exit is, in effect, a proof-of-liabilities that is\npublishable onchain, to prevent the LSP from rugging the client.</p>\n<p>Thus, this scheme also provides an \u201cassisted exit\u201d where, in\nexchange for the client keys in this construction, the LSP assists\nthe client to get an onchain UTXO, or to move to a new factory in\nthe ladder.\nThis is done by using PTLCs to swap, with the scalar being the\nprivate key.</p>\n<p>The assisted exit is part of the protocol so that the LSP has an\nincentive to retain clients in the mechanism, until the clients\nhave performed an assisted exit.</p>\n<ul>\n<li>If all clients have performed an assisted exit from one of the\nfactories, the LSP can immediately reclaim the funds in the\nfactory, even before the timeout.\n<ul>\n<li>Even if some clients do not perform an assisted exit, the LSP\ncan, at its option (i.e. if onchain fees are low) perform a\npartial unilateral exit to reclaim funds from subsets of the\nparticipating clients.</li>\n</ul>\n</li>\n</ul>\n<p>Our goal is that, if the client is unsatisfied with the performance\nof the LSP, the client can perform a unilateral exit at the\nexpense of the LSP.</p>\n<p>Crucially, as we update offchain, the LSP has an incentive to\nclaw back its funds in case of a unilateral exit, by waiting for\nolder states to be publishable onchain (by the Decker-Wattenhofer\nmechanism) and then paying to have that confirmed.\nIf clients do not have an existing onchain UTXO with which to\npay fees, and all their Bitcoins are held in a shared UTXO with\nthe LSP, then the clients will not be able to have the newer states\nconfirmed.</p>\n<p>Our exact scheme for the not-really-Spilman factory is thus:</p>\n<ul>\n<li>All clients in the liquidity stock sign <em>two</em> transactions\nspending the liquidity stock:\n<ul>\n<li>One is the transaction we showed above, funding new client\nchannel(s) and an optional change output that is the new\nliquidity stock.\n<ul>\n<li>This transaction is <code>nVersion=3</code>, has 0 fee, and has a\nP2A output for feebumping.</li>\n<li>Call this the \u201cstate\u201d transaction.</li>\n</ul>\n</li>\n<li>Another version is a <code>nLockTime</code>d transaction, with timelock\nequal to the timeout of the tree, and with a single <code>OP_RETURN</code>\noutput.\n<ul>\n<li>Care must be take to respect minimum transaction size\n(65 bytes in txid format).</li>\n<li>Also has <code>nVersion=3</code>, but its fee is effectively the entire\nvalue of the liquidity stock.</li>\n<li>Call this the \u201cburn\u201d transaction.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>The liquidity stock output of the wide leaf has effectively two\nstates:</p>\n<ul>\n<li>The original starting state where it is owned semantically by\nthe LSP, but is claimable at the end of the tree timeout.</li>\n<li>The new state where part of the fund is allocated to a new\nchannel with a client.</li>\n</ul>\n<p>The LSP may attempt to claw back the original state by simply\nnot feebumping the 0-fee state transaction.\nHowever, if so, the clients can retaliate by simply publishing\nthe burn transaction.\nDue to its small size, it is very difficult for the LSP to\nreplace it with a higher-fee transaction; it can only do so by\neffectively spending more than the actual original liquidity\nstock.\nIf so, the LSP has incentive to always publish \u2014 and pay for\nconfirmation of \u2014 the correct latest state, as it ends up\nsaving more money that way.</p>\n<p>As practical consideration, the actual <code>L &amp; CLTV</code> locktime should\nbe a little later than the formal end of the timeout tree, while\nthe burn transaction should have the <code>nLockTime</code> of the timeout\ntree.</p>",
  "post_number": 16,
  "post_type": 1,
  "updated_at": "2024-10-02T16:41:04.524Z",
  "reply_count": 1,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 15,
  "reads": 12,
  "readers_count": 11,
  "score": 77.4,
  "yours": false,
  "topic_id": 1143,
  "topic_slug": "superscalar-laddered-timeout-tree-structured-decker-wattenhofer-factories",
  "topic_title": "SuperScalar: Laddered Timeout-Tree-Structured Decker-Wattenhofer Factories",
  "topic_html_title": "SuperScalar: Laddered Timeout-Tree-Structured Decker-Wattenhofer Factories",
  "category_id": 7,
  "display_username": "ZmnSCPxj jxPCSnmZ",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Wide Leaves With Pseudo-Spilman Multiparty (N>2) Channel Factories\n==================================================================\n\nConsider the following sub-tree:\n\n                                        nSequence\n                                         +-----+---+\n                                         |     |A&L| LN channel\n                            +--+-----+   |     +---+\n      nSequence           +>|  |A&B&L|-->| 432 |B&L| LN channel\n       +-----+----------+ | +--+-----+   |     +---+\n       |     |  (A&B&L) |-+              |     | L | Liquidity stock\n       |     |or(L&CLTV)|                +-----+---+\n    -->| 432 +----------+               nSequence\n       |     |  (C&D&L) |                +-----+---+\n       |     |or(L&CLTV)|-+              |     |C&L| LN channel\n       +-----+----------+ | +--+-----+   |     +---+\n                          +>|  |C&D&L|-->| 432 |D&L| LN channel\n                            +--+-----+   |     +---+\n                                         |     | L | Liquidity stock\n                                         +-----+---+\n\nThe above is not quite what I showed earlier, but the only real\nchange is that the kickoff hosting the leaves have an arity of 1\nrather than 2, which I suggested earlier to provide better isolation\nof the pair `C` `D` from the pair `A` `B`.\nWe do have the option of having the kickoff transactions have an\narity of 2 or more for higher up in the tree, just as we might have\nhigher arities for state transactions at nodes higher up the tree.\n\nFor the above sub-tree, we have the following operations that can\nbe done without touching the blockchain:\n\n* `A` can buy liquidity from the LSP if `B` and `L` are online.\n* `B` can buy liquidity from the LSP if `A` and `L` are online.\n* `C` can buy liquidity from the LSP if `D` and `L` are online.\n* `D` can buy liquidity from the LSP if `C` and `L` are online.\n\nNow, let me present an alternative implementation of the above\nsub-tree, that also allows the above operations, again without\ntouching the blockchain.\nThe advantage of the below is *the removal of one Decker-Wattenhofer\nlayer*, which translates to a reduction in the maximum total\nrelative locktime (`nSequence`).\n\n       +-----+----------+\n       |     |    A&L   | LN channel\n       |     +----------+\n       |     |    B&L   | LN channel\n       |     +----------+\n       |     |  (A&B&L) | Liquidity stock (A&B)\n       |     |or(L&CLTV)|\n    -->| 432 +----------+\n       |     |    C&L   | LN channel\n       |     +----------+\n       |     |    D&L   | LN channel\n       |     +----------+\n       |     |  (C&D&L) | Liquidity stock (C&D)\n       |     |or(L&CLTV)|\n       +-----+----------+\n\nHow does `A` (`B` `C` `D`) buy liquidity from `L` in the above\nscheme?\nLike so:\n\n       +-----+----------+\n       |     |    A&L   |\n       |     +----------+\n       |     |    B&L   |   +--+----------+\n       |     +----------+   |  |    A&L   |\n       |     |  (A&B&L) |-->|  +----------+\n       |     |or(L&CLTV)|   |  |  (A&B&L) |\n    -->| 432 +----------+   |  |or(L&CLTV)|\n       |     |    C&L   |   +--+----------+\n       |     +----------+\n       |     |    D&L   |\n       |     +----------+\n       |     |  (C&D&L) |\n       |     |or(L&CLTV)|\n       +-----+----------+\n\nThe new transaction takes the `A & B & L` branch.\n(In the case that the LSP incentivizes `B` to join the signing\nsession by providing a small amount of free inbound liquidity,\nwe \"simply\" add another `B & L` output as an extra channel.)\n\nThe above is remniscient of Spilman channels; the output here is\nsemantically owned by `L`, and `L` may reduce its allocation of\nfunds to give more funds (or in this use-case, inbound liquidity)\nto the other participants.\n\nHowever, a difference with the above vs ***real*** Spilman channels\nis when `A` buys liquidity again:\n\n       +-----+----------+\n       |     |    A&L   |\n       |     +----------+\n       |     |    B&L   |   +--+----------+\n       |     +----------+   |  |    A&L   |   +--+----------+\n       |     |  (A&B&L) |-->|  +----------+   |  |    A&L   |\n       |     |or(L&CLTV)|   |  |  (A&B&L) |-->|  +----------+\n    -->| 432 +----------+   |  |or(L&CLTV)|   |  |  (A&B&L) |\n       |     |    C&L   |   +--+----------+   |  |or(L&CLTV)|\n       |     +----------+                     +--+----------+\n       |     |    D&L   |\n       |     +----------+\n       |     |  (C&D&L) |\n       |     |or(L&CLTV)|\n       +-----+----------+\n\nIn a ***real*** Spilman channel, `L` would have simply replaced\nthe previous transaction with a new one.\nHowever, direct replacement is unsafe when there are more than 2\nparticipants, because the other participants could actually be\nsockpuppets of `L`.\nIn that case, `L` can get a complete set of signatures for all\nversions of the transaction, including older versions of the\ntransaction, and can bribe a miner to confirm the older version.\nThus, this scheme is not a true Spilman channel factory.\n\nInstead, the above scheme forces the LSP to only spend\neach of the liquidity stock UTXOs at most once, and protects\nagainst double-spending by clients simply refusing to sign for a\ntransaction that spends an already-used liquidity stock UTXO.\nEven if the other participants are sockpuppets of `L`, as long\nas the buying participant is a signatory, it can ensure the\ncorrect operation of the scheme.\n\nThe major advantage of this wide leaf is that it provides the\nsame basic liquidity purchase operations as the first sub-tree\nshown earlier, but with one less Decker-Wattenhofer layer.\nEach layer of Decker-Wattenhofer is a liability even if the\nconstruction never hits the blockchain, because each\nDecker-Wattenhofer layer adds more relative locktimes.\nAny hosted HTLCs or PTLCs would need a CLTV-delta that is at\nleast the total maximum Decker-Wattenhofer locktime, plus any\nmargin deemed necessary by the receiving side;\nif the remaining time in a pending HTLC or PTLC is less than\nthe current Decker-Wattenhofer locktime plus margin, participants\n***MUST*** drop the construction onchain, which is expensive and\ntime-consuming due to the larger participant set.\nThus, reducing the worst-case Decker-Wattenhofer locktime\nis always an advantage, as it helps avoid unilateral closes.\n\nIf a client has ever bought liquidity, then its unilateral\nclose involves more bytes on the blockchain.\nThis is a distinct disadvantage over the original sub-tree.\nIn addition, because the new inbound liquidity is in a new\nchannel, forwarded HTLCs from the LSP to client may need to\nbe split at that hop (i.e. local multipath).\n\nFurther, this additional complexity with managing liquidity\ncompounds.\nIf the wide leaf is replaced entirely (for instance, if the\nliquidity stock for `A` and `B` runs out and the LSP wants to\nmove some of the stock from `C` and `D`), it would be advantageous\nto cut-through all the dependent transactions that give\nadditional channels to the buying client `A`, creating just a\nsingle channel.\nThis means that any hosted HTLCs would need to be put in the\nsame single new channel in the new state, effectively merging\nthe pending HTLC sets.\n\nAgainst Internal Splicing\n-------------------------\n\nIn this scheme, as noted, the LSP creates a new channel to the\nclient instead of increasing the capacity of the existing channel\ninside the construction.\nThis adds complications, in that HTLCs forwarded from the LSP to\nthe client may need to be split among the multiple channels.\nWe might wonder if we could instead splice, so that there is only\none liquidity \"bag\" for the HTLCs.\n\nSuppose that the LSP has the policy that incentivizes `B` to\nparticipate in signing sessions by giving `B` a small amount of\nfree inbound liquidity whenever it is online to assist the\npurchase of `A` of inbound liquidity.\nIn that case, the splice transaction would spend the `A & L` and\n`B & L` outputs.\n\nHowever, suppose in addition that `B` is actually a sockpuppet of\nthe LSP.\nIn that case, the LSP can trivially invalidate the splice transaction\nby simply spending from the `B & L` output, as it is actually in\npossession of both keys.\n\nThe same may happen even if the LSP does ***not*** have a policy\nof incentivizing signing sessions by offering free inbound\nliquidity.\nIf `B` purchases inbound liquidity first (or rather, the LSP emulates\n`B` purchasing inbound liquidity) and *then* `A` buys inbound\nliquidity, then again the splice of the `A & L` channel is dependent\non the `B & L` output, and if `B` is actually a sockpuppet of the LSP,\nthen this is still a way for the LSP to clawback the sold liquidity.\n\nThus, it is not safe to use internal splicing inside offchain\nmechanisms; we should use cut-through instead when transaction\nreplacement is possible (which is not true in this scheme; it is\ndependent on a parent node being able to perform replacement).\nSplicing in general is only safe if confirmed onchain.\n\nIncentivizing LSP-pays-mining-fee\n---------------------------------\n\nAn important model here is that clients may not have onchain\nUTXOs with which to pay for unilateral exit.\nOne may consider this scheme, as well as related schemes, as ways\nfor a client to build up their Bitcoin HODLings without having an\nonchain UTXO, but with an assurance that the service provider has\nno incentive to rug their funds until they have accumulated enough\nto own their own unique UTXO.\n\nThe unilateral exit is, in effect, a proof-of-liabilities that is\npublishable onchain, to prevent the LSP from rugging the client.\n\nThus, this scheme also provides an \"assisted exit\" where, in\nexchange for the client keys in this construction, the LSP assists\nthe client to get an onchain UTXO, or to move to a new factory in\nthe ladder.\nThis is done by using PTLCs to swap, with the scalar being the\nprivate key.\n\nThe assisted exit is part of the protocol so that the LSP has an\nincentive to retain clients in the mechanism, until the clients\nhave performed an assisted exit.\n\n* If all clients have performed an assisted exit from one of the\n  factories, the LSP can immediately reclaim the funds in the\n  factory, even before the timeout.\n  * Even if some clients do not perform an assisted exit, the LSP\n    can, at its option (i.e. if onchain fees are low) perform a\n    partial unilateral exit to reclaim funds from subsets of the\n    participating clients.\n\nOur goal is that, if the client is unsatisfied with the performance\nof the LSP, the client can perform a unilateral exit at the\nexpense of the LSP.\n\nCrucially, as we update offchain, the LSP has an incentive to\nclaw back its funds in case of a unilateral exit, by waiting for\nolder states to be publishable onchain (by the Decker-Wattenhofer\nmechanism) and then paying to have that confirmed.\nIf clients do not have an existing onchain UTXO with which to\npay fees, and all their Bitcoins are held in a shared UTXO with\nthe LSP, then the clients will not be able to have the newer states\nconfirmed.\n\nOur exact scheme for the not-really-Spilman factory is thus:\n\n* All clients in the liquidity stock sign *two* transactions\n  spending the liquidity stock:\n  * One is the transaction we showed above, funding new client\n    channel(s) and an optional change output that is the new\n    liquidity stock.\n    - This transaction is `nVersion=3`, has 0 fee, and has a\n      P2A output for feebumping.\n    - Call this the \"state\" transaction.\n  * Another version is a `nLockTime`d transaction, with timelock\n    equal to the timeout of the tree, and with a single `OP_RETURN`\n    output.\n    - Care must be take to respect minimum transaction size\n      (65 bytes in txid format).\n    - Also has `nVersion=3`, but its fee is effectively the entire\n      value of the liquidity stock.\n    - Call this the \"burn\" transaction.\n\nThe liquidity stock output of the wide leaf has effectively two\nstates:\n\n* The original starting state where it is owned semantically by\n  the LSP, but is claimable at the end of the tree timeout.\n* The new state where part of the fund is allocated to a new\n  channel with a client.\n\nThe LSP may attempt to claw back the original state by simply\nnot feebumping the 0-fee state transaction.\nHowever, if so, the clients can retaliate by simply publishing\nthe burn transaction.\nDue to its small size, it is very difficult for the LSP to\nreplace it with a higher-fee transaction; it can only do so by\neffectively spending more than the actual original liquidity\nstock.\nIf so, the LSP has incentive to always publish --- and pay for\nconfirmation of --- the correct latest state, as it ends up\nsaving more money that way.\n\nAs practical consideration, the actual `L & CLTV` locktime should\nbe a little later than the formal end of the timeout tree, while\nthe burn transaction should have the `nLockTime` of the timeout\ntree.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 104,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}