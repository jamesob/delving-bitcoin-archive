{
  "id": 3457,
  "name": null,
  "username": "JohnLaw",
  "avatar_template": "/letter_avatar_proxy/v4/letter/j/58956e/{size}.png",
  "created_at": "2024-10-31T22:45:07.504Z",
  "cooked": "<p>The security of all known Lightning payment protocols breaks down when the incremental cost of resolving a payment on-chain exceeds the value of the payment.</p>\n<p>For example, if Alice uses the current Lightning protocol to offer an HTLC to Bob, and Bob fulfills the HTLC by providing the required hash preimage before its expiry, Alice is supposed to update the channel state off-chain to reflect the payment of the HTLC to Bob.\nHowever, if Alice fails to do so, Bob\u2019s only recourse is to put an HTLC-success transaction on-chain.\nIf the cost of putting the HTLC-success transaction on-chain exceeds the value of the payment, resolving the HTLC on-chain is more costly for Bob than allowing Alice to claim the payment.\nTherefore, Alice is incentivized to violate the protocol by not giving the payment\u2019s funds to Bob off-chain, as she will receive those funds unless Bob acts against his immediate self-interest.</p>\n<p>This post presents a new Lightning payment resolution protocol, called the Off-chain Payment Resolution (OPR) protocol, that has the following properties:</p>\n<ol>\n<li>all payments are resolved correctly, provided both parties are self-interested and able to implement the protocol, regardless of how small the payment is,</li>\n<li>all payments are resolved within seconds (as compared to hours for the current protocol),</li>\n<li>there is never a need for a party to go on-chain to resolve a payment (thus greatly improving scalability), and</li>\n<li>casual users can send and receive payments without having a watchtower service (and without maintaining high availability).</li>\n</ol>\n<p>As a result, the OPR protocol appears to be well-suited to supporting small, everyday Lightning payments.\nIn addition, the OPR protocol can be used for large payments, either directly or by dividing the large payment into many smaller ones.</p>\n<p>The OPR protocol has weaker security than a trust-free protocol (in which one cannot lose funds if they follow the protocol), but stronger than a trust-based protocol (in which one\u2019s funds can be stolen).\nThe OPR protocol is a <em>griefer-penalized</em> protocol, as an honest party can be made to lose certain funds by a dishonest channel partner who griefs them.\nHowever, the griefer also has to lose a comparable amount of funds.\nAs a result, an honest party who only creates channels with self-interested parties will never be subject to a griefing attack.</p>\n<p>A more complete description, including figures, is given in a paper [14].</p>\n<h1><a name=\"p-3457-security-of-the-current-lightning-protocol-1\" class=\"anchor\" href=\"#p-3457-security-of-the-current-lightning-protocol-1\"></a>Security Of The Current Lightning Protocol</h1>\n<p>As noted above, with the current Lightning protocol an offeree of an HTLC may be forced to put an HTLC-success transaction on-chain.\nThe HTLC-success transaction requires about 702 vbytes [3], and the additional input in the transaction that spends the HTLC-sucess transaction\u2019s output requires about 316 vbytes, for a total of about 1018 incremental vbytes to claim a payment on-chain.\nAssuming $50k per BTC and the historically common fee rates of 10 sat/vbyte to 100 sat/vbyte [17], the incremental cost for claiming a payment on-chain is in the range of $5 to $50.</p>\n<p>Of course, even if the incremental cost of claiming a payment exceeds the value of the payment, that doesn\u2019t mean that all Lightning nodes will try to steal the payment.\nFor example, the expected value of future routing fees could exceed the value of the currently-outstanding small payments, thus preventing thefts.\nAlso, there are significant software engineering barriers to stealing small payments, as the offeree of an HTLC <em>will</em> choose to lose funds by securing a small payment on-chain if the offeree is running standard software that implements the Lightning protocol.</p>\n<p>On the other hand, there are situations where the current Lightning protocol could lead to an attempt to steal funds.\nFor example, if Alice wants to close a channel with Bob, she could create one large payment and very many small payments for which Alice offers Bob HTLCs.\nNext, Alice stops responding to Bob\u2019s messages after receiving the HTLCs\u2019 hash preimages.\nAs a result, Bob will put his Commitment transaction and the large payment\u2019s HTLC-success transaction on-chain.\nIn addition, Bob must either lose funds by claiming all of the small payments on-chain, or forfeit those payments to Alice.</p>\n<p>This attack is costless for Alice, has at least some possibility of allowing her to steal funds, appears to be due to an involuntary failure (rather than malicious behavior), and is performed when she no longer needs to maintain her reputation with Bob in order to obtain future routing fees.</p>\n<h1><a name=\"p-3457-off-chain-payment-resolution-opr-protocol-2\" class=\"anchor\" href=\"#p-3457-off-chain-payment-resolution-opr-protocol-2\"></a>Off-chain Payment Resolution (OPR) Protocol</h1>\n<p>The OPR protocol operates in conjunction with a channel protocol that creates a series of signed off-chain transactions reflecting the current channel state.\nOld channel states can be replaced by a new channel state via a revocation key (as in the current Lightning protocol [2]) or a per-commitment key (as in the Tunable Penalty [9] or Fully-Factory-Optimized protocol [10]).\nThe details of how to maintain the channel state are presented in the paper [14].</p>\n<p>When the channel is created, each party gets signed transactions with three outputs, one of which pays to each party, with the third one being a <em>burn output</em>.\nThe burn output pays to anyone after a 20-year delay (so the burn output will be claimed by a miner 20 years in the future).\nEach party must contribute a fixed amount (called \u201cbase funds\u201d) to the burn output.</p>\n<p>In order to route a new payment, an HTLC is created for the amount of the payment plus routing fees.\nEach party gets new channel state transactions where the value of the HTLC is moved from the offerer\u2019s output to the burn output.\nIn addition, each party adds a fixed fraction of the value of the HTLC (called \u201cmatching funds\u201d) to the burn output.</p>\n<p>As in the current Lightning protocol, the HTLC pays to the offeree only if the offeree provides the offerer with a hash preimage before the HTLC\u2019s expiry.\nHowever, the expiry is set at most seconds in the future, based on the parties\u2019 htlc_expiry_delta_msec and min_final_expiry_delta_msec parameters.\nThese parameters are set to provide enough time to resolve the HTLC off-chain by receiving an update_fulfill_htlc or update_fail_htlc message, signing updated channel state transactions, and propagating the payment resolution to the upstream channel.\nThese parameters also include buffers for communication and computation delays caused by unusually heavy traffic, but they <em>do not</em> include time for putting channel state transactions on-chain.</p>\n<p>If an HTLC is resolved successfully before its expiry, the HTLC\u2019s funds are moved to the offeree\u2019s output and both parties\u2019 matching funds for the HTLC are returned to them.\nIf an HTLC fails, the HTLC\u2019s funds are moved to the offerer\u2019s output and both parties\u2019 matching funds for the HTLC are returned to them.</p>\n<p>As long as both parties agree on whether the HTLC succeeded or failed, they will agree on the new channel state transactions that resolve the HTLC and they will both get back their matching funds for the HTLC.\nFinally, if both parties agree on the resolution of all HTLCs and they want to close the channel, they can create a Cooperative Close transaction that returns their base funds to them and eliminates the burn output.</p>\n<h1><a name=\"p-3457-burned-funds-3\" class=\"anchor\" href=\"#p-3457-burned-funds-3\"></a>Burned Funds</h1>\n<p>There are three ways in which a party that follows the OPR protocol can be forced to burn funds.</p>\n<p>First, a dishonest channel partner can put channel state transactions with a burn output on-chain in order to grief their partner (while also griefing themselves).\nIn this case, the griefer loses (at least) their base and matching funds, which are set high enough to discourage most or all such griefing attacks.\nSpecifically, if each party devotes a fraction m of the HTLC amount as matching funds, the griefer must lose at least m/(1+m) as many funds as their partner loses (and at least their base funds).</p>\n<p>Second, if an honest party\u2019s channel partner completely fails and can\u2019t update the channel state for a very long time (e.g., months), the honest party can be forced to close the channel unilaterally by putting their channel state transactions with a burn output on-chain.\nThe amount of time an honest party is willing to wait is based on the likelihood of their partner becoming responsive versus the cost of the channel\u2019s capital, and is independent of the lengths of the HTLCs\u2019 expiries.</p>\n<p>Third, if both parties are honest but they fail in such a way that they don\u2019t agree on the resolution of an HTLC, they will be forced to burn the HTLC\u2019s funds and their base and matching funds.\nFortunately, there are many techniques that reduce the likelihood of such failures.</p>\n<p>In order to determine if an HTLC was resolved successfully, a node has to determine if the required hash preimage was provided before the HTLC\u2019s expiry.\nAll hash preimage messages can include a time stamp recording when they were sent, and each node can keep a time-stamped nonvolatile log of each hash preimage that it sends or receives.\nThis log can be used to determine the result of an HTLC, even if the node crashes when the HTLC was being resolved.\nChannel partners can keep their clocks synchronized by exchanging frequent time stamp messages, and the htlc_expiry_delta_msec parameters can include a buffer for clock skew.</p>\n<p>The greatest challenge in getting agreement on whether or not an HTLC was resolved successfully occurs when the offeree sends the hash preimage before the expiry, but the offerer doesn\u2019t receive the preimage until after the expiry.\nThis case can be made less frequent by calculating the maximum communication latency L between channel partners and never sending a hash preimage less than L before the HTLC\u2019s expiry,</p>\n<p>Also, multiple encrypted copies of hash preimage messages can be sent using different communication paths.\nIf all of these multiple copies are sent but fail to reach the offerer before the HTLC\u2019s expiry, it\u2019s likely there was either a complete loss of communication by the offeree or a failure of the offerer.\nThese cases can be differentiated by looking at the nonvolatile logs for the nodes\u2019 other channels.\nFor example, if a node has 20 channels with different partners and stops receiving time-stamped messages from just one of those partners, they can conclude that the failure was likely caused by that partner.\nOn the other hand, if the node stops receiving time-stamped messages on all 20 channels, the node can conclude that it is likely the cause of the failures.</p>\n<h1><a name=\"p-3457-htlc-failures-4\" class=\"anchor\" href=\"#p-3457-htlc-failures-4\"></a>HTLC Failures</h1>\n<p>In addition to the risk of burning funds, a routing node can lose funds if it causes an HTLC to fail.</p>\n<p>If a node failure prevents it from fulfilling an upstream HTLC, the node will lose the value of the HTLC because it\u2019s still liable for paying the corresponding downstream HTLC.\nThe risk of losing HTLC funds by having to pay a downstream HTLC without receiving an upstream HTLC exists in the current Lightning protocol.\nHowever, the OPR protocol greatly increases this risk because it commits the node to delaying the resolution of the HTLC by at most seconds, as opposed to hours in the current Lightning protocol.</p>\n<p>This risk is covered by Lightning routing fees, so it\u2019s worth quantifying the risk in order to determine whether or not those fees will be prohibitive.\nIf we assume the average incremental latency required to resolve an HTLC is 100 milliseconds and the average payment traverses 11 hops, each HTLC will be resolved an average of 600 milliseconds after it\u2019s created.\nIf each node fails (due to a crash, delay, or protocol error) randomly 10 times a day, thus causing it to lose the value of all unresolved HTLCs, that node will lose the value of one out of every 14,400 HTLCs.\nTherefore, increasing the routing fee by 1/14,400 = 0.007% of the HTLC value per node (and thus 0.077% per payment) will cover the cost of node failures that cause HTLC failures.</p>\n<p>As a result, it seems plausible that the OPR protocol could be used to implement fast off-chain payments without imposing excessive routing fees.</p>\n<h1><a name=\"p-3457-bullying-5\" class=\"anchor\" href=\"#p-3457-bullying-5\"></a>Bullying</h1>\n<p>Finally, a party can lose funds if they can be psychologically manipulated to allow their partner to steal from them.\nFor example, if Alice and Bob should each receive two million sats from the burn output, Bob could refuse to update the channel state unless he gets three million sats from the burn output (and Alice could agree in order to at least get the remaining one million sats).</p>\n<p>This type of bullying attack can be prevented by ensuring that all channel updates are performed automatically, rather than under human control.</p>\n<h1><a name=\"p-3457-scalability-6\" class=\"anchor\" href=\"#p-3457-scalability-6\"></a>Scalability</h1>\n<p>The OPR protocol has remarkable scaling properties.</p>\n<p>First, the addition of an HTLC to a channel doesn\u2019t add any outputs to the channel state transactions.\nAs a result, even if the channel state is put on-chain, there\u2019s no incremental on-chain footprint due to the HTLC.\nIn addition, there\u2019s no protocol-defined upper bound on the number of active HTLCs per channel.</p>\n<p>Second, the OPR protocol\u2019s resolution of an HTLC never requires any transactions to be put on-chain.\nThis is extremely important for scalability, as channel factories [1][4][11] and timeout-trees [7][13] have been proposed for opening and closing channels off-chain, and hierarchical channels [12] have been proposed for resizing channels off-chain.\nAs a result, without the OPR protocol, the on-chain resolution of HTLCs is likely to be the greatest limitation to Lightning\u2019s scalability.</p>\n<h1><a name=\"p-3457-usability-7\" class=\"anchor\" href=\"#p-3457-usability-7\"></a>Usability</h1>\n<p>The OPR protocol\u2019s guaranteed resolution of a payment attempt within seconds makes it much more attractive to casual users than the current Lightning protocol, which could require waiting hours to find out that a payment attempt failed.\nThe fact that the payment\u2019s receiver never has to go on-chain to resolve the payment means that the OPR protocol supports one-shot receives [8].\nAsynchronous trampoline payments (as described in Section 3.6 of [8]) can be used for payments between casual users that aren\u2019t online at the same time.</p>\n<p>Finally, the OPR protocol can be combined with either revocation keys or per-commitment keys in a way that allows casual users to perform watchtower-free sends and receives.\nThe details are given in the paper [14].</p>\n<h1><a name=\"p-3457-summary-8\" class=\"anchor\" href=\"#p-3457-summary-8\"></a>Summary</h1>\n<p>Combining the OPR protocol with per-commitment keys [14] yields the following properties:</p>\n<ul>\n<li>tunable penalties for attempting to put an old channel state on-chain [9],</li>\n<li>a watchtower service only requires storage that\u2019s logarithmic (as opposed to linear) in the number of channel states,</li>\n<li>if the channel is created in a channel factory or timeout-tree, the maximum latency of the payment is independent of the time required to put any channel factory or timeout-tree transactions on-chain [10],</li>\n<li>casual users can receive payments in a one-shot manner [8],</li>\n<li>casual users can send and receive payments without using a watchtower service (and without requiring them to be online more than once every three months) [8],</li>\n<li>arbitrarily small payments are routed securely, provided the parties routing the payment are self-interested,</li>\n<li>there is never any incremental on-chain footprint required to resolve a payment, and</li>\n<li>all payments are resolved within seconds.</li>\n</ul>\n<h1><a name=\"p-3457-griefer-penalized-protocols-for-other-applications-9\" class=\"anchor\" href=\"#p-3457-griefer-penalized-protocols-for-other-applications-9\"></a>Griefer-Penalized Protocols For Other Applications</h1>\n<p>In the OPR protocol, both parties move funds to a burn output and they only receive those funds if they agree on how the funds should be divided.\nThe technique of devoting funds to a burn output can be used for any protocol where both parties automatically calculate the same division of funds (at least in the vast majority of cases) and both parties always receive a significant portion of those funds (in order to motivate cooperation).</p>\n<p>Using a burn output in this manner has many advantages over using pre-signed transactions to determine fund divisions, including:</p>\n<ul>\n<li>elimination of the need for calculating and pre-signing transactions,</li>\n<li>the ability to resolve the division of funds in seconds,</li>\n<li>the ability to use computations that aren\u2019t supported by Bitcoin script when dividing funds, and</li>\n<li>the lack of any on-chain footprint when dividing funds.</li>\n</ul>\n<p>For example, burn outputs could be used as an alternative to Discreet Log Contracts [5] for resolving smart contracts.\nThis could be attractive as it eliminates the need for an oracle that creates a Schnorr signature, as well as the need to create a large number of pre-signed contracts [6].</p>\n<p>Another example is the creation of a fee-based protocol for reducing spam on Lightning.\nSuch a protocol will be presented in a future post.</p>\n<h1><a name=\"p-3457-related-work-10\" class=\"anchor\" href=\"#p-3457-related-work-10\"></a>Related Work</h1>\n<p>The OPR protocol\u2019s use of a burn output to obtain cooperation is similar to the use of security bonds.\nHowever, the OPR protocol differs by having both partners contribute to the burn output, and by apportioning burn output funds to the partners based on a condition that they calculate off-chain (as opposed to the result of an on-chain Bitcoin script).\nIt\u2019s this difference that allows the OPR protocol to resolve payments so quickly and efficiently.</p>\n<p>The idea of using a burn output to encourage cooperation between channel partners was suggested by Riard [15] in the context of preventing channel jamming.\nHowever, Riard and Naumenko [16] left the creation of a protocol based on a burn output as future work.</p>\n<h1><a name=\"p-3457-conclusions-11\" class=\"anchor\" href=\"#p-3457-conclusions-11\"></a>Conclusions</h1>\n<p>The ability to support small, everyday payments is essential if Lightning is to become a widely-used means of payment.\nAlthough the OPR protocol has weaker security than the current Lightning protocol when making large payments, the comparison reverses with small payments.</p>\n<p>The OPR protocol\u2019s ability to route small payments, coupled with its excellent scalability and usability, makes it an attractive candidate for supporting large numbers of casual Lightning users.\nThe OPR protocol can also be used for large payments, either directly or by dividing the large payment into many smaller ones.</p>\n<h1><a name=\"p-3457-references-12\" class=\"anchor\" href=\"#p-3457-references-12\"></a>References</h1>\n<p>[1] Burchert, Decker and Wattenhofer, \u201cScalable Funding of Bitcoin Micropayment Channel Networks\u201d, <a href=\"http://dx.doi.org/10.1098/rsos.180089\" rel=\"noopener nofollow ugc\">http://dx.doi.org/10.1098/rsos.180089</a>\n[2] BOLT 02 - Peer Protocol, <a href=\"https://github.com/lightning/bolts/blob/247e83d528a2a380e533e89f31918d7b0ce6a0c1/02-peer-protocol.md\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">bolts/02-peer-protocol.md at 247e83d528a2a380e533e89f31918d7b0ce6a0c1 \u00b7 lightning/bolts \u00b7 GitHub</a>\n[3] BOLT 03 - Transactions, <a href=\"https://github.com/lightning/bolts/blob/247e83d528a2a380e533e89f31918d7b0ce6a0c1/03-transactions.md\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">bolts/03-transactions.md at 247e83d528a2a380e533e89f31918d7b0ce6a0c1 \u00b7 lightning/bolts \u00b7 GitHub</a>\n[4] Decker, Russell and Osuntokun, \u201celtoo: A Simple Layer2 Protocol for Bitcoin\u201d, <a href=\"https://blockstream.com/eltoo.pdf\" rel=\"noopener nofollow ugc\">https://blockstream.com/eltoo.pdf</a>\n[5] Dryja, \u201cDiscreet Log Contracts\u201d, <a href=\"https://adiabat.github.io/dlc.pdf\" rel=\"noopener nofollow ugc\">https://adiabat.github.io/dlc.pdf</a>\n[6] Fournier, \u201cCTV dramatically improves DLCs\u201d, <a href=\"https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019808.html\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">[bitcoin-dev] CTV dramatically improves DLCs</a>\n[7] Law, \u201cScaling Bitcoin With Inherited IDs\u201d, <a href=\"https://github.com/JohnLaw2/btc-iids\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">GitHub - JohnLaw2/btc-iids</a>\n[8] Law, \u201cWatchtower-Free Lightning Channels For Casual Users\u201d, <a href=\"https://github.com/JohnLaw2/ln-watchtower-free\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">GitHub - JohnLaw2/ln-watchtower-free</a>\n[9] Law, \u201cLightning Channels With Tunable Penalties\u201d, <a href=\"https://github.com/JohnLaw2/ln-tunable-penalties\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">GitHub - JohnLaw2/ln-tunable-penalties</a>\n[10] Law, \u201cFactory-Optimized Channel Protocols For Lightning\u201d, <a href=\"https://github.com/JohnLaw2/ln-factory-optimized\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">GitHub - JohnLaw2/ln-factory-optimized: Factory-optimized Lightning channels for Bitcoin</a>\n[11] Law, \u201cEfficient Factories For Lightning Channels\u201d, <a href=\"https://github.com/JohnLaw2/ln-efficient-factories\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">GitHub - JohnLaw2/ln-efficient-factories</a>\n[12] Law, \u201cResizing Lightning Channels Off-Chain With Hierarchical Channels\u201d, <a href=\"https://github.com/JohnLaw2/ln-hierarchical-channels\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">GitHub - JohnLaw2/ln-hierarchical-channels</a>\n[13] Law, \u201cScaling Lightning With Simple Covenants\u201d, <a href=\"https://github.com/JohnLaw2/ln-scaling-covenants\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">GitHub - JohnLaw2/ln-scaling-covenants: Protocols that use simple covenants to scale Lightning</a>\n[14] Law, \u201cA Fast, Scalable Protocol For Resolving Lightning Payments\u201d, <a href=\"https://github.com/JohnLaw2/ln-opr\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">GitHub - JohnLaw2/ln-opr: A fast, scalable protocol for resolving Lightning payments</a>\n[15] Riard, \u201cUnjamming lightning (new research paper)\u201d, <a href=\"https://www.mail-archive.com/lightning-dev@lists.linuxfoundation.org/msg02996.html\" rel=\"noopener nofollow ugc\">https://www.mail-archive.com/lightning-dev@lists.linuxfoundation.org/msg02996.html</a>\n[16] Riard and Naumenko, \u201cLightning Jamming Book\u201d, <a href=\"https://jamming-dev.github.io/book/\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">About</a>\n[17] Transaction Fees, <a href=\"https://blockchain.com/explorer/charts/transaction-fees\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">Blockchain.com | Charts - Total Transaction Fees (BTC)</a></p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2024-10-31T22:50:15.637Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 13,
  "reads": 13,
  "readers_count": 12,
  "score": 82.6,
  "yours": false,
  "topic_id": 1233,
  "topic_slug": "a-fast-scalable-protocol-for-resolving-lightning-payments",
  "topic_title": "A Fast, Scalable Protocol For Resolving Lightning Payments",
  "topic_html_title": "A Fast, Scalable Protocol For Resolving Lightning Payments",
  "category_id": 7,
  "display_username": null,
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "\nThe security of all known Lightning payment protocols breaks down when the incremental cost of resolving a payment on-chain exceeds the value of the payment.\n\nFor example, if Alice uses the current Lightning protocol to offer an HTLC to Bob, and Bob fulfills the HTLC by providing the required hash preimage before its expiry, Alice is supposed to update the channel state off-chain to reflect the payment of the HTLC to Bob.\nHowever, if Alice fails to do so, Bob's only recourse is to put an HTLC-success transaction on-chain.\nIf the cost of putting the HTLC-success transaction on-chain exceeds the value of the payment, resolving the HTLC on-chain is more costly for Bob than allowing Alice to claim the payment.\nTherefore, Alice is incentivized to violate the protocol by not giving the payment's funds to Bob off-chain, as she will receive those funds unless Bob acts against his immediate self-interest.\n\nThis post presents a new Lightning payment resolution protocol, called the Off-chain Payment Resolution (OPR) protocol, that has the following properties:\n1) all payments are resolved correctly, provided both parties are self-interested and able to implement the protocol, regardless of how small the payment is,\n2) all payments are resolved within seconds (as compared to hours for the current protocol),\n3) there is never a need for a party to go on-chain to resolve a payment (thus greatly improving scalability), and\n4) casual users can send and receive payments without having a watchtower service (and without maintaining high availability).\n\nAs a result, the OPR protocol appears to be well-suited to supporting small, everyday Lightning payments.\nIn addition, the OPR protocol can be used for large payments, either directly or by dividing the large payment into many smaller ones.\n\nThe OPR protocol has weaker security than a trust-free protocol (in which one cannot lose funds if they follow the protocol), but stronger than a trust-based protocol (in which one's funds can be stolen).\nThe OPR protocol is a *griefer-penalized* protocol, as an honest party can be made to lose certain funds by a dishonest channel partner who griefs them.\nHowever, the griefer also has to lose a comparable amount of funds.\nAs a result, an honest party who only creates channels with self-interested parties will never be subject to a griefing attack.\n\nA more complete description, including figures, is given in a paper [14].\n\nSecurity Of The Current Lightning Protocol\n==========================================\n\nAs noted above, with the current Lightning protocol an offeree of an HTLC may be forced to put an HTLC-success transaction on-chain.\nThe HTLC-success transaction requires about 702 vbytes [3], and the additional input in the transaction that spends the HTLC-sucess transaction's output requires about 316 vbytes, for a total of about 1018 incremental vbytes to claim a payment on-chain.\nAssuming $50k per BTC and the historically common fee rates of 10 sat/vbyte to 100 sat/vbyte [17], the incremental cost for claiming a payment on-chain is in the range of $5 to $50.\n\nOf course, even if the incremental cost of claiming a payment exceeds the value of the payment, that doesn't mean that all Lightning nodes will try to steal the payment.\nFor example, the expected value of future routing fees could exceed the value of the currently-outstanding small payments, thus preventing thefts.\nAlso, there are significant software engineering barriers to stealing small payments, as the offeree of an HTLC *will* choose to lose funds by securing a small payment on-chain if the offeree is running standard software that implements the Lightning protocol.\n\nOn the other hand, there are situations where the current Lightning protocol could lead to an attempt to steal funds.\nFor example, if Alice wants to close a channel with Bob, she could create one large payment and very many small payments for which Alice offers Bob HTLCs.\nNext, Alice stops responding to Bob's messages after receiving the HTLCs' hash preimages.\nAs a result, Bob will put his Commitment transaction and the large payment's HTLC-success transaction on-chain.\nIn addition, Bob must either lose funds by claiming all of the small payments on-chain, or forfeit those payments to Alice.\n\nThis attack is costless for Alice, has at least some possibility of allowing her to steal funds, appears to be due to an involuntary failure (rather than malicious behavior), and is performed when she no longer needs to maintain her reputation with Bob in order to obtain future routing fees.\n\nOff-chain Payment Resolution (OPR) Protocol\n===========================================\n\nThe OPR protocol operates in conjunction with a channel protocol that creates a series of signed off-chain transactions reflecting the current channel state.\nOld channel states can be replaced by a new channel state via a revocation key (as in the current Lightning protocol [2]) or a per-commitment key (as in the Tunable Penalty [9] or Fully-Factory-Optimized protocol [10]).\nThe details of how to maintain the channel state are presented in the paper [14].\n\nWhen the channel is created, each party gets signed transactions with three outputs, one of which pays to each party, with the third one being a *burn output*.\nThe burn output pays to anyone after a 20-year delay (so the burn output will be claimed by a miner 20 years in the future).\nEach party must contribute a fixed amount (called \"base funds\") to the burn output.\n\nIn order to route a new payment, an HTLC is created for the amount of the payment plus routing fees.\nEach party gets new channel state transactions where the value of the HTLC is moved from the offerer's output to the burn output.\nIn addition, each party adds a fixed fraction of the value of the HTLC (called \"matching funds\") to the burn output.\n\nAs in the current Lightning protocol, the HTLC pays to the offeree only if the offeree provides the offerer with a hash preimage before the HTLC's expiry.\nHowever, the expiry is set at most seconds in the future, based on the parties' htlc_expiry_delta_msec and min_final_expiry_delta_msec parameters.\nThese parameters are set to provide enough time to resolve the HTLC off-chain by receiving an update_fulfill_htlc or update_fail_htlc message, signing updated channel state transactions, and propagating the payment resolution to the upstream channel.\nThese parameters also include buffers for communication and computation delays caused by unusually heavy traffic, but they *do not* include time for putting channel state transactions on-chain.\n\nIf an HTLC is resolved successfully before its expiry, the HTLC's funds are moved to the offeree's output and both parties' matching funds for the HTLC are returned to them.\nIf an HTLC fails, the HTLC's funds are moved to the offerer's output and both parties' matching funds for the HTLC are returned to them.\n\nAs long as both parties agree on whether the HTLC succeeded or failed, they will agree on the new channel state transactions that resolve the HTLC and they will both get back their matching funds for the HTLC.\nFinally, if both parties agree on the resolution of all HTLCs and they want to close the channel, they can create a Cooperative Close transaction that returns their base funds to them and eliminates the burn output.\n\nBurned Funds\n============\n\nThere are three ways in which a party that follows the OPR protocol can be forced to burn funds.\n\nFirst, a dishonest channel partner can put channel state transactions with a burn output on-chain in order to grief their partner (while also griefing themselves).\nIn this case, the griefer loses (at least) their base and matching funds, which are set high enough to discourage most or all such griefing attacks.\nSpecifically, if each party devotes a fraction m of the HTLC amount as matching funds, the griefer must lose at least m/(1+m) as many funds as their partner loses (and at least their base funds).\n\nSecond, if an honest party's channel partner completely fails and can't update the channel state for a very long time (e.g., months), the honest party can be forced to close the channel unilaterally by putting their channel state transactions with a burn output on-chain.\nThe amount of time an honest party is willing to wait is based on the likelihood of their partner becoming responsive versus the cost of the channel's capital, and is independent of the lengths of the HTLCs' expiries.\n\nThird, if both parties are honest but they fail in such a way that they don't agree on the resolution of an HTLC, they will be forced to burn the HTLC's funds and their base and matching funds.\nFortunately, there are many techniques that reduce the likelihood of such failures.\n\nIn order to determine if an HTLC was resolved successfully, a node has to determine if the required hash preimage was provided before the HTLC's expiry.\nAll hash preimage messages can include a time stamp recording when they were sent, and each node can keep a time-stamped nonvolatile log of each hash preimage that it sends or receives.\nThis log can be used to determine the result of an HTLC, even if the node crashes when the HTLC was being resolved.\nChannel partners can keep their clocks synchronized by exchanging frequent time stamp messages, and the htlc_expiry_delta_msec parameters can include a buffer for clock skew.\n\nThe greatest challenge in getting agreement on whether or not an HTLC was resolved successfully occurs when the offeree sends the hash preimage before the expiry, but the offerer doesn't receive the preimage until after the expiry.\nThis case can be made less frequent by calculating the maximum communication latency L between channel partners and never sending a hash preimage less than L before the HTLC's expiry,\n\nAlso, multiple encrypted copies of hash preimage messages can be sent using different communication paths.\nIf all of these multiple copies are sent but fail to reach the offerer before the HTLC's expiry, it's likely there was either a complete loss of communication by the offeree or a failure of the offerer.\nThese cases can be differentiated by looking at the nonvolatile logs for the nodes' other channels.\nFor example, if a node has 20 channels with different partners and stops receiving time-stamped messages from just one of those partners, they can conclude that the failure was likely caused by that partner.\nOn the other hand, if the node stops receiving time-stamped messages on all 20 channels, the node can conclude that it is likely the cause of the failures.\n\nHTLC Failures\n=============\n\nIn addition to the risk of burning funds, a routing node can lose funds if it causes an HTLC to fail.\n\nIf a node failure prevents it from fulfilling an upstream HTLC, the node will lose the value of the HTLC because it's still liable for paying the corresponding downstream HTLC.\nThe risk of losing HTLC funds by having to pay a downstream HTLC without receiving an upstream HTLC exists in the current Lightning protocol.\nHowever, the OPR protocol greatly increases this risk because it commits the node to delaying the resolution of the HTLC by at most seconds, as opposed to hours in the current Lightning protocol.\n\nThis risk is covered by Lightning routing fees, so it's worth quantifying the risk in order to determine whether or not those fees will be prohibitive.\nIf we assume the average incremental latency required to resolve an HTLC is 100 milliseconds and the average payment traverses 11 hops, each HTLC will be resolved an average of 600 milliseconds after it's created.\nIf each node fails (due to a crash, delay, or protocol error) randomly 10 times a day, thus causing it to lose the value of all unresolved HTLCs, that node will lose the value of one out of every 14,400 HTLCs.\nTherefore, increasing the routing fee by 1/14,400 = 0.007% of the HTLC value per node (and thus 0.077% per payment) will cover the cost of node failures that cause HTLC failures.\n\nAs a result, it seems plausible that the OPR protocol could be used to implement fast off-chain payments without imposing excessive routing fees.\n\nBullying\n========\n\nFinally, a party can lose funds if they can be psychologically manipulated to allow their partner to steal from them.\nFor example, if Alice and Bob should each receive two million sats from the burn output, Bob could refuse to update the channel state unless he gets three million sats from the burn output (and Alice could agree in order to at least get the remaining one million sats).\n\nThis type of bullying attack can be prevented by ensuring that all channel updates are performed automatically, rather than under human control.\n\nScalability\n===========\n\nThe OPR protocol has remarkable scaling properties.\n\nFirst, the addition of an HTLC to a channel doesn't add any outputs to the channel state transactions.\nAs a result, even if the channel state is put on-chain, there's no incremental on-chain footprint due to the HTLC.\nIn addition, there's no protocol-defined upper bound on the number of active HTLCs per channel.\n\nSecond, the OPR protocol's resolution of an HTLC never requires any transactions to be put on-chain.\nThis is extremely important for scalability, as channel factories [1][4][11] and timeout-trees [7][13] have been proposed for opening and closing channels off-chain, and hierarchical channels [12] have been proposed for resizing channels off-chain.\nAs a result, without the OPR protocol, the on-chain resolution of HTLCs is likely to be the greatest limitation to Lightning's scalability.\n\nUsability\n=========\n\nThe OPR protocol's guaranteed resolution of a payment attempt within seconds makes it much more attractive to casual users than the current Lightning protocol, which could require waiting hours to find out that a payment attempt failed.\nThe fact that the payment's receiver never has to go on-chain to resolve the payment means that the OPR protocol supports one-shot receives [8].\nAsynchronous trampoline payments (as described in Section 3.6 of [8]) can be used for payments between casual users that aren't online at the same time.\n\nFinally, the OPR protocol can be combined with either revocation keys or per-commitment keys in a way that allows casual users to perform watchtower-free sends and receives.\nThe details are given in the paper [14].\n\nSummary\n=======\n\nCombining the OPR protocol with per-commitment keys [14] yields the following properties:\n\n* tunable penalties for attempting to put an old channel state on-chain [9],\n* a watchtower service only requires storage that's logarithmic (as opposed to linear) in the number of channel states,\n* if the channel is created in a channel factory or timeout-tree, the maximum latency of the payment is independent of the time required to put any channel factory or timeout-tree transactions on-chain [10],\n* casual users can receive payments in a one-shot manner [8],\n* casual users can send and receive payments without using a watchtower service (and without requiring them to be online more than once every three months) [8],\n* arbitrarily small payments are routed securely, provided the parties routing the payment are self-interested,\n* there is never any incremental on-chain footprint required to resolve a payment, and\n* all payments are resolved within seconds.\n\nGriefer-Penalized Protocols For Other Applications\n==================================================\n\nIn the OPR protocol, both parties move funds to a burn output and they only receive those funds if they agree on how the funds should be divided.\nThe technique of devoting funds to a burn output can be used for any protocol where both parties automatically calculate the same division of funds (at least in the vast majority of cases) and both parties always receive a significant portion of those funds (in order to motivate cooperation).\n\nUsing a burn output in this manner has many advantages over using pre-signed transactions to determine fund divisions, including:\n* elimination of the need for calculating and pre-signing transactions,\n* the ability to resolve the division of funds in seconds,\n* the ability to use computations that aren't supported by Bitcoin script when dividing funds, and\n* the lack of any on-chain footprint when dividing funds.\n\nFor example, burn outputs could be used as an alternative to Discreet Log Contracts [5] for resolving smart contracts.\nThis could be attractive as it eliminates the need for an oracle that creates a Schnorr signature, as well as the need to create a large number of pre-signed contracts [6].\n\nAnother example is the creation of a fee-based protocol for reducing spam on Lightning.\nSuch a protocol will be presented in a future post.\n\nRelated Work\n============\n\nThe OPR protocol's use of a burn output to obtain cooperation is similar to the use of security bonds.\nHowever, the OPR protocol differs by having both partners contribute to the burn output, and by apportioning burn output funds to the partners based on a condition that they calculate off-chain (as opposed to the result of an on-chain Bitcoin script).\nIt's this difference that allows the OPR protocol to resolve payments so quickly and efficiently.\n\nThe idea of using a burn output to encourage cooperation between channel partners was suggested by Riard [15] in the context of preventing channel jamming.\nHowever, Riard and Naumenko [16] left the creation of a protocol based on a burn output as future work.\n\nConclusions\n===========\n\nThe ability to support small, everyday payments is essential if Lightning is to become a widely-used means of payment.\nAlthough the OPR protocol has weaker security than the current Lightning protocol when making large payments, the comparison reverses with small payments.\n\nThe OPR protocol's ability to route small payments, coupled with its excellent scalability and usability, makes it an attractive candidate for supporting large numbers of casual Lightning users. \nThe OPR protocol can also be used for large payments, either directly or by dividing the large payment into many smaller ones.\n\nReferences\n==========\n[1] Burchert, Decker and Wattenhofer, \"Scalable Funding of Bitcoin Micropayment Channel Networks\", http://dx.doi.org/10.1098/rsos.180089\n[2] BOLT 02 - Peer Protocol, https://github.com/lightning/bolts/blob/247e83d528a2a380e533e89f31918d7b0ce6a0c1/02-peer-protocol.md\n[3] BOLT 03 - Transactions, https://github.com/lightning/bolts/blob/247e83d528a2a380e533e89f31918d7b0ce6a0c1/03-transactions.md\n[4] Decker, Russell and Osuntokun, \"eltoo: A Simple Layer2 Protocol for Bitcoin\", https://blockstream.com/eltoo.pdf\n[5] Dryja, \"Discreet Log Contracts\", https://adiabat.github.io/dlc.pdf\n[6] Fournier, \"CTV dramatically improves DLCs\", https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019808.html\n[7] Law, \"Scaling Bitcoin With Inherited IDs\", https://github.com/JohnLaw2/btc-iids\n[8] Law, \"Watchtower-Free Lightning Channels For Casual Users\", https://github.com/JohnLaw2/ln-watchtower-free\n[9] Law, \"Lightning Channels With Tunable Penalties\", https://github.com/JohnLaw2/ln-tunable-penalties\n[10] Law, \"Factory-Optimized Channel Protocols For Lightning\", https://github.com/JohnLaw2/ln-factory-optimized\n[11] Law, \"Efficient Factories For Lightning Channels\", https://github.com/JohnLaw2/ln-efficient-factories\n[12] Law, \"Resizing Lightning Channels Off-Chain With Hierarchical Channels\", https://github.com/JohnLaw2/ln-hierarchical-channels\n[13] Law, \"Scaling Lightning With Simple Covenants\", https://github.com/JohnLaw2/ln-scaling-covenants\n[14] Law, \"A Fast, Scalable Protocol For Resolving Lightning Payments\", https://github.com/JohnLaw2/ln-opr\n[15] Riard, \"Unjamming lightning (new research paper)\", https://www.mail-archive.com/lightning-dev@lists.linuxfoundation.org/msg02996.html\n[16] Riard and Naumenko, \"Lightning Jamming Book\", https://jamming-dev.github.io/book/\n[17] Transaction Fees, https://blockchain.com/explorer/charts/transaction-fees",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 279,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": "Github link was replaced with a permanent link",
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "eyes",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}