{
  "id": 3438,
  "name": "Anthony Towns",
  "username": "ajtowns",
  "avatar_template": "/user_avatar/delvingbitcoin.org/ajtowns/{size}/417_2.png",
  "created_at": "2024-10-29T12:14:36.989Z",
  "cooked": "<p>Longer delay since my <a href=\"https://delvingbitcoin.org/t/btc-lisp-as-an-alternative-to-script/682\">last post on the topic</a> than I\u2019d hoped. Most of it was spent thinking about this bit of feedback (particularly in the context of how annoying I was finding it to write btclisp code):</p>\n<aside class=\"quote no-group\" data-username=\"prozacchiwawa\" data-post=\"2\" data-topic=\"682\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/prozacchiwawa/48/431_2.png\" class=\"avatar\"><a href=\"https://delvingbitcoin.org/t/btc-lisp-as-an-alternative-to-script/682/2\">BTC Lisp as an alternative to Script</a></div>\n<blockquote>\n<p>If I had one piece of advice, it\u2019s to nail down a great system for mapping high level lisp to low level code for debuggers and interpreters early. Chia is behind in this (hoping to catch up) and it\u2019s probably the biggest negative feedback about chialisp development.</p>\n</blockquote>\n</aside>\n<p>I spent a bunch of time trying to figure out if using <a href=\"https://racket-lang.org/\">racket-lang</a> would be a better approach \u2013 it\u2019s a lisp dialect that\u2019s designed for creating your own DSLs, it has a nice IDE, and it has some nice \u201cintroduction to computer science\u201d tooling, that in theory should work great for deeply understanding small bits of code. But that didn\u2019t seem to really pan out: the debugging stuff still becomes complicated when macros are involved, customising the debugging interface seems to require getting your hands very dirty, and there aren\u2019t nice easy libraries for doing all the cryptographic operations, so implementing tx parsing and secp maths would\u2019ve been a bunch of work.</p>\n<p>The conclusion I eventually came to are that macros represent something of a false idol \u2013 they\u2019re a really great way of <em>building</em> a language feature, because they let you say \u201cwhen I write this expression, I want you to treat it as if I\u2019d done some other more complicated thing\u201d. But the problem is that you\u2019re leaving implicit the meaning of the expression, so when you try to debug things, the computer can only do what you told it and perform the mechanical translation and continue on from there, which confuses things immensely, because you\u2019re no longer debugging the code that you wrote, but some complicated equivalent expression that you didn\u2019t write. Which sucks: if you\u2019d been happy dealing with the complicated expression, you never would have bothered writing the macro in the first place! So, they\u2019re great for building a language, but not actually sufficient once you want to use the language.</p>\n<p>Another aspect of the \u201clisp approach\u201d that was bugging me is the conflict between having an \u201ceval\u201d function, and translating from a high-level to a low-level. In particular, if you have a high-level eval, how do you translate that to the low-level? If you do it natively, then your low-level language essentially is your high-level language; and if you don\u2019t, then you have to implement the entire high-level language in the low-level one in order to implement eval.</p>\n<p>Thinking about <a href=\"https://bitcoinops.org/en/topics/miniscript/\">miniscript</a> finally brought these ideas together in a way that allowed progress: if you treat the high-level language as a friendly variation of the low-level language (as miniscript does with script), then it perhaps makes sense to have two interpreters (one that keeps everything friendly and high-level, and one for the low-level language), and just have a separate translator/compiler to go from one to the other. That\u2019s a little frustrating, in that it introduces the possibility of the high-level interpreter coming up with a different answer to what the compiler and low-level interpreter would produce; but it seems well worth the tradeoff, and that problem is potentially eventually solvable by formal analysis tools.</p>\n<p>So jumping on that idea, I\u2019ve rewritten almost everything into that new model, with a bit more of a focus on debugging, which means I\u2019ve now got three things: a basic lisp language which I\u2019m calling \u201cbll\u201d, that\u2019s designed to be able to be slotted into consensus, a higher level language that\u2019s designed to be both easier to program in and able to be compiled into bll in a straightforward way, which I\u2019m calling \u201csymbll\u201d for \u201csymbolic bll\u201d, and a REPL for developing in those languages, called \u201cbllsh\u201d for \u201cbll shell\u201d, and which is pronounced \u201cbullish\u201d, because what\u2019s the point of a multi-month diversion if you can\u2019t come out of it with some pun-based AI art?</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/1X/ebf6b559ead854dfc47b527056de10b284cac44e.jpeg\" data-download-href=\"https://delvingbitcoin.org/uploads/default/ebf6b559ead854dfc47b527056de10b284cac44e\" title=\"bllsh - a bull of shells, before a new dawn in scripting\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/1X/ebf6b559ead854dfc47b527056de10b284cac44e_2_690x172.jpeg\" alt=\"bllsh - a bull of shells, before a new dawn in scripting\" data-base62-sha1=\"xFqM6rYD13KsH8M3T4htPy0C4yO\" width=\"690\" height=\"172\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/1X/ebf6b559ead854dfc47b527056de10b284cac44e_2_690x172.jpeg, https://delvingbitcoin.org/uploads/default/optimized/1X/ebf6b559ead854dfc47b527056de10b284cac44e_2_1035x258.jpeg 1.5x, https://delvingbitcoin.org/uploads/default/optimized/1X/ebf6b559ead854dfc47b527056de10b284cac44e_2_1380x344.jpeg 2x\" data-dominant-color=\"6E6B5C\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">bllsh - a bull of shells, before a new dawn in scripting</span><span class=\"informations\">1920\u00d7480 113 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<aside class=\"onebox githubrepo\" data-onebox-src=\"https://github.com/ajtowns/bllsh\">\n  <header class=\"source\">\n\n      <a href=\"https://github.com/ajtowns/bllsh\" target=\"_blank\" rel=\"noopener\">github.com</a>\n  </header>\n\n  <article class=\"onebox-body\">\n    <div class=\"github-row\" data-github-private-repo=\"false\">\n  <img width=\"690\" height=\"344\" src=\"https://delvingbitcoin.org/uploads/default/optimized/1X/195cf1b9e3b0d59b77e91a2e520c717ce4fe41f2_2_690x344.png\" class=\"thumbnail\" data-dominant-color=\"F1F2F4\">\n\n  <h3><a href=\"https://github.com/ajtowns/bllsh\" target=\"_blank\" rel=\"noopener\">GitHub - ajtowns/bllsh: A Bullish Shell for a Basic Bitcoin Lisp Language</a></h3>\n\n    <p><span class=\"github-repo-description\">A Bullish Shell for a Basic Bitcoin Lisp Language</span></p>\n</div>\n\n  </article>\n\n  <div class=\"onebox-metadata\">\n    \n    \n  </div>\n\n  <div style=\"clear: both\"></div>\n</aside>\n\n<p>In essence, bll isn\u2019t very different from <a href=\"https://delvingbitcoin.org/t/btc-lisp-as-an-alternative-to-script/682\">btclisp</a> as it was in March; the biggest difference is that it\u2019s no longer lazily evaluated, so all arguments to an operation are evaluated (unless the script aborts), though there are other tweaks, such as some opcodes being implemented (<code>partial</code>), some being dropped (<code>/%</code>) and some being changed (<code>c</code> becomes <code>rc</code> and builds the list in reverse). The actual code implementing it is quite different, though, mostly due to adopting <a href=\"https://en.wikipedia.org/wiki/Continuation-passing_style\">continuation passing style</a>.</p>\n<p>Here\u2019s what a simple factorial calculator looks like in bll:</p>\n<pre><code class=\"lang-auto\">$ ./bllsh\n&gt;&gt;&gt; blleval (a (nil a 2) (rc 1 (b (nil a (i 3 (nil * 3 (a 2 (rc (b (- 3 (nil . 1))) 2))) (nil nil . 1)))))) 5\n120\n</code></pre>\n<p>Writing code in symbll is somewhat easier, provided you\u2019re familiar with functional programming:</p>\n<pre><code class=\"lang-auto\">$ ./bllsh\n&gt;&gt;&gt; def (FR N) (if N (* N (FR (- N 1))) 1)\n&gt;&gt;&gt; eval (FR 5)\n120\n</code></pre>\n<p>There is also some fairly straightforward ability to do debugging, either printf-style:</p>\n<pre><code class=\"lang-auto\">$ ./bllsh\n&gt;&gt;&gt; def (FR N) (if (report N 'FR-called) (* N (FR (- N 1))) 1)\n&gt;&gt;&gt; eval (FR 5)\nreport: (5 &lt;FR-called&gt;)\nreport: (4 &lt;FR-called&gt;)\nreport: (3 &lt;FR-called&gt;)\nreport: (2 &lt;FR-called&gt;)\nreport: (1 &lt;FR-called&gt;)\nreport: (nil &lt;FR-called&gt;)\n120\n</code></pre>\n<p>or step-through debugging:</p>\n<pre><code class=\"lang-auto\">$ ./bllsh\n&gt;&gt;&gt; def (FR N) (if N (* N (FR (- N 1))) 1)\n&gt;&gt;&gt; debug (FR 5)\n   -- 1. FN(fn_symbll_eval,nil)    [&lt;FR&gt; 5]\n&gt;&gt;&gt; step\n   -- 1. FN(fn_userfunc,[[&lt;if&gt; &lt;N&gt; [&lt;*&gt; &lt;N&gt; [&lt;FR&gt; [&lt;-&gt; &lt;N&gt; 1]]] 1] [&lt;N&gt;]])    (5)\n&gt;&gt;&gt; step\n   -- 2. FN(fn_symbll_eval,nil)    5\n   -- 1. FN(fn_userfunc,[[&lt;if&gt; &lt;N&gt; [&lt;*&gt; &lt;N&gt; [&lt;FR&gt; [&lt;-&gt; &lt;N&gt; 1]]] 1] [&lt;N&gt;]])    nil\n&gt;&gt;&gt; step\n   -- 2. FN(fn_fin,nil)    5\n   -- 1. FN(fn_userfunc,[[&lt;if&gt; &lt;N&gt; [&lt;*&gt; &lt;N&gt; [&lt;FR&gt; [&lt;-&gt; &lt;N&gt; 1]]] 1] [&lt;N&gt;]])    nil\n&gt;&gt;&gt; step\n   -- 1. FN(fn_userfunc,[[&lt;if&gt; &lt;N&gt; [&lt;*&gt; &lt;N&gt; [&lt;FR&gt; [&lt;-&gt; &lt;N&gt; 1]]] 1] nil [5 . &lt;N&gt;]])    nil\n&gt;&gt;&gt; cont\nResult: 120\n</code></pre>\n<p>There\u2019s also the ability to compile symbll into bll:</p>\n<pre><code class=\"lang-auto\">$ ./bllsh\n&gt;&gt;&gt; def (FR N) (if N (* N (FR (- N 1))) 1)\n&gt;&gt;&gt; program FR\n(1 (nil 1 2) (6 1 (10 (nil 1 (5 3 (nil 25 3 (1 2 (6 (10 (24 3 (nil . 1))) 2))) (nil nil . 1))))))\n</code></pre>\n<p>(which is just the original bll program we had above, with the opcodes represented by their numbers, rather than their symbol). The compiler logic is essentially simple macro rewriting, so there\u2019s plenty of potential for optimisation there eventually, but it already seems to work pretty well, and being able to run and debug the high level code natively is (at least in my opinion) a huge win.</p>\n<p>Anyway, the point of this post was just to update on the language design; hopefully having done that it won\u2019t be too hard to move onto discussing actual interesting things you can do in future posts.</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2024-10-29T12:14:36.989Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 60,
  "reads": 15,
  "readers_count": 14,
  "score": 318.0,
  "yours": false,
  "topic_id": 1224,
  "topic_slug": "debuggable-lisp-scripts",
  "topic_title": "Debuggable Lisp Scripts",
  "topic_html_title": "Debuggable Lisp Scripts",
  "category_id": 7,
  "display_username": "Anthony Towns",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Longer delay since my [last post on the topic](https://delvingbitcoin.org/t/btc-lisp-as-an-alternative-to-script/682) than I'd hoped. Most of it was spent thinking about this bit of feedback (particularly in the context of how annoying I was finding it to write btclisp code):\n\n[quote=\"prozacchiwawa, post:2, topic:682\"]\nIf I had one piece of advice, it\u2019s to nail down a great system for mapping high level lisp to low level code for debuggers and interpreters early. Chia is behind in this (hoping to catch up) and it\u2019s probably the biggest negative feedback about chialisp development.\n[/quote]\n\nI spent a bunch of time trying to figure out if using [racket-lang](https://racket-lang.org/) would be a better approach -- it's a lisp dialect that's designed for creating your own DSLs, it has a nice IDE, and it has some nice \"introduction to computer science\" tooling, that in theory should work great for deeply understanding small bits of code. But that didn't seem to really pan out: the debugging stuff still becomes complicated when macros are involved, customising the debugging interface seems to require getting your hands very dirty, and there aren't nice easy libraries for doing all the cryptographic operations, so implementing tx parsing and secp maths would've been a bunch of work.\n\nThe conclusion I eventually came to are that macros represent something of a false idol -- they're a really great way of *building* a language feature, because they let you say \"when I write this expression, I want you to treat it as if I'd done some other more complicated thing\". But the problem is that you're leaving implicit the meaning of the expression, so when you try to debug things, the computer can only do what you told it and perform the mechanical translation and continue on from there, which confuses things immensely, because you're no longer debugging the code that you wrote, but some complicated equivalent expression that you didn't write. Which sucks: if you'd been happy dealing with the complicated expression, you never would have bothered writing the macro in the first place! So, they're great for building a language, but not actually sufficient once you want to use the language.\n\nAnother aspect of the \"lisp approach\" that was bugging me is the conflict between having an \"eval\" function, and translating from a high-level to a low-level. In particular, if you have a high-level eval, how do you translate that to the low-level? If you do it natively, then your low-level language essentially is your high-level language; and if you don't, then you have to implement the entire high-level language in the low-level one in order to implement eval.\n\nThinking about [miniscript](https://bitcoinops.org/en/topics/miniscript/) finally brought these ideas together in a way that allowed progress: if you treat the high-level language as a friendly variation of the low-level language (as miniscript does with script), then it perhaps makes sense to have two interpreters (one that keeps everything friendly and high-level, and one for the low-level language), and just have a separate translator/compiler to go from one to the other. That's a little frustrating, in that it introduces the possibility of the high-level interpreter coming up with a different answer to what the compiler and low-level interpreter would produce; but it seems well worth the tradeoff, and that problem is potentially eventually solvable by formal analysis tools.\n\nSo jumping on that idea, I've rewritten almost everything into that new model, with a bit more of a focus on debugging, which means I've now got three things: a basic lisp language which I'm calling \"bll\", that's designed to be able to be slotted into consensus, a higher level language that's designed to be both easier to program in and able to be compiled into bll in a straightforward way, which I'm calling \"symbll\" for \"symbolic bll\", and a REPL for developing in those languages, called \"bllsh\" for \"bll shell\", and which is pronounced \"bullish\", because what's the point of a multi-month diversion if you can't come out of it with some pun-based AI art?\n\n![bllsh - a bull of shells, before a new dawn in scripting|690x172, 100%](upload://xFqM6rYD13KsH8M3T4htPy0C4yO.jpeg)\n\nhttps://github.com/ajtowns/bllsh\n\nIn essence, bll isn't very different from [btclisp](https://delvingbitcoin.org/t/btc-lisp-as-an-alternative-to-script/682) as it was in March; the biggest difference is that it's no longer lazily evaluated, so all arguments to an operation are evaluated (unless the script aborts), though there are other tweaks, such as some opcodes being implemented (`partial`), some being dropped (`/%`) and some being changed (`c` becomes `rc` and builds the list in reverse). The actual code implementing it is quite different, though, mostly due to adopting [continuation passing style](https://en.wikipedia.org/wiki/Continuation-passing_style).\n\nHere's what a simple factorial calculator looks like in bll:\n\n```\n$ ./bllsh\n>>> blleval (a (nil a 2) (rc 1 (b (nil a (i 3 (nil * 3 (a 2 (rc (b (- 3 (nil . 1))) 2))) (nil nil . 1)))))) 5\n120\n```\n\nWriting code in symbll is somewhat easier, provided you're familiar with functional programming:\n\n```\n$ ./bllsh\n>>> def (FR N) (if N (* N (FR (- N 1))) 1)\n>>> eval (FR 5)\n120\n```\n\nThere is also some fairly straightforward ability to do debugging, either printf-style:\n\n```\n$ ./bllsh\n>>> def (FR N) (if (report N 'FR-called) (* N (FR (- N 1))) 1)\n>>> eval (FR 5)\nreport: (5 <FR-called>)\nreport: (4 <FR-called>)\nreport: (3 <FR-called>)\nreport: (2 <FR-called>)\nreport: (1 <FR-called>)\nreport: (nil <FR-called>)\n120\n```\n\nor step-through debugging:\n\n```\n$ ./bllsh\n>>> def (FR N) (if N (* N (FR (- N 1))) 1)\n>>> debug (FR 5)\n   -- 1. FN(fn_symbll_eval,nil)    [<FR> 5]\n>>> step\n   -- 1. FN(fn_userfunc,[[<if> <N> [<*> <N> [<FR> [<-> <N> 1]]] 1] [<N>]])    (5)\n>>> step\n   -- 2. FN(fn_symbll_eval,nil)    5\n   -- 1. FN(fn_userfunc,[[<if> <N> [<*> <N> [<FR> [<-> <N> 1]]] 1] [<N>]])    nil\n>>> step\n   -- 2. FN(fn_fin,nil)    5\n   -- 1. FN(fn_userfunc,[[<if> <N> [<*> <N> [<FR> [<-> <N> 1]]] 1] [<N>]])    nil\n>>> step\n   -- 1. FN(fn_userfunc,[[<if> <N> [<*> <N> [<FR> [<-> <N> 1]]] 1] nil [5 . <N>]])    nil\n>>> cont\nResult: 120\n```\n\nThere's also the ability to compile symbll into bll:\n\n```\n$ ./bllsh\n>>> def (FR N) (if N (* N (FR (- N 1))) 1)\n>>> program FR\n(1 (nil 1 2) (6 1 (10 (nil 1 (5 3 (nil 25 3 (1 2 (6 (10 (24 3 (nil . 1))) 2))) (nil nil . 1))))))\n```\n\n(which is just the original bll program we had above, with the opcodes represented by their numbers, rather than their symbol). The compiler logic is essentially simple macro rewriting, so there's plenty of potential for optimisation there eventually, but it already seems to work pretty well, and being able to run and debug the high level code natively is (at least in my opinion) a huge win.\n\nAnyway, the point of this post was just to update on the language design; hopefully having done that it won't be too hard to move onto discussing actual interesting things you can do in future posts.",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": true,
  "admin": true,
  "staff": true,
  "user_id": 3,
  "hidden": false,
  "trust_level": 4,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}