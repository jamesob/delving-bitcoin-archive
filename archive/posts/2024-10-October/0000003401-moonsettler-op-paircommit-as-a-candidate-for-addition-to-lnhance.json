{
  "id": 3401,
  "name": "moonsettler",
  "username": "moonsettler",
  "avatar_template": "/user_avatar/delvingbitcoin.org/moonsettler/{size}/38_2.png",
  "created_at": "2024-10-25T14:31:23.307Z",
  "cooked": "<p>Hi All,</p>\n<p>Looking for some feedback on what I ended up with for PC.</p>\n<p>The idea is that the number of SHA256 iterations should be minimized in the most likely use case we can optimize for, which is LN-Symmetry. Since the Tag can be pre-computed as a mid-state it would only take 1 or 2 hash cycles in validation for the LN-Symmetry use case.</p>\n<p>In case of a 7 byte balance commitment + 32 byte CTV hash (no HTLCs in-flight), the total preimage size is 55 bytes. Which should make it fit into a single block with the SHA256 length commitment.</p>\n<p>In case there are 2x 32 byte CTV hash commitments, the first 64 byte block is comprised of those hashes, and the second block is the vectors\u2019 size and total length commitment, which would be a largely 0 filled block with a very few bits set to 1.</p>\n<p>It\u2019s a particular concern for LN-Symmetry with CTV that the concatenation of the two preimages allows for length redistribution attacks, because CTV is only defined for 32 byte templates and will act as NOP for different template sizes for upgradeability.</p>\n<p>The question is, is it a good idea to increase the number of bits expected to changed in the preimage in case of stack element resizing attacks?</p>\n<pre data-code-wrap=\"c++\"><code class=\"lang-c++\">const HashWriter HASHER_PAIRCOMMIT{TaggedHash(\"PairCommit\")};\n\nnamespace {\n/* uint32_t hash function using primes 0x3B9ACA07 multiplier and 0x7FFFFFFF modulo\n * expected to change on average ~16 bits in output for a single bit change in input */\n__inline uint32_t uint32_t_hash_x3B9ACA07(const uint32_t&amp; i)\n{\n    static const uint64_t p = 0x3B9ACA07;\n    static const uint32_t m = 0x7FFFFFFF;\n\n    return (p * i) % m;\n}\n}\n\n/* PairCommitHash preimage is expected to change over 32 bits on average in case of\n * length redistribution between the two input vectors */\nuint256 PairCommitHash(const std::vector&lt;unsigned char&gt;&amp; x1, const std::vector&lt;unsigned char&gt;&amp; x2)\n{\n    const uint32_t x1_size = x1.size();\n    const uint32_t x2_size = x2.size();\n    const uint32_t x1_sh = uint32_t_hash_x3B9ACA07(x1_size);\n    const uint32_t x2_sh = uint32_t_hash_x3B9ACA07(x2_size);\n\n    HashWriter ss{HASHER_PAIRCOMMIT};\n    ss &lt;&lt; x1\n       &lt;&lt; x2\n       &lt;&lt; x1_size\n       &lt;&lt; x1_sh\n       &lt;&lt; x2_size\n       &lt;&lt; x2_sh;\n\n    return ss.GetSHA256();\n}\n</code></pre>\n<p>Link: <a href=\"https://github.com/lnhance/bitcoin/pull/7/files\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">OP_PAIRCOMMIT alternative with hash_x3B9ACA07 by moonsettler \u00b7 Pull Request #7 \u00b7 lnhance/bitcoin \u00b7 GitHub</a></p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 12,
  "updated_at": "2024-10-25T14:34:33.286Z",
  "reply_count": 1,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 186,
  "reads": 43,
  "readers_count": 42,
  "score": 958.6,
  "yours": false,
  "topic_id": 1216,
  "topic_slug": "op-paircommit-as-a-candidate-for-addition-to-lnhance",
  "topic_title": "OP_PAIRCOMMIT as a candidate for addition to LNhance",
  "topic_html_title": "OP_PAIRCOMMIT as a candidate for addition to LNhance",
  "category_id": 7,
  "display_username": "moonsettler",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Hi All,\n\nLooking for some feedback on what I ended up with for PC.\n\nThe idea is that the number of SHA256 iterations should be minimized in the most likely use case we can optimize for, which is LN-Symmetry. Since the Tag can be pre-computed as a mid-state it would only take 1 or 2 hash cycles in validation for the LN-Symmetry use case.\n\nIn case of a 7 byte balance commitment + 32 byte CTV hash (no HTLCs in-flight), the total preimage size is 55 bytes. Which should make it fit into a single block with the SHA256 length commitment.\n\nIn case there are 2x 32 byte CTV hash commitments, the first 64 byte block is comprised of those hashes, and the second block is the vectors' size and total length commitment, which would be a largely 0 filled block with a very few bits set to 1.\n\nIt's a particular concern for LN-Symmetry with CTV that the concatenation of the two preimages allows for length redistribution attacks, because CTV is only defined for 32 byte templates and will act as NOP for different template sizes for upgradeability.\n\nThe question is, is it a good idea to increase the number of bits expected to changed in the preimage in case of stack element resizing attacks?\n\n```c++\nconst HashWriter HASHER_PAIRCOMMIT{TaggedHash(\"PairCommit\")};\n\nnamespace {\n/* uint32_t hash function using primes 0x3B9ACA07 multiplier and 0x7FFFFFFF modulo\n * expected to change on average ~16 bits in output for a single bit change in input */\n__inline uint32_t uint32_t_hash_x3B9ACA07(const uint32_t& i)\n{\n    static const uint64_t p = 0x3B9ACA07;\n    static const uint32_t m = 0x7FFFFFFF;\n\n    return (p * i) % m;\n}\n}\n\n/* PairCommitHash preimage is expected to change over 32 bits on average in case of\n * length redistribution between the two input vectors */\nuint256 PairCommitHash(const std::vector<unsigned char>& x1, const std::vector<unsigned char>& x2)\n{\n    const uint32_t x1_size = x1.size();\n    const uint32_t x2_size = x2.size();\n    const uint32_t x1_sh = uint32_t_hash_x3B9ACA07(x1_size);\n    const uint32_t x2_sh = uint32_t_hash_x3B9ACA07(x2_size);\n\n    HashWriter ss{HASHER_PAIRCOMMIT};\n    ss << x1\n       << x2\n       << x1_size\n       << x1_sh\n       << x2_size\n       << x2_sh;\n\n    return ss.GetSHA256();\n}\n```\nLink: https://github.com/lnhance/bitcoin/pull/7/files",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 48,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "Hi All, \nLooking for some feedback on what I ended up with for PC. \nThe idea is that the number of SHA256 iterations should be minimized in the most likely use case we can optimize for, which is LN-Symmetry. Since the Tag can be pre-computed as a mid-state it would only take 1 or 2 hash cycles in va&hellip;",
  "truncated": true,
  "post_url": "/t/op-paircommit-as-a-candidate-for-addition-to-lnhance/1216/1",
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}