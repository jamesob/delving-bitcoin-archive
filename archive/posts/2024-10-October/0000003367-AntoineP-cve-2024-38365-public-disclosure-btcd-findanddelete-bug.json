{
  "id": 3367,
  "name": "Antoine Poinsot",
  "username": "AntoineP",
  "avatar_template": "/user_avatar/delvingbitcoin.org/antoinep/{size}/483_2.png",
  "created_at": "2024-10-15T13:09:04.772Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"ariard\" data-post=\"8\" data-topic=\"1184\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/letter_avatar_proxy/v4/letter/a/c67d28/48.png\" class=\"avatar\"> ariard:</div>\n<blockquote>\n<p>Though there is still the possibility that the signature is invalid w.r.t the <code>scriptCode</code> and the script execution still valid.</p>\n</blockquote>\n</aside>\n<p>Sure, but what we want here is a different script execution between btcd and Core. In the context of this disclosure, this was only possible using a discrepancy in the <code>FindAndDelete</code> implementation therefore you need a signature to be found in the <code>scriptCode</code>. Further, you need the signature to be valid for either btcd or Core, which is only possible if you do public key recovery.</p>\n<aside class=\"quote no-group\" data-username=\"ariard\" data-post=\"8\" data-topic=\"1184\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/letter_avatar_proxy/v4/letter/a/c67d28/48.png\" class=\"avatar\"> ariard:</div>\n<blockquote>\n<p>What if you have : &lt;invalid_sig+noise&gt; &lt;invalid_sig&gt; &lt;OP_CHECKSIG&gt; &lt;OP_SIZE&gt; &lt;length_invalid_sig+noise&gt; OP_EQUALVERIFY.</p>\n<p>In my understanding, core\u2019 should only remove 1 instance of &lt;invalid_sig&gt;, fails on the CHECKSIG (though <code>NULLFAIL</code> policy only) and then succeed on the OP_SIZE. On the other hand, non-upgraded btcd should remove the 2 instances of &lt;invalid_sig&gt; (as invalid_sig+noise contains the invalid_sig) and fails the OP_SIZE + OP_EQUALVERIFY.</p>\n</blockquote>\n</aside>\n<p>I\u2019m not sure what you are trying to get at since your Script is different from what i think you meant:</p>\n<ul>\n<li>Here the <code>CHECKSIG</code> would be executed taking <code>&lt;invalid_sig+noise&gt;</code> as signature and <code>&lt;invalid_sig&gt;</code> as public key, which is always going to push 0 on the stack;</li>\n<li><code>OP_SIZE</code> would then be executed on the result of the <code>CHECKSIG</code>, which is always 0, and so would always return 0 as well;</li>\n<li>Then <code>OP_EQUALVERIFY</code> would always fail since the length of the invalid sig + noise would never be 0.</li>\n</ul>\n<p>I assume you mean that running OP_CHECKSIG would drop the <code>&lt;invalid_sig&gt;</code> (in Bitcoin Core), or both <code>&lt;invalid_sig&gt;</code> and <code>&lt;invalid_sig + noise&gt;</code>, from the Script itself and lead to a discrepancy of the execution when asserting the size of the top element left on the stack. Then you are misunderstanding what <code>FindAndDelete</code> does. It does not tamper with the Script being executed at all, it only modifies a copy of it for the purpose of committing to it in the sighash. Even if your Script from above correctly implemented what i think you intended it to, it would not cause a different execution between btcd and Bitcoin Core: the executed script is always the same so the size of the top stack element would always be the same for both.</p>",
  "post_number": 9,
  "post_type": 1,
  "posts_count": 12,
  "updated_at": "2024-10-15T13:09:04.772Z",
  "reply_count": 1,
  "reply_to_post_number": 8,
  "quote_count": 1,
  "incoming_link_count": 0,
  "reads": 51,
  "readers_count": 50,
  "score": 15.2,
  "yours": false,
  "topic_id": 1184,
  "topic_slug": "cve-2024-38365-public-disclosure-btcd-findanddelete-bug",
  "topic_title": "CVE-2024-38365 public disclosure (btcd `FindAndDelete` bug)",
  "topic_html_title": "CVE-2024-38365 public disclosure (btcd `FindAndDelete` bug)",
  "category_id": 8,
  "display_username": "Antoine Poinsot",
  "primary_group_name": null,
  "flair_name": "wg-consensus-cleanup",
  "flair_url": "/uploads/default/original/1X/856d779f9ec58484f3a96285a21a813538b689f6.png",
  "flair_bg_color": "",
  "flair_color": "",
  "flair_group_id": 43,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": "Regular",
  "title_is_group": false,
  "bookmarked": false,
  "raw": "[quote=\"ariard, post:8, topic:1184\"]\nThough there is still the possibility that the signature is invalid w.r.t the `scriptCode` and the script execution still valid.\n[/quote]\n\nSure, but what we want here is a different script execution between btcd and Core. In the context of this disclosure, this was only possible using a discrepancy in the `FindAndDelete` implementation therefore you need a signature to be found in the `scriptCode`. Further, you need the signature to be valid for either btcd or Core, which is only possible if you do public key recovery.\n\n[quote=\"ariard, post:8, topic:1184\"]\nWhat if you have : <invalid_sig+noise> <invalid_sig> <OP_CHECKSIG> <OP_SIZE> <length_invalid_sig+noise> OP_EQUALVERIFY.\n\nIn my understanding, core\u2019 should only remove 1 instance of <invalid_sig>, fails on the CHECKSIG (though `NULLFAIL` policy only) and then succeed on the OP_SIZE. On the other hand, non-upgraded btcd should remove the 2 instances of <invalid_sig> (as invalid_sig+noise contains the invalid_sig) and fails the OP_SIZE + OP_EQUALVERIFY.\n[/quote]\n\nI'm not sure what you are trying to get at since your Script is different from what i think you meant:\n- Here the `CHECKSIG` would be executed taking `<invalid_sig+noise>` as signature and `<invalid_sig>` as public key, which is always going to push 0 on the stack;\n- `OP_SIZE` would then be executed on the result of the `CHECKSIG`, which is always 0, and so would always return 0 as well;\n- Then `OP_EQUALVERIFY` would always fail since the length of the invalid sig + noise would never be 0.\n\nI assume you mean that running OP_CHECKSIG would drop the `<invalid_sig>` (in Bitcoin Core), or both `<invalid_sig>` and `<invalid_sig + noise>`, from the Script itself and lead to a discrepancy of the execution when asserting the size of the top element left on the stack. Then you are misunderstanding what `FindAndDelete` does. It does not tamper with the Script being executed at all, it only modifies a copy of it for the purpose of committing to it in the sighash. Even if your Script from above correctly implemented what i think you intended it to, it would not cause a different execution between btcd and Bitcoin Core: the executed script is always the same so the size of the top stack element would always be the same for both.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 12,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "Sure, but what we want here is a different script execution between btcd and Core. In the context of this disclosure, this was only possible using a discrepancy in the FindAndDelete implementation therefore you need a signature to be found in the scriptCode. Further, you need the signature to be va&hellip;",
  "truncated": true,
  "post_url": "/t/cve-2024-38365-public-disclosure-btcd-findanddelete-bug/1184/9",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}