{
  "id": 6038,
  "name": "ZmnSCPxj jxPCSnmZ",
  "username": "ZmnSCPxj",
  "avatar_template": "/letter_avatar_proxy/v4/letter/z/ee7513/{size}.png",
  "created_at": "2025-10-10T06:21:59.582Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"ZmnSCPxj\" data-post=\"3\" data-topic=\"2029\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/letter_avatar_proxy/v4/letter/z/ee7513/48.png\" class=\"avatar\"> ZmnSCPxj:</div>\n<blockquote>\n<p>You could even use standard LUKS</p>\n</blockquote>\n</aside>\n<p>After a bit of research, I found that LUKSv2 composes two subsystems: dm-crypt and dm-integrity. The combination is <em>effectively</em> equivalent to an AE scheme, with dm-integrity checking for data modification or corruption before dm-crypt decrypts (effectively equivalent to Encrypt-then-MAC).  dm-integrity however needs to ensure atomicity of both the tag (what it calls the MAC) update and the actual sector, and to do so, it uses\u2026 a journal!</p>\n<p>The problem is that of a <a href=\"https://www.usenix.org/system/files/conference/inflow14/inflow14-yang.pdf\" rel=\"noopener nofollow ugc\">log on a log</a>.  Briefly, a log \u2014 including just a short write-ahead log or journal \u2014 is required for atomicity, but represent writing twice as much on every write: once to the log, once to the real location.  But if you have a <em><strong>logged layer on top of a logged layer</strong></em>, then you are writing <em><strong>four times</strong></em>: first the upper layer writes to its log, which on the lower layer translates to two writes (one to the lower-layer log, one to the lower-layer storage), and then the upper layer writes to it storage, which on the lower layer translates to two <em><strong>more</strong></em> writes (one to the lower-layer log, one to the lower-layer storage).</p>\n<p>Such a thing can happen when our array-management code uses a journal to write out planned writes to ensure atomicity across devices and plug the RAID5 write hole, then have an additional layer on top that handles AE (i.e. dm-integrity+dm-crypt aka LUKS2) that has its own journal to write out planned writes to ensure atomicity of updating MACs and the actual sector storage.</p>\n<p>The correct solution is to collapse the log layers into a single one, which is why ZFS is <em><strong>awesome</strong></em>, it uses the same atomicity logging for both plugging the RAID5 write hole <em><strong>and</strong></em> ensuring it is a transactional filesystem <em><strong>and</strong></em> it is capable of using cryptography-quality checksums <em><strong>and</strong></em> has encryption <em><strong>and</strong></em> that is all on one log layer.  More broadly, XFS has been proposing a bunch of extensions as well to integrate database logs into its own logs so that it can provide the atomicity of its own log to upper layer databases running on XFS, and avoid the log-on-a-log problem.</p>\n<p>The eventual evolution of this is that you have a lower layer that has a ridiculously large log / journal, because all the higher layers are relying on it for atomicity, and that means more and more data being pushed inside an atomic operation.  The end result is you have a copy-on-write filesystem, just like ZFS, where in essence the <em><strong>whole</strong></em> disk is a log and there is no separate \u201cstorage\u201d to rewrite to \u2014 you just write the log on to whatever free space is available instead of overwriting existing storage, and then after you are <em><strong>sure</strong></em> the lying underlying disk has <em><strong>actually</strong></em> written the data out, you mark the existing storage whose data you replaced as \u201cnow this is free\u201d, without having to double-write from the journal to the storage: the journal <em><strong>is</strong></em> the storage.</p>\n<p>The problem with that scheme is for the \u201ckey deletion\u201d problem of statechain signers.  Old journal entries are effectively backups of the data, and therefore at risk of exfiltration of supposedly-deleted keys.  So we actually have to <em><strong>avoid</strong></em> copy-on-write schemes for statechain signers; we want a short journal that we specifically destroy each time we have applied the latest journal entry.  However, we <em><strong>can</strong></em> at least merge the atomicity-providing log layers for the AE and the RAID-X.</p>\n<p>We can have an array of IV+MAC.  Each IV+MAC covers on sector of encrypted storage, and is itself stored in some number of sectors.  Like the encrypted storage itself, the IV+MAC is also done with erasure coding \u2014 note that we do not need to IV+MAC the parity sectors, only the actual storage sectors; if we can recover using the parity sectors and the recovered data matches the IV+MAC, then the parity sectors are also correct, thus they are implicitly covered by the same IV+MAC.  The IV removes the problem of using a stream cipher with full disk encryption, as full disk encryption requires sector-addressible deciphering; each encrypted storage sector gets its own IV, and we can use an AEAD scheme where the AD is the encrypted storage sector index in the RAID array.  For ChaCha20, the IV is 12 bytes.  We should use HMAC instead of Poly1305, due to a minor weakness in Poly1305 that allows the tag to be malleated by attackers to match the same encrypted data to a different MAC encryption key, in that the Poly1305 MAC matches, but decryption results in garbage output \u2014 but the point of Encrypt-then-MAC is that the probability of MAC matching for a different key is so low that if the MAC matches then decryption will be for the same encryption key and result in the original plaintext and not garbage, thus this issue with Poly1305 violates that assumption.  This is the key-commitment problem, and HMAC naturally commits to the MAC key (but polynomial-based MACs like Poly1305 do not).  The output of HMAC-SHA-2-256 is 32 bytes but I understand that it can be truncated to 16 bytes, so a 28 byte IV(12 bytes)+MAC(16 bytes) for each 4096 sector is slightly above half a percent overhead.  The array of IV+MAC would also be grouped into 4096-byte sectors, and each such sector also needs its own IV+MAC covering the section of the array it contains \u2014 we can have 145 IV+MAC entries in a 4096-byte sector, plus a 146th entry covering itself.</p>\n<p>The journal only needs to be expanded enough to be able to contain one stripe width (storage sectors + parity sectors) for the main data, plus two IV+MAC storage sectors and the IV+MAC parity sectors to update.  We only need two IV+MAC sectors in case the storage sectors of a stripe have to cross between two IV+MAC sectors.  Then we can atomically ensure not only against RAID5 write hole, but also atomic update of the encryption+integrity data.  At the same time, the (relatively) small journal means we can afford to ask the disk to delete the journal data and leave only the version counter in the atomicity sector, thus also preventing having natural backups of supposedly-deleted keys.  While typical modern filesystems and databases will actually have logs on top for atomicity as well, a statechain signer application can simply perform direct writes to a dedicated partition of the simulated persistent storage disk, to ensure that erasure of old keys goes through fewer layers that need to be audited against having accidental backup copies.</p>",
  "post_number": 4,
  "post_type": 1,
  "posts_count": 4,
  "updated_at": "2025-10-10T06:21:59.582Z",
  "reply_count": 0,
  "reply_to_post_number": 3,
  "quote_count": 1,
  "incoming_link_count": 0,
  "reads": 18,
  "readers_count": 17,
  "score": 3.6,
  "yours": false,
  "topic_id": 2029,
  "topic_slug": "persisting-mutable-storage-inside-the-t-ee",
  "topic_title": "Persisting Mutable Storage Inside The \"T\"EE",
  "topic_html_title": "Persisting Mutable Storage Inside The &ldquo;T&rdquo;EE",
  "category_id": 8,
  "display_username": "ZmnSCPxj jxPCSnmZ",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"ZmnSCPxj, post:3, topic:2029\"]\nYou could even use standard LUKS\n\n[/quote]\n\nAfter a bit of research, I found that LUKSv2 composes two subsystems: dm-crypt and dm-integrity. The combination is *effectively* equivalent to an AE scheme, with dm-integrity checking for data modification or corruption before dm-crypt decrypts (effectively equivalent to Encrypt-then-MAC).  dm-integrity however needs to ensure atomicity of both the tag (what it calls the MAC) update and the actual sector, and to do so, it uses\u2026 a journal!\n\nThe problem is that of a [log on a log](https://www.usenix.org/system/files/conference/inflow14/inflow14-yang.pdf).  Briefly, a log \u2014 including just a short write-ahead log or journal \u2014 is required for atomicity, but represent writing twice as much on every write: once to the log, once to the real location.  But if you have a ***logged layer on top of a logged layer***, then you are writing ***four times***: first the upper layer writes to its log, which on the lower layer translates to two writes (one to the lower-layer log, one to the lower-layer storage), and then the upper layer writes to it storage, which on the lower layer translates to two ***more*** writes (one to the lower-layer log, one to the lower-layer storage).\n\nSuch a thing can happen when our array-management code uses a journal to write out planned writes to ensure atomicity across devices and plug the RAID5 write hole, then have an additional layer on top that handles AE (i.e. dm-integrity+dm-crypt aka LUKS2) that has its own journal to write out planned writes to ensure atomicity of updating MACs and the actual sector storage.\n\nThe correct solution is to collapse the log layers into a single one, which is why ZFS is ***awesome***, it uses the same atomicity logging for both plugging the RAID5 write hole ***and*** ensuring it is a transactional filesystem ***and*** it is capable of using cryptography-quality checksums ***and*** has encryption ***and*** that is all on one log layer.  More broadly, XFS has been proposing a bunch of extensions as well to integrate database logs into its own logs so that it can provide the atomicity of its own log to upper layer databases running on XFS, and avoid the log-on-a-log problem.\n\nThe eventual evolution of this is that you have a lower layer that has a ridiculously large log / journal, because all the higher layers are relying on it for atomicity, and that means more and more data being pushed inside an atomic operation.  The end result is you have a copy-on-write filesystem, just like ZFS, where in essence the ***whole*** disk is a log and there is no separate \u201cstorage\u201d to rewrite to \u2014 you just write the log on to whatever free space is available instead of overwriting existing storage, and then after you are ***sure*** the lying underlying disk has ***actually*** written the data out, you mark the existing storage whose data you replaced as \u201cnow this is free\u201d, without having to double-write from the journal to the storage: the journal ***is*** the storage.\n\nThe problem with that scheme is for the \u201ckey deletion\u201d problem of statechain signers.  Old journal entries are effectively backups of the data, and therefore at risk of exfiltration of supposedly-deleted keys.  So we actually have to ***avoid*** copy-on-write schemes for statechain signers; we want a short journal that we specifically destroy each time we have applied the latest journal entry.  However, we ***can*** at least merge the atomicity-providing log layers for the AE and the RAID-X.\n\nWe can have an array of IV+MAC.  Each IV+MAC covers on sector of encrypted storage, and is itself stored in some number of sectors.  Like the encrypted storage itself, the IV+MAC is also done with erasure coding \u2014 note that we do not need to IV+MAC the parity sectors, only the actual storage sectors; if we can recover using the parity sectors and the recovered data matches the IV+MAC, then the parity sectors are also correct, thus they are implicitly covered by the same IV+MAC.  The IV removes the problem of using a stream cipher with full disk encryption, as full disk encryption requires sector-addressible deciphering; each encrypted storage sector gets its own IV, and we can use an AEAD scheme where the AD is the encrypted storage sector index in the RAID array.  For ChaCha20, the IV is 12 bytes.  We should use HMAC instead of Poly1305, due to a minor weakness in Poly1305 that allows the tag to be malleated by attackers to match the same encrypted data to a different MAC encryption key, in that the Poly1305 MAC matches, but decryption results in garbage output \u2014 but the point of Encrypt-then-MAC is that the probability of MAC matching for a different key is so low that if the MAC matches then decryption will be for the same encryption key and result in the original plaintext and not garbage, thus this issue with Poly1305 violates that assumption.  This is the key-commitment problem, and HMAC naturally commits to the MAC key (but polynomial-based MACs like Poly1305 do not).  The output of HMAC-SHA-2-256 is 32 bytes but I understand that it can be truncated to 16 bytes, so a 28 byte IV(12 bytes)+MAC(16 bytes) for each 4096 sector is slightly above half a percent overhead.  The array of IV+MAC would also be grouped into 4096-byte sectors, and each such sector also needs its own IV+MAC covering the section of the array it contains \u2014 we can have 145 IV+MAC entries in a 4096-byte sector, plus a 146th entry covering itself.\n\nThe journal only needs to be expanded enough to be able to contain one stripe width (storage sectors + parity sectors) for the main data, plus two IV+MAC storage sectors and the IV+MAC parity sectors to update.  We only need two IV+MAC sectors in case the storage sectors of a stripe have to cross between two IV+MAC sectors.  Then we can atomically ensure not only against RAID5 write hole, but also atomic update of the encryption+integrity data.  At the same time, the (relatively) small journal means we can afford to ask the disk to delete the journal data and leave only the version counter in the atomicity sector, thus also preventing having natural backups of supposedly-deleted keys.  While typical modern filesystems and databases will actually have logs on top for atomicity as well, a statechain signer application can simply perform direct writes to a dedicated partition of the simulated persistent storage disk, to ensure that erasure of old keys goes through fewer layers that need to be audited against having accidental backup copies.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 104,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "After a bit of research, I found that LUKSv2 composes two subsystems: dm-crypt and dm-integrity. The combination is effectively equivalent to an AE scheme, with dm-integrity checking for data modification or corruption before dm-crypt decrypts (effectively equivalent to Encrypt-then-MAC).  dm-integ&hellip;",
  "truncated": true,
  "post_url": "/t/persisting-mutable-storage-inside-the-t-ee/2029/4",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}