{
  "id": 6024,
  "name": "ZmnSCPxj jxPCSnmZ",
  "username": "ZmnSCPxj",
  "avatar_template": "/letter_avatar_proxy/v4/letter/z/ee7513/{size}.png",
  "created_at": "2025-10-08T16:01:51.082Z",
  "cooked": "<p>An objection against this scheme is: why would you even do this?</p>\n<p>For instance, instead of having n storage devices and building against failure of n - k devices, why not just have a k-of-n signer, with n \u201cT\u201dEEs running signer code and using ephemeral keys?</p>\n<p>The reason for preferring this scheme is: What are the reasons for you to bring down a running \u201cT\u201dEE?</p>\n<p>Now, the more things a piece of code does, the more likely we need to stop it in order to update it.</p>\n<p>And in the case of a simple storage \u201cT\u201dEE program, there is very little it does:</p>\n<ol>\n<li>Validate that request comes from an authorized main program (e.g. if it is a Lightning node, it could sign all requests with the node key; the model being that exfiltration of the node key would be total loss of funds anyway)\n<ol>\n<li>This public key can be hardcoded so that it is part of the PCR attested to when the main program first mounts the array.</li>\n</ol>\n</li>\n<li>Read sector</li>\n<li>Write sector</li>\n<li>(if we optimize) copy sector</li>\n<li>(if we are paranoid about key deletion) trim/<code>memset(buf, 0, sizeof(buf))</code> sector</li>\n</ol>\n<p>The sheer simplicity of this means there is little reason to ever update the storage \u201cT\u201dEE program, and thus, to ever have to stop it and restart it.</p>\n<p>In addition, the \u201cT\u201dEE program itself does not have any private keys of its own.  If the main application itself needs to store keys, and is paranoid about sidechannels in the remote storage \u201cT\u201dEE letting the keys be exfiltrated because it has been running for several years on old hardware with old microcode that lets sidechannels exist, it can encrypt the keys (using the same key it uses to authorize itself as a reader/writer to the \u201cT\u201dEE disks) while still able to restart and migrate to new hardware with fixed microcode itself, since the persistent layer is separate from the business logic layer.</p>\n<p>Thus the model is:</p>\n<ul>\n<li>The main program is stateless except for the private key it holds (wave hands about how it gets into the enclave; see ACINQ setup if you want an example).\n<ul>\n<li>It can be restarted at any time, and the software updated.</li>\n<li>Operator is responsible for ensuring the updated software is trustworthy enough to hand over the private keys to (e.g. see how it is done for ACINQ setup, they basically have a number of responsible developers sign off on each version that they allow to run in the \u201cT\u201dEE, and the loader component that is fixed validates the developer signatures before running the main program and giving it the private key via a <code>tmpfs</code> mount)</li>\n</ul>\n</li>\n<li>The storage programs are always kept running at very high uptime, with no real expectation to be restarted.\n<ul>\n<li>Even if new sidechannel attacks on their old hardware arise, the storage programs hold NO private keys of their own.  They only validate the commands sent by the purported main program via the hardcoded public key.</li>\n<li>Without their own private key (not even an ephemeral one) the \u201cT\u201dEE storage program cannot establish an encrypted tunnel with the main program!  But:\n<ul>\n<li>The main program array-managing code can encrypt the data it puts in the sectors, and place the MAC elsewhere such as in a validation tree of sectors (like how ZFS does its checksums, because ZFS is <em><strong>awesome</strong></em>).  Then, as far as the storage programs are concerned, the data it receives from the main program in the \u201cwrite sector\u201d command, and thus stores in its \u201cpersistent\u201d memory, is \u201cplaintext\u201d, even though the array-managing code is actually encrypting the data before handing over to the \u201cT\u201dEE storage program.  That way, there is no need to establish an encrypted tunnel (which would require that the \u201cT\u201dEE storage program hold an ephemeral private key for purposes of establishing encrypted tunnels via ECDH), because the array-managing code has already encrypted the data that will be put remotely, and the \u201cplaintext\u201d commands contain ciphertexts already.  Integrity is still preserved by the requirement that commands be signed by the authorized main program, thus any change in the data in-transit will be detectable by failing the signature.</li>\n<li>If you think about it, persistent storage is just a messaging system between your past self and your future self, and thus, you only need to encrypt data from your past self to your future self, with the persistent storage not requiring its own dedicated encrypted tunnel; your encrypted tunnel goes from your past self to your future self.</li>\n<li>What about rollback attacks, which do not require that attackers be able to decrypt, only that they have an old copy of the ciphertext? Well, on each \u201cread sector\u201d command, the \u201cT\u201dEE storage program also creates a remote hardware attestation, committing to the sector read plus a challenge nonce from the main program, and thus assuring the main program that the \u201cT\u201dEE storage program with <em><strong>no</strong></em> rollback code is the one responding with the latest data for that sector, and not old data inserted by a MITM (the challenge nonce means old responses cannot be replayed, and the attestation key is something you already trust to not be exfiltrated, ever, because that would allow the \u201cT\u201dEE to be virtualized sufficiently that the program giving attestations can be different from the program you signed and checked the PCRs of).</li>\n</ul>\n</li>\n<li>You could even use standard LUKS, with the Lightning node key, or the statechain operator signing key, as the password to the LUKS volume, so that the array-managing code is just emulating a disk and presenting it to LUKS as the mountable disk, which simplifies your array manager so that the necessary MACs are handled by the LUKS layer.  OR just use ZFS with encryption on top, though that may be problematic for the statechain signer case as ZFS naturally does copy-on-write and may retain old \u201cdeleted\u201d keys \u2014 at least LUKS itself presents just a disk as well, and you can use a non-journalled EXT4 to avoid the issue of multiple copies of stored disk, or manage the deletable keys yourself in a separate partition and put a proper filesystem like ZFS on the rest of the storage.</li>\n</ul>\n</li>\n</ul>",
  "post_number": 3,
  "post_type": 1,
  "posts_count": 4,
  "updated_at": "2025-10-08T16:13:19.116Z",
  "reply_count": 1,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 23,
  "readers_count": 22,
  "score": 9.6,
  "yours": false,
  "topic_id": 2029,
  "topic_slug": "persisting-mutable-storage-inside-the-t-ee",
  "topic_title": "Persisting Mutable Storage Inside The \"T\"EE",
  "topic_html_title": "Persisting Mutable Storage Inside The &ldquo;T&rdquo;EE",
  "category_id": 8,
  "display_username": "ZmnSCPxj jxPCSnmZ",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "An objection against this scheme is: why would you even do this?\n\nFor instance, instead of having n storage devices and building against failure of n - k devices, why not just have a k-of-n signer, with n \u201cT\u201dEEs running signer code and using ephemeral keys?\n\nThe reason for preferring this scheme is: What are the reasons for you to bring down a running \u201cT\u201dEE?\n\nNow, the more things a piece of code does, the more likely we need to stop it in order to update it.\n\nAnd in the case of a simple storage \u201cT\u201dEE program, there is very little it does:\n\n1. Validate that request comes from an authorized main program (e.g. if it is a Lightning node, it could sign all requests with the node key; the model being that exfiltration of the node key would be total loss of funds anyway)\n   1. This public key can be hardcoded so that it is part of the PCR attested to when the main program first mounts the array.\n2. Read sector\n3. Write sector\n4. (if we optimize) copy sector\n5. (if we are paranoid about key deletion) trim/`memset(buf, 0, sizeof(buf))` sector\n\nThe sheer simplicity of this means there is little reason to ever update the storage \u201cT\u201dEE program, and thus, to ever have to stop it and restart it.\n\nIn addition, the \u201cT\u201dEE program itself does not have any private keys of its own.  If the main application itself needs to store keys, and is paranoid about sidechannels in the remote storage \u201cT\u201dEE letting the keys be exfiltrated because it has been running for several years on old hardware with old microcode that lets sidechannels exist, it can encrypt the keys (using the same key it uses to authorize itself as a reader/writer to the \u201cT\u201dEE disks) while still able to restart and migrate to new hardware with fixed microcode itself, since the persistent layer is separate from the business logic layer.\n\nThus the model is:\n\n* The main program is stateless except for the private key it holds (wave hands about how it gets into the enclave; see ACINQ setup if you want an example).\n  * It can be restarted at any time, and the software updated.\n  * Operator is responsible for ensuring the updated software is trustworthy enough to hand over the private keys to (e.g. see how it is done for ACINQ setup, they basically have a number of responsible developers sign off on each version that they allow to run in the \u201cT\u201dEE, and the loader component that is fixed validates the developer signatures before running the main program and giving it the private key via a `tmpfs` mount)\n* The storage programs are always kept running at very high uptime, with no real expectation to be restarted.\n  * Even if new sidechannel attacks on their old hardware arise, the storage programs hold NO private keys of their own.  They only validate the commands sent by the purported main program via the hardcoded public key.\n  * Without their own private key (not even an ephemeral one) the \u201cT\u201dEE storage program cannot establish an encrypted tunnel with the main program!  But:\n    * The main program array-managing code can encrypt the data it puts in the sectors, and place the MAC elsewhere such as in a validation tree of sectors (like how ZFS does its checksums, because ZFS is ***awesome***).  Then, as far as the storage programs are concerned, the data it receives from the main program in the \u201cwrite sector\u201d command, and thus stores in its \u201cpersistent\u201d memory, is \u201cplaintext\u201d, even though the array-managing code is actually encrypting the data before handing over to the \u201cT\u201dEE storage program.  That way, there is no need to establish an encrypted tunnel (which would require that the \u201cT\u201dEE storage program hold an ephemeral private key for purposes of establishing encrypted tunnels via ECDH), because the array-managing code has already encrypted the data that will be put remotely, and the \u201cplaintext\u201d commands contain ciphertexts already.  Integrity is still preserved by the requirement that commands be signed by the authorized main program, thus any change in the data in-transit will be detectable by failing the signature.\n    * If you think about it, persistent storage is just a messaging system between your past self and your future self, and thus, you only need to encrypt data from your past self to your future self, with the persistent storage not requiring its own dedicated encrypted tunnel; your encrypted tunnel goes from your past self to your future self.\n    * What about rollback attacks, which do not require that attackers be able to decrypt, only that they have an old copy of the ciphertext? Well, on each \u201cread sector\u201d command, the \u201cT\u201dEE storage program also creates a remote hardware attestation, committing to the sector read plus a challenge nonce from the main program, and thus assuring the main program that the \u201cT\u201dEE storage program with ***no*** rollback code is the one responding with the latest data for that sector, and not old data inserted by a MITM (the challenge nonce means old responses cannot be replayed, and the attestation key is something you already trust to not be exfiltrated, ever, because that would allow the \u201cT\u201dEE to be virtualized sufficiently that the program giving attestations can be different from the program you signed and checked the PCRs of).\n  * You could even use standard LUKS, with the Lightning node key, or the statechain operator signing key, as the password to the LUKS volume, so that the array-managing code is just emulating a disk and presenting it to LUKS as the mountable disk, which simplifies your array manager so that the necessary MACs are handled by the LUKS layer.  OR just use ZFS with encryption on top, though that may be problematic for the statechain signer case as ZFS naturally does copy-on-write and may retain old \u201cdeleted\u201d keys \u2014 at least LUKS itself presents just a disk as well, and you can use a non-journalled EXT4 to avoid the issue of multiple copies of stored disk, or manage the deletable keys yourself in a separate partition and put a proper filesystem like ZFS on the rest of the storage.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 104,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "An objection against this scheme is: why would you even do this? \nFor instance, instead of having n storage devices and building against failure of n - k devices, why not just have a k-of-n signer, with n \u201cT\u201dEEs running signer code and using ephemeral keys? \nThe reason for preferring this scheme is:&hellip;",
  "truncated": true,
  "post_url": "/t/persisting-mutable-storage-inside-the-t-ee/2029/3",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}