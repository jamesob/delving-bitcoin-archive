{
  "id": 6056,
  "name": "Pieter Wuille",
  "username": "sipa",
  "avatar_template": "/user_avatar/delvingbitcoin.org/sipa/{size}/1100_2.png",
  "created_at": "2025-10-13T14:49:52.548Z",
  "cooked": "<p>I think the same estimate is possible without actually maintaining the template set <span class=\"math\">R</span>, even incrementally.</p>\n<p>Inside <code>TxGraph</code> (the internal component abstracting away the cluster linearization complexity from the mempool), we currently maintain an index of all chunks, sorted by descending feerate. This index is totally ordered, and is used for block building and eviction, but can be used for more than that.</p>\n<p>The idea would be to maintain an <em>implicit</em> block template, consisting of all chunks in <code>TxGraph</code> from the beginning of the index, up to but excluding a non-fitting chunk <span class=\"math\">c_\\mathrm{nf}</span>, so <span class=\"math\">F = \\sum_{c=0}^{c &lt; c_\\mathrm{nf}} \\mathrm{fee}(c)</span>, and <span class=\"math\">S = \\sum_{c=0}^{c &lt; c_\\mathrm{nf}} \\mathrm{size}(c)</span>. The non-fitting chunk <span class=\"math\">c_\\mathrm{nf}</span> is such that <span class=\"math\">S \\leq 3992000</span>, but <span class=\"math\">S + \\mathrm{size}(c_\\mathrm{nf}) &gt; 39920000</span>. <code>TxGraph</code> stores <span class=\"math\">F</span>, <span class=\"math\">S</span>, and a pointer to <span class=\"math\">c_\\mathrm{nf}</span>.</p>\n<p>After any operation that modifies <code>TxGraph</code>, these variables can be updated. If a chunk <span class=\"math\">c</span> is removed for which <span class=\"math\">c &lt; c_\\mathrm{nf}</span>, subtract it from <span class=\"math\">(F, S)</span>. If a chunk <span class=\"math\">c</span> is added for which <span class=\"math\">c &lt; c_\\mathrm{nf}</span>, add it to <span class=\"math\">(F, S)</span>. If the pointed-to chunk itself is removed, move the pointer up, <span class=\"math\">c_\\mathrm{nf} := c_\\mathrm{nf} + 1</span>. If at the end <span class=\"math\">S + \\mathrm{size}(c_\\mathrm{nf}) \\leq 3992000</span>, add it to <span class=\"math\">(F, S)</span> and move the pointer up. If at the end <span class=\"math\">S &gt; 3992000</span>, subtract from <span class=\"math\">(F, S)</span> and move the pointer down.</p>\n<p>These operations are all <span class=\"math\">\\mathcal{O}(n)</span> in the number of modified chunks, so don\u2019t change any internal complexity, and they only need <span class=\"math\">\\mathcal{O}(1)</span> memory (<span class=\"math\">F</span>, <span class=\"math\">S</span>, and one pointer).</p>\n<p>And with these variables, we can associate two block fee estimates:</p>\n<ul>\n<li>A conservative lower bound: <span class=\"math\">F</span>.</li>\n<li>A conservative upper bound: <span class=\"math\">F + \\frac{\\mathrm{fee}(c_\\mathrm{nf})}{\\mathrm{size}(c_\\mathrm{nf})} \\cdot (3992000 - S)</span>.</li>\n</ul>\n<p>A combination of the two could be used as approximation.</p>\n<p>My idea would be to allow the block template waiting code to install a callback function into <code>TxGraph</code>, which would get called any time the lower/upper bound change. The callback function could then decide whether the increase since the last computed block template is significant enough to trigger a full block templating building.</p>",
  "post_number": 2,
  "post_type": 1,
  "posts_count": 2,
  "updated_at": "2025-10-13T14:52:48.326Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 3,
  "readers_count": 2,
  "score": 15.6,
  "yours": false,
  "topic_id": 2052,
  "topic_slug": "determining-blocktemplate-fee-increase-using-fee-rate-diagram",
  "topic_title": "Determining BlockTemplate Fee Increase Using Fee Rate Diagram",
  "topic_html_title": "Determining BlockTemplate Fee Increase Using Fee Rate Diagram",
  "category_id": 8,
  "display_username": "Pieter Wuille",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "I think the same estimate is possible without actually maintaining the template set $R$, even incrementally.\n\nInside `TxGraph` (the internal component abstracting away the cluster linearization complexity from the mempool), we currently maintain an index of all chunks, sorted by descending feerate. This index is totally ordered, and is used for block building and eviction, but can be used for more than that.\n\nThe idea would be to maintain an *implicit* block template, consisting of all chunks in `TxGraph` from the beginning of the index, up to but excluding a non-fitting chunk $c_\\mathrm{nf}$, so $F = \\sum_{c=0}^{c < c_\\mathrm{nf}} \\mathrm{fee}(c)$, and $S = \\sum_{c=0}^{c < c_\\mathrm{nf}} \\mathrm{size}(c)$. The non-fitting chunk $c_\\mathrm{nf}$ is such that $S \\leq 3992000$, but $S + \\mathrm{size}(c_\\mathrm{nf}) > 39920000$. `TxGraph` stores $F$, $S$, and a pointer to $c_\\mathrm{nf}$. \n\nAfter any operation that modifies `TxGraph`, these variables can be updated. If a chunk $c$ is removed for which $c < c_\\mathrm{nf}$, subtract it from $(F, S)$. If a chunk $c$ is added for which $c < c_\\mathrm{nf}$, add it to $(F, S)$. If the pointed-to chunk itself is removed, move the pointer up, $c_\\mathrm{nf} := c_\\mathrm{nf} + 1$. If at the end $S + \\mathrm{size}(c_\\mathrm{nf}) \\leq 3992000$, add it to $(F, S)$ and move the pointer up. If at the end $S > 3992000$, subtract from $(F, S)$ and move the pointer down.\n\nThese operations are all $\\mathcal{O}(n)$ in the number of modified chunks, so don't change any internal complexity, and they only need $\\mathcal{O}(1)$ memory ($F$, $S$, and one pointer).\n\nAnd with these variables, we can associate two block fee estimates:\n* A conservative lower bound: $F$.\n* A conservative upper bound: $F + \\frac{\\mathrm{fee}(c_\\mathrm{nf})}{\\mathrm{size}(c_\\mathrm{nf})} \\cdot (3992000 - S)$.\n\nA combination of the two could be used as approximation.\n\nMy idea would be to allow the block template waiting code to install a callback function into `TxGraph`, which would get called any time the lower/upper bound change. The callback function could then decide whether the increase since the last computed block template is significant enough to trigger a full block templating building.",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 96,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "I think the same estimate is possible without actually maintaining the template set R, even incrementally. \nInside TxGraph (the internal component abstracting away the cluster linearization complexity from the mempool), we currently maintain an index of all chunks, sorted by descending feerate. This&hellip;",
  "truncated": true,
  "post_url": "/t/determining-blocktemplate-fee-increase-using-fee-rate-diagram/2052/2",
  "reactions": [
    {
      "id": "heart",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}