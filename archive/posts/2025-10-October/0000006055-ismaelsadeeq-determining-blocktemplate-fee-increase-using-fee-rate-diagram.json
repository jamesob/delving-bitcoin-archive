{
  "id": 6055,
  "name": "Abubakar Sadiq Ismail",
  "username": "ismaelsadeeq",
  "avatar_template": "/user_avatar/delvingbitcoin.org/ismaelsadeeq/{size}/151_2.png",
  "created_at": "2025-10-13T14:20:58.359Z",
  "cooked": "<h4><a name=\"p-6055-motivation-and-background-1\" class=\"anchor\" href=\"#p-6055-motivation-and-background-1\"></a>Motivation and Background</h4>\n<p>Currently, when miners want to determine whether a block template with more fees is available, they repeatedly poll the <code>getblocktemplate</code> RPC until a better template is returned (relative to the one they are working on). This approach can lead to redundant block template builds in some cases.</p>\n<p>The experimental mining interface introduced in <a href=\"https://delvingbitcoin.org/t/bitcoin-core-v30-0-released/2050\">Bitcoin Core v30</a>, <code>waitnext()</code>, improves this by allowing clients to wait and receive a new block template after a noticeable fee increase or when the blockchain tip changes.</p>\n<p>However, internally, <code>waitnext()</code> also regenerates block templates every second.\nBuilding a block template locks Bitcoin Core mutexes, (mempool (<code>cs</code>) and <code>cs_main</code>) throughout the build. These locks prevent concurrent access during template generation for thread safety purpose, which can delay transaction processing and relay to peers.</p>\n<p>A better approach is to <strong>track the potential fee increase</strong> resulting from each mempool update that affects the current block template. The node can then decide whether rebuilding the template is worthwhile based on the accumulated fee increase.</p>\n<p>Implementing this in current Bitcoin Core is challenging because, for each mempool update, the <strong>effective chunk fee rate</strong> of affected transactions is not explicitly known [0].</p>\n<p>However, with the introduction of the <strong>Cluster Mempool</strong> [1], this limitation no longer applies.</p>\n<p>This post explores a simple method that leverages Cluster Mempool feature to determine whether there has been a potential <strong>fee rate improvement</strong> in a block template without requiring a full rebuild.</p>\n<h4><a name=\"p-6055-prerequisites-2\" class=\"anchor\" href=\"#p-6055-prerequisites-2\"></a>Prerequisites</h4>\n<ul>\n<li><a href=\"https://delvingbitcoin.org/t/cluster-mempool-definitions-theory/202\">Cluster Mempool Definitions</a></li>\n<li><a href=\"https://delvingbitcoin.org/t/mempool-incentive-compatibility/553\">Mempool Incentive Compatibility</a></li>\n<li><a href=\"https://delvingbitcoin.org/t/cluster-mempool-rbf-thoughts/156\">Cluster Mempool RBF Thoughts</a></li>\n</ul>\n<h4><a name=\"p-6055-definitions-3\" class=\"anchor\" href=\"#p-6055-definitions-3\"></a>Definitions</h4>\n<ul>\n<li><strong>Fee Rate:</strong> The fee of a transaction divided by its size.</li>\n<li><strong>Chunk:</strong> A grouped list of related transactions that should be mined together.</li>\n<li><strong>Chunk Fee Rate:</strong> The total fees of all transactions in a chunk divided by their total size.</li>\n<li><strong>Fee Rate Diagram:</strong> A monotonically decreasing list of chunks used to plot a graph where the y-axis represents the fee and the x-axis represents transaction size.</li>\n</ul>\n<h3><a name=\"p-6055-block-template-fee-increase-4\" class=\"anchor\" href=\"#p-6055-block-template-fee-increase-4\"></a>Block Template Fee Increase</h3>\n<p>The objective is to determine the potential <strong>fee increase</strong> of a block template as the mempool evolves, <strong>without rebuilding</strong> the block template using the node\u2019s block assembler.</p>\n<p>Given a previously built block template, compute/save:</p>\n<div class=\"math\">\n\\begin{aligned}\nF_{\\text{threshold}} &amp;=  \\text{(the fee increase that warrants a new block template build)} \\\\\nF &amp;= \\sum_{i=1}^{n} f_i  \\text{( sum of fees of all chunks in the current block template)} \\\\\nS &amp;= \\sum_{i=1}^{n} s_i \\text{( sum of size of all chunks in the current block template)} \\\\\nF_{\\text{modified}} &amp;= F \\text{(modified total fee after mempool updates)} \\\\\nS_{\\text{modified}} &amp;= S \\text{(modified total size after mempool updates)} \\\\\nW &amp;= \\text{maximum allowed block weight} \\\\\nL &amp;= \\text{the lowest-fee-rate (worst) chunk currently in the block template} \\\\\nA &amp;= \\lbrace\\rbrace  \\text{(list of newly added chunks with } r_i &gt; r_L \\text{, sorted descending by fee rate)} \\\\\nR &amp;= \\lbrace\\rbrace \\text{(list of removed chunks with } r_i \\ge r_L \\text{, sorted ascending by fee rate)} \\\\\nr_i &amp;= \\frac{f_i}{s_i}  \\text{(fee rate of chunk } i)\n\\end{aligned}\n</div>\n<h4><a name=\"p-6055-mempool-update-scenarios-5\" class=\"anchor\" href=\"#p-6055-mempool-update-scenarios-5\"></a>Mempool Update Scenarios</h4>\n<p>When a new transaction enters the mempool, two primary cases occur:</p>\n<ol>\n<li>\n<p><strong>Addition without in-mempool conflicts</strong>\nThe transaction connects to zero or more existing clusters. A new linearization is computed for the affected clusters, producing both an <strong>old</strong> and <strong>new</strong> fee rate diagram.</p>\n</li>\n<li>\n<p><strong>Addition with in-mempool conflicts</strong>\nThe transaction conflicts with one or more existing transactions in the mempool. The connected clusters are re-linearized, generating both <strong>old</strong> and <strong>new</strong> fee rate diagrams.</p>\n</li>\n</ol>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/2X/e/e8108e41ead3057a19a0ae6110064f047a93fd6e.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/e8108e41ead3057a19a0ae6110064f047a93fd6e\" title=\"Example of mempool addition\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/2X/e/e8108e41ead3057a19a0ae6110064f047a93fd6e_2_690x431.png\" alt=\"Example of mempool addition\" data-base62-sha1=\"x6Wf6dCJCkIpHa9AGpeF0KWRWfI\" width=\"690\" height=\"431\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/2X/e/e8108e41ead3057a19a0ae6110064f047a93fd6e_2_690x431.png, https://delvingbitcoin.org/uploads/default/original/2X/e/e8108e41ead3057a19a0ae6110064f047a93fd6e.png 1.5x, https://delvingbitcoin.org/uploads/default/original/2X/e/e8108e41ead3057a19a0ae6110064f047a93fd6e.png 2x\" data-dominant-color=\"FBFBFB\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">Example of mempool addition</span><span class=\"informations\">800\u00d7500 30.3 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p><em>Naive example of mempool addition of b\u2032 that improves the fee rate of b.</em></p>\n<p>In both cases, the addition is accepted <em>iff</em> the <strong>new fee rate diagram</strong> is strictly better.</p>\n<p>There is also a rare case where update has <strong>only the old diagram</strong>,  for example, when the mempool is full and the lowest-fee chunk is evicted. This is uncommon, as miners typically run nodes with large mempools, but it should still be handled.</p>\n<h4><a name=\"p-6055-after-an-update-6\" class=\"anchor\" href=\"#p-6055-after-an-update-6\"></a>After an Update</h4>\n<p><strong>If there is an old diagram:</strong></p>\n<p>Initialize an empty temporary list <span class=\"math\">\\text{New}_R = \\{\\}</span>.</p>\n<p>For each chunk <span class=\"math\">c</span> in the <strong>old fee rate diagram</strong>, if <span class=\"math\">r_c \\ge r_L</span>, add <span class=\"math\">c</span> to <span class=\"math\">\\text{New}_R</span>.</p>\n<p>Maintain <span class=\"math\">\\text{New}_R</span> in <strong>ascending order</strong> by fee rate.</p>\n<p>Iterate through <span class=\"math\">\\text{New}_R</span>:</p>\n<p>For each chunk <span class=\"math\">c \\in \\text{New}_R</span> (from lowest fee rate):</p>\n<p><span class=\"math\">\n\\begin{cases}\n\\text{if } c = L: &amp; \\text{Remove } L \\text{ from block template} \\\\\n&amp; \\text{Update } L \\text{ to the new worst chunk in the remaining block template} \\\\\n&amp; \\text{Remove } c \\text{ from } \\text{New}_R \\\\\n&amp; F_{\\text{modified}} \\leftarrow F_{\\text{modified}} - f_c \\\\\n&amp; S_{\\text{modified}} \\leftarrow S_{\\text{modified}} - s_c \\\\\n\\text{else if } r_c &gt; r_L: &amp; \\text{Exit loop \u2014 all remaining chunks have } r_c &gt; r_L\n\\end{cases}\n</span></p>\n<p>After the loop, add all remaining chunks in <span class=\"math\">\\text{New}_R</span> to the persistent set <span class=\"math\">R</span> (chunks with <span class=\"math\">r_c &gt; r_L</span> that were removed but not equal to the old <span class=\"math\">L</span>).</p>\n<p><strong>If there is a new diagram:</strong></p>\n<p>For each chunk <span class=\"math\">c</span> in the <strong>new fee rate diagram</strong>, if <span class=\"math\">r_c &gt; r_L</span>, add <span class=\"math\">c</span> to <span class=\"math\">A</span> (maintained in descending fee rate order).</p>\n<h3><a name=\"p-6055-evaluating-potential-fee-increase-7\" class=\"anchor\" href=\"#p-6055-evaluating-potential-fee-increase-7\"></a>Evaluating Potential Fee Increase</h3>\n<p><strong>Phase 1: Remove evicted chunks from block template</strong></p>\n<p>Loop through the block template chunks. For each chunk <span class=\"math\">c</span>:</p>\n<ul>\n<li>If any chunk in <span class=\"math\">R</span> matches <span class=\"math\">c</span>, remove it from the block template.\nSubtract its fees from <span class=\"math\">F_{\\text{modified}}</span> and its size from <span class=\"math\">S_{\\text{modified}}</span>.</li>\n</ul>\n<p>Clear <span class=\"math\">R</span> afterward.</p>\n<p><strong>Phase 2: Perform naive merge</strong></p>\n<p>Initialize:</p>\n<div class=\"math\">\nF_{\\text{naive}} = F_{\\text{modified}}, \\quad S_{\\text{naive}} = S_{\\text{modified}}\n</div>\n<p>Iterate through chunks in <span class=\"math\">A</span> (in descending fee rate order):</p>\n<div class=\"math\">\n\\text{for each chunk } a_i \\in A:\n</div>\n<p>If <span class=\"math\">S_{\\text{naive}} + s_{a_i} \\le W</span>, then:</p>\n<div class=\"math\">\n\\begin{cases}\nF_{\\text{naive}} \\leftarrow F_{\\text{naive}} + f_{a_i} \\\\\nS_{\\text{naive}} \\leftarrow S_{\\text{naive}} + s_{a_i}\n\\end{cases}\n</div>\n<p>Compute:</p>\n<div class=\"math\">\n\\Delta F = F_{\\text{naive}} - F\n</div>\n<ul>\n<li><strong>If</strong> <span class=\"math\">\\Delta F \\ge F_{\\text{threshold}}</span>: rebuild the block template.</li>\n<li><strong>If</strong> all chunks in <span class=\"math\">A</span> are added and <span class=\"math\">\\Delta F &lt; F_{\\text{threshold}}</span>: stop (insufficient improvement).</li>\n</ul>\n<p><strong>Phase 3: Iterative merge (if naive merge is inconclusive)</strong></p>\n<p>If the naive merge shows potential but is inconclusive, perform an <strong>iterative merge</strong> of the block template chunks and chunks in <span class=\"math\">A</span>:</p>\n<ul>\n<li>\n<p>Initialize an empty block template and fill it by selecting the best chunks from both the existing template and <span class=\"math\">A</span>.</p>\n</li>\n<li>\n<p>Stop when:</p>\n<ul>\n<li>Block weight <span class=\"math\">W</span> is reached,</li>\n<li>No chunk from the template or <span class=\"math\">A</span> will fit, or</li>\n<li>The iteration limit is reached.</li>\n</ul>\n</li>\n</ul>\n<p>Compute:</p>\n<div class=\"math\">\n\\Delta F_{\\text{new}} = F_{\\text{new}} - F\n</div>\n<ul>\n<li><strong>If</strong> <span class=\"math\">\\Delta F_{\\text{new}} \\ge F_{\\text{threshold}}</span>: build and return the new block template.</li>\n</ul>\n<p><strong>Phase 4: Update state</strong></p>\n<p>After building a new block template:</p>\n<ul>\n<li>Clear <span class=\"math\">A</span></li>\n<li>Set the new template as the current one</li>\n<li>Update <span class=\"math\">L</span> to the worst chunk in the new template</li>\n<li>Update <span class=\"math\">F_{\\text{modified}} = F_{\\text{new}}</span>, <span class=\"math\">S_{\\text{modified}} = S_{\\text{new}}</span></li>\n</ul>\n<h3><a name=\"p-6055-implementation-note-8\" class=\"anchor\" href=\"#p-6055-implementation-note-8\"></a>Implementation Note</h3>\n<p>This computation can be handled asynchronously by a <strong>Block Template Manager</strong> (as proposed in <a href=\"https://github.com/bitcoin/bitcoin/issues/33389\" rel=\"noopener nofollow ugc\">Bitcoin Core Issue #33389</a>).\nIt should operate independently of <code>cs_main</code> and mempool locks by using a validation interface notification executed in a scheduler thread after each mempool update.\nThis notification provides both <strong>old and new fee rate diagrams</strong>, which is also useful for the block policy estimator [2].\nThe Block Template Manager maintains its own internal locks to ensure thread safety without blocking mempool or transaction relay operations.</p>\n<h3><a name=\"p-6055-limitation-9\" class=\"anchor\" href=\"#p-6055-limitation-9\"></a>Limitation</h3>\n<p>This approach does not account for bin-packing effects at the block template tail [3].</p>\n<h3><a name=\"p-6055-references-10\" class=\"anchor\" href=\"#p-6055-references-10\"></a>References</h3>\n<p>[0] <a href=\"https://github.com/bitcoin/bitcoin/issues/27677\" rel=\"noopener nofollow ugc\">Proposal for a new mempool design</a></p>\n<p>[1] <a href=\"https://github.com/bitcoin/bitcoin/issues/28676\" rel=\"noopener nofollow ugc\">Cluster Mempool</a></p>\n<p>[2] <a href=\"https://delvingbitcoin.org/t/package-aware-fee-estimator-post-cluster-mempool/312\">Package-Aware Fee Estimator Post Cluster Mempool</a></p>\n<p>[3] <a href=\"https://en.wikipedia.org/wiki/Bin_packing_problem\" rel=\"noopener nofollow ugc\">Bin Packing Problem</a></p>\n<p><em>Original post <a href=\"https://delvingbitcoin.org/t/determining-block-template-fee-increase-using-fee-rate-diagram/2051\" class=\"inline-onebox\">Determining Block Template Fee Increase Using Fee Rate Diagram</a> deleted mistakenly sorry for the noise</em></p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 3,
  "updated_at": "2025-10-13T18:42:54.780Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 133,
  "reads": 40,
  "readers_count": 39,
  "score": 637.4,
  "yours": false,
  "topic_id": 2052,
  "topic_slug": "determining-blocktemplate-fee-increase-using-fee-rate-diagram",
  "topic_title": "Determining BlockTemplate Fee Increase Using Fee Rate Diagram",
  "topic_html_title": "Determining BlockTemplate Fee Increase Using Fee Rate Diagram",
  "category_id": 8,
  "display_username": "Abubakar Sadiq Ismail",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 5,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "#### Motivation and Background\n\nCurrently, when miners want to determine whether a block template with more fees is available, they repeatedly poll the `getblocktemplate` RPC until a better template is returned (relative to the one they are working on). This approach can lead to redundant block template builds in some cases.\n\nThe experimental mining interface introduced in [Bitcoin Core v30](https://delvingbitcoin.org/t/bitcoin-core-v30-0-released/2050), `waitnext()`, improves this by allowing clients to wait and receive a new block template after a noticeable fee increase or when the blockchain tip changes.\n\nHowever, internally, `waitnext()` also regenerates block templates every second.\nBuilding a block template locks Bitcoin Core mutexes, (mempool (`cs`) and `cs_main`) throughout the build. These locks prevent concurrent access during template generation for thread safety purpose, which can delay transaction processing and relay to peers.\n\nA better approach is to **track the potential fee increase** resulting from each mempool update that affects the current block template. The node can then decide whether rebuilding the template is worthwhile based on the accumulated fee increase.\n\nImplementing this in current Bitcoin Core is challenging because, for each mempool update, the **effective chunk fee rate** of affected transactions is not explicitly known [0].\n\nHowever, with the introduction of the **Cluster Mempool** [1], this limitation no longer applies.\n\nThis post explores a simple method that leverages Cluster Mempool feature to determine whether there has been a potential **fee rate improvement** in a block template without requiring a full rebuild.\n\n#### Prerequisites\n\n* [Cluster Mempool Definitions](https://delvingbitcoin.org/t/cluster-mempool-definitions-theory/202)\n* [Mempool Incentive Compatibility](https://delvingbitcoin.org/t/mempool-incentive-compatibility/553)\n* [Cluster Mempool RBF Thoughts](https://delvingbitcoin.org/t/cluster-mempool-rbf-thoughts/156)\n\n#### Definitions\n\n* **Fee Rate:** The fee of a transaction divided by its size.\n* **Chunk:** A grouped list of related transactions that should be mined together.\n* **Chunk Fee Rate:** The total fees of all transactions in a chunk divided by their total size.\n* **Fee Rate Diagram:** A monotonically decreasing list of chunks used to plot a graph where the y-axis represents the fee and the x-axis represents transaction size.\n\n### Block Template Fee Increase\n\nThe objective is to determine the potential **fee increase** of a block template as the mempool evolves, **without rebuilding** the block template using the node's block assembler.\n\nGiven a previously built block template, compute/save:\n\n$$\n\\begin{aligned}\nF_{\\text{threshold}} &=  \\text{(the fee increase that warrants a new block template build)} \\\\\nF &= \\sum_{i=1}^{n} f_i  \\text{( sum of fees of all chunks in the current block template)} \\\\\nS &= \\sum_{i=1}^{n} s_i \\text{( sum of size of all chunks in the current block template)} \\\\\nF_{\\text{modified}} &= F \\text{(modified total fee after mempool updates)} \\\\\nS_{\\text{modified}} &= S \\text{(modified total size after mempool updates)} \\\\\nW &= \\text{maximum allowed block weight} \\\\\nL &= \\text{the lowest-fee-rate (worst) chunk currently in the block template} \\\\\nA &= \\lbrace\\rbrace  \\text{(list of newly added chunks with } r_i > r_L \\text{, sorted descending by fee rate)} \\\\\nR &= \\lbrace\\rbrace \\text{(list of removed chunks with } r_i \\ge r_L \\text{, sorted ascending by fee rate)} \\\\\nr_i &= \\frac{f_i}{s_i}  \\text{(fee rate of chunk } i)\n\\end{aligned}\n$$\n\n#### Mempool Update Scenarios\n\nWhen a new transaction enters the mempool, two primary cases occur:\n\n1. **Addition without in-mempool conflicts**\n   The transaction connects to zero or more existing clusters. A new linearization is computed for the affected clusters, producing both an **old** and **new** fee rate diagram.\n\n2. **Addition with in-mempool conflicts**\n   The transaction conflicts with one or more existing transactions in the mempool. The connected clusters are re-linearized, generating both **old** and **new** fee rate diagrams.\n\n![Example of mempool addition|690x431](upload://x6Wf6dCJCkIpHa9AGpeF0KWRWfI.png)\n\n*Naive example of mempool addition of b\u2032 that improves the fee rate of b.*\n\nIn both cases, the addition is accepted *iff* the **new fee rate diagram** is strictly better.\n\nThere is also a rare case where update has **only the old diagram**,  for example, when the mempool is full and the lowest-fee chunk is evicted. This is uncommon, as miners typically run nodes with large mempools, but it should still be handled.\n\n#### After an Update\n\n**If there is an old diagram:**\n\nInitialize an empty temporary list $\\text{New}_R = \\{\\}$.\n\nFor each chunk $c$ in the **old fee rate diagram**, if $r_c \\ge r_L$, add $c$ to $\\text{New}_R$.\n\nMaintain $\\text{New}_R$ in **ascending order** by fee rate.\n\nIterate through $\\text{New}_R$:\n\nFor each chunk $c \\in \\text{New}_R$ (from lowest fee rate):\n\n$\n\\begin{cases}\n\\text{if } c = L: & \\text{Remove } L \\text{ from block template} \\\\\n& \\text{Update } L \\text{ to the new worst chunk in the remaining block template} \\\\\n& \\text{Remove } c \\text{ from } \\text{New}_R \\\\\n& F_{\\text{modified}} \\leftarrow F_{\\text{modified}} - f_c \\\\\n& S_{\\text{modified}} \\leftarrow S_{\\text{modified}} - s_c \\\\\n\\text{else if } r_c > r_L: & \\text{Exit loop \u2014 all remaining chunks have } r_c > r_L\n\\end{cases}\n$\n\nAfter the loop, add all remaining chunks in $\\text{New}_R$ to the persistent set $R$ (chunks with $r_c > r_L$ that were removed but not equal to the old $L$).\n\n**If there is a new diagram:**\n\nFor each chunk $c$ in the **new fee rate diagram**, if $r_c > r_L$, add $c$ to $A$ (maintained in descending fee rate order).\n\n### Evaluating Potential Fee Increase\n\n**Phase 1: Remove evicted chunks from block template**\n\nLoop through the block template chunks. For each chunk $c$:\n\n* If any chunk in $R$ matches $c$, remove it from the block template.\n  Subtract its fees from $F_{\\text{modified}}$ and its size from $S_{\\text{modified}}$.\n\nClear $R$ afterward.\n\n**Phase 2: Perform naive merge**\n\nInitialize:\n\n$$\nF_{\\text{naive}} = F_{\\text{modified}}, \\quad S_{\\text{naive}} = S_{\\text{modified}}\n$$\n\nIterate through chunks in $A$ (in descending fee rate order):\n\n$$\n\\text{for each chunk } a_i \\in A:\n$$\n\nIf $S_{\\text{naive}} + s_{a_i} \\le W$, then:\n\n$$\n\\begin{cases}\nF_{\\text{naive}} \\leftarrow F_{\\text{naive}} + f_{a_i} \\\\\nS_{\\text{naive}} \\leftarrow S_{\\text{naive}} + s_{a_i}\n\\end{cases}\n$$\n\nCompute:\n\n$$\n\\Delta F = F_{\\text{naive}} - F\n$$\n\n* **If** $\\Delta F \\ge F_{\\text{threshold}}$: rebuild the block template.\n* **If** all chunks in $A$ are added and $\\Delta F < F_{\\text{threshold}}$: stop (insufficient improvement).\n\n**Phase 3: Iterative merge (if naive merge is inconclusive)**\n\nIf the naive merge shows potential but is inconclusive, perform an **iterative merge** of the block template chunks and chunks in $A$:\n\n* Initialize an empty block template and fill it by selecting the best chunks from both the existing template and $A$.\n\n* Stop when:\n\n  * Block weight $W$ is reached,\n  * No chunk from the template or $A$ will fit, or\n  * The iteration limit is reached.\n\nCompute:\n\n$$\n\\Delta F_{\\text{new}} = F_{\\text{new}} - F\n$$\n\n* **If** $\\Delta F_{\\text{new}} \\ge F_{\\text{threshold}}$: build and return the new block template.\n\n**Phase 4: Update state**\n\nAfter building a new block template:\n\n* Clear $A$\n* Set the new template as the current one\n* Update $L$ to the worst chunk in the new template\n* Update $F_{\\text{modified}} = F_{\\text{new}}$, $S_{\\text{modified}} = S_{\\text{new}}$\n\n### Implementation Note\n\nThis computation can be handled asynchronously by a **Block Template Manager** (as proposed in [Bitcoin Core Issue #33389](https://github.com/bitcoin/bitcoin/issues/33389)).\nIt should operate independently of `cs_main` and mempool locks by using a validation interface notification executed in a scheduler thread after each mempool update.\nThis notification provides both **old and new fee rate diagrams**, which is also useful for the block policy estimator [2].\nThe Block Template Manager maintains its own internal locks to ensure thread safety without blocking mempool or transaction relay operations.\n\n### Limitation\n\nThis approach does not account for bin-packing effects at the block template tail [3].\n\n### References\n\n[0] [Proposal for a new mempool design](https://github.com/bitcoin/bitcoin/issues/27677)\n\n[1] [Cluster Mempool](https://github.com/bitcoin/bitcoin/issues/28676)\n\n[2] [Package-Aware Fee Estimator Post Cluster Mempool](https://delvingbitcoin.org/t/package-aware-fee-estimator-post-cluster-mempool/312)\n\n[3] [Bin Packing Problem](https://en.wikipedia.org/wiki/Bin_packing_problem)\n\n_Original post https://delvingbitcoin.org/t/determining-block-template-fee-increase-using-fee-rate-diagram/2051 deleted mistakenly sorry for the noise_",
  "actions_summary": [
    {
      "id": 2,
      "count": 2
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 135,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "<a name=\"p-6055-motivation-and-background-1\" class=\"anchor\" href=\"#p-6055-motivation-and-background-1\"></a>Motivation and Background\nCurrently, when miners want to determine whether a block template with more fees is available, they repeatedly poll the getblocktemplate RPC until a better template is returned (relative to the one they are working on). This approach can lead to redundant block template bui&hellip;",
  "truncated": true,
  "post_url": "/t/determining-blocktemplate-fee-increase-using-fee-rate-diagram/2052/1",
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 2
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 2,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}