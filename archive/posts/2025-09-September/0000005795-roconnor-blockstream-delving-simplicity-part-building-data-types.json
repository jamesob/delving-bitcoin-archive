{
  "id": 5795,
  "name": "",
  "username": "roconnor-blockstream",
  "avatar_template": "/user_avatar/delvingbitcoin.org/roconnor-blockstream/{size}/427_2.png",
  "created_at": "2025-09-02T23:52:41.332Z",
  "cooked": "<p>In <a href=\"https://delvingbitcoin.org/t/delving-simplicity-part-combinator-completeness-of-simplicity/1935\">Part \u2161</a> of this series, we introduced Simplicity\u2019s type system and its core set of computational combinators. However, with only three kinds of type formers and nine core combinators, the language may seem too meager for practical computations. Can we really build any computation using only the three fundamental forms of composition we described in Part \u2160 of this series? In the same way that computers are built out of logic gates, we start with the humble bit and build up abstractions from it. Let\u2019s delve in.</p>\n<h1><a name=\"p-5795-boolean-logic-1\" class=\"anchor\" href=\"#p-5795-boolean-logic-1\"></a>Boolean Logic</h1>\n<p>In Part \u2161, we introduced the Boolean type, which is <code>\ud835\udfd9 + \ud835\udfd9</code>. We use the notation <code>\ud835\udfda</code> for this type. It has two values: <code>\u03c3\u1d38\u27e8\u27e9</code> and <code>\u03c3\u1d3f\u27e8\u27e9</code>. By convention, we use the notation <code>0</code> or <code>false</code> for <code>\u03c3\u1d38\u27e8\u27e9</code>, and the notation <code>1</code> or <code>true</code> for <code>\u03c3\u1d3f\u27e8\u27e9</code>. Using our computational combinators, we can build Boolean logic operators.</p>\n<h2><a name=\"p-5795-and-operation-2\" class=\"anchor\" href=\"#p-5795-and-operation-2\"></a>And operation</h2>\n<p>The logical <code>and : \ud835\udfda \u00d7 \ud835\udfda \u22a2 \ud835\udfda</code> operation takes two bits as input and returns one bit as output. Since Simplicity expressions have only a single input type, we use the product of the two input arguments as the input type. There are several ways of implementing this function. One way is to branch on the first bit: if the first bit is <code>false</code>, we return <code>false</code>; otherwise, we return the second bit.</p>\n<pre data-code-wrap=\"none\"><code class=\"lang-none\">and \u2254 case (injl unit) (drop iden) : \ud835\udfda \u00d7 \ud835\udfda \u22a2 \ud835\udfda\n</code></pre>\n<p>We can check this definition on the input <code>\u27e8false, false\u27e9</code> by using equational reasoning:</p>\n<pre data-code-wrap=\"none\"><code class=\"lang-none\">\u27e6and\u27e7\u27e8false, false\u27e9\n = {expand the notation for false}\n\u27e6and\u27e7\u27e8\u03c3\u1d38\u27e8\u27e9, \u03c3\u1d38\u27e8\u27e9\u27e9\n = {expand the definition of and}\n\u27e6case (injl unit) (drop iden)\u27e7\u27e8\u03c3\u1d38\u27e8\u27e9, \u03c3\u1d38\u27e8\u27e9\u27e9\n = {evaluate case for \u03c3\u1d38}\n\u27e6injl unit\u27e7\u27e8\u27e8\u27e9, \u03c3\u1d38\u27e8\u27e9\u27e9\n = {evaluate injl}\n\u03c3\u1d38(\u27e6unit\u27e7\u27e8\u27e8\u27e9, \u03c3\u1d38\u27e8\u27e9\u27e9)\n = {evaluate unit}\n\u03c3\u1d38\u27e8\u27e9\n = {by the notation for false}\nfalse\n</code></pre>\n<p>We get the expected result of <code>false</code>.</p>\n<p>Let\u2019s try it again on the input <code>\u27e8true, true\u27e9</code>.</p>\n<pre data-code-wrap=\"none\"><code class=\"lang-none\">\u27e6and\u27e7\u27e8true, true\u27e9\n = {expand the notation for true and the definition of and}\n\u27e6case (injl unit) (drop iden)\u27e7\u27e8\u03c3\u1d3f\u27e8\u27e9, \u03c3\u1d3f\u27e8\u27e9\u27e9\n = {evaluate case for \u03c3\u1d3f}\n\u27e6drop iden\u27e7\u27e8\u27e8\u27e9, \u03c3\u1d3f\u27e8\u27e9\u27e9\n = {evaluate drop}\n\u27e6iden\u27e7(\u03c3\u1d3f\u27e8\u27e9)\n = {evaluate iden}\n\u03c3\u1d3f\u27e8\u27e9\n = {by the notation for true}\ntrue\n</code></pre>\n<p>Again, we get the expected result of <code>true</code>. We will leave trying the remaining inputs for the curious reader.</p>\n<h2><a name=\"p-5795-other-logic-operations-3\" class=\"anchor\" href=\"#p-5795-other-logic-operations-3\"></a>Other logic operations</h2>\n<p>The definition of the <code>not</code> operation requires a helper combinator:</p>\n<pre data-code-wrap=\"none\"><code class=\"lang-none\">                   f : A \u22a2 C    g : B \u22a2 C\n-------------------------------------------------------------\ncopair f g \u2254 iden \u25b5 unit \u2a3e case (take f) (take g) : A + B \u22a2 C\n</code></pre>\n<p>The initial <code>iden \u25b5 unit : A \u22a2 A \u00d7 \ud835\udfd9</code>  adds an empty \u201cenvironment\u201d to the input, enabling the <code>case</code> combinator to apply. The use of <code>take</code> in the two branches drops this empty environment to execute <code>f</code> or <code>g</code>.</p>\n<p>Now we can define all other Boolean logical operations:</p>\n<ul>\n<li><code>or \u2254 case (drop iden) (injr unit) : \ud835\udfda \u00d7 \ud835\udfda \u22a2 \ud835\udfda</code></li>\n<li><code>not \u2254 copair (injr unit) (injl unit) : \ud835\udfda \u22a2 \ud835\udfda</code></li>\n<li><code>xor \u2254 case (drop iden) (drop not) : \ud835\udfda \u00d7 \ud835\udfda \u22a2 \ud835\udfda</code></li>\n</ul>\n<h2><a name=\"p-5795-bit-adders-4\" class=\"anchor\" href=\"#p-5795-bit-adders-4\"></a>Bit Adders</h2>\n<p>In digital logic, a \u201chalf-adder\u201d is a circuit that takes two bits and adds them, producing a two-bit output: a carry bit and the sum bit. We can implement this in Simplicity by pairing up the <code>and</code> and <code>xor</code> operations:</p>\n<pre data-code-wrap=\"none\"><code class=\"lang-none\">half-adder \u2254 and \u25b5 xor : \ud835\udfda \u00d7 \ud835\udfda \u22a2 \ud835\udfda \u00d7 \ud835\udfda \n</code></pre>\n<p>This function has two output bits, so we return a pair of the two output types.</p>\n<p>A \u201cfull-adder\u201d takes an additional third \u201ccarry-in\u201d bit and adds them all together, producing the same two-bit output. We must use a nested tuple to represent three inputs. We have two choices: <code>\ud835\udfda \u00d7 (\ud835\udfda \u00d7 \ud835\udfda)</code> or <code>(\ud835\udfda \u00d7 \ud835\udfda) \u00d7 \ud835\udfda</code>. These types are not quite the same, and we must choose one. For this example, we will choose the latter.</p>\n<p>Types in Simplicity are often nested tuples, representing an \u201cenvironment\u201d of parameters. It is common to use sequences of <code>take</code>, <code>drop</code>, and <code>iden</code> to access specific parameters from such an environment. For sequences of these combinators, a compact notation will be used:</p>\n<ul>\n<li><code>O f</code>  is notation for <code>take f</code>.</li>\n<li><code>I f</code> is notation for <code>drop f</code>.</li>\n<li><code>H</code> is notation for <code>iden</code>.</li>\n</ul>\n<p>For example, <code>I O H</code> means <code>drop (take iden) : A \u00d7 (B \u00d7 C) \u22a2 B</code>, which extracts the middle value out of its input.</p>\n<p>\ud83d\udec8\nThe use of <code>O</code> and <code>I</code> for <code>take</code> and <code>drop</code> is meant to evoke a sense of binary digits. If we think of a nested tuple as a binary tree and label the tree\u2019s positions with positive binary numbers appropriately, then our notation becomes the reversed binary digits (thinking of <code>H</code> as the leading 1 digit) of a location within that tree from which we are retrieving data. Such expressions form a kind of De Bruijn indices for Simplicity</p>\n<p><img src=\"https://delvingbitcoin.org/images/emoji/twitter/warning.png?v=14\" title=\":warning:\" class=\"emoji only-emoji\" alt=\":warning:\" loading=\"lazy\" width=\"20\" height=\"20\">\nThe <code>I</code>, <code>O</code>, and <code>H</code> notation is only used for subexpressions that consist only of <code>take</code>, <code>drop</code>, and <code>iden</code>. They are not used for other occurrences of <code>take</code> or <code>drop</code>.</p>\n<p>A full-adder is the composition of two half-adders, taking the logical <code>or</code> of the two carry bits:</p>\n<pre data-code-wrap=\"none\"><code class=\"lang-none\">full-adder \u2254 take half-adder \u25b5 I H\n           \u2a3e O O H \u25b5 (O I H \u25b5 I H \u2a3e half-adder)\n           \u2a3e (O H \u25b5 I O H \u2a3e or) \u25b5 I I H\n           : (\ud835\udfda \u00d7 \ud835\udfda) \u00d7 \ud835\udfda \u22a2 \ud835\udfda \u00d7 \ud835\udfda\n</code></pre>\n<p>In the first line, <code>take half-adder \u25b5 I H : (\ud835\udfda \u00d7 \ud835\udfda) \u00d7 \ud835\udfda \u22a2 (\ud835\udfda \u00d7 \ud835\udfda) \u00d7 \ud835\udfda</code>, we run the half-adder on the first two bits, and we save the last bit. In the second line, <code>O O H \u25b5 (O I H \u25b5 I H \u2a3e half-adder) : (\ud835\udfda \u00d7 \ud835\udfda) \u00d7 \ud835\udfda \u22a2 \ud835\udfda \u00d7 (\ud835\udfda \u00d7 \ud835\udfda)</code>, we save the first bit (which is the carry-out bit of the first half-adder) and run the half-adder on the last two bits. In the last line, <code>(O H \u25b5 I O H \u2a3e or) \u25b5 I I H: \ud835\udfda \u00d7 (\ud835\udfda \u00d7 \ud835\udfda) \u22a2 \ud835\udfda \u00d7 \ud835\udfda</code>, we take the logical <em>or</em> of the first two bits (which are the carry-outs of the two half-adders) and also return the sum-out bit of the second half-adder.</p>\n<p>This code illustrates how one programs in Simplicity. We use the <code>I</code>, <code>O</code>, and <code>H</code> notation to reference bits of data from the subexpression\u2019s input type, which is then formed into a suitable \u201cenvironment\u201d that is used to \u201ccall\u201d other functions using sequential composition.</p>\n<p>Simplicity users do not have to define such low-level operations themselves. Later in this series, we will discuss our standard library of jets that implement common functions.</p>\n<p>Furthermore, end users are not expected to directly program in Simplicity, in the same way that end users are not expected to directly program with Bitcoin Script. Instead, we expect end users will use higher-level languages, such as SimplicityHL, to generate Simplicity. For example, SimplicityHL manages the \u201cenvironment\u201d of each subexpression, letting one use named variables, which are compiled into appropriate sequence of <code>take</code>s and <code>drop</code>s.</p>\n<h1><a name=\"p-5795-vectors-5\" class=\"anchor\" href=\"#p-5795-vectors-5\"></a>Vectors</h1>\n<p>Given a Simplicity type <code>A</code>, we can define fixed-length vectors by forming iterated products of <code>A</code>:</p>\n<ul>\n<li><code>A\u00b2 \u2254 A \u00d7 A</code></li>\n<li><code>A\u2074 \u2254 A\u00b2 \u00d7 A\u00b2</code></li>\n<li><code>A\u2078 \u2254 A\u2074 \u00d7 A\u2074</code></li>\n<li><code>\u2026</code></li>\n</ul>\n<p>These types may be alternatively written as <code>A^2</code>, <code>A^4</code>, <code>A^8</code>, etc.</p>\n<p>We will define vectors only for lengths that are powers of two. One can define notation for other powers, but a convention needs to be chosen for how to bracket the product types.</p>\n<p>Given an expression <code>f : A \u22a2 B</code>, we can repeatedly pair it with itself in order to \u201cmap\u201d it over a vector of any fixed length:</p>\n<ul>\n<li><code>f\u00b2 \u2254 f \u25b5 f : A\u00b2 \u22a2 B\u00b2</code></li>\n<li><code>f\u2074 \u2254 f\u00b2 \u25b5 f\u00b2 : A\u2074 \u22a2 B\u2074</code></li>\n<li><code>f\u2078 \u2254 f\u2074 \u25b5 f\u2074 : A\u2078 \u22a2 B\u2078</code></li>\n</ul>\n<p>Given a function <code>f : A \u00d7 B \u22a2 B</code>, we can iterate or \u201cfold\u201d it over a vector of any fixed length:</p>\n<ul>\n<li><code>fold-right-2 f \u2254 O O H \u25b5 (O I H \u25b5 I H \u2a3e f) \u2a3e f : A\u00b2 \u00d7 B \u22a2 B</code></li>\n<li><code>fold-right-4 f \u2254 fold-right-2 (fold-right-2 f) : A\u2074 \u00d7 B \u22a2 B</code></li>\n<li><code>fold-right-8 f \u2254 fold-right-2 (fold-right-4 f) : A\u2078 \u00d7 B \u22a2 B</code></li>\n</ul>\n<p>There are many variations of these constructions we can implement. Given <code>f : A \u00d7 B \u22a2 C</code>, we can \u201czip\u201d it over a pair of vectors with <code>zip-n f : (A\u207f \u00d7 B\u207f) \u22a2 C\u207f</code>. Given <code>f : (A \u00d7 B) \u00d7 C \u22a2 C</code>, we can fold it over a pair of vectors with <code>bifold-right-n f : (A\u207f \u00d7 B\u207f) \u22a2 C</code>. We can combine <code>map</code> and <code>fold-right</code> into an accumulating combinator that takes <code>f : A \u00d7 C \u22a2 C \u00d7 B</code> and results in <code>map-accum-right-n f : A\u207f \u00d7 C \u22a2 C \u00d7 B\u207f</code>. Many more variants are possible.</p>\n<h2><a name=\"p-5795-multi-bit-words-6\" class=\"anchor\" href=\"#p-5795-multi-bit-words-6\"></a>Multi-bit Words</h2>\n<p>A vector of bits gives us multi-bit integers. For example, <code>\ud835\udfda\u00b3\u00b2</code> is a 32-bit word type. <code>\ud835\udfda\u00b2\u2075\u2076</code> is a 256-bit word type, which is suitable for hashes and other cryptographic operations.</p>\n<p>Given our \u201cfull-adder\u201d on bits, we can use a variant of the vector operations above to define a \u201cripple carry adder\u201d over multi-bit words:</p>\n<pre data-code-wrap=\"none\"><code class=\"lang-none\">full-adder-n \u2254 zip-accum-right-n full-adder : (\ud835\udfda\u207f \u00d7 \ud835\udfda\u207f) \u00d7 \ud835\udfda \u22a2 \ud835\udfda \u00d7 \ud835\udfda\u207f\n</code></pre>\n<p><code>full-adder-n</code> takes two n-bit binary numbers and a one-bit carry-input value and returns a one-bit carry-out flag and an n-bit sum.</p>\n<h3><a name=\"p-5795-sha-256-7\" class=\"anchor\" href=\"#p-5795-sha-256-7\"></a>SHA-256</h3>\n<p>In this manner, we can recursively define all our arithmetic operations on multi-bit words: subtraction, multiplication, division, etc. We can define bit-wise logical operations such as logical <em>and</em>, logical <em>or</em>, logical <em>xor</em>, etc. By repeatedly combining these operations, we can even build SHA-256\u2019s block compression function:</p>\n<p><code>sha256-hash-block \u2254 \u2026 : \ud835\udfda\u00b2\u2075\u2076 \u00d7 \ud835\udfda\u2075\u00b9\u00b2 \u22a2 \ud835\udfda\u00b2\u2075\u2076</code></p>\n<p>But you don\u2019t have to trust us. <a href=\"https://github.com/BlockstreamResearch/simplicity/blob/a619ab60d1c1e4c67b7e8680237ec811215f7cbc/Coq/Simplicity/SHA256.v#L93-L141\" rel=\"noopener nofollow ugc\">The SHA-256 compression is formally defined using Simplicity</a> within the Rocq proof assistant (formerly named the Coq proof assistant), and it comes with <a href=\"https://github.com/BlockstreamResearch/simplicity/blob/a619ab60d1c1e4c67b7e8680237ec811215f7cbc/Coq/Simplicity/SHA256.v#L235-L236\" rel=\"noopener nofollow ugc\">a formal proof that the <code>sha256-hash-block</code> implementation is correct</a>.</p>\n<p>Of course, the compression runs too slowly to be practical when executing it as raw Simplicity. We will introduce jets later in this series, which are used to execute common functions such as the SHA-256 compression function natively. However, we will still make use of such pure Simplicity implementations as formal specifications for our jets.</p>\n<h1><a name=\"p-5795-option-types-8\" class=\"anchor\" href=\"#p-5795-option-types-8\"></a>Option Types</h1>\n<p>Option types are made by taking a sum with the unit type:</p>\n<p><code>Option A \u2254 \ud835\udfd9 + A</code></p>\n<p>The type <code>Option A</code> may also be written as <code>A?</code> or <code>\ud835\udd4a A</code> (where <code>\ud835\udd4a</code> stands for \u201csuccessor\u201d). As with vectors, functions can be \u201cmapped\u201d over the option type:</p>\n<pre data-code-wrap=\"none\"><code class=\"lang-none\">                 f : A \u22a2 B\n------------------------------------------\nf? \u2254 copair (injl unit) (injr f) : A? \u22a2 B?\n</code></pre>\n<p>We can also define monadic combinators such as bind:</p>\n<pre data-code-wrap=\"none\"><code class=\"lang-none\">              f : A \u22a2 B?\n---------------------------------------\nbind f \u2254 copair (injl unit) f : A? \u22a2 B?\n</code></pre>\n<h1><a name=\"p-5795-variable-length-buffers-9\" class=\"anchor\" href=\"#p-5795-variable-length-buffers-9\"></a>Variable Length Buffers</h1>\n<p>We can also define what we call \u201cbuffers,\u201d which are types for partially filled vectors.</p>\n<ul>\n<li><code>A\u1449\u00b2 \u2254 A?</code></li>\n<li><code>A\u1449\u2074 \u2254 A\u00b2? \u00d7 A\u1449\u00b2</code></li>\n<li><code>A\u1449\u2078 \u2254 A\u2074? \u00d7 A\u1449\u2074</code></li>\n<li><code>\u2026</code></li>\n</ul>\n<p>\ud83d\udec8\nThe type <code>X\u1449\u2078</code> expands to <code>(1 + X\u2074) \u00d7 ((1 + X\u00b2) \u00d7 (1 + X))</code>. If we pretend this is a polynomial and expand it, we get <code>1 + X + X\u00b2 + X\u00b3 + X\u2074 + X\u2075 + X\u2076 + X\u2077</code>. Interpreting this polynomial as a type, it is the sum of all possible tuples of X up to 7, including the empty tuple. In other words, it is exactly the type of lists whose length is strictly less than 8.</p>\n<p>As with vectors, we can define various mapping and folding operations over buffers. We can also define stack operations such as <code>push-&lt;n : A\u1449\u207f \u00d7 A \u22a2 A\u207f + A\u1449\u207f</code> and <code>pop-&lt;n : A\u1449\u207f \u22a2 (A\u1449\u207f \u00d7 A)?</code>. <code>push-&lt;n</code> takes a buffer and a new item and appends it to the buffer, returning a full vector in case the buffer overflows. <code>pop-&lt;n</code> takes a buffer and removes an item, returning the smaller buffer and the item removed, optionally returning nothing in case the original buffer was empty.</p>\n<p>For example, we can define <code>push-&lt;n</code> recursively:</p>\n<ul>\n<li>\n<pre><code class=\"lang-auto\">push-&lt;2 \u2254 case (drop (injr (injr iden))) (injl iden)\n</code></pre>\n</li>\n<li>\n<pre><code class=\"lang-auto\">push-&lt;4 \u2254 ((O I H \u25b5 IH) \u2a3e push-&lt;2) \u25b5 O O H\n        \u2a3e case (I H \u25b5 O H \u2a3e case (injr (injr (I H) \u25b5 injl unit)) (injl iden))\n               (injr (I H \u25b5 O H))\n</code></pre>\n</li>\n<li>\n<pre><code class=\"lang-auto\">push-&lt;8 \u2254 ((O I H \u25b5 IH) \u2a3e push-&lt;4) \u25b5 O O H\n        \u2a3e case (I H \u25b5 O H \u2a3e case (injr (injr (I H) \u25b5 (injl unit \u25b5 injl unit))) (injl iden))\n               (injr (I H \u25b5 O H))\n</code></pre>\n</li>\n<li><code>\u2026</code></li>\n</ul>\n<p>As you can see, raw Simplicity becomes inscrutable once one reaches a certain level of complexity. Again, we expect end users to utilize higher-level languages, such as SimplicityHL, that can generate these idiomatic expressions.</p>\n<h1><a name=\"p-5795-conclusion-10\" class=\"anchor\" href=\"#p-5795-conclusion-10\"></a>Conclusion</h1>\n<p>In this part, we illustrated how to build logical operations starting from bits. From these logic operations, we were able to build bit-level arithmetic and illustrate how to reason about their execution. After developing vector types, we showed how to iterate over multi-bit words to define arithmetic. Continuing in this way, we can define cryptographic operations, such as SHA-256 and Schnorr signature validation, using just our computational Simplicity combinators. All of which we have actually defined using Simplicity.</p>\n<p>This part is not meant as a comprehensive guide to the various possible data types and operations that we can build in Simplicity, but instead, it serves to illustrate how it is possible to build practical functionality within Simplicity\u2019s constraints. Even though Simplicity\u2019s types are all finitely bounded, we can still define useful vectors and buffer types and operations that iterate over values within these structures.</p>\n<p>The actual specifications of operations in our standard library are a little different from the definitions used here. For instance, the full-adder in our standard library uses a 3-way <em>xor</em> and a \u201cmajority\u201d logic function in its implementation, rather than using two half-adders as shown here.</p>\n<p>Later, we will see that, in practice, Simplicity programs use jets for arithmetic and cryptographic operations. However, jets are limited to replacing expressions. The combinators for iterating over buffers and vectors we have defined cannot be replaced with jets. These defined combinators will appear in actual Simplicity programs. Although, rather than directly using these combinators, we expect end users will use higher-level languages, such as SimplicityHL, to generate such Simplicity expressions.</p>\n<p>A keen-eyed reader may have noticed that our recursively defined combinators appear to grow exponentially in expression size. However, this is not a problem. Later, when we talk about serialization, we will see that expressions are encoded as a DAG (directed acyclic graph) rather than as a tree. So the actual presentation of these expressions will only grow linearly in size.</p>\n<p>So far, we have only been considering pure computations. However, we need some way to interact with transaction data for tasks like signing transactions, and we need to be able to have the program fail somehow if the signature is not valid. In the next part, we will discuss side-effects in Simplicity.</p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 1,
  "updated_at": "2025-09-02T23:52:41.332Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 2,
  "reads": 10,
  "readers_count": 9,
  "score": 11.8,
  "yours": false,
  "topic_id": 1956,
  "topic_slug": "delving-simplicity-part-building-data-types",
  "topic_title": "Delving Simplicity Part \u2162: Building Data Types",
  "topic_html_title": "Delving Simplicity Part \u2162: Building Data Types",
  "category_id": 7,
  "display_username": "",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "In [Part \u2161](https://delvingbitcoin.org/t/delving-simplicity-part-combinator-completeness-of-simplicity/1935) of this series, we introduced Simplicity\u2019s type system and its core set of computational combinators. However, with only three kinds of type formers and nine core combinators, the language may seem too meager for practical computations. Can we really build any computation using only the three fundamental forms of composition we described in Part \u2160 of this series? In the same way that computers are built out of logic gates, we start with the humble bit and build up abstractions from it. Let\u2019s delve in.\n\n# Boolean Logic\n\nIn Part \u2161, we introduced the Boolean type, which is `\ud835\udfd9 + \ud835\udfd9`. We use the notation `\ud835\udfda` for this type. It has two values: `\u03c3\u1d38\u27e8\u27e9` and `\u03c3\u1d3f\u27e8\u27e9`. By convention, we use the notation `0` or `false` for `\u03c3\u1d38\u27e8\u27e9`, and the notation `1` or `true` for `\u03c3\u1d3f\u27e8\u27e9`. Using our computational combinators, we can build Boolean logic operators.\n\n## And operation\n\nThe logical `and : \ud835\udfda \u00d7 \ud835\udfda \u22a2 \ud835\udfda` operation takes two bits as input and returns one bit as output. Since Simplicity expressions have only a single input type, we use the product of the two input arguments as the input type. There are several ways of implementing this function. One way is to branch on the first bit: if the first bit is `false`, we return `false`; otherwise, we return the second bit.\n\n```none\nand \u2254 case (injl unit) (drop iden) : \ud835\udfda \u00d7 \ud835\udfda \u22a2 \ud835\udfda\n```\n\nWe can check this definition on the input `\u27e8false, false\u27e9` by using equational reasoning:\n\n```none\n\u27e6and\u27e7\u27e8false, false\u27e9\n = {expand the notation for false}\n\u27e6and\u27e7\u27e8\u03c3\u1d38\u27e8\u27e9, \u03c3\u1d38\u27e8\u27e9\u27e9\n = {expand the definition of and}\n\u27e6case (injl unit) (drop iden)\u27e7\u27e8\u03c3\u1d38\u27e8\u27e9, \u03c3\u1d38\u27e8\u27e9\u27e9\n = {evaluate case for \u03c3\u1d38}\n\u27e6injl unit\u27e7\u27e8\u27e8\u27e9, \u03c3\u1d38\u27e8\u27e9\u27e9\n = {evaluate injl}\n\u03c3\u1d38(\u27e6unit\u27e7\u27e8\u27e8\u27e9, \u03c3\u1d38\u27e8\u27e9\u27e9)\n = {evaluate unit}\n\u03c3\u1d38\u27e8\u27e9\n = {by the notation for false}\nfalse\n```\n\nWe get the expected result of `false`. \n\nLet\u2019s try it again on the input `\u27e8true, true\u27e9`.\n\n```none\n\u27e6and\u27e7\u27e8true, true\u27e9\n = {expand the notation for true and the definition of and}\n\u27e6case (injl unit) (drop iden)\u27e7\u27e8\u03c3\u1d3f\u27e8\u27e9, \u03c3\u1d3f\u27e8\u27e9\u27e9\n = {evaluate case for \u03c3\u1d3f}\n\u27e6drop iden\u27e7\u27e8\u27e8\u27e9, \u03c3\u1d3f\u27e8\u27e9\u27e9\n = {evaluate drop}\n\u27e6iden\u27e7(\u03c3\u1d3f\u27e8\u27e9)\n = {evaluate iden}\n\u03c3\u1d3f\u27e8\u27e9\n = {by the notation for true}\ntrue\n```\n\nAgain, we get the expected result of `true`. We will leave trying the remaining inputs for the curious reader.\n\n## Other logic operations\n\nThe definition of the `not` operation requires a helper combinator:\n\n```none\n                   f : A \u22a2 C    g : B \u22a2 C\n-------------------------------------------------------------\ncopair f g \u2254 iden \u25b5 unit \u2a3e case (take f) (take g) : A + B \u22a2 C\n```\n\nThe initial `iden \u25b5 unit : A \u22a2 A \u00d7 \ud835\udfd9`  adds an empty \u201cenvironment\u201d to the input, enabling the `case` combinator to apply. The use of `take` in the two branches drops this empty environment to execute `f` or `g`.\n\nNow we can define all other Boolean logical operations:\n\n* `or \u2254 case (drop iden) (injr unit) : \ud835\udfda \u00d7 \ud835\udfda \u22a2 \ud835\udfda`\n* `not \u2254 copair (injr unit) (injl unit) : \ud835\udfda \u22a2 \ud835\udfda`\n* `xor \u2254 case (drop iden) (drop not) : \ud835\udfda \u00d7 \ud835\udfda \u22a2 \ud835\udfda`\n\n## Bit Adders\n\nIn digital logic, a \u201chalf-adder\u201d is a circuit that takes two bits and adds them, producing a two-bit output: a carry bit and the sum bit. We can implement this in Simplicity by pairing up the `and` and `xor` operations:\n\n```none\nhalf-adder \u2254 and \u25b5 xor : \ud835\udfda \u00d7 \ud835\udfda \u22a2 \ud835\udfda \u00d7 \ud835\udfda \n```\n\nThis function has two output bits, so we return a pair of the two output types.\n\nA \u201cfull-adder\u201d takes an additional third \u201ccarry-in\u201d bit and adds them all together, producing the same two-bit output. We must use a nested tuple to represent three inputs. We have two choices: `\ud835\udfda \u00d7 (\ud835\udfda \u00d7 \ud835\udfda)` or `(\ud835\udfda \u00d7 \ud835\udfda) \u00d7 \ud835\udfda`. These types are not quite the same, and we must choose one. For this example, we will choose the latter.\n\nTypes in Simplicity are often nested tuples, representing an \u201cenvironment\u201d of parameters. It is common to use sequences of `take`, `drop`, and `iden` to access specific parameters from such an environment. For sequences of these combinators, a compact notation will be used:\n\n* `O f`  is notation for `take f`.\n* `I f` is notation for `drop f`.\n* `H` is notation for `iden`.\n\nFor example, `I O H` means `drop (take iden) : A \u00d7 (B \u00d7 C) \u22a2 B`, which extracts the middle value out of its input.\n\n\n\ud83d\udec8\nThe use of `O` and `I` for `take` and `drop` is meant to evoke a sense of binary digits. If we think of a nested tuple as a binary tree and label the tree\u2019s positions with positive binary numbers appropriately, then our notation becomes the reversed binary digits (thinking of `H` as the leading 1 digit) of a location within that tree from which we are retrieving data. Such expressions form a kind of De Bruijn indices for Simplicity\n\n\u26a0\nThe `I`, `O`, and `H` notation is only used for subexpressions that consist only of `take`, `drop`, and `iden`. They are not used for other occurrences of `take` or `drop`.\n\nA full-adder is the composition of two half-adders, taking the logical `or` of the two carry bits:\n\n```none\nfull-adder \u2254 take half-adder \u25b5 I H\n           \u2a3e O O H \u25b5 (O I H \u25b5 I H \u2a3e half-adder)\n           \u2a3e (O H \u25b5 I O H \u2a3e or) \u25b5 I I H\n           : (\ud835\udfda \u00d7 \ud835\udfda) \u00d7 \ud835\udfda \u22a2 \ud835\udfda \u00d7 \ud835\udfda\n```\n\nIn the first line, `take half-adder \u25b5 I H : (\ud835\udfda \u00d7 \ud835\udfda) \u00d7 \ud835\udfda \u22a2 (\ud835\udfda \u00d7 \ud835\udfda) \u00d7 \ud835\udfda`, we run the half-adder on the first two bits, and we save the last bit. In the second line, `O O H \u25b5 (O I H \u25b5 I H \u2a3e half-adder) : (\ud835\udfda \u00d7 \ud835\udfda) \u00d7 \ud835\udfda \u22a2 \ud835\udfda \u00d7 (\ud835\udfda \u00d7 \ud835\udfda)`, we save the first bit (which is the carry-out bit of the first half-adder) and run the half-adder on the last two bits. In the last line, `(O H \u25b5 I O H \u2a3e or) \u25b5 I I H: \ud835\udfda \u00d7 (\ud835\udfda \u00d7 \ud835\udfda) \u22a2 \ud835\udfda \u00d7 \ud835\udfda`, we take the logical *or* of the first two bits (which are the carry-outs of the two half-adders) and also return the sum-out bit of the second half-adder.\n\nThis code illustrates how one programs in Simplicity. We use the `I`, `O`, and `H` notation to reference bits of data from the subexpression\u2019s input type, which is then formed into a suitable \u201cenvironment\u201d that is used to \u201ccall\u201d other functions using sequential composition.\n\nSimplicity users do not have to define such low-level operations themselves. Later in this series, we will discuss our standard library of jets that implement common functions.\n\nFurthermore, end users are not expected to directly program in Simplicity, in the same way that end users are not expected to directly program with Bitcoin Script. Instead, we expect end users will use higher-level languages, such as SimplicityHL, to generate Simplicity. For example, SimplicityHL manages the \u201cenvironment\u201d of each subexpression, letting one use named variables, which are compiled into appropriate sequence of `take`s and `drop`s.\n\n# Vectors\n\nGiven a Simplicity type `A`, we can define fixed-length vectors by forming iterated products of `A`:\n\n* `A\u00b2 \u2254 A \u00d7 A`\n* `A\u2074 \u2254 A\u00b2 \u00d7 A\u00b2`\n* `A\u2078 \u2254 A\u2074 \u00d7 A\u2074`\n* `\u2026`\n\nThese types may be alternatively written as `A^2`, `A^4`, `A^8`, etc.\n\nWe will define vectors only for lengths that are powers of two. One can define notation for other powers, but a convention needs to be chosen for how to bracket the product types.\n\nGiven an expression `f : A \u22a2 B`, we can repeatedly pair it with itself in order to \u201cmap\u201d it over a vector of any fixed length:\n\n* `f\u00b2 \u2254 f \u25b5 f : A\u00b2 \u22a2 B\u00b2`\n* `f\u2074 \u2254 f\u00b2 \u25b5 f\u00b2 : A\u2074 \u22a2 B\u2074`\n* `f\u2078 \u2254 f\u2074 \u25b5 f\u2074 : A\u2078 \u22a2 B\u2078`\n\nGiven a function `f : A \u00d7 B \u22a2 B`, we can iterate or \u201cfold\u201d it over a vector of any fixed length:\n\n* `fold-right-2 f \u2254 O O H \u25b5 (O I H \u25b5 I H \u2a3e f) \u2a3e f : A\u00b2 \u00d7 B \u22a2 B`\n* `fold-right-4 f \u2254 fold-right-2 (fold-right-2 f) : A\u2074 \u00d7 B \u22a2 B`\n* `fold-right-8 f \u2254 fold-right-2 (fold-right-4 f) : A\u2078 \u00d7 B \u22a2 B`\n\nThere are many variations of these constructions we can implement. Given `f : A \u00d7 B \u22a2 C`, we can \u201czip\u201d it over a pair of vectors with `zip-n f : (A\u207f \u00d7 B\u207f) \u22a2 C\u207f`. Given `f : (A \u00d7 B) \u00d7 C \u22a2 C`, we can fold it over a pair of vectors with `bifold-right-n f : (A\u207f \u00d7 B\u207f) \u22a2 C`. We can combine `map` and `fold-right` into an accumulating combinator that takes `f : A \u00d7 C \u22a2 C \u00d7 B` and results in `map-accum-right-n f : A\u207f \u00d7 C \u22a2 C \u00d7 B\u207f`. Many more variants are possible.\n\n## Multi-bit Words\n\nA vector of bits gives us multi-bit integers. For example, `\ud835\udfda\u00b3\u00b2` is a 32-bit word type. `\ud835\udfda\u00b2\u2075\u2076` is a 256-bit word type, which is suitable for hashes and other cryptographic operations.\n\nGiven our \u201cfull-adder\u201d on bits, we can use a variant of the vector operations above to define a \u201cripple carry adder\u201d over multi-bit words:\n\n```none\nfull-adder-n \u2254 zip-accum-right-n full-adder : (\ud835\udfda\u207f \u00d7 \ud835\udfda\u207f) \u00d7 \ud835\udfda \u22a2 \ud835\udfda \u00d7 \ud835\udfda\u207f\n```\n\n`full-adder-n` takes two n-bit binary numbers and a one-bit carry-input value and returns a one-bit carry-out flag and an n-bit sum.\n\n### SHA-256\n\nIn this manner, we can recursively define all our arithmetic operations on multi-bit words: subtraction, multiplication, division, etc. We can define bit-wise logical operations such as logical *and*, logical *or*, logical *xor*, etc. By repeatedly combining these operations, we can even build SHA-256\u2019s block compression function: \n\n`sha256-hash-block \u2254 \u2026 : \ud835\udfda\u00b2\u2075\u2076 \u00d7 \ud835\udfda\u2075\u00b9\u00b2 \u22a2 \ud835\udfda\u00b2\u2075\u2076`\n\nBut you don\u2019t have to trust us. [The SHA-256 compression is formally defined using Simplicity](https://github.com/BlockstreamResearch/simplicity/blob/a619ab60d1c1e4c67b7e8680237ec811215f7cbc/Coq/Simplicity/SHA256.v#L93-L141) within the Rocq proof assistant (formerly named the Coq proof assistant), and it comes with [a formal proof that the `sha256-hash-block` implementation is correct](https://github.com/BlockstreamResearch/simplicity/blob/a619ab60d1c1e4c67b7e8680237ec811215f7cbc/Coq/Simplicity/SHA256.v#L235-L236).\n\nOf course, the compression runs too slowly to be practical when executing it as raw Simplicity. We will introduce jets later in this series, which are used to execute common functions such as the SHA-256 compression function natively. However, we will still make use of such pure Simplicity implementations as formal specifications for our jets.\n\n# Option Types\n\nOption types are made by taking a sum with the unit type:\n\n`Option A \u2254 \ud835\udfd9 + A`\n\nThe type `Option A` may also be written as `A?` or `\ud835\udd4a A` (where `\ud835\udd4a` stands for \u201csuccessor\u201d). As with vectors, functions can be \u201cmapped\u201d over the option type:\n\n```none\n                 f : A \u22a2 B\n------------------------------------------\nf? \u2254 copair (injl unit) (injr f) : A? \u22a2 B?\n```\n\nWe can also define monadic combinators such as bind:\n\n```none\n              f : A \u22a2 B?\n---------------------------------------\nbind f \u2254 copair (injl unit) f : A? \u22a2 B?\n```\n\n# Variable Length Buffers\n\nWe can also define what we call \u201cbuffers,\u201d which are types for partially filled vectors.\n\n* `A\u1449\u00b2 \u2254 A?`\n* `A\u1449\u2074 \u2254 A\u00b2? \u00d7 A\u1449\u00b2`\n* `A\u1449\u2078 \u2254 A\u2074? \u00d7 A\u1449\u2074`\n* `\u2026`\n\n\n\ud83d\udec8\nThe type `X\u1449\u2078` expands to `(1 + X\u2074) \u00d7 ((1 + X\u00b2) \u00d7 (1 + X))`. If we pretend this is a polynomial and expand it, we get `1 + X + X\u00b2 + X\u00b3 + X\u2074 + X\u2075 + X\u2076 + X\u2077`. Interpreting this polynomial as a type, it is the sum of all possible tuples of X up to 7, including the empty tuple. In other words, it is exactly the type of lists whose length is strictly less than 8.\n\nAs with vectors, we can define various mapping and folding operations over buffers. We can also define stack operations such as `push-<n : A\u1449\u207f \u00d7 A \u22a2 A\u207f + A\u1449\u207f` and `pop-<n : A\u1449\u207f \u22a2 (A\u1449\u207f \u00d7 A)?`. `push-<n` takes a buffer and a new item and appends it to the buffer, returning a full vector in case the buffer overflows. `pop-<n` takes a buffer and removes an item, returning the smaller buffer and the item removed, optionally returning nothing in case the original buffer was empty.\n\nFor example, we can define `push-<n` recursively:\n\n* ```\n  push-<2 \u2254 case (drop (injr (injr iden))) (injl iden)\n* ```\n  push-<4 \u2254 ((O I H \u25b5 IH) \u2a3e push-<2) \u25b5 O O H\n          \u2a3e case (I H \u25b5 O H \u2a3e case (injr (injr (I H) \u25b5 injl unit)) (injl iden))\n                 (injr (I H \u25b5 O H))\n* ```\n  push-<8 \u2254 ((O I H \u25b5 IH) \u2a3e push-<4) \u25b5 O O H\n          \u2a3e case (I H \u25b5 O H \u2a3e case (injr (injr (I H) \u25b5 (injl unit \u25b5 injl unit))) (injl iden))\n                 (injr (I H \u25b5 O H))\n* `\u2026`\n\nAs you can see, raw Simplicity becomes inscrutable once one reaches a certain level of complexity. Again, we expect end users to utilize higher-level languages, such as SimplicityHL, that can generate these idiomatic expressions.\n\n# Conclusion\n\nIn this part, we illustrated how to build logical operations starting from bits. From these logic operations, we were able to build bit-level arithmetic and illustrate how to reason about their execution. After developing vector types, we showed how to iterate over multi-bit words to define arithmetic. Continuing in this way, we can define cryptographic operations, such as SHA-256 and Schnorr signature validation, using just our computational Simplicity combinators. All of which we have actually defined using Simplicity.\n\nThis part is not meant as a comprehensive guide to the various possible data types and operations that we can build in Simplicity, but instead, it serves to illustrate how it is possible to build practical functionality within Simplicity\u2019s constraints. Even though Simplicity\u2019s types are all finitely bounded, we can still define useful vectors and buffer types and operations that iterate over values within these structures.\n\nThe actual specifications of operations in our standard library are a little different from the definitions used here. For instance, the full-adder in our standard library uses a 3-way *xor* and a \u201cmajority\u201d logic function in its implementation, rather than using two half-adders as shown here.\n\nLater, we will see that, in practice, Simplicity programs use jets for arithmetic and cryptographic operations. However, jets are limited to replacing expressions. The combinators for iterating over buffers and vectors we have defined cannot be replaced with jets. These defined combinators will appear in actual Simplicity programs. Although, rather than directly using these combinators, we expect end users will use higher-level languages, such as SimplicityHL, to generate such Simplicity expressions.\n\nA keen-eyed reader may have noticed that our recursively defined combinators appear to grow exponentially in expression size. However, this is not a problem. Later, when we talk about serialization, we will see that expressions are encoded as a DAG (directed acyclic graph) rather than as a tree. So the actual presentation of these expressions will only grow linearly in size.\n\nSo far, we have only been considering pure computations. However, we need some way to interact with transaction data for tasks like signing transactions, and we need to be able to have the program fail somehow if the signature is not valid. In the next part, we will discuss side-effects in Simplicity.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 351,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "In <a href=\"https://delvingbitcoin.org/t/delving-simplicity-part-combinator-completeness-of-simplicity/1935\">Part \u2161</a> of this series, we introduced Simplicity\u2019s type system and its core set of computational combinators. However, with only three kinds of type formers and nine core combinators, the language may seem too meager for practical computations. Can we really build any computation using only the th&hellip;",
  "truncated": true,
  "post_url": "/t/delving-simplicity-part-building-data-types/1956/1",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}