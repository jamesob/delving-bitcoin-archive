{
  "id": 5888,
  "name": "ZmnSCPxj jxPCSnmZ",
  "username": "ZmnSCPxj",
  "avatar_template": "/letter_avatar_proxy/v4/letter/z/ee7513/{size}.png",
  "created_at": "2025-09-17T04:34:14.378Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"ZmnSCPxj\" data-post=\"6\" data-topic=\"1983\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/letter_avatar_proxy/v4/letter/z/ee7513/48.png\" class=\"avatar\"> ZmnSCPxj:</div>\n<blockquote>\n<p>So my current proposed MultiPTLC scheme requires just 1.5 roundtrips:</p>\n</blockquote>\n</aside>\n<p>LOL wait I just realized\u2026. the MultiPTLC P branches are just <code>(proof-of-payment + delta) * G</code>.  And nothing really requires that the onion data includes the actual incoming point or the outgoing point, it only requires the <code>delta</code> shard for that hop to be included.  So the LSP can select the receiver-can-claim scalar <em><strong>after</strong></em> Ursula gets the MultiPTLC irrevocably committed \u2014 <em><strong>Ursula does not need to know either the receiver-can-claim scalar or its point</strong></em>.  So the LSP <em><strong>adds</strong></em> the receiver-can-claim point to the point asked for by the incoming P branch and fire out an outgoing plain PTLC to the receiver with the point added, so that at the receiver, it needs the receiver-can-claim scalar from the LSP to be able to finally claim the money.  This lets us remove the 1.0 roundtrips for Ursula to request for receiver-can-claim points, getting us down to 0.5 roundtrips at the Ursula\u2192(Alice,Bob,Carol) hop if we use \u201cfast forwards\u201d in the MultiChannel.  In fact, we do not even need to use TCP (which requires <code>ACK</code>ing return packets) we can use UDP and forward error correction like the old mining protocol compact blocks encoding thing by TheBlueMatt to make it truly 0.5 roundtrips from Ursula\u2192(Alice, Bob, Carol) and have Ursula just blast out the data to all of the LSPs.  As long as any one of the LSPs can recover enough of the FEC data, they can then share with the others in the quorum via standard TCP and be able to facilitate the rest of the \u201cstuckless but not actually lolololol\u201d payment flow.</p>\n<p>MultiPTLC is awesome man.</p>\n<p>I mean think about it: what the sender Ursula wants is \u201cany one of these <code>proof-of-payment + delta</code> is revealed to me, but at most only one.\u201d  MultiPTLC encodes that directly, because only one of the P branches can be fulfilled.  HAving multiple parallel plain PTLCs at the Ursula\u2192(Alice,Bob,Carol) hop does not encode that directly, we need to add the receiver-can-claim scalar to ensure that exactly only one PTLC can be claimed by the receiver.  So multiple parallel plain PTLCs are. from a system design standpoint, <em><strong>more</strong></em>  complicated than just a MultiPTLC because it requires adding in a receiver-can-claim scalar.  Basically, the MultiPTLC simply directly encodes the intent of Ursula the user: \u201cI only care that at most one of these paths succeeds, I do not care what happens to the others\u201d and it is the LSPs who can make those paths be runnable in parallel by adding in their own receiver-can-claim secret at their hop.</p>\n<p>SOOOO anyway the final piece is: how would the LSPs prove that they managed to get a payment out to the receiver? What we can do is that the final onion payload at the receiver gets a challenge nonce that the receiver hands back to the \u201csender\u201d (or more specifically, whoever holds the receiver-can-claim secret); in terms of \u201cstateless\u201d LDK that nonce can be used to derive the receiver-can-claim secret, just like the payment secret in LDK is used to derive the payment preimage.  In the case of MultiPTLC in MultiChannel, that nonce is the proof that the final onion payload reached the receiver \u2014 Ursula puts different receiver-end nonces in the onions it prepares, and provides the HASH of those nonce in the MultiPTLC package.  The winning LSP can then show this preimage (which is unique to one of the paths that the LSP sent out) to convince the other LSPs to sign for the MultiPTLC branch that finalizes that path, so that the LSP can be assured that it can claim the Ursula-provided funds if it releases the corresponding receiver-can-claim secret to the receiver.  Yes Ursula can provide that receiver-reached-nonce to the LSP directly, but that is no different than just handing over money to the LSP it is favoring, which it can do with a direct transfer to that LSP over the MultiChannel, so this is just doing the same thing that Ursula can already do anyway.</p>",
  "post_number": 7,
  "post_type": 1,
  "posts_count": 7,
  "updated_at": "2025-09-17T04:37:50.246Z",
  "reply_count": 0,
  "reply_to_post_number": 6,
  "quote_count": 1,
  "incoming_link_count": 0,
  "reads": 2,
  "readers_count": 1,
  "score": 0.4,
  "yours": false,
  "topic_id": 1983,
  "topic_slug": "multichannel-and-multiptlc-towards-a-global-high-availability-cp-database-for-bitcoin-payments",
  "topic_title": "MultiChannel and MultiPTLC: Towards A Global High-Availability CP Database For Bitcoin Payments",
  "topic_html_title": "MultiChannel and MultiPTLC: Towards A Global High-Availability CP Database For Bitcoin Payments",
  "category_id": 7,
  "display_username": "ZmnSCPxj jxPCSnmZ",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"ZmnSCPxj, post:6, topic:1983\"]\nSo my current proposed MultiPTLC scheme requires just 1.5 roundtrips:\n\n[/quote]\n\nLOL wait I just realized\u2026. the MultiPTLC P branches are just `(proof-of-payment + delta) * G`.  And nothing really requires that the onion data includes the actual incoming point or the outgoing point, it only requires the `delta` shard for that hop to be included.  So the LSP can select the receiver-can-claim scalar ***after*** Ursula gets the MultiPTLC irrevocably committed \u2014 ***Ursula does not need to know either the receiver-can-claim scalar or its point***.  So the LSP ***adds*** the receiver-can-claim point to the point asked for by the incoming P branch and fire out an outgoing plain PTLC to the receiver with the point added, so that at the receiver, it needs the receiver-can-claim scalar from the LSP to be able to finally claim the money.  This lets us remove the 1.0 roundtrips for Ursula to request for receiver-can-claim points, getting us down to 0.5 roundtrips at the Ursula\u2192(Alice,Bob,Carol) hop if we use \u201cfast forwards\u201d in the MultiChannel.  In fact, we do not even need to use TCP (which requires `ACK`ing return packets) we can use UDP and forward error correction like the old mining protocol compact blocks encoding thing by TheBlueMatt to make it truly 0.5 roundtrips from Ursula\u2192(Alice, Bob, Carol) and have Ursula just blast out the data to all of the LSPs.  As long as any one of the LSPs can recover enough of the FEC data, they can then share with the others in the quorum via standard TCP and be able to facilitate the rest of the \u201cstuckless but not actually lolololol\u201d payment flow.\n\nMultiPTLC is awesome man.\n\nI mean think about it: what the sender Ursula wants is \u201cany one of these `proof-of-payment + delta` is revealed to me, but at most only one.\u201d  MultiPTLC encodes that directly, because only one of the P branches can be fulfilled.  HAving multiple parallel plain PTLCs at the Ursula\u2192(Alice,Bob,Carol) hop does not encode that directly, we need to add the receiver-can-claim scalar to ensure that exactly only one PTLC can be claimed by the receiver.  So multiple parallel plain PTLCs are. from a system design standpoint, ***more***  complicated than just a MultiPTLC because it requires adding in a receiver-can-claim scalar.  Basically, the MultiPTLC simply directly encodes the intent of Ursula the user: \u201cI only care that at most one of these paths succeeds, I do not care what happens to the others\u201d and it is the LSPs who can make those paths be runnable in parallel by adding in their own receiver-can-claim secret at their hop.\n\nSOOOO anyway the final piece is: how would the LSPs prove that they managed to get a payment out to the receiver? What we can do is that the final onion payload at the receiver gets a challenge nonce that the receiver hands back to the \u201csender\u201d (or more specifically, whoever holds the receiver-can-claim secret); in terms of \u201cstateless\u201d LDK that nonce can be used to derive the receiver-can-claim secret, just like the payment secret in LDK is used to derive the payment preimage.  In the case of MultiPTLC in MultiChannel, that nonce is the proof that the final onion payload reached the receiver \u2014 Ursula puts different receiver-end nonces in the onions it prepares, and provides the HASH of those nonce in the MultiPTLC package.  The winning LSP can then show this preimage (which is unique to one of the paths that the LSP sent out) to convince the other LSPs to sign for the MultiPTLC branch that finalizes that path, so that the LSP can be assured that it can claim the Ursula-provided funds if it releases the corresponding receiver-can-claim secret to the receiver.  Yes Ursula can provide that receiver-reached-nonce to the LSP directly, but that is no different than just handing over money to the LSP it is favoring, which it can do with a direct transfer to that LSP over the MultiChannel, so this is just doing the same thing that Ursula can already do anyway.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 104,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "LOL wait I just realized\u2026. the MultiPTLC P branches are just (proof-of-payment + delta) * G.  And nothing really requires that the onion data includes the actual incoming point or the outgoing point, it only requires the delta shard for that hop to be included.  So the LSP can select the receiver-c&hellip;",
  "truncated": true,
  "post_url": "/t/multichannel-and-multiptlc-towards-a-global-high-availability-cp-database-for-bitcoin-payments/1983/7",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}