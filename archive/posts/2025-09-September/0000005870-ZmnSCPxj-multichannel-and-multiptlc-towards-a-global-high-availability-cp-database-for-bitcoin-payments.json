{
  "id": 5870,
  "name": "ZmnSCPxj jxPCSnmZ",
  "username": "ZmnSCPxj",
  "avatar_template": "/letter_avatar_proxy/v4/letter/z/ee7513/{size}.png",
  "created_at": "2025-09-14T21:43:32.468Z",
  "cooked": "<p>Title: Towards a High-Availability CP Database For Bitcoin Payments</p>\n<h1><a name=\"p-5870-introduction-1\" class=\"anchor\" href=\"#p-5870-introduction-1\"></a>Introduction</h1>\n<p>The CAP Theorem is: You can have any two of these three:</p>\n<ol>\n<li>Consistency</li>\n<li>Availability</li>\n<li>Partition-Tolerance</li>\n</ol>\n<p>Now, because network is unreliable, what you actually <em>can</em> have\nare any one of these two:</p>\n<ol>\n<li>CP - Consistent and Partition-Tolerant</li>\n<li>AP - Available and Partition-Tolerant</li>\n</ol>\n<p>The Bitcoin blockchain is ultimately a database \u2014 the\nblockchain itself is a write-ahead log that is never reset, and\ntransactions delete entries (UTXOs) and add new entries (updates\nare effectively an atomic deletion followed by an insertion, thus\nBitcoin is actually a full ACID CRUD database).</p>\n<p>The Bitcoin blockchain is an AP database.\nDue to the thousands of fullnodes (some of which even have hashpower)\ndeployed worldwide, the Bitcoin blockchain is never going to go down.</p>\n<p>However, it <em>does</em> allow for temporary inconsistency.\nIn particular, zero-conf transactions may later be reverted, and if\nyou read zero-conf transactions, you\u2019ll be getting dirty reads\n(There Ain\u2019t No Such Thing As A Global Mempool problem).\nEven confirmed transactions may theoretically still be later\nreverted, though the probability of that grows very low with more\nconfirmations.\nThus, to ensure consistency, payments on the blockchain are slow,\nin order to ensure that potential inconsistencies settle down into\nconfirmed-committed transactions.</p>\n<p>But the gold standard for high-speed global financial applications\nis a high-availability CP database (which prioritizes Consistency\nover Availability, but does have mitigations to improve its\nAvailability in practice).\nAnd the Bitcoin blockchain, as we have demonstrated, is not a CP\ndatabase, but an AP one (and not even a high-consistency AP\ndatabase).</p>\n<h1><a name=\"p-5870-lightning-as-a-global-cp-database-2\" class=\"anchor\" href=\"#p-5870-lightning-as-a-global-cp-database-2\"></a>Lightning as a Global CP Database</h1>\n<p>Surprisingly, we have actually managed to build and deploy a\nglobal CP database built on top of the AP database: Lightning\nNetwork.</p>\n<p>It is not a <em>high-availability</em> CP database, but it <em>is</em> a CP\ndatabase, and a globally CP database at that.\nBecause of its CP nature, financial payments on the Lightning\nNetwork can be very fast, as there is no need to wait to\nreduce the incidence of dirty reads due to inconsistencies.</p>\n<p>The core of the Lightning Network being a <em>global</em> CP database\nlies in two constructions:</p>\n<ol>\n<li>The Channel, a <em>local</em> two-node CP database for financial\ntransactions that can only safely hold money for the two\nnodes on it, with the ability to publish its final state\nat any time on the \u201clayer 1 blockchain\u201d aka the AP\ndatabase we are building on.</li>\n<li>The HTLC, a financial contract that can be used to ensure\natomicity across multiple financial databases.</li>\n</ol>\n<p>The Channel is local: it can only safely hold money for the\ntwo nodes that are managing the database.\nHowever, it is very CP, using a bespoke consistency protocol:\nwe have a hand-over-hand for updating to the next database\nstate (creating an intermediate metastate where both are\nvalid), then revoking the old state, leaving just the next\nstate as valid.\nRevocation is thus the point at which consistency is assured,\nas it prevents the other side from putting old state and thus\nconsistent with the latest state.\nIn case of a network partition (i.e. connection lost, then\nreestablished) the two nodes show the signatures for the\nlatest state that the other side has provided as well as the\nlatest revocation they have, thus proving to the other node\nwhat the latest state actually is.</p>\n<p>We then build up these local CP databases into a <em>global</em>\nCP database by using HTLCs to ensure consistent updates\nacross multiple, local CP databases.\nThe HTLC is effectively a row-level lock on some amount of\ncoins on the CP database, locking their use until either\nthe payment reaches the receiver, or some other failure\noccurs.\nDeadlock is prevented by the simple expedient of doing\nlocks from the order sender to receiver.\nA payment is thus composed of a series of locks on multiple\nlocal CP databases, and once the payment is received, the\nlocks are freed in reverse order.</p>\n<h2><a name=\"p-5870-lightning-flaw-low-availability-3\" class=\"anchor\" href=\"#p-5870-lightning-flaw-low-availability-3\"></a>Lightning Flaw: Low-Availability</h2>\n<p>The Lightning Network is <em>not</em> high-availability, meaning\nthat in case of network partitions, sometimes payments are\nimpossible.</p>\n<p>For example, if an HTLC has already propagated, and one of\nthe nodes along the path goes down, then the payment update\ncannot finish at the sender.\nIn case of some other failure, the payment may also fail\nbefore it reaches the receiver, and because the sender and\nthe receiver cannot be sure of what the status of the\nHTLC-lock-chain, they are unable to do anything to complete\nthe payment: the sender cannot safely send out another\nalternate payment without trusting that the receiver will not\nspend both the original and the alernate payment, and the\nreceiver literally holds no money at this point and cannot\ntrust the sender claim that it has sent out the funds.</p>\n<p>Thus, the Lightning Network availability drops whenever a\npublic routing node goes offline.</p>\n<p>The reason why Lightning Network is <em>not</em> high-availability\nCP lies precisely in the Channel:</p>\n<blockquote>\n<p>The Channel, a local <em>two-node</em> CP database for financial\ntransactions</p>\n</blockquote>\n<p>Having only two nodes means that if one of the nodes is down,\nthere is simply no way for the remaining node to update the\ndatabase state.\nIn order to get a <em>high-availability</em> CP database, we need at\nleast <em>three</em> nodes, not two, and the rule that if one of\nthem goes down, the remaining two can keep updating the\ndatabase.</p>\n<p>The more general rule is that if at least 50%, plus 1, are\navailable, they can update the database state.</p>\n<p>The problem with the typical high-availability CP database\nrule above (\u201cthree can keep updating if one of them is\ndead\u201d) is that it is in conflict with an important principle\nof self-custody:</p>\n<blockquote>\n<p><em><strong>NOT YOUR KEYS, NOT YOUR COINS</strong></em></p>\n</blockquote>\n<p>On the underlying Bitcoin AP database, deletions of UTXOs\nare authorized by signatures.\nAnd thus, for the Lightning Channel two-node local CP\ndatabase, the authorizers are <em>both</em> nodes, and both must\nprovide signatures whenever they are updating the local\nCP database.</p>\n<p>Obviously, if a node is down, it <em>cannot</em> provide a\nsignature.\nIf we were to naively follow the high-availability CP\ndatabase rule of \u201cthree can keep updating if one of them\nis dead\u201d then that implies that only two nodes need to\nprovide signatures for a three-node construction.\nBut that means that the dead node does not have its key\nused to spend the money: the fund is spendable without\nits signature, i.e. it can be spent with\n<em><strong>NOT ITS KEY</strong></em>.\nThus, that node has to assume that its funds are\npotentially <em><strong>NOT ITS COIN</strong></em> if the remaining two nodes\ncollude to steal the coin.</p>\n<h1><a name=\"p-5870-high-availability-cp-with-your-keys-your-coins-for-end-users-4\" class=\"anchor\" href=\"#p-5870-high-availability-cp-with-your-keys-your-coins-for-end-users-4\"></a>High-Availability CP With Your Keys, Your Coins For End Users</h1>\n<p>We have established two facts:</p>\n<ul>\n<li>For high-availability CP, we need at least 3 nodes, and\nallow 2 to update if 1 is dead.</li>\n<li><em><strong>NOT YOUR KEYS, NOT YOUR COINS</strong></em> requires consensus,\ni.e. everyone has to be around to sign.</li>\n</ul>\n<p>On the face of it, the two facts imply that we cannot have\nhigh-availability CP in combination with self-custody, at\nleast with current schemes available in Bitcoin.</p>\n<p>However, we can instead degrade the strong self-custody\nrequirement as follows:</p>\n<ul>\n<li>The public forwarding nodes have significant resources\nto check the trustworthiness of other public forwarding\nnodes.\nThey also have a public reputation, which, if destroyed,\nalso potentially destroys their income stream (routing\nfees).</li>\n<li>The end user does <em>not</em> have the resources to check the\ntrustworthiness of <em>any</em> public forwarding nodes.\nThey also do not have a public reputation, and are\ntherefore less trustworthy-by-default than public\nforwarding nodes.</li>\n<li>Therefore:\n<ul>\n<li>The end user <em><strong>MUST NOT</strong></em> trust any public forwarding\nnodes, because they might not have the resources to\ncheck if the public forwarding nodes are trustworthy.</li>\n<li>The public forwarding nodes <em><strong>MUST NOT</strong></em> trust the\nend user, because the end user is literally some random\nInternet person.</li>\n<li>The public forwarding nodes <em>can</em> trust other public\nforwarding nodes, by doing things like know-your-business,\nservice level agreements, legal contracts, being owned by\nthe same company, and so on.</li>\n</ul>\n</li>\n</ul>\n<p>What I propose, then, is:</p>\n<ul>\n<li>Have a 2-of-2:\n<ul>\n<li>One is the end user.</li>\n<li>The other is a 2-of-3 of 3 different public forwarding\nnodes.\n(Or, more generally, some <code>k</code>-of-<code>n</code> of public\nforwarding nodes where <code>n &gt; 3</code> and <code>k &gt;= 1 + floor(n / 2)</code>).\n<ul>\n<li>This implies that the each of the public forwarding nodes\nhave to trust that a quorum of the other public forwarding\nnodes does not steal funds.\nThis is trivially achievable if the public forwarding\nnodes are run by the same corporation; they might do\nthis precisely so that they can keep high availability,\nsuch as doing rolling updates of their nodes.\nAlternately, public forwarding nodes may have legal\nguards to protect against misbehavior of other public\nforwarding nodes, without requiring the same legal\nguards against end users (or for the end users to\nrequire legal guards against any or all of the public\nforwarding nodes).</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><em><strong>Digression</strong></em> I mean \u2014 if you are pushing Spark or Ark\nor some other statechain-based mechanism or federated mechanism\nwhere end users have to trust a quorum of big corporate service\nproviders, then you are making an assertion that big corporate\nservice providers are trustworthy.\nIf so, and you are a big corporate service provider, put your\nmoney where your mouth is: trust a quorum of those other big\ncorporate service providers yourself, instead of forcing end\nusers to trust them.\nIf you will not do that, then that reveals your actual\nassessment of the risk of trusting big corporate service\nproviders.\nYes, you are putting more funds into this than an end user,\nbut the end user is also much poorer than a big corporation\nand the loss of those funds would cut just as deeply for\nthem.\nHey at least you do not have to trust end users with this\nmechanism, unlike SuperScalar where you trust that they will\nactually come online to help you move liquidity where it is\nneeded, or to cooperatively exit before the tree times out,\nor else you pay more onchain fees.</p>\n</blockquote>\n<p>(Note: as there is currently no proof that FROST-in-MuSig2 is\nsafe, we should use explicit SCRIPT-based checking of two\nsignatures, one of which is the end user signature, the other\nbeing the FROST of the public forwarding nodes.)</p>\n<p>The reason for using 2-of-3 is as noted above:</p>\n<blockquote>\n<p>\u201cthree can do an update if one of them is dead\u201d</p>\n</blockquote>\n<p>This is then where we upgrade the low-availability CP\ndatabase of the plain Channel to a high-availability CP\ndatabase of this novel construction, which I will now dub\nthe MultiChannel.</p>\n<p>(Unfortunately, MultiChannels can only use PTLCs, not\nHTLCs, as I will show below.)</p>\n<h2><a name=\"p-5870-multichannel-sending-5\" class=\"anchor\" href=\"#p-5870-multichannel-sending-5\"></a>MultiChannel Sending</h2>\n<p>First, let me introduce the PTLC.\nLike the HTLC, the PTLC is effectively a row-level lock on\nsome funds, which can then be either moved to the receiver,\nor returned to the sender.\nLike the HTLC, the PTLC can be used for locking across\nmultiple local CP databases in order to allow for global\nupdates that let senders send money to distant receivers.</p>\n<p>The advantage of the PTLC is that it allows certain kinds of\nmath to be used.</p>\n<p>The reason for introducing PTLCs here is that we want the\nend user to send out just <em>one</em> PTLC on its MultiChannel\nwith the public network, and then for the public forwarding\nnodes to be able to send out PTLCs in parallel, on behalf\nof the sender, until one of them is able to have the\npayment reach the receiver.\nThen, we must ensure that the receiver is able to claim\nonly one of the payments, even if multiple arrive at the\nreceiver.</p>\n<p>Now, \u201csend out multiple PTLCs in parallel, of which only\none should be claimed at the receiver\u201d is precisely the\nscheme of <a href=\"https://diyhpl.us/~bryan/irc/bitcoin/bitcoin-dev/linuxfoundation-pipermail/lightning-dev/2019-June/002029.txt\" rel=\"noopener nofollow ugc\">stuckless payments</a>.\nThe stuckless payments proposal, however, requires PTLCs.</p>\n<p>Briefly, a stuckless payment involves two secret scalars\nper payment attempt:</p>\n<ul>\n<li>One is known by the receiver, and its revelation to\nthe sender is \u201cproof of payment\u201d because the sender\ncannot know it unless the payment is received.\n<ul>\n<li>All payment attempts use the same proof-of-payment\nsecret.</li>\n</ul>\n</li>\n<li>One is known by the sender, and its revelation to the\nreceiver allows the receiver to claim this attempt.\n<ul>\n<li>Each payment attempt has a unique receiver-can-claim\nsecret.</li>\n</ul>\n</li>\n</ul>\n<p>The reason for the PTLC is that the PTLC can be arranged\nto be claimable only if the receiver knows both the\nproof-of-payment secret <em>and</em> the receiver-can-claim\nsecret: this is done by having the PTLC require a single\nscalar that is the known sum of the two secrets (this\nrequirement can be imposed without actual knowledge of\neither secret, only the knowledge of the two points\nthat hide the secret).\nIn practice, we also want a third secret. the \u201cdelta\u201d,\nthat is used to obfuscate the actual proof-of-payment\nsecret from forwarding nodes, and is changed at each\nhop to reduce correlatable data if a surveillor has\ncontrol of multiple public forwarding nodes on the\nnetwork.</p>\n<p>The primary difference between stuckless payments via\nPTLCs versus HTLCs is this:</p>\n<ul>\n<li>HTLCs lock rows in multiple databases, and allows the\nreceiver to claim <em>any</em> or <em>all</em> of the funds that\nreach it with the same hash of the HTLC.\nThus, it is unsafe to have multiple HTLC-lock-chains\nin flight that total to more than the payment amount,\nbecause the receiver can commit the transfer for all\nthose funds.</li>\n<li>PTLCs allow the sender to also be required in order\nto commit any PTLC-lock-chains.\nThus, the sender can ensure that only one\nPTLC-lock-chain is committed (or more generally, that\nthe amounts locked by PTLC-lock-chains it allows to\ncommit sum exactly to the agreed payment amount), and\nthe other PTLC-lock-chain are forced to roll back.\nThis allows the sender to make multiple parallel\nPTLC-lock-chains terminating at the receiver, because\nthe receiver can only commit any PTLC-lock-chain (and\nfinalize the transfer) if the sender allows it.</li>\n</ul>\n<p>Suppose an end user, Ursula, with a MultiChannel to 3\nforwarding nodes, Alice, Bob, and Carol, wants to send\nout a PTLC-based payment to some remote receiver.\nThe end-user first maps out multiple paths to the\nreceiver.</p>\n<p>Source routing has the drawback that the sender has\nlittle information about remote channel state, but has\nthe major advantage of not revealing the sender or\nreceiver to intermediate forwarding nodes.\nBy simply preparing multiple possible paths beforehand\nand using a novel construction I call the MultiPTLC,\nUrsula the user can delegate retrying to the forwarding\nnodes and go offline afterwards, while still preserving\ngood privacy of payment receiver.</p>\n<p>Once Ursula has mapped out multiple possible paths to\nthe destination, it creates a MultiPTLC, with a branch\nfor each of its mapped-out paths.</p>\n<h3><a name=\"p-5870-the-multiptlc-6\" class=\"anchor\" href=\"#p-5870-the-multiptlc-6\"></a>The MultiPTLC</h3>\n<p>The MultiPTLC is simply a contract with multiple P\nbranches and a single TL branch.\nIf you know what a PTLC looks like, then you know what a\nMultiPTLC looks like from that sentence.</p>\n<p>Basically, each of the P branches is a payment attempt.\nThat branch pays out to <em>one</em> of the forwarding nodes,\nAlice, Bob, or Carol, depending on whether that payment\nattempt starts at that node or not.\nThe scalar demanded by each one is different, because\nas noted above, in the stuckless payments scheme, each\nattempt has a different receiver-can-claim secret, and\neach P branch does demands a different sum of\nproof-of-payment secret plus receiver-can-claim secret.</p>\n<p>As noted, each P branch is one payment attempt.\nThere are likely more payment attempts than there are\nactual forwarding nodes, because there are likely\nmultiple possible paths for each forwarding node.\nThus, there are multiple P branches that go to Alice,\none for each payment attempt that starts at Alice,\nand so on for Bob and Carol as well.</p>\n<p>In actual implementation, what happens is that the\noutput at the Poon-Dryja layer is another 2-of-2,\nwhere one of them is Ursula the user and the other is a\nk-of-n of the public forwarding nodes Alice, Bob, and\nCarol.\nAn alternate branch of the 2-of-2 is the timelock going\nback to Ursula.\nThen there are multiple transactions spending that\noutput, pre-signed by Ursula, that go to each of the P\nbranches, plus another revert-to-Ursula timelock: in\neffect, each of the branches is just a plain PTLC.</p>\n<p><em><strong>The advantage of the MultiPTLC is that Ursula the\nend-user sender is only required to lock exactly the\namount they want to pay plus routing fees.</strong></em>\nThis is a major difference from the plain stuckless\npayment model, where the ultimate sender has to lock\nmultiple times their payment amount, one for each\nparallel attempt.</p>\n<p>This advantage is important:</p>\n<ul>\n<li>We expect Ursula the end-user to not have a lot of\nliquidity on the MultiChannel.</li>\n<li>We expect Alice, Bob, and Carol the public forwarding\nnodes to have a lot of liquidity on the public network,\nand can thus afford to lock more of that liquidity in\nparallel outgoing PTLCs to the receiver in a race to\nreach the receiver first.</li>\n</ul>\n<p>Suppose that Bob is the first to get to the receiver,\nand then the receiver asks Bob for the receiver-can-claim\nfor that attempt.</p>\n<p>Actually, back when Ursula was giving over the MultiPTLC\nand its signatures and the onions for each attempt, it\nwas also giving over the receiver-can-claim secrets.\nUrsula gives them, encrypted to the respective public\nforwarding node for that attempt, to the forwarding nodes.\nAfter giving them all that data, Ursula can then go offline\nand just let Alice, Bob, and Carol attempt the payment on\nall the paths that Ursula pre-found.</p>\n<p>Giving the receiver-can-claim secrets to the public forwarding\nnodes is safe for Ursula: Ursula is only committing the exact\npayment amount (plus fees).\nThe onus is then on the consistency protocol of Alice, Bob,\nand Carol to ensure that only one of them sends the\nreceiver-can-claim secret that allows one of the\nPTLC-lock-chains to commit.</p>\n<p>Then, when the receiver asks Bob for the receiver-can-claim\nsecret, Bob asks Alice and Carol to sign for the P branch\nthat goes to that attempt for Bob (Ursula is not needed,\nas Ursula has already signed for all the P branches).\nAs the remaining signature to enable the P branch requires\nk-of-n, even if either Alice or Carol is down, it is enough\nfor Bob to create the signature with the other surviving\npublic routing node, thus keeping high-availability CP.</p>\n<p>Then Bob can sign the P branch itself, which then lets,\nvia Magic Math, Ursula learn the sum of proof-of-payment\nplus receiver-can-claim plus delta, once Bob has presented\nit to Ursula either onchain or offchain.</p>\n<p>With that assurance, Bob can send the correct\nreceiver-can-claim secret to the receiver, and once the\nreceiver claims the payment, Bob now knows the sum of\nproof-of-payment plus receiver-can-claim plus delta, but\ndoes not know the delta (Ursula knows the delta and\nreceiver-can-claim secrets, so it can learn the\nproof-of-payment by subtracting both).\nBob can now use that secret to claim the funds from the\nenabled P branch of the MultiPTLC.</p>\n<p>Now you might ask: what if both Alice and Carol refuse to\nsign for the P branch going to Bob?\nWell, then Bob cannot earn routing fees, because it cannot\nsafely send the receiver-can-claim secret and the receiver\nwill then try one of the other attempts that reach them,\nwhich could then go to Alice or Carol, who are clearly\ncolluding to steal the routing fee from Bob.\nIs that a problem?\nSucks for Bob, but remember earlier?</p>\n<blockquote>\n<ul>\n<li>This implies that each of the public forwarding nodes have\nto trust that a quorum of the other public forwarding nodes\ndoes not steal funds.</li>\n</ul>\n</blockquote>\n<p>Routing fees are just funds, thus stealing the routing fees\nis just stealing funds, and we already gave the assumption\nthat the public forwarding nodes have to trust that a quorum\nof the other public forwarding nodes does not steal funds (and\ntherefore routing fees).</p>\n<p>If Bob has already gotten the signature for the P branch for\nthe first-place payment attempt, it\u2019s still possible for\nanother payment attempt to reach the receiver.\nSuppose that Bob got a signature from Alice to enable the P\nbranch.\nThen Carol gets the second-place payment attempt, requesting\nfor the receiver-can-claim secret.\nBob and Alice can then collude to keep the fact that the P\nbranch was already enabled for Bob, and sign for the P branch\ngoing to Carol, but again, see above.</p>\n<p>Now, who is \u201cfirst place\u201d and \u201csecond place\u201d, if the race is\nvery close, and we are in a relativistic universe where\n\u201cglobal order\u201d is a delusion of merely human minds?\nAlice, Bob, and Carol can use standard Raft consistency\nprotocols (or any other quorum consistency protocol) to decide\non who wins the race; the assertion \u201cBob wins\u201d or \u201cCarol wins\u201d\nis simply two conflicting transactions to the database.\nNote that Ursula is not involved here; it can be completely\noffline once it has sent out the send-payment request with all\nthe necessary data and signatures to a quorum of the public\nforwarding nodes.</p>\n<p>Note that even inside a plain Channel, a MultiPTLC still has\nsome of the same benefits: the public routing node can\nperform the payment attempts, in parallel, after the user\nUrsula has given all the necessary data (and in particular,\nUrsula can go offline while the public routing node is\nattempting payments, and Ursula only needs to lock the\nexact amount it wants to send).\nHowever, the issue with using a MultiPTLC inside a plain\nChannel is that if the <em>single</em> public routing node goes down,\nUrsula cannot make payments or determine if the payment went\nthrough or not, again, because of the lack of a sufficient\nquorum to safely update state; with a MultiChannel, the\navailability of the CP database is much higher.</p>\n<p>The drawback of the MultiPTLC is that it requires that\npretty much the entire network upgrade to use PTLCs instead\nof HTLCs, as well as to support a stuckless payments protocol\nthat is compatible with getting the receiver-can-claim secret\nfrom the LSP instead of the ultimate sender.\nGood luck with that.</p>\n<p>Nothing really prevents the use of HTLCs within a MultiChannel.\nHowever, the advantage of having high availability at the\nMultiChannel hop is lost because Ursula can only safely make\none payment attempt at a time, meaning that if there are\nfurther availability issues beyond the MultiChannel, the payment\nremains stuck and Ursula suffers low availability.</p>\n<p>So actually yes, we can still use HTLCs on this MultiChannel\nscheme, but it still does not achieve global high-availability\nCP database semantics, only local high-availability CP database,\nwhich is insufficient for actual payments.</p>\n<p>In effect:</p>\n<ul>\n<li>MultiChannel protects against <em>local</em> availability issues,\ni.e. where one of Alice, Bob, or Carol are down.\n<ul>\n<li>MultiChannel hosting plain HTLCs still suffer from\navailability issues if a remote forwarding node goes down,\nand Ursula needs to be online to perform alternate payment\nattempts if the current payment attempt fails.</li>\n</ul>\n</li>\n<li>MultiPTLC (actually stuckless payments, but MultiPTLC allows\nfor less funds to be locked at the sending end user hop than\nplain PTLC-only stuckless payments) protects against <em>global</em>\navailability issues, where some remote node goes down while\nit holds PTLC locks that are associated with the lock on\nUrsula funds on the direct (Multi)Channel.\n<ul>\n<li>MultiPTLC in a plain Channel with a single forwarding node\nstill suffer from local availability issues if that single\nforwarding node goes down.</li>\n</ul>\n</li>\n</ul>\n<p>Both are needed for a <em>global</em> high-availability CP payments\ndatabase.</p>\n<p>Both the MultiPTLC and the MultiChannel, allow the funds that\nUrsula has, to be pointed at <em>one of multiple nodes</em>, instead\nof just being pointed at one node which can have availability\nissues.</p>\n<h2><a name=\"p-5870-multichannel-receiving-7\" class=\"anchor\" href=\"#p-5870-multichannel-receiving-7\"></a>MultiChannel Receiving</h2>\n<p>This simply uses a plain PTLC funded from the funds of\nwhichever one of the public forwarding nodes got the payment.\nOnce Ursula the user comes online, a quorum of the public\nforwarding nodes can update the state and forward the funds\nto Ursula.</p>\n<p>Clearly, each of the public forwarding nodes has to have\nsome amount of liquidity towards Ursula, and in the actual\nchannel state, there would be separate outputs for those.</p>\n<p>This is left as an exercise to the reader.</p>\n<p>It should be a well-known fact by now that senders get all the\npayment failure data, and receivers simply get no payment\nfailure data.\nThus, the interesting part is getting senders to have higher\nprobability of successfully paying, because there is simply\n<em><strong>nothing</strong></em> the receiver can do if none of the lock-chains\neven reach it; it cannot even know about the inability to get\npaid.</p>\n<h2><a name=\"p-5870-poon-dryja-multichannel-8\" class=\"anchor\" href=\"#p-5870-poon-dryja-multichannel-8\"></a>Poon-Dryja MultiChannel</h2>\n<p>With Bitcoin ossified, there are only a few viable offchain\nmechanisms.\nPoon-Dryja is one of them, and is what is currently deployed\non the Lightning Network.</p>\n<p>Largely, Ursula the user talks with a quorum of Alice, Bob,\nand Carol, and they talk almost entirely using the Poon-Dryja\nconsistency protocol.\nThis lets Ursula rely on standard Poon-Dryja assurances when\nassessing security risks from the public forwarding nodes, and\nvice versa, the public forwarding nodes can rely on standard\nPoon-Dryja assurances to assess security risks from Ursula the\nuser.</p>\n<p>However, the issue is with the revocation secret.\nWe require that a quorum of Alice, Bob, and Carol is needed\nto release the revocation secret to Ursula.\nOtherwise, if all of the public forwarding nodes know the\nsame secreet, all it takes is for one of them to collude\nwith Ursula to reveal the secret \u201cearly\u201d, for the latest\nstate, and then trigger a closure of the MultiChannel at\nthe latest state, which is now revocable by Ursula.</p>\n<p>Rather than a revocation secret, we have a revocation\ntransaction; the normal claim path is locked with a\nrelative timelock (as is normal for Poon-Dryja) while\nthe revocation transaction has no timelock, and can be\nclaimed.\nThe revocation transaction then has to be signed by a\nquorum of Alice, Bob, and Carol \u2014 standard k-of-n\nscheme \u2014 and puts the funds to Ursula.\nThus, to update the state, a minimum quorum of Alice,\nBob, and Carol is needed to provide revocations to\nUrsula, a necessary part of the Poon-Dryja consistency\nprotocol.\nHowever, <em>only</em> a quorum is needed, so even if one of\nAlice, Bob, or Carol is down, the remaining are still\nenough to update the CP database and achieve local\nhigh availability.</p>\n<p>Of course, a quorum of Alice, Bob, and Carol can still\ncollude with Ursula to steal funds by giving the\nrevocation \u201cearly\u201d (i.e. giving revocation for the latest\nstate instead of only older states), but again:</p>\n<blockquote>\n<ul>\n<li>This implies that each of the public forwarding nodes have\nto trust that a quorum of the other public forwarding nodes\ndoes not steal funds.</li>\n</ul>\n</blockquote>\n<p>The 2-of-2 layer of the nested 2-of-2 where one is a k-of-n\nscheme means that the user Ursula has the same security posture\nas with plain 2-of-2 Poon-Dryja Channels: Ursula needs to pay\nattention to the blockchain and watch for theft attempts.</p>\n<p>The problem now is that our current Poon-Dryja\nimplementations use a \u201cshachain\u201d construct to store\nrevocation secrets.\nThe \u201cshachain\u201d is an O(1) space, O(log N) insertion,\nO(log N) lookup structure for a sequence of revocation\nsecrets.\nWhen we switch to providing signatures for revocation\ntransactions instead of revocation preimages like our current\nPoon-Dryja implementations, the O(1) space shachain is not\nuseable anymore.</p>\n<p>In short, the drawback is that Ursula needs O(n) storage\nfor each open MultiChannel.</p>\n<p>The advantage is that Ursula only needs to maintain one\nMultiChannel, as that single consturct can be used to pay\nvia multiple forwarding nodes without requiring additional\nliquidity in a hot wallet, so this may be a better tradeoff\nin practice than having to maintain multiple channels to\nmultiple public forwarding nodes.</p>\n<p>Alternatively, we can use the Decker-Wattenhofer\ndecrementing-<code>nSequence</code> mechanism instead.\nThis does not require storing O(n) revocations, but instead\ngets larger, variable timelocks that would also create\nminimum timeouts for the MultiPTLCs in-flight inside the\nMultiChannel.\nWe also have absolutely no experience in using these in\nproduction, so there may be hidden edge-case gotchas\nthat we are not aware of, and may become future CVEs.\nAnother issue is that if you then embed MultiChannels inside a\nSuperScalar, and if the MultiChannel is a Decker-Wattenhofer,\nthe SuperScalar also adds a few Decker-Wattenhofer layers,\nadding even more variable delays that impact the minimum\ntimelocks for hosted MultiPTLCs.</p>\n<p>Other multi-participant constructs are also available in an\nossified Bitcoin, but require significant amounts of funds to\nbe locked into bonds, and thus I normally do not bother\nanalyzing those; my model is that Ursula the user really wants\nto have only a small amount of funds at risk on a hot wallet,\nthus any bond-requiring construction is simply a no-go for\nanything that is intended for last-mile connection to end users.\nAnalyses of the use of those constructs for a MultiChannel\nis thus left as an exercise to the reader.</p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 1,
  "updated_at": "2025-09-14T21:43:32.468Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 5,
  "reads": 8,
  "readers_count": 7,
  "score": 26.6,
  "yours": false,
  "topic_id": 1983,
  "topic_slug": "multichannel-and-multiptlc-towards-a-global-high-availability-cp-database-for-bitcoin-payments",
  "topic_title": "MultiChannel and MultiPTLC: Towards A Global High-Availability CP Database For Bitcoin Payments",
  "topic_html_title": "MultiChannel and MultiPTLC: Towards A Global High-Availability CP Database For Bitcoin Payments",
  "category_id": 7,
  "display_username": "ZmnSCPxj jxPCSnmZ",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Title: Towards a High-Availability CP Database For Bitcoin Payments\n\n# Introduction\n\nThe CAP Theorem is: You can have any two of these three:\n\n1. Consistency\n2. Availability\n3. Partition-Tolerance\n\nNow, because network is unreliable, what you actually *can* have\nare any one of these two:\n\n1. CP - Consistent and Partition-Tolerant\n2. AP - Available and Partition-Tolerant\n\nThe Bitcoin blockchain is ultimately a database \u2014 the\nblockchain itself is a write-ahead log that is never reset, and\ntransactions delete entries (UTXOs) and add new entries (updates\nare effectively an atomic deletion followed by an insertion, thus\nBitcoin is actually a full ACID CRUD database).\n\nThe Bitcoin blockchain is an AP database.\nDue to the thousands of fullnodes (some of which even have hashpower)\ndeployed worldwide, the Bitcoin blockchain is never going to go down.\n\nHowever, it *does* allow for temporary inconsistency.\nIn particular, zero-conf transactions may later be reverted, and if\nyou read zero-conf transactions, you\u2019ll be getting dirty reads\n(There Ain\u2019t No Such Thing As A Global Mempool problem).\nEven confirmed transactions may theoretically still be later\nreverted, though the probability of that grows very low with more\nconfirmations.\nThus, to ensure consistency, payments on the blockchain are slow,\nin order to ensure that potential inconsistencies settle down into\nconfirmed-committed transactions.\n\nBut the gold standard for high-speed global financial applications\nis a high-availability CP database (which prioritizes Consistency\nover Availability, but does have mitigations to improve its\nAvailability in practice).\nAnd the Bitcoin blockchain, as we have demonstrated, is not a CP\ndatabase, but an AP one (and not even a high-consistency AP\ndatabase).\n\n# Lightning as a Global CP Database\n\nSurprisingly, we have actually managed to build and deploy a\nglobal CP database built on top of the AP database: Lightning\nNetwork.\n\nIt is not a *high-availability* CP database, but it *is* a CP\ndatabase, and a globally CP database at that.\nBecause of its CP nature, financial payments on the Lightning\nNetwork can be very fast, as there is no need to wait to\nreduce the incidence of dirty reads due to inconsistencies.\n\nThe core of the Lightning Network being a *global* CP database\nlies in two constructions:\n\n1. The Channel, a *local* two-node CP database for financial\n   transactions that can only safely hold money for the two\n   nodes on it, with the ability to publish its final state\n   at any time on the \u201clayer 1 blockchain\u201d aka the AP\n   database we are building on.\n2. The HTLC, a financial contract that can be used to ensure\n   atomicity across multiple financial databases.\n\nThe Channel is local: it can only safely hold money for the\ntwo nodes that are managing the database.\nHowever, it is very CP, using a bespoke consistency protocol:\nwe have a hand-over-hand for updating to the next database\nstate (creating an intermediate metastate where both are\nvalid), then revoking the old state, leaving just the next\nstate as valid.\nRevocation is thus the point at which consistency is assured,\nas it prevents the other side from putting old state and thus\nconsistent with the latest state.\nIn case of a network partition (i.e. connection lost, then\nreestablished) the two nodes show the signatures for the\nlatest state that the other side has provided as well as the\nlatest revocation they have, thus proving to the other node\nwhat the latest state actually is.\n\nWe then build up these local CP databases into a *global*\nCP database by using HTLCs to ensure consistent updates\nacross multiple, local CP databases.\nThe HTLC is effectively a row-level lock on some amount of\ncoins on the CP database, locking their use until either\nthe payment reaches the receiver, or some other failure\noccurs.\nDeadlock is prevented by the simple expedient of doing\nlocks from the order sender to receiver.\nA payment is thus composed of a series of locks on multiple\nlocal CP databases, and once the payment is received, the\nlocks are freed in reverse order.\n\n## Lightning Flaw: Low-Availability\n\nThe Lightning Network is *not* high-availability, meaning\nthat in case of network partitions, sometimes payments are\nimpossible.\n\nFor example, if an HTLC has already propagated, and one of\nthe nodes along the path goes down, then the payment update\ncannot finish at the sender.\nIn case of some other failure, the payment may also fail\nbefore it reaches the receiver, and because the sender and\nthe receiver cannot be sure of what the status of the\nHTLC-lock-chain, they are unable to do anything to complete\nthe payment: the sender cannot safely send out another\nalternate payment without trusting that the receiver will not\nspend both the original and the alernate payment, and the\nreceiver literally holds no money at this point and cannot\ntrust the sender claim that it has sent out the funds.\n\nThus, the Lightning Network availability drops whenever a\npublic routing node goes offline.\n\nThe reason why Lightning Network is *not* high-availability\nCP lies precisely in the Channel:\n\n> The Channel, a local *two-node* CP database for financial\n> transactions\n\nHaving only two nodes means that if one of the nodes is down,\nthere is simply no way for the remaining node to update the\ndatabase state.\nIn order to get a *high-availability* CP database, we need at\nleast *three* nodes, not two, and the rule that if one of\nthem goes down, the remaining two can keep updating the\ndatabase.\n\nThe more general rule is that if at least 50%, plus 1, are\navailable, they can update the database state.\n\nThe problem with the typical high-availability CP database\nrule above (\u201cthree can keep updating if one of them is\ndead\u201d) is that it is in conflict with an important principle\nof self-custody:\n\n> ***NOT YOUR KEYS, NOT YOUR COINS***\n\nOn the underlying Bitcoin AP database, deletions of UTXOs\nare authorized by signatures.\nAnd thus, for the Lightning Channel two-node local CP\ndatabase, the authorizers are *both* nodes, and both must\nprovide signatures whenever they are updating the local\nCP database.\n\nObviously, if a node is down, it *cannot* provide a\nsignature.\nIf we were to naively follow the high-availability CP\ndatabase rule of \u201cthree can keep updating if one of them\nis dead\u201d then that implies that only two nodes need to\nprovide signatures for a three-node construction.\nBut that means that the dead node does not have its key\nused to spend the money: the fund is spendable without\nits signature, i.e. it can be spent with\n***NOT ITS KEY***.\nThus, that node has to assume that its funds are\npotentially ***NOT ITS COIN*** if the remaining two nodes\ncollude to steal the coin.\n\n# High-Availability CP With Your Keys, Your Coins For End Users\n\nWe have established two facts:\n\n* For high-availability CP, we need at least 3 nodes, and\n  allow 2 to update if 1 is dead.\n* ***NOT YOUR KEYS, NOT YOUR COINS*** requires consensus,\n  i.e. everyone has to be around to sign.\n\nOn the face of it, the two facts imply that we cannot have\nhigh-availability CP in combination with self-custody, at\nleast with current schemes available in Bitcoin.\n\nHowever, we can instead degrade the strong self-custody\nrequirement as follows:\n\n* The public forwarding nodes have significant resources\n  to check the trustworthiness of other public forwarding\n  nodes.\n  They also have a public reputation, which, if destroyed,\n  also potentially destroys their income stream (routing\n  fees).\n* The end user does *not* have the resources to check the\n  trustworthiness of *any* public forwarding nodes.\n  They also do not have a public reputation, and are\n  therefore less trustworthy-by-default than public\n  forwarding nodes.\n* Therefore:\n  * The end user ***MUST NOT*** trust any public forwarding\n    nodes, because they might not have the resources to\n    check if the public forwarding nodes are trustworthy.\n  * The public forwarding nodes ***MUST NOT*** trust the\n    end user, because the end user is literally some random\n    Internet person.\n  * The public forwarding nodes *can* trust other public\n    forwarding nodes, by doing things like know-your-business,\n    service level agreements, legal contracts, being owned by\n    the same company, and so on.\n\nWhat I propose, then, is:\n\n* Have a 2-of-2:\n  * One is the end user.\n  * The other is a 2-of-3 of 3 different public forwarding\n    nodes.\n    (Or, more generally, some `k`-of-`n` of public\n    forwarding nodes where `n > 3` and `k >= 1 + floor(n / 2)`).\n    * This implies that the each of the public forwarding nodes\n      have to trust that a quorum of the other public forwarding\n      nodes does not steal funds.\n      This is trivially achievable if the public forwarding\n      nodes are run by the same corporation; they might do\n      this precisely so that they can keep high availability,\n      such as doing rolling updates of their nodes.\n      Alternately, public forwarding nodes may have legal\n      guards to protect against misbehavior of other public\n      forwarding nodes, without requiring the same legal\n      guards against end users (or for the end users to\n      require legal guards against any or all of the public\n      forwarding nodes).\n\n> ***Digression*** I mean \u2014 if you are pushing Spark or Ark\n> or some other statechain-based mechanism or federated mechanism\n> where end users have to trust a quorum of big corporate service\n> providers, then you are making an assertion that big corporate\n> service providers are trustworthy.\n> If so, and you are a big corporate service provider, put your\n> money where your mouth is: trust a quorum of those other big\n> corporate service providers yourself, instead of forcing end\n> users to trust them.\n> If you will not do that, then that reveals your actual\n> assessment of the risk of trusting big corporate service\n> providers.\n> Yes, you are putting more funds into this than an end user,\n> but the end user is also much poorer than a big corporation\n> and the loss of those funds would cut just as deeply for\n> them.\n> Hey at least you do not have to trust end users with this\n> mechanism, unlike SuperScalar where you trust that they will\n> actually come online to help you move liquidity where it is\n> needed, or to cooperatively exit before the tree times out,\n> or else you pay more onchain fees.\n\n(Note: as there is currently no proof that FROST-in-MuSig2 is\nsafe, we should use explicit SCRIPT-based checking of two\nsignatures, one of which is the end user signature, the other\nbeing the FROST of the public forwarding nodes.)\n\nThe reason for using 2-of-3 is as noted above:\n\n> \u201cthree can do an update if one of them is dead\u201d\n\nThis is then where we upgrade the low-availability CP\ndatabase of the plain Channel to a high-availability CP\ndatabase of this novel construction, which I will now dub\nthe MultiChannel.\n\n(Unfortunately, MultiChannels can only use PTLCs, not\nHTLCs, as I will show below.)\n\n## MultiChannel Sending\n\nFirst, let me introduce the PTLC.\nLike the HTLC, the PTLC is effectively a row-level lock on\nsome funds, which can then be either moved to the receiver,\nor returned to the sender.\nLike the HTLC, the PTLC can be used for locking across\nmultiple local CP databases in order to allow for global\nupdates that let senders send money to distant receivers.\n\nThe advantage of the PTLC is that it allows certain kinds of\nmath to be used.\n\nThe reason for introducing PTLCs here is that we want the\nend user to send out just *one* PTLC on its MultiChannel\nwith the public network, and then for the public forwarding\nnodes to be able to send out PTLCs in parallel, on behalf\nof the sender, until one of them is able to have the\npayment reach the receiver.\nThen, we must ensure that the receiver is able to claim\nonly one of the payments, even if multiple arrive at the\nreceiver.\n\nNow, \u201csend out multiple PTLCs in parallel, of which only\none should be claimed at the receiver\u201d is precisely the\nscheme of [stuckless payments](https://diyhpl.us/~bryan/irc/bitcoin/bitcoin-dev/linuxfoundation-pipermail/lightning-dev/2019-June/002029.txt).\nThe stuckless payments proposal, however, requires PTLCs.\n\nBriefly, a stuckless payment involves two secret scalars\nper payment attempt:\n\n* One is known by the receiver, and its revelation to\n  the sender is \u201cproof of payment\u201d because the sender\n  cannot know it unless the payment is received.\n  * All payment attempts use the same proof-of-payment\n    secret.\n* One is known by the sender, and its revelation to the\n  receiver allows the receiver to claim this attempt.\n  * Each payment attempt has a unique receiver-can-claim\n    secret.\n\nThe reason for the PTLC is that the PTLC can be arranged\nto be claimable only if the receiver knows both the\nproof-of-payment secret *and* the receiver-can-claim\nsecret: this is done by having the PTLC require a single\nscalar that is the known sum of the two secrets (this\nrequirement can be imposed without actual knowledge of\neither secret, only the knowledge of the two points\nthat hide the secret).\nIn practice, we also want a third secret. the \u201cdelta\u201d,\nthat is used to obfuscate the actual proof-of-payment\nsecret from forwarding nodes, and is changed at each\nhop to reduce correlatable data if a surveillor has\ncontrol of multiple public forwarding nodes on the\nnetwork.\n\nThe primary difference between stuckless payments via\nPTLCs versus HTLCs is this:\n\n* HTLCs lock rows in multiple databases, and allows the\n  receiver to claim *any* or *all* of the funds that\n  reach it with the same hash of the HTLC.\n  Thus, it is unsafe to have multiple HTLC-lock-chains\n  in flight that total to more than the payment amount,\n  because the receiver can commit the transfer for all\n  those funds.\n* PTLCs allow the sender to also be required in order\n  to commit any PTLC-lock-chains.\n  Thus, the sender can ensure that only one\n  PTLC-lock-chain is committed (or more generally, that\n  the amounts locked by PTLC-lock-chains it allows to\n  commit sum exactly to the agreed payment amount), and\n  the other PTLC-lock-chain are forced to roll back.\n  This allows the sender to make multiple parallel\n  PTLC-lock-chains terminating at the receiver, because\n  the receiver can only commit any PTLC-lock-chain (and\n  finalize the transfer) if the sender allows it.\n\nSuppose an end user, Ursula, with a MultiChannel to 3\nforwarding nodes, Alice, Bob, and Carol, wants to send\nout a PTLC-based payment to some remote receiver.\nThe end-user first maps out multiple paths to the\nreceiver.\n\nSource routing has the drawback that the sender has\nlittle information about remote channel state, but has\nthe major advantage of not revealing the sender or\nreceiver to intermediate forwarding nodes.\nBy simply preparing multiple possible paths beforehand\nand using a novel construction I call the MultiPTLC,\nUrsula the user can delegate retrying to the forwarding\nnodes and go offline afterwards, while still preserving\ngood privacy of payment receiver.\n\nOnce Ursula has mapped out multiple possible paths to\nthe destination, it creates a MultiPTLC, with a branch\nfor each of its mapped-out paths.\n\n### The MultiPTLC\n\nThe MultiPTLC is simply a contract with multiple P\nbranches and a single TL branch.\nIf you know what a PTLC looks like, then you know what a\nMultiPTLC looks like from that sentence.\n\nBasically, each of the P branches is a payment attempt.\nThat branch pays out to *one* of the forwarding nodes,\nAlice, Bob, or Carol, depending on whether that payment\nattempt starts at that node or not.\nThe scalar demanded by each one is different, because\nas noted above, in the stuckless payments scheme, each\nattempt has a different receiver-can-claim secret, and\neach P branch does demands a different sum of\nproof-of-payment secret plus receiver-can-claim secret.\n\nAs noted, each P branch is one payment attempt.\nThere are likely more payment attempts than there are\nactual forwarding nodes, because there are likely\nmultiple possible paths for each forwarding node.\nThus, there are multiple P branches that go to Alice,\none for each payment attempt that starts at Alice,\nand so on for Bob and Carol as well.\n\nIn actual implementation, what happens is that the\noutput at the Poon-Dryja layer is another 2-of-2,\nwhere one of them is Ursula the user and the other is a\nk-of-n of the public forwarding nodes Alice, Bob, and\nCarol.\nAn alternate branch of the 2-of-2 is the timelock going\nback to Ursula.\nThen there are multiple transactions spending that\noutput, pre-signed by Ursula, that go to each of the P\nbranches, plus another revert-to-Ursula timelock: in\neffect, each of the branches is just a plain PTLC.\n\n***The advantage of the MultiPTLC is that Ursula the\nend-user sender is only required to lock exactly the\namount they want to pay plus routing fees.***\nThis is a major difference from the plain stuckless\npayment model, where the ultimate sender has to lock\nmultiple times their payment amount, one for each\nparallel attempt.\n\nThis advantage is important:\n\n* We expect Ursula the end-user to not have a lot of\n  liquidity on the MultiChannel.\n* We expect Alice, Bob, and Carol the public forwarding\n  nodes to have a lot of liquidity on the public network,\n  and can thus afford to lock more of that liquidity in\n  parallel outgoing PTLCs to the receiver in a race to\n  reach the receiver first.\n\nSuppose that Bob is the first to get to the receiver,\nand then the receiver asks Bob for the receiver-can-claim\nfor that attempt.\n\nActually, back when Ursula was giving over the MultiPTLC\nand its signatures and the onions for each attempt, it\nwas also giving over the receiver-can-claim secrets.\nUrsula gives them, encrypted to the respective public\nforwarding node for that attempt, to the forwarding nodes.\nAfter giving them all that data, Ursula can then go offline\nand just let Alice, Bob, and Carol attempt the payment on\nall the paths that Ursula pre-found.\n\nGiving the receiver-can-claim secrets to the public forwarding\nnodes is safe for Ursula: Ursula is only committing the exact\npayment amount (plus fees).\nThe onus is then on the consistency protocol of Alice, Bob,\nand Carol to ensure that only one of them sends the\nreceiver-can-claim secret that allows one of the\nPTLC-lock-chains to commit.\n\nThen, when the receiver asks Bob for the receiver-can-claim\nsecret, Bob asks Alice and Carol to sign for the P branch\nthat goes to that attempt for Bob (Ursula is not needed,\nas Ursula has already signed for all the P branches).\nAs the remaining signature to enable the P branch requires\nk-of-n, even if either Alice or Carol is down, it is enough\nfor Bob to create the signature with the other surviving\npublic routing node, thus keeping high-availability CP.\n\nThen Bob can sign the P branch itself, which then lets,\nvia Magic Math, Ursula learn the sum of proof-of-payment\nplus receiver-can-claim plus delta, once Bob has presented\nit to Ursula either onchain or offchain.\n\nWith that assurance, Bob can send the correct\nreceiver-can-claim secret to the receiver, and once the\nreceiver claims the payment, Bob now knows the sum of\nproof-of-payment plus receiver-can-claim plus delta, but\ndoes not know the delta (Ursula knows the delta and\nreceiver-can-claim secrets, so it can learn the\nproof-of-payment by subtracting both).\nBob can now use that secret to claim the funds from the\nenabled P branch of the MultiPTLC.\n\nNow you might ask: what if both Alice and Carol refuse to\nsign for the P branch going to Bob?\nWell, then Bob cannot earn routing fees, because it cannot\nsafely send the receiver-can-claim secret and the receiver\nwill then try one of the other attempts that reach them,\nwhich could then go to Alice or Carol, who are clearly\ncolluding to steal the routing fee from Bob.\nIs that a problem?\nSucks for Bob, but remember earlier?\n\n> * This implies that each of the public forwarding nodes have\n>   to trust that a quorum of the other public forwarding nodes\n>   does not steal funds.\n\nRouting fees are just funds, thus stealing the routing fees\nis just stealing funds, and we already gave the assumption\nthat the public forwarding nodes have to trust that a quorum\nof the other public forwarding nodes does not steal funds (and\ntherefore routing fees).\n\nIf Bob has already gotten the signature for the P branch for\nthe first-place payment attempt, it\u2019s still possible for\nanother payment attempt to reach the receiver.\nSuppose that Bob got a signature from Alice to enable the P\nbranch.\nThen Carol gets the second-place payment attempt, requesting\nfor the receiver-can-claim secret.\nBob and Alice can then collude to keep the fact that the P\nbranch was already enabled for Bob, and sign for the P branch\ngoing to Carol, but again, see above.\n\nNow, who is \u201cfirst place\u201d and \u201csecond place\u201d, if the race is\nvery close, and we are in a relativistic universe where\n\u201cglobal order\u201d is a delusion of merely human minds?\nAlice, Bob, and Carol can use standard Raft consistency\nprotocols (or any other quorum consistency protocol) to decide\non who wins the race; the assertion \u201cBob wins\u201d or \u201cCarol wins\u201d\nis simply two conflicting transactions to the database.\nNote that Ursula is not involved here; it can be completely\noffline once it has sent out the send-payment request with all\nthe necessary data and signatures to a quorum of the public\nforwarding nodes.\n\nNote that even inside a plain Channel, a MultiPTLC still has\nsome of the same benefits: the public routing node can\nperform the payment attempts, in parallel, after the user\nUrsula has given all the necessary data (and in particular,\nUrsula can go offline while the public routing node is\nattempting payments, and Ursula only needs to lock the\nexact amount it wants to send).\nHowever, the issue with using a MultiPTLC inside a plain\nChannel is that if the *single* public routing node goes down,\nUrsula cannot make payments or determine if the payment went\nthrough or not, again, because of the lack of a sufficient\nquorum to safely update state; with a MultiChannel, the\navailability of the CP database is much higher.\n\nThe drawback of the MultiPTLC is that it requires that\npretty much the entire network upgrade to use PTLCs instead\nof HTLCs, as well as to support a stuckless payments protocol\nthat is compatible with getting the receiver-can-claim secret\nfrom the LSP instead of the ultimate sender.\nGood luck with that.\n\nNothing really prevents the use of HTLCs within a MultiChannel.\nHowever, the advantage of having high availability at the\nMultiChannel hop is lost because Ursula can only safely make\none payment attempt at a time, meaning that if there are\nfurther availability issues beyond the MultiChannel, the payment\nremains stuck and Ursula suffers low availability.\n\nSo actually yes, we can still use HTLCs on this MultiChannel\nscheme, but it still does not achieve global high-availability\nCP database semantics, only local high-availability CP database,\nwhich is insufficient for actual payments.\n\nIn effect:\n\n* MultiChannel protects against *local* availability issues,\n  i.e. where one of Alice, Bob, or Carol are down.\n  * MultiChannel hosting plain HTLCs still suffer from\n    availability issues if a remote forwarding node goes down,\n    and Ursula needs to be online to perform alternate payment\n    attempts if the current payment attempt fails.\n* MultiPTLC (actually stuckless payments, but MultiPTLC allows\n  for less funds to be locked at the sending end user hop than\n  plain PTLC-only stuckless payments) protects against *global*\n  availability issues, where some remote node goes down while\n  it holds PTLC locks that are associated with the lock on\n  Ursula funds on the direct (Multi)Channel.\n  * MultiPTLC in a plain Channel with a single forwarding node\n    still suffer from local availability issues if that single\n    forwarding node goes down.\n\nBoth are needed for a *global* high-availability CP payments\ndatabase.\n\nBoth the MultiPTLC and the MultiChannel, allow the funds that\nUrsula has, to be pointed at *one of multiple nodes*, instead\nof just being pointed at one node which can have availability\nissues.\n\n## MultiChannel Receiving\n\nThis simply uses a plain PTLC funded from the funds of\nwhichever one of the public forwarding nodes got the payment.\nOnce Ursula the user comes online, a quorum of the public\nforwarding nodes can update the state and forward the funds\nto Ursula.\n\nClearly, each of the public forwarding nodes has to have\nsome amount of liquidity towards Ursula, and in the actual\nchannel state, there would be separate outputs for those.\n\nThis is left as an exercise to the reader.\n\nIt should be a well-known fact by now that senders get all the\npayment failure data, and receivers simply get no payment\nfailure data.\nThus, the interesting part is getting senders to have higher\nprobability of successfully paying, because there is simply\n***nothing*** the receiver can do if none of the lock-chains\neven reach it; it cannot even know about the inability to get\npaid.\n\n## Poon-Dryja MultiChannel\n\nWith Bitcoin ossified, there are only a few viable offchain\nmechanisms.\nPoon-Dryja is one of them, and is what is currently deployed\non the Lightning Network.\n\nLargely, Ursula the user talks with a quorum of Alice, Bob,\nand Carol, and they talk almost entirely using the Poon-Dryja\nconsistency protocol.\nThis lets Ursula rely on standard Poon-Dryja assurances when\nassessing security risks from the public forwarding nodes, and\nvice versa, the public forwarding nodes can rely on standard\nPoon-Dryja assurances to assess security risks from Ursula the\nuser.\n\nHowever, the issue is with the revocation secret.\nWe require that a quorum of Alice, Bob, and Carol is needed\nto release the revocation secret to Ursula.\nOtherwise, if all of the public forwarding nodes know the\nsame secreet, all it takes is for one of them to collude\nwith Ursula to reveal the secret \u201cearly\u201d, for the latest\nstate, and then trigger a closure of the MultiChannel at\nthe latest state, which is now revocable by Ursula.\n\nRather than a revocation secret, we have a revocation\ntransaction; the normal claim path is locked with a\nrelative timelock (as is normal for Poon-Dryja) while\nthe revocation transaction has no timelock, and can be\nclaimed.\nThe revocation transaction then has to be signed by a\nquorum of Alice, Bob, and Carol \u2014 standard k-of-n\nscheme \u2014 and puts the funds to Ursula.\nThus, to update the state, a minimum quorum of Alice,\nBob, and Carol is needed to provide revocations to\nUrsula, a necessary part of the Poon-Dryja consistency\nprotocol.\nHowever, *only* a quorum is needed, so even if one of\nAlice, Bob, or Carol is down, the remaining are still\nenough to update the CP database and achieve local\nhigh availability.\n\nOf course, a quorum of Alice, Bob, and Carol can still\ncollude with Ursula to steal funds by giving the\nrevocation \u201cearly\u201d (i.e. giving revocation for the latest\nstate instead of only older states), but again:\n\n> * This implies that each of the public forwarding nodes have\n>   to trust that a quorum of the other public forwarding nodes\n>   does not steal funds.\n\nThe 2-of-2 layer of the nested 2-of-2 where one is a k-of-n\nscheme means that the user Ursula has the same security posture\nas with plain 2-of-2 Poon-Dryja Channels: Ursula needs to pay\nattention to the blockchain and watch for theft attempts.\n\nThe problem now is that our current Poon-Dryja\nimplementations use a \u201cshachain\u201d construct to store\nrevocation secrets.\nThe \u201cshachain\u201d is an O(1) space, O(log N) insertion,\nO(log N) lookup structure for a sequence of revocation\nsecrets.\nWhen we switch to providing signatures for revocation\ntransactions instead of revocation preimages like our current\nPoon-Dryja implementations, the O(1) space shachain is not\nuseable anymore.\n\nIn short, the drawback is that Ursula needs O(n) storage\nfor each open MultiChannel.\n\nThe advantage is that Ursula only needs to maintain one\nMultiChannel, as that single consturct can be used to pay\nvia multiple forwarding nodes without requiring additional\nliquidity in a hot wallet, so this may be a better tradeoff\nin practice than having to maintain multiple channels to\nmultiple public forwarding nodes.\n\nAlternatively, we can use the Decker-Wattenhofer\ndecrementing-`nSequence` mechanism instead.\nThis does not require storing O(n) revocations, but instead\ngets larger, variable timelocks that would also create\nminimum timeouts for the MultiPTLCs in-flight inside the\nMultiChannel.\nWe also have absolutely no experience in using these in\nproduction, so there may be hidden edge-case gotchas\nthat we are not aware of, and may become future CVEs.\nAnother issue is that if you then embed MultiChannels inside a\nSuperScalar, and if the MultiChannel is a Decker-Wattenhofer,\nthe SuperScalar also adds a few Decker-Wattenhofer layers,\nadding even more variable delays that impact the minimum\ntimelocks for hosted MultiPTLCs.\n\nOther multi-participant constructs are also available in an\nossified Bitcoin, but require significant amounts of funds to\nbe locked into bonds, and thus I normally do not bother\nanalyzing those; my model is that Ursula the user really wants\nto have only a small amount of funds at risk on a hot wallet,\nthus any bond-requiring construction is simply a no-go for\nanything that is intended for last-mile connection to end users.\nAnalyses of the use of those constructs for a MultiChannel\nis thus left as an exercise to the reader.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 104,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "Title: Towards a High-Availability CP Database For Bitcoin Payments \n<a name=\"p-5870-introduction-1\" class=\"anchor\" href=\"#p-5870-introduction-1\"></a>Introduction\nThe CAP Theorem is: You can have any two of these three: \n\nConsistency\nAvailability\nPartition-Tolerance\n\nNow, because network is unreliable, what you actually can have\nare any one of these two: \n\nCP - Consistent and Pa&hellip;",
  "truncated": true,
  "post_url": "/t/multichannel-and-multiptlc-towards-a-global-high-availability-cp-database-for-bitcoin-payments/1983/1",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}