{
  "id": 5885,
  "name": "ZmnSCPxj jxPCSnmZ",
  "username": "ZmnSCPxj",
  "avatar_template": "/letter_avatar_proxy/v4/letter/z/ee7513/{size}.png",
  "created_at": "2025-09-16T18:48:02.842Z",
  "cooked": "<aside class=\"quote no-group quote-modified\" data-username=\"harding\" data-post=\"2\" data-topic=\"1983\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/harding/48/925_2.png\" class=\"avatar\"> harding:</div>\n<blockquote>\n<aside class=\"quote no-group quote-modified\" data-username=\"ZmnSCPxj\" data-post=\"1\" data-topic=\"1983\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/letter_avatar_proxy/v4/letter/z/ee7513/48.png\" class=\"avatar\"> ZmnSCPxj:</div>\n<blockquote>\n<p>The advantage of the MultiPTLC [over sender-created stuckless payments] is that Ursula the end-user sender is only required to lock exactly the amount they want to pay plus routing fees.</p>\n</blockquote>\n</aside>\n<p>Would you be able to explain more about why you think that\u2019s an advantage worth the additional complexity?</p>\n</blockquote>\n</aside>\n<p>As mentioned, my model is that Ursula has a small amount of funds.</p>\n<p>In particular, as noted elsewhere, MultiPTLC really protects against <em><strong>global</strong></em> high-availability, i.e. when a <em><strong>remote</strong></em> routing node goes down while it is in the middle of a PTLC-lock-chain.  Suppose, as you mention, Ursula makes 10 stuckless payments using plain PTLCs.  Suppose one goes through, but one of the other 9 does not get a <code>update_fail_ptlc</code> message.  That fund remains locked, potentially for the entire lock time, which, since Ursula is the sender, is at its largest.  This can happen if one of the routing nodes along that path goes down while it has a PTLC on one or both of the channels it has on the route.</p>\n<p>So tell me: how do I explain to  Ursula \u201cYes, the 1000 sats payment got through and I deducted it from your account, but now I have to hold <em><strong>another</strong></em> 1000 sats of your money because the Lightning Network had problems.\u201d?  Sure, I could hide that fact and hope that Ursula never actually needs to zero out their wallet in the next two weeks, but if Ursula <em><strong>does</strong></em> want to drain their wallet, the jig is up and now I have just doubled down on my little white UX lie.</p>\n<p>I mean\u2026 \u201cstuckless\u201d is really a lie.  It can still get stuck, it is just that we can now let them get stuck <em><strong>in parallel</strong></em> instead of having a strict required serialization where I have to wait for the current attempt to get unstuck before making a different attempt.  It is not really stuckless, it is actually \u201cparallel stuckness is not a money loss risk\u201d.  The locks still exists on the money. and the issue is that, because we do not have control over the <em><strong>rest</strong></em> of the network, we cannot ensure that the money will not get locked for two weeks due to failures of the remote nodes that we do not control.</p>\n<p>The fact that MultiPTLC only locks <em><strong>one</strong></em> unit of the payment on the side of Ursula is nearer to how the mind of a human-implemented Ursula works: they have allocated <em><strong>one</strong></em> unit of the payment for this receiver, so it getting locked until the network is able to deliver it or not is what Ursula expects.  Ursula <em><strong>does not expect</strong></em> that multiples of their designated amounts get lockedd.</p>\n<hr>\n<p>That is just <em><strong>one</strong></em> advantage of MultiPTLC.  Another is that it is significantly better for mobile devices with low or spurious connectivity.</p>\n<p>By having just <em><strong>one</strong></em> unit of the payment locked on the side of Ursula, Ursula can outright hand over the receiver-can-claim scalars to the LSPs.  Then, Ursula device can calculate all the necessities \u2014 signatures, encrypted blobs, paths, onions \u2014 without touching the network, then send out all of those to at least two LSPs (or whatever minimum quorum) over a few dozen IP packets.  Then Ursula can go offline once again.  Ursula only needs those few dozen IP packets, and the rest of the payment flow is now handled by the LSPs.</p>\n<p>Compare this to the sender-created \u201cstuckless\u201d payment, where Ursula needs to be constantly online, waiting for \u201crequest for receiver-can-claim scalar\u201d.  Because Ursula is putting out multiples of the payment amount, it cannot hand over the receiver-can-claim scalars to the LSPs.  If Ursula loses connectivity after sending out the payment request, then Ursula cannot give the receiver-can-claim scalar and the receiver might decide to free up inbound liquidity early by giving up after a short timeout, leading to total payment failure.</p>\n<p>The LSPs are better positioned to have high connectivity and high uptime.  Let us delegate the payment re-attempt flow and the receiver-can-claim scalar sending to them, not on Ursula, who could be low-connectivity and low uptime.</p>\n<aside class=\"quote no-group quote-modified\" data-username=\"harding\" data-post=\"2\" data-topic=\"1983\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/harding/48/925_2.png\" class=\"avatar\"> harding:</div>\n<blockquote>\n<aside class=\"quote no-group quote-modified\" data-username=\"ZmnSCPxj\" data-post=\"1\" data-topic=\"1983\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/letter_avatar_proxy/v4/letter/z/ee7513/48.png\" class=\"avatar\"> ZmnSCPxj:</div>\n<blockquote></blockquote>\n</aside>\n<aside class=\"quote no-group\" data-username=\"ZmnSCPxj\" data-post=\"1\" data-topic=\"1983\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/letter_avatar_proxy/v4/letter/z/ee7513/48.png\" class=\"avatar\"> ZmnSCPxj:</div>\n<blockquote>\n<p>We expect Ursula the end-user to not have a lot of liquidity on the MultiChannel.</p>\n</blockquote>\n</aside>\n<p>What is the basis for that expectation?  Almost all of my payments with physical cash, LN sats, and bank credit are for less than half of my available liquidity (respectively: cash-in-wallet, sats-on-my-side-of-the-channel, and available credit); I would guess most of my payments are for less than 1/10th my liquidity.  User-initiated stuckless payments should be convenient under those conditions, with no need for additional third party liquidity.</p>\n<p>In the rare cases where I make payments that approach the limit of my liquidity\u2014conditions where stuckless payments might not function well or at all\u2014I don\u2019t usually mind waiting longer.  For example, I don\u2019t want to wait more than a few seconds to complete a purchase of a $5 hot beverage but I don\u2019t mind much that it often takes over a minute to complete a $2,000 purchase of airplane tickets on my current credit card (the bank usually requiring me to verify the purchase via text message).</p>\n</blockquote>\n</aside>\n<p>As noted earlier, the problem is not just that Ursula might not have the liquidity, it is simply that it does not match the expectations of a naive human Ursula that multiple units of their payment amount get locked, and potentially can be locked for two weeks if bad things happen beyond the control of Ursula, the wallet developer, or the LSPs.  It is already bad enough that, with MultiPTLC, if <em><strong>all</strong></em> the parallel attempts by the quorum of LSPs fail but at least one of them gets stuck, the MultiPTLC is still stuck (the LSPs cannot safely revert it while at least one of their outgoing PTLCs are not reverted or commited, since Ursula might be a pseudonym of ZmnSCPxj the notorious hacker who can directly hand over the receiver-can-claim scalar to the receiver by sneakernet).</p>",
  "post_number": 4,
  "post_type": 1,
  "posts_count": 12,
  "updated_at": "2025-09-16T18:48:02.842Z",
  "reply_count": 1,
  "reply_to_post_number": 2,
  "quote_count": 2,
  "incoming_link_count": 0,
  "reads": 45,
  "readers_count": 44,
  "score": 14.0,
  "yours": false,
  "topic_id": 1983,
  "topic_slug": "multichannel-and-multiptlc-towards-a-global-high-availability-consistent-partition-tolerant-database-for-bitcoin-payments",
  "topic_title": "MultiChannel and MultiPTLC: Towards A Global High-Availability Consistent/Partition-Tolerant Database For Bitcoin Payments",
  "topic_html_title": "MultiChannel and MultiPTLC: Towards A Global High-Availability Consistent/Partition-Tolerant Database For Bitcoin Payments",
  "category_id": 7,
  "display_username": "ZmnSCPxj jxPCSnmZ",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"harding, post:2, topic:1983\"]\n[quote=\"ZmnSCPxj, post:1, topic:1983\"]\nThe advantage of the MultiPTLC \\[over sender-created stuckless payments\\] is that Ursula the end-user sender is only required to lock exactly the amount they want to pay plus routing fees.\n\n[/quote]\n\nWould you be able to explain more about why you think that\u2019s an advantage worth the additional complexity?\n\n[/quote]\n\nAs mentioned, my model is that Ursula has a small amount of funds.\n\nIn particular, as noted elsewhere, MultiPTLC really protects against ***global*** high-availability, i.e. when a ***remote*** routing node goes down while it is in the middle of a PTLC-lock-chain.  Suppose, as you mention, Ursula makes 10 stuckless payments using plain PTLCs.  Suppose one goes through, but one of the other 9 does not get a `update_fail_ptlc` message.  That fund remains locked, potentially for the entire lock time, which, since Ursula is the sender, is at its largest.  This can happen if one of the routing nodes along that path goes down while it has a PTLC on one or both of the channels it has on the route.\n\nSo tell me: how do I explain to  Ursula \u201cYes, the 1000 sats payment got through and I deducted it from your account, but now I have to hold ***another*** 1000 sats of your money because the Lightning Network had problems.\u201d?  Sure, I could hide that fact and hope that Ursula never actually needs to zero out their wallet in the next two weeks, but if Ursula ***does*** want to drain their wallet, the jig is up and now I have just doubled down on my little white UX lie.\n\nI mean\u2026 \u201cstuckless\u201d is really a lie.  It can still get stuck, it is just that we can now let them get stuck ***in parallel*** instead of having a strict required serialization where I have to wait for the current attempt to get unstuck before making a different attempt.  It is not really stuckless, it is actually \u201cparallel stuckness is not a money loss risk\u201d.  The locks still exists on the money. and the issue is that, because we do not have control over the ***rest*** of the network, we cannot ensure that the money will not get locked for two weeks due to failures of the remote nodes that we do not control.\n\nThe fact that MultiPTLC only locks ***one*** unit of the payment on the side of Ursula is nearer to how the mind of a human-implemented Ursula works: they have allocated ***one*** unit of the payment for this receiver, so it getting locked until the network is able to deliver it or not is what Ursula expects.  Ursula ***does not expect*** that multiples of their designated amounts get lockedd.\n\n---\n\nThat is just ***one*** advantage of MultiPTLC.  Another is that it is significantly better for mobile devices with low or spurious connectivity.\n\nBy having just ***one*** unit of the payment locked on the side of Ursula, Ursula can outright hand over the receiver-can-claim scalars to the LSPs.  Then, Ursula device can calculate all the necessities \u2014 signatures, encrypted blobs, paths, onions \u2014 without touching the network, then send out all of those to at least two LSPs (or whatever minimum quorum) over a few dozen IP packets.  Then Ursula can go offline once again.  Ursula only needs those few dozen IP packets, and the rest of the payment flow is now handled by the LSPs.\n\nCompare this to the sender-created \u201cstuckless\u201d payment, where Ursula needs to be constantly online, waiting for \u201crequest for receiver-can-claim scalar\u201d.  Because Ursula is putting out multiples of the payment amount, it cannot hand over the receiver-can-claim scalars to the LSPs.  If Ursula loses connectivity after sending out the payment request, then Ursula cannot give the receiver-can-claim scalar and the receiver might decide to free up inbound liquidity early by giving up after a short timeout, leading to total payment failure.\n\nThe LSPs are better positioned to have high connectivity and high uptime.  Let us delegate the payment re-attempt flow and the receiver-can-claim scalar sending to them, not on Ursula, who could be low-connectivity and low uptime.\n\n[quote=\"harding, post:2, topic:1983\"]\n[quote=\"ZmnSCPxj, post:1, topic:1983\"]\n\n[/quote]\n\n[quote=\"ZmnSCPxj, post:1, topic:1983\"]\nWe expect Ursula the end-user to not have a lot of liquidity on the MultiChannel.\n\n[/quote]\n\nWhat is the basis for that expectation?  Almost all of my payments with physical cash, LN sats, and bank credit are for less than half of my available liquidity (respectively: cash-in-wallet, sats-on-my-side-of-the-channel, and available credit); I would guess most of my payments are for less than 1/10th my liquidity.  User-initiated stuckless payments should be convenient under those conditions, with no need for additional third party liquidity.\n\nIn the rare cases where I make payments that approach the limit of my liquidity\u2014conditions where stuckless payments might not function well or at all\u2014I don\u2019t usually mind waiting longer.  For example, I don\u2019t want to wait more than a few seconds to complete a purchase of a $5 hot beverage but I don\u2019t mind much that it often takes over a minute to complete a $2,000 purchase of airplane tickets on my current credit card (the bank usually requiring me to verify the purchase via text message).\n\n[/quote]\n\nAs noted earlier, the problem is not just that Ursula might not have the liquidity, it is simply that it does not match the expectations of a naive human Ursula that multiple units of their payment amount get locked, and potentially can be locked for two weeks if bad things happen beyond the control of Ursula, the wallet developer, or the LSPs.  It is already bad enough that, with MultiPTLC, if ***all*** the parallel attempts by the quorum of LSPs fail but at least one of them gets stuck, the MultiPTLC is still stuck (the LSPs cannot safely revert it while at least one of their outgoing PTLCs are not reverted or commited, since Ursula might be a pseudonym of ZmnSCPxj the notorious hacker who can directly hand over the receiver-can-claim scalar to the receiver by sneakernet).",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 104,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "Would you be able to explain more about why you think that\u2019s an advantage worth the additional complexity? \n\n\nAs mentioned, my model is that Ursula has a small amount of funds. \nIn particular, as noted elsewhere, MultiPTLC really protects against global high-availability, i.e. when a remote routing&hellip;",
  "truncated": true,
  "post_url": "/t/multichannel-and-multiptlc-towards-a-global-high-availability-consistent-partition-tolerant-database-for-bitcoin-payments/1983/4",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}