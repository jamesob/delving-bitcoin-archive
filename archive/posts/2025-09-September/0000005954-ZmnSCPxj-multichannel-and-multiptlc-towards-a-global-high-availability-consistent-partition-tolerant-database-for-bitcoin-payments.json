{
  "id": 5954,
  "name": "ZmnSCPxj jxPCSnmZ",
  "username": "ZmnSCPxj",
  "avatar_template": "/letter_avatar_proxy/v4/letter/z/ee7513/{size}.png",
  "created_at": "2025-09-22T23:17:46.225Z",
  "cooked": "<p>I will sketch out here the RAFT-inspired MultiPTLC competition algorithm.  I think in practice, the idea of \u201cjust have the LSPs probe in parallel first\u201d will get us high-enough probability of success that MultiPTLC is unnecessary even in a future PTLC world (its \u201conly\u201d improvement is that, after the \u201cLSPs probe in parallel\u201d phase, Ursula can send out all successful probed paths instead of having to select one as with HTLC or PTLC; that is the point of MultiPTLC, that it can provide paths starting at <em><strong>multiple LSPs</strong></em>, not just one as would the \u201ctrampoline routing\u201d case), so I will not go into much detail. The assumptions I need are that (1) the sender has to give <em>some</em> nonce to the receiver in the onion and (2) the receiver also receives a blinded path to the \u201csender\u201d (in the case of MultiPTLC, the \u201csender\u201d that does the retrying in parallel is actually the LSP, not Ursula).  So in the MultiPTLC package that contains all the Ursula-side signatures and the onions, Ursula provides the HASHES of the receiver-side nonce (which the receiver has to present to the \u201csender\u201d when it requests for the receiver-can-claim scalar; LDK in particular can use it for a \u201cstateless\u201d design where the receiver-can-claim scalar is HMAC(node_secret, receiver_request_nonce)), and of course the outward onions encrypt the receiver-request nonce to the receiver.  Suppose the LSP quorum set is a 2-of-3 of Alice, Bob, and Charlie.  Alice and Bob receive the responses from the receiver close enough in time that relativistic time dilation due to network speed-of-light transmission speeds make \u201cwho came first?\u201d ambiguous.  Both of them validate that the receiver-request nonce matches the hash given in the MultiPTLC package. then send to each other as well as Charlie.  They then proceed to proof-of-work, creating a \u201cblock\u201d by appending a 64-bit counter to the receiver-request-nonce and its hash, and hashingg and incrementing the counter until it achieves some work target.  They then build additional blocks by hashing the previous hash appended with another 64-bit counter.  Alice,and Bob hen have the policy that \u201cif I see that my competitor has gotten a block before I do, I will concede, stop doing proof-of-work and become a follower\u201d and Charlie (who was not lucky enough to get any request from the receiver) will follow along as \u201cwhoever has the longest chain gets my vote\u201d (alternatively, it can treat itself as having a block height of 0 and a simple presentation of receiver-request-nonce plus its hash from the MultiPTLC package, without additional proof of work, as height 1, which would be equivalent).  Suppose Alice wins blocks faster than Bob, and Bob concedes.  Then Charlie, Bob, and Alice are in full agreement and any 2 of them can form the 2-of-3 required to instantiate the branch of the MultiPTLC that goes to Alice.  Even if Bob refuses to concede defeat, if Charlie sees Alice have a longer number of blocks, Charlie will follow Alice anyway (Charlie provides a signature signing against the longest chain it saw from Alice, and then Alice can present it to the other participants \u2014 this bit is important once we think of 3-of-5 or 4-of-7 cases, once Alice has gotten itself and 2 others in a 3-of-5 case, it can present the 2 signatures of its longest blockchain plus its own as a fiat accompli to the 2 followers it won so they can form a quorum that agrees Alice won) and signs the necessary k-of-n that enables the MultiPTLC branch that goes to Alice, so that Alice can now safely release the receiver-can-claim scalar to the receiver.  The proof-of-work is necessary to ensure that LSPs <em><strong>only</strong></em> degrade their security to k-of-n; the original RAFT algorithm requires <em><strong>only</strong></em> random timeouts, but a cheating LSP can set their timeout to 0 to get the leadership and win every time and thus every LSP has to trust <em><strong>every other LSP</strong></em> if we did not have proof-of-work-randomized-timeouts, whereas proof-of-work <em><strong>forces</strong></em> time to pass due to thermodynamics (produced proof-of-work is thermodynamically \u201ccolder\u201d than normal, implying there was an improbability pump / refrigeration process that had to have increased <em><strong>global</strong></em> entropy (and the arrow of time goes from globally low entropy to globally high entropy, thus proving time passed) to get <em><strong>local</strong></em> negentropy at the block hashes) and at least k-of-n is needed to agree on who won.</p>",
  "post_number": 11,
  "post_type": 1,
  "posts_count": 11,
  "updated_at": "2025-09-22T23:17:46.225Z",
  "reply_count": 0,
  "reply_to_post_number": 10,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 4,
  "readers_count": 3,
  "score": 0.8,
  "yours": false,
  "topic_id": 1983,
  "topic_slug": "multichannel-and-multiptlc-towards-a-global-high-availability-consistent-partition-tolerant-database-for-bitcoin-payments",
  "topic_title": "MultiChannel and MultiPTLC: Towards A Global High-Availability Consistent/Partition-Tolerant Database For Bitcoin Payments",
  "topic_html_title": "MultiChannel and MultiPTLC: Towards A Global High-Availability Consistent/Partition-Tolerant Database For Bitcoin Payments",
  "category_id": 7,
  "display_username": "ZmnSCPxj jxPCSnmZ",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "reply_to_user": {
    "id": 104,
    "username": "ZmnSCPxj",
    "name": "ZmnSCPxj jxPCSnmZ",
    "avatar_template": "/letter_avatar_proxy/v4/letter/z/ee7513/{size}.png"
  },
  "bookmarked": false,
  "raw": "I will sketch out here the RAFT-inspired MultiPTLC competition algorithm.  I think in practice, the idea of \u201cjust have the LSPs probe in parallel first\u201d will get us high-enough probability of success that MultiPTLC is unnecessary even in a future PTLC world (its \u201conly\u201d improvement is that, after the \u201cLSPs probe in parallel\u201d phase, Ursula can send out all successful probed paths instead of having to select one as with HTLC or PTLC; that is the point of MultiPTLC, that it can provide paths starting at ***multiple LSPs***, not just one as would the \u201ctrampoline routing\u201d case), so I will not go into much detail. The assumptions I need are that (1) the sender has to give *some* nonce to the receiver in the onion and (2) the receiver also receives a blinded path to the \u201csender\u201d (in the case of MultiPTLC, the \u201csender\u201d that does the retrying in parallel is actually the LSP, not Ursula).  So in the MultiPTLC package that contains all the Ursula-side signatures and the onions, Ursula provides the HASHES of the receiver-side nonce (which the receiver has to present to the \u201csender\u201d when it requests for the receiver-can-claim scalar; LDK in particular can use it for a \u201cstateless\u201d design where the receiver-can-claim scalar is HMAC(node_secret, receiver_request_nonce)), and of course the outward onions encrypt the receiver-request nonce to the receiver.  Suppose the LSP quorum set is a 2-of-3 of Alice, Bob, and Charlie.  Alice and Bob receive the responses from the receiver close enough in time that relativistic time dilation due to network speed-of-light transmission speeds make \u201cwho came first?\u201d ambiguous.  Both of them validate that the receiver-request nonce matches the hash given in the MultiPTLC package. then send to each other as well as Charlie.  They then proceed to proof-of-work, creating a \u201cblock\u201d by appending a 64-bit counter to the receiver-request-nonce and its hash, and hashingg and incrementing the counter until it achieves some work target.  They then build additional blocks by hashing the previous hash appended with another 64-bit counter.  Alice,and Bob hen have the policy that \u201cif I see that my competitor has gotten a block before I do, I will concede, stop doing proof-of-work and become a follower\u201d and Charlie (who was not lucky enough to get any request from the receiver) will follow along as \u201cwhoever has the longest chain gets my vote\u201d (alternatively, it can treat itself as having a block height of 0 and a simple presentation of receiver-request-nonce plus its hash from the MultiPTLC package, without additional proof of work, as height 1, which would be equivalent).  Suppose Alice wins blocks faster than Bob, and Bob concedes.  Then Charlie, Bob, and Alice are in full agreement and any 2 of them can form the 2-of-3 required to instantiate the branch of the MultiPTLC that goes to Alice.  Even if Bob refuses to concede defeat, if Charlie sees Alice have a longer number of blocks, Charlie will follow Alice anyway (Charlie provides a signature signing against the longest chain it saw from Alice, and then Alice can present it to the other participants \u2014 this bit is important once we think of 3-of-5 or 4-of-7 cases, once Alice has gotten itself and 2 others in a 3-of-5 case, it can present the 2 signatures of its longest blockchain plus its own as a fiat accompli to the 2 followers it won so they can form a quorum that agrees Alice won) and signs the necessary k-of-n that enables the MultiPTLC branch that goes to Alice, so that Alice can now safely release the receiver-can-claim scalar to the receiver.  The proof-of-work is necessary to ensure that LSPs ***only*** degrade their security to k-of-n; the original RAFT algorithm requires ***only*** random timeouts, but a cheating LSP can set their timeout to 0 to get the leadership and win every time and thus every LSP has to trust ***every other LSP*** if we did not have proof-of-work-randomized-timeouts, whereas proof-of-work ***forces*** time to pass due to thermodynamics (produced proof-of-work is thermodynamically \u201ccolder\u201d than normal, implying there was an improbability pump / refrigeration process that had to have increased ***global*** entropy (and the arrow of time goes from globally low entropy to globally high entropy, thus proving time passed) to get ***local*** negentropy at the block hashes) and at least k-of-n is needed to agree on who won.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 104,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "I will sketch out here the RAFT-inspired MultiPTLC competition algorithm.  I think in practice, the idea of \u201cjust have the LSPs probe in parallel first\u201d will get us high-enough probability of success that MultiPTLC is unnecessary even in a future PTLC world (its \u201conly\u201d improvement is that, after the&hellip;",
  "truncated": true,
  "post_url": "/t/multichannel-and-multiptlc-towards-a-global-high-availability-consistent-partition-tolerant-database-for-bitcoin-payments/1983/11",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}