{
  "id": 5985,
  "name": "",
  "username": "setavenger",
  "avatar_template": "/user_avatar/delvingbitcoin.org/setavenger/{size}/573_2.png",
  "created_at": "2025-09-29T19:49:26.538Z",
  "cooked": "<p>I tried to make a little write up to structure what was discussed above. It might help others to better understand the idea presented here. I took the liberty to make some small changes or annotations where I believe some improvements could be made. I marked those with <code>(*)</code>. Maybe some of the things were implied, marking them nonetheless.</p>\n<h3><a name=\"p-5985-definitions-1\" class=\"anchor\" href=\"#p-5985-definitions-1\"></a>Definitions</h3>\n<p>Sender: Alice (nsec: <code>a</code> npub: <code>A</code>)</p>\n<p>Receiver Bob (nsec: <code>b</code> npub: <code>B</code>)</p>\n<p>(*) Hash_tagged(x): <code>SHA256(SHA256(\"stealth\") || SHA256(\"stealth\") || x)</code> (Tagged hash like Bip340)</p>\n<p>Counter: <code>i</code>, counter starting from 0. +1 for every pubkey Alice generates when sending to Bob</p>\n<h3><a name=\"p-5985-crypto-2\" class=\"anchor\" href=\"#p-5985-crypto-2\"></a>Crypto</h3>\n<p>Shared Secret (<code>S</code>): <code>a * B</code> or <code>b * A</code> (remember that parity matters here and the nostr protocol implies even parity for it\u2019s keys)</p>\n<p>Stealth component (<code>c</code>): <code>Hash_tagged(S || i)</code></p>\n<p>Stealth Address Pubkey: <code>P = B + c * G</code></p>\n<p>Stealth Secret Seckey: <code>p = (b + c) mod n</code> (where n is the curve order)</p>\n<p>Alice encodes P to a taproot script and sends to it. <code>Address = \"5120 + P\"</code> where P is a 32 byte x-only pubkey.</p>\n<h3><a name=\"p-5985-communication-3\" class=\"anchor\" href=\"#p-5985-communication-3\"></a>Communication</h3>\n<p>Communication starts after Alice has already made the transaction</p>\n<ol>\n<li>\n<p>Alice: notifies Bob of the transaction. The message needs to at least include the counter. But more information can/should be given to make finding the actual outpoint easier</p>\n</li>\n<li>\n<p>(*) Bob: upon receiving the notification should validate the utxo and store the pubkey</p>\n</li>\n<li>\n<p>(*) Bob: if (2) was successful send a simple confirmation message - could include the counter to avoid confusion with potential other transactions which Alice made to Bob</p>\n</li>\n<li>\n<p>(*) Alice: until receiving the confirmation message with a counter <code>i</code> should periodically rebroadcast the notification message</p>\n</li>\n</ol>\n<h3><a name=\"p-5985-backup-4\" class=\"anchor\" href=\"#p-5985-backup-4\"></a>Backup (*)</h3>\n<p>Note: As a general statement: Bob has no option to find out whether all transactions made to him have been seen by him</p>\n<p>Recovering from scratch:</p>\n<ul>\n<li>\n<p><strong>nsec-only:</strong> Bob is dependant on relays still having all the relevant notification messages available to find his transactions</p>\n</li>\n<li>\n<p><strong>nsec + backup file:</strong> A simple list mapping sender npubs and the respective highest counters</p>\n</li>\n</ul>\n<h3><a name=\"p-5985-additional-notes-5\" class=\"anchor\" href=\"#p-5985-additional-notes-5\"></a>Additional Notes</h3>\n<p>General opinionated ideas for improving the Stealth Address protocol</p>\n<ul>\n<li>\n<p>Signaling of receive support:</p>\n<ul>\n<li>Alice must not send to Bob if Bob does not signal support for the protocol anywhere. Ignoring this will most definitely lead to lost funds some time or another unless combined with the below point of reclaiming utxos considered unredeemed</li>\n</ul>\n</li>\n<li>\n<p>Reclaim branch:</p>\n<ul>\n<li>\n<p>I\u2019m imagining a simple block delay after which Alice can reclaim coins she believes to be unredeemed. Something like 3 months would give Bob plenty of time to claim and move the coins. Alice could get back the coins if she thinks they were \u201clost\u201d. She can obviously always decide to not move the coins f she thinks Bob has heard of the coins and still has the ability to spend them</p>\n</li>\n<li>\n<p>e.g. Alice can use a script path spend to send the coins back to an address she controls if it should turn out that Bob does not support Stealth Addresses or never received the notification and Alice has no other way of notifying Bob</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Use Silent Payments logic instead of new stealth address specific logic</p>\n<ul>\n<li>\n<p>The above protocol can easily be redefined to using Silent Payments for the underlying crypto part</p>\n</li>\n<li>\n<p>The notification message could contain the tweak of the transaction made to Bob. So Alice would send a Txid and optionally the tweak (<code>input_hash * A</code>) and/or the computed pubkeys for the transaction she made. Bob\u2019s scanning effort would be minimal to zero (only validation of information Alice sent)</p>\n</li>\n<li>\n<p>Bob can always fallback to scanning the entire chain if he believes that a notification message was lost. Silent Payments only use on-chain available data to derive the pubkeys for Bob. As long as Bob somehow has access to blockchain he can find everything which was sent to him</p>\n</li>\n<li>\n<p>Added benefit: wallets would be more interoperable</p>\n</li>\n<li>\n<p>Swapping in the silent payment logic for pubkey derivation and combining it with nostr notifications would basically remove a lot of the potential footguns with Stealth Addresses as I currently see them. It would still achieve the goal of a reduced scanning effort and the added benefit of not yet another way for deriving keys</p>\n</li>\n<li>\n<p>One thing I almost forgot. Technically the spend and scan secret keys for Silent Payments don\u2019t have to be created using the key derivation paths. A nostr specific way could be thought of to make this also more compatible in a nostr case</p>\n</li>\n</ul>\n</li>\n</ul>",
  "post_number": 8,
  "post_type": 1,
  "posts_count": 10,
  "updated_at": "2025-09-29T19:49:26.538Z",
  "reply_count": 0,
  "reply_to_post_number": 7,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 20,
  "readers_count": 19,
  "score": 18.6,
  "yours": false,
  "topic_id": 1816,
  "topic_slug": "stealth-addresses-using-nostr",
  "topic_title": "Stealth addresses using nostr",
  "topic_html_title": "Stealth addresses using nostr",
  "category_id": 8,
  "display_username": "",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "reply_to_user": {
    "id": 247,
    "username": "1440000bytes",
    "name": "/dev/fd0",
    "avatar_template": "/user_avatar/delvingbitcoin.org/1440000bytes/{size}/301_2.png"
  },
  "bookmarked": false,
  "raw": "I tried to make a little write up to structure what was discussed above. It might help others to better understand the idea presented here. I took the liberty to make some small changes or annotations where I believe some improvements could be made. I marked those with `(*)`. Maybe some of the things were implied, marking them nonetheless.\n\n### Definitions\n\nSender: Alice (nsec: `a` npub: `A`)\n\nReceiver Bob (nsec: `b` npub: `B`)\n\n(\\*) Hash_tagged(x): `SHA256(SHA256(\"stealth\") || SHA256(\"stealth\") || x)` (Tagged hash like Bip340)\n\nCounter: `i`, counter starting from 0. +1 for every pubkey Alice generates when sending to Bob\n\n### Crypto\n\nShared Secret (`S`): `a * B` or `b * A` (remember that parity matters here and the nostr protocol implies even parity for it's keys)\n\nStealth component (`c`): `Hash_tagged(S || i)`\n\nStealth Address Pubkey: `P = B + c * G`\n\nStealth Secret Seckey: `p = (b + c) mod n` (where n is the curve order)\n\nAlice encodes P to a taproot script and sends to it. `Address = \"5120 + P\"` where P is a 32 byte x-only pubkey.\n\n### Communication\n\nCommunication starts after Alice has already made the transaction\n\n1. Alice: notifies Bob of the transaction. The message needs to at least include the counter. But more information can/should be given to make finding the actual outpoint easier\n\n2. (\\*) Bob: upon receiving the notification should validate the utxo and store the pubkey\n\n3. (\\*) Bob: if (2) was successful send a simple confirmation message - could include the counter to avoid confusion with potential other transactions which Alice made to Bob\n\n4. (\\*) Alice: until receiving the confirmation message with a counter `i` should periodically rebroadcast the notification message\n\n### Backup (\\*)\n\nNote: As a general statement: Bob has no option to find out whether all transactions made to him have been seen by him\n\nRecovering from scratch:\n\n* **nsec-only:** Bob is dependant on relays still having all the relevant notification messages available to find his transactions\n\n* **nsec + backup file:** A simple list mapping sender npubs and the respective highest counters\n\n### Additional Notes\n\nGeneral opinionated ideas for improving the Stealth Address protocol\n\n* Signaling of receive support:\n\n  * Alice must not send to Bob if Bob does not signal support for the protocol anywhere. Ignoring this will most definitely lead to lost funds some time or another unless combined with the below point of reclaiming utxos considered unredeemed\n\n* Reclaim branch:\n\n  * I'm imagining a simple block delay after which Alice can reclaim coins she believes to be unredeemed. Something like 3 months would give Bob plenty of time to claim and move the coins. Alice could get back the coins if she thinks they were \"lost\". She can obviously always decide to not move the coins f she thinks Bob has heard of the coins and still has the ability to spend them\n\n  * e.g. Alice can use a script path spend to send the coins back to an address she controls if it should turn out that Bob does not support Stealth Addresses or never received the notification and Alice has no other way of notifying Bob\n\n* Use Silent Payments logic instead of new stealth address specific logic\n\n  * The above protocol can easily be redefined to using Silent Payments for the underlying crypto part\n\n  * The notification message could contain the tweak of the transaction made to Bob. So Alice would send a Txid and optionally the tweak (`input_hash * A`) and/or the computed pubkeys for the transaction she made. Bob's scanning effort would be minimal to zero (only validation of information Alice sent)\n\n  * Bob can always fallback to scanning the entire chain if he believes that a notification message was lost. Silent Payments only use on-chain available data to derive the pubkeys for Bob. As long as Bob somehow has access to blockchain he can find everything which was sent to him\n\n  * Added benefit: wallets would be more interoperable\n\n  * Swapping in the silent payment logic for pubkey derivation and combining it with nostr notifications would basically remove a lot of the potential footguns with Stealth Addresses as I currently see them. It would still achieve the goal of a reduced scanning effort and the added benefit of not yet another way for deriving keys\n\n  * One thing I almost forgot. Technically the spend and scan secret keys for Silent Payments don't have to be created using the key derivation paths. A nostr specific way could be thought of to make this also more compatible in a nostr case",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 435,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "I tried to make a little write up to structure what was discussed above. It might help others to better understand the idea presented here. I took the liberty to make some small changes or annotations where I believe some improvements could be made. I marked those with (*). Maybe some of the things &hellip;",
  "truncated": true,
  "post_url": "/t/stealth-addresses-using-nostr/1816/8",
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}