{
  "id": 5886,
  "name": "ZmnSCPxj jxPCSnmZ",
  "username": "ZmnSCPxj",
  "avatar_template": "/letter_avatar_proxy/v4/letter/z/ee7513/{size}.png",
  "created_at": "2025-09-16T20:10:15.516Z",
  "cooked": "<p>Come to think of it, it is significantly better if it is only the LSPs know the receiver-can-claim scalar, as it protects against Ursula (who could be notorious hacker ZmnSCPxj in disguise) giving that receiver-can-claim scalar to the receiver.  Instead, the receiver-can-claim scalar is generated by the LSP for each attempt the Ursula wants to have in parallel (and during this stage, the LSP can indicate how many parallel attempts it allows Ursula to have at its node, by giving only a specific number of receiver-can-claim points when Ursula asks for it).</p>\n<p>This worsens the mobile case a little, as now Ursula has to query the LSPs for receiver-can-claim points <em><strong>before</strong></em> it can do the offline preparation of routes and signatures and revocation keys and etc etc.  But now the MultiPTLC is now a multi-headed PTLC where all the points are <code>(delta + proof-of-payment) </code> <em><code>*</code></em><code>G</code><em>,</em> and the point of the plain PTLC on the payment attempt on the LSP onwards is <code>(delta + proof-of-payment + receiver-can-claim) * G</code>.  At the receiver, the point has the <code>delta</code> (which is the sum of the hiding scalar at each hop) already cancelled out, and the point is now <code>(proof-of-payment + receiver-can-claim) * G</code>, and the LSP is the one who authorizes whether to give the receiver-can-claim scalar.</p>\n<p>This allows the LSPs to rollback the MultiPTLC <em><strong>even if it has a PTLC-chain out there that is locked due to global availability problems</strong></em>.  Once the LSPs rollback the MultiPTLC lock, they simply never reveal the receiver-can-claim scalars ever, and they can ensure this because they are the only ones that know the receiver-can-claim scalar (2-of-3 of the LSPs can secretly rollback the MultiPTLC lock to Ursula and never tell the third, but that is again covered by \u201cLSP trusts a quorum of other LSPs\u201d disclaimer).  With this scheme, <em><strong>global</strong></em> availability problems (i.e. remote nodes going offline while holding up a PTLC-chain involving you) <em><strong>do not affect Ursula at all</strong></em>.  Only the LSP is affected by <em><strong>global</strong></em> low-availability issues, and it can afford that more readily than Ursula (and pass on the amortized cost via routing fees) simply because it has more funds in public channels than Ursula has on their dinky little MultiChannel.</p>\n<p>The ability to rollback the MultiPTLC exists only if the LSPs are the ones with knowledge of the receiver-can-claim scalars, and Ursula can only delegate that <em><strong>if it is making a single unit MultiPTLC instead of multiple parallel PTLCs</strong></em>.</p>\n<p>The receiver-can-claim scalar can use the cryptographic trick that LDK uses for \u201cstateless\u201d invoices.  When Ursula asks for receiver-can-claim points, the LSP hands over a random 256-bit number and the receiver-can-claim point.  The LSP derives the receiver-can-claim scalar via <code>HMAC(lsp_secret, random-number-I-will-give-to-Ursula)</code>.  The <code>lsp_secret</code> here can be a separate key from the node key or onchain wallet key, because even if this key is lost, all it means is that the LSP cannot earn routing funds if it wins payment attempts, which is <em><strong>tiny</strong></em> compared to channel funds or onchain funds. That way, the LSP does not have to store this state until Ursula later gives it back in the MultiPTLC package together with the crypto stuff needed to lock the MultiPTLC on the MultiChannel, at which point Ursula has already staked an amount and the cost of storing the underlying receiver-can-claim scalar on the LSP can be justified (otherwise Ursula can DoS the LSP by asking for receiver-can-claim points and never using them, wasting storage at the LSP).</p>\n<hr>\n<p>I <em><strong>REALLY REALLY</strong></em> want to emphasize that <em><strong>Lightning is a global CP database</strong></em> simply because of <em><strong>two</strong></em> things:</p>\n<ul>\n<li>The 2-node Poon-Dryja consistency algorithm which gives CP <em><strong>locally</strong></em>.\n<ul>\n<li>Low availability because only 2 nodes and \u201cthree can do an update if one of them is dead\u201d.</li>\n</ul>\n</li>\n<li>The HTLC lock-chain which upgrades the local CP to <em><strong>globally</strong></em> CP.\n<ul>\n<li>Low availability due to serial locking where someone holding an HTLC lock on your lock-chain dies unexpectedly can lock your funds for two weeks.</li>\n</ul>\n</li>\n</ul>\n<p>In order to mitigate the existing low-availability issues of both the Channel and the HTLC, we need <em><strong>two</strong></em> novel constructions that provide high availability, the MultiChannel and the MultiPTLC.  The MultiPTLC is necessary.</p>",
  "post_number": 5,
  "post_type": 1,
  "posts_count": 12,
  "updated_at": "2025-09-16T20:14:26.169Z",
  "reply_count": 1,
  "reply_to_post_number": 4,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 40,
  "readers_count": 39,
  "score": 28.0,
  "yours": false,
  "topic_id": 1983,
  "topic_slug": "multichannel-and-multiptlc-towards-a-global-high-availability-consistent-partition-tolerant-database-for-bitcoin-payments",
  "topic_title": "MultiChannel and MultiPTLC: Towards A Global High-Availability Consistent/Partition-Tolerant Database For Bitcoin Payments",
  "topic_html_title": "MultiChannel and MultiPTLC: Towards A Global High-Availability Consistent/Partition-Tolerant Database For Bitcoin Payments",
  "category_id": 7,
  "display_username": "ZmnSCPxj jxPCSnmZ",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "reply_to_user": {
    "id": 104,
    "username": "ZmnSCPxj",
    "name": "ZmnSCPxj jxPCSnmZ",
    "avatar_template": "/letter_avatar_proxy/v4/letter/z/ee7513/{size}.png"
  },
  "bookmarked": false,
  "raw": "Come to think of it, it is significantly better if it is only the LSPs know the receiver-can-claim scalar, as it protects against Ursula (who could be notorious hacker ZmnSCPxj in disguise) giving that receiver-can-claim scalar to the receiver.  Instead, the receiver-can-claim scalar is generated by the LSP for each attempt the Ursula wants to have in parallel (and during this stage, the LSP can indicate how many parallel attempts it allows Ursula to have at its node, by giving only a specific number of receiver-can-claim points when Ursula asks for it).\n\nThis worsens the mobile case a little, as now Ursula has to query the LSPs for receiver-can-claim points ***before*** it can do the offline preparation of routes and signatures and revocation keys and etc etc.  But now the MultiPTLC is now a multi-headed PTLC where all the points are `(delta + proof-of-payment) ` *`*`*`G`*,* and the point of the plain PTLC on the payment attempt on the LSP onwards is `(delta + proof-of-payment + receiver-can-claim) * G`.  At the receiver, the point has the `delta` (which is the sum of the hiding scalar at each hop) already cancelled out, and the point is now `(proof-of-payment + receiver-can-claim) * G`, and the LSP is the one who authorizes whether to give the receiver-can-claim scalar.\n\nThis allows the LSPs to rollback the MultiPTLC ***even if it has a PTLC-chain out there that is locked due to global availability problems***.  Once the LSPs rollback the MultiPTLC lock, they simply never reveal the receiver-can-claim scalars ever, and they can ensure this because they are the only ones that know the receiver-can-claim scalar (2-of-3 of the LSPs can secretly rollback the MultiPTLC lock to Ursula and never tell the third, but that is again covered by \u201cLSP trusts a quorum of other LSPs\u201d disclaimer).  With this scheme, ***global*** availability problems (i.e. remote nodes going offline while holding up a PTLC-chain involving you) ***do not affect Ursula at all***.  Only the LSP is affected by ***global*** low-availability issues, and it can afford that more readily than Ursula (and pass on the amortized cost via routing fees) simply because it has more funds in public channels than Ursula has on their dinky little MultiChannel.\n\nThe ability to rollback the MultiPTLC exists only if the LSPs are the ones with knowledge of the receiver-can-claim scalars, and Ursula can only delegate that ***if it is making a single unit MultiPTLC instead of multiple parallel PTLCs***.\n\nThe receiver-can-claim scalar can use the cryptographic trick that LDK uses for \u201cstateless\u201d invoices.  When Ursula asks for receiver-can-claim points, the LSP hands over a random 256-bit number and the receiver-can-claim point.  The LSP derives the receiver-can-claim scalar via `HMAC(lsp_secret, random-number-I-will-give-to-Ursula)`.  The `lsp_secret` here can be a separate key from the node key or onchain wallet key, because even if this key is lost, all it means is that the LSP cannot earn routing funds if it wins payment attempts, which is ***tiny*** compared to channel funds or onchain funds. That way, the LSP does not have to store this state until Ursula later gives it back in the MultiPTLC package together with the crypto stuff needed to lock the MultiPTLC on the MultiChannel, at which point Ursula has already staked an amount and the cost of storing the underlying receiver-can-claim scalar on the LSP can be justified (otherwise Ursula can DoS the LSP by asking for receiver-can-claim points and never using them, wasting storage at the LSP).\n\n---\n\nI ***REALLY REALLY*** want to emphasize that ***Lightning is a global CP database*** simply because of ***two*** things:\n\n* The 2-node Poon-Dryja consistency algorithm which gives CP ***locally***.\n  * Low availability because only 2 nodes and \u201cthree can do an update if one of them is dead\u201d.\n* The HTLC lock-chain which upgrades the local CP to ***globally*** CP.\n  * Low availability due to serial locking where someone holding an HTLC lock on your lock-chain dies unexpectedly can lock your funds for two weeks.\n\nIn order to mitigate the existing low-availability issues of both the Channel and the HTLC, we need ***two*** novel constructions that provide high availability, the MultiChannel and the MultiPTLC.  The MultiPTLC is necessary.",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 104,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "Come to think of it, it is significantly better if it is only the LSPs know the receiver-can-claim scalar, as it protects against Ursula (who could be notorious hacker ZmnSCPxj in disguise) giving that receiver-can-claim scalar to the receiver.  Instead, the receiver-can-claim scalar is generated by&hellip;",
  "truncated": true,
  "post_url": "/t/multichannel-and-multiptlc-towards-a-global-high-availability-consistent-partition-tolerant-database-for-bitcoin-payments/1983/5",
  "reactions": [
    {
      "id": "eyes",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}