{
  "id": 5956,
  "name": "Matt Morehouse",
  "username": "morehouse",
  "avatar_template": "/letter_avatar_proxy/v4/letter/m/df705f/{size}.png",
  "created_at": "2025-09-23T14:22:09.386Z",
  "cooked": "<p><em>The following disclosure is copied verbatim from a <a href=\"https://morehouse.github.io/lightning/eclair-preimage-extraction-exploit/\" rel=\"noopener nofollow ugc\">blog post</a> on <a href=\"http://morehouse.github.io\" rel=\"noopener nofollow ugc\">morehouse.github.io</a>, reproduced here to facilitate discussion.</em></p>\n<p>A critical vulnerability in Eclair versions 0.11.0 and below allows attackers to steal node funds.\nUsers should immediately upgrade to <a href=\"https://github.com/ACINQ/eclair/releases/tag/v0.12.0\" rel=\"noopener nofollow ugc\">Eclair 0.12.0</a> or later to protect their funds.</p>\n<h1><a name=\"p-5956-background-1\" class=\"anchor\" href=\"#p-5956-background-1\"></a>Background</h1>\n<p>In the Lightning Network, nodes forward payments using contracts called HTLCs (Hash Time-Locked Contracts).\nTo settle a payment, the final recipient reveals a secret piece of data called a preimage.\nThis preimage is passed backward along the payment route, allowing each node to claim their funds from the previous node.</p>\n<p>If a channel is forced to close, these settlements can happen on the Bitcoin blockchain.\nNodes must watch the blockchain to spot these preimages so they can claim their own funds.</p>\n<h1><a name=\"p-5956-the-preimage-extraction-vulnerability-2\" class=\"anchor\" href=\"#p-5956-the-preimage-extraction-vulnerability-2\"></a>The Preimage Extraction Vulnerability</h1>\n<p>The vulnerability in Eclair existed in how it monitored the blockchain for preimages during a force close.\nEclair would only check for HTLCs that existed in its <strong>local commitment transaction</strong> \u2014 its own current version of the channel\u2019s state.\nThe code incorrectly assumed this local state would always contain a complete list of all possible HTLCs.</p>\n<p>However, a malicious channel partner could broadcast an older, but still valid, commitment transaction.\nThis older state could contain an HTLC that the victim\u2019s node had already removed from its own local state.\nWhen the attacker claimed this HTLC on-chain with a preimage, the victim\u2019s Eclair node would ignore it because the HTLC wasn\u2019t in its local records, causing the victim to lose the funds.</p>\n<p>The original <a href=\"https://github.com/ACINQ/eclair/blob/c7a288b91fc19e89683c531cb3e9f61e59deace9/eclair-core/src/main/scala/fr/acinq/eclair/channel/Helpers.scala#L1299-L1314\" rel=\"noopener nofollow ugc\">code snippet</a> illustrates the issue:</p>\n<pre data-code-wrap=\"scala\"><code class=\"lang-scala\">def extractPreimages(localCommit: LocalCommit, tx: Transaction)(implicit log: LoggingAdapter): Set[(UpdateAddHtlc, ByteVector32)] = {\n  // ... (code omitted that extracts htlcSuccess and claimHtlcSuccess preimages from tx)\n  val paymentPreimages = (htlcSuccess ++ claimHtlcSuccess).toSet\n  paymentPreimages.flatMap { paymentPreimage =&gt;\n    // we only consider htlcs in our local commitment, because we only care about outgoing htlcs, which disappear first in the remote commitment\n    // if an outgoing htlc is in the remote commitment, then:\n    // - either it is in the local commitment (it was never fulfilled)\n    // - or we have already received the fulfill and forwarded it upstream\n    localCommit.spec.htlcs.collect {\n      case OutgoingHtlc(add) if add.paymentHash == sha256(paymentPreimage) =&gt; (add, paymentPreimage)\n    }\n  }\n}\n</code></pre>\n<p>The misleading comment in the code suggests this approach is safe, hiding the bug from a casual review.</p>\n<h1><a name=\"p-5956-stealing-htlcs-3\" class=\"anchor\" href=\"#p-5956-stealing-htlcs-3\"></a>Stealing HTLCs</h1>\n<p>An attacker could exploit this bug to steal funds as follows:</p>\n<ol>\n<li>The attacker <code>M</code> opens a channel with the victim <code>B</code>, creating the following topology: <code>A -- B -- M</code>.</li>\n<li>The attacker routes a payment to themselves along the path <code>A-&gt;B-&gt;M</code>.</li>\n<li><code>M</code> fails the payment by sending <code>update_fail_htlc</code> followed by <code>commitment_signed</code>.  <code>B</code> updates their local commitment and revokes their previous one by sending <code>revoke_and_ack</code> followed by <code>commitment_signed</code>.</li>\n</ol>\n<ul>\n<li>At this point, <code>M</code> has two valid commitments: one with the HTLC present and one with it removed.</li>\n<li>Also at this point, <code>B</code> only has one valid commitment with the HTLC already removed.</li>\n</ul>\n<ol start=\"4\">\n<li><code>M</code> force-closes the channel by broadcasting their <em>older</em> commitment transaction where the HTLC still exists.</li>\n<li><code>M</code> claims the HTLC on the blockchain using the payment preimage.</li>\n<li><code>B</code> sees the on-chain transaction but fails to extract the preimage because the corresponding HTLC is missing from its <em>local</em> commitment.</li>\n<li>Because <code>B</code> never learned the preimage, it cannot claim the payment from <code>A</code>.</li>\n</ol>\n<p>When the time limit expires, <code>A</code> gets a refund, and the victim is left with the loss.\nThe attacker keeps both the original funds and the payment they claimed on-chain.</p>\n<h1><a name=\"p-5956-the-fix-4\" class=\"anchor\" href=\"#p-5956-the-fix-4\"></a>The Fix</h1>\n<p>The solution was to update <code>extractPreimages</code> to check for HTLCs across <strong>all relevant commitment transactions</strong>, including the remote and next-remote commitments, not just the local one.</p>\n<pre data-code-wrap=\"scala\"><code class=\"lang-scala\">def extractPreimages(commitment: FullCommitment, tx: Transaction)(implicit log: LoggingAdapter): Set[(UpdateAddHtlc, ByteVector32)] = {\n  // ... (code omitted that extracts htlcSuccess and claimHtlcSuccess preimages from tx)\n  val paymentPreimages = (htlcSuccess ++ claimHtlcSuccess).toSet\n  paymentPreimages.flatMap { paymentPreimage =&gt;\n    val paymentHash = sha256(paymentPreimage)\n    // We only care about outgoing HTLCs when we're trying to learn a preimage to relay upstream.\n    // Note that we may have already relayed the fulfill upstream if we already saw the preimage.\n    val fromLocal = commitment.localCommit.spec.htlcs.collect {\n      case OutgoingHtlc(add) if add.paymentHash == paymentHash =&gt; (add, paymentPreimage)\n    }\n    // From the remote point of view, those are incoming HTLCs.\n    val fromRemote = commitment.remoteCommit.spec.htlcs.collect {\n      case IncomingHtlc(add) if add.paymentHash == paymentHash =&gt; (add, paymentPreimage)\n    }\n    val fromNextRemote = commitment.nextRemoteCommit_opt.map(_.commit.spec.htlcs).getOrElse(Set.empty).collect {\n      case IncomingHtlc(add) if add.paymentHash == paymentHash =&gt; (add, paymentPreimage)\n    }\n    fromLocal ++ fromRemote ++ fromNextRemote\n  }\n}\n</code></pre>\n<p>This change ensures that Eclair will correctly identify the HTLC and extract the necessary preimage, even if a malicious partner broadcasts an old channel state.\nThe <a href=\"https://github.com/ACINQ/eclair/commit/6a8df49a9bf006a0826b828020f551ecb6c7a33e#diff-97779917bce211cd035ebf8f9f265a7ecece4efcd1861c7bab05e0113dd86b06R1306-R1319\" rel=\"noopener nofollow ugc\">fix</a> was discreetly included in a <a href=\"https://github.com/ACINQ/eclair/pull/2966\" rel=\"noopener nofollow ugc\">larger pull request</a> for splicing and released in <a href=\"https://github.com/ACINQ/eclair/releases/tag/v0.12.0\" rel=\"noopener nofollow ugc\">Eclair 0.12.0</a>.</p>\n<h1><a name=\"p-5956-discovery-5\" class=\"anchor\" href=\"#p-5956-discovery-5\"></a>Discovery</h1>\n<p>The vulnerability was discovered accidentally during a discussion with Bastien Teinturier, who asked for a second look at the logic in the <code>extractPreimage</code> function.\nUpon review, the attack scenario was identified and reported.</p>\n<h2><a name=\"p-5956-timeline-6\" class=\"anchor\" href=\"#p-5956-timeline-6\"></a>Timeline</h2>\n<ul>\n<li><strong>2025-03-05:</strong> Vulnerability reported to Bastien.</li>\n<li><strong>2025-03-11:</strong> Fix <a href=\"https://github.com/ACINQ/eclair/commit/6a8df49a9bf006a0826b828020f551ecb6c7a33e#diff-97779917bce211cd035ebf8f9f265a7ecece4efcd1861c7bab05e0113dd86b06R1306-R1319\" rel=\"noopener nofollow ugc\">merged</a> and Eclair 0.12.0 released.</li>\n<li><strong>2025-03-21:</strong> Agreement on public disclosure in six months.</li>\n<li><strong>2025-09-23:</strong> Public disclosure.</li>\n</ul>\n<h1><a name=\"p-5956-prevention-7\" class=\"anchor\" href=\"#p-5956-prevention-7\"></a>Prevention</h1>\n<p>In response to the vulnerability report, Bastien sent the following:</p>\n<blockquote>\n<p>This code seems to have been there from the very beginning of eclair, and has not been updated or challenged since then.\nThis is bad, I\u2019m noticing that we lack a lot of unit tests for this kind of scenario, this should have been audited\u2026\nI\u2019ll spend time next week to check that we have tests for every known type of malicious force-close\u2026\nThanks for reporting this, it\u2019s high time we audited that.</p>\n</blockquote>\n<p>As promised, Bastien added a force-close <a href=\"https://github.com/ACINQ/eclair/pull/3040\" rel=\"noopener nofollow ugc\">test suite</a> a couple weeks later.\nHad these tests existed from the start, this vulnerability would have been prevented.</p>\n<h1><a name=\"p-5956-takeaways-8\" class=\"anchor\" href=\"#p-5956-takeaways-8\"></a>Takeaways</h1>\n<ul>\n<li>More robust testing and auditing of Lightning implementations is badly needed.</li>\n<li>Users should keep their node software updated.</li>\n</ul>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 2,
  "updated_at": "2025-09-23T14:22:09.386Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 292,
  "reads": 68,
  "readers_count": 67,
  "score": 1628.6,
  "yours": false,
  "topic_id": 2010,
  "topic_slug": "disclosure-eclair-preimage-extraction-exploit",
  "topic_title": "Disclosure: Eclair Preimage Extraction Exploit",
  "topic_html_title": "Disclosure: Eclair Preimage Extraction Exploit",
  "category_id": 8,
  "display_username": "Matt Morehouse",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "*The following disclosure is copied verbatim from a [blog post](https://morehouse.github.io/lightning/eclair-preimage-extraction-exploit/) on [morehouse.github.io](http://morehouse.github.io), reproduced here to facilitate discussion.*\n\nA critical vulnerability in Eclair versions 0.11.0 and below allows attackers to steal node funds.\nUsers should immediately upgrade to [Eclair 0.12.0](https://github.com/ACINQ/eclair/releases/tag/v0.12.0) or later to protect their funds.\n\n# Background\n\nIn the Lightning Network, nodes forward payments using contracts called HTLCs (Hash Time-Locked Contracts).\nTo settle a payment, the final recipient reveals a secret piece of data called a preimage.\nThis preimage is passed backward along the payment route, allowing each node to claim their funds from the previous node.\n\nIf a channel is forced to close, these settlements can happen on the Bitcoin blockchain.\nNodes must watch the blockchain to spot these preimages so they can claim their own funds.\n\n# The Preimage Extraction Vulnerability\n\nThe vulnerability in Eclair existed in how it monitored the blockchain for preimages during a force close.\nEclair would only check for HTLCs that existed in its **local commitment transaction** --- its own current version of the channel's state.\nThe code incorrectly assumed this local state would always contain a complete list of all possible HTLCs.\n\nHowever, a malicious channel partner could broadcast an older, but still valid, commitment transaction.\nThis older state could contain an HTLC that the victim's node had already removed from its own local state.\nWhen the attacker claimed this HTLC on-chain with a preimage, the victim's Eclair node would ignore it because the HTLC wasn't in its local records, causing the victim to lose the funds.\n\nThe original [code snippet](https://github.com/ACINQ/eclair/blob/c7a288b91fc19e89683c531cb3e9f61e59deace9/eclair-core/src/main/scala/fr/acinq/eclair/channel/Helpers.scala#L1299-L1314) illustrates the issue:\n\n```scala\ndef extractPreimages(localCommit: LocalCommit, tx: Transaction)(implicit log: LoggingAdapter): Set[(UpdateAddHtlc, ByteVector32)] = {\n  // ... (code omitted that extracts htlcSuccess and claimHtlcSuccess preimages from tx)\n  val paymentPreimages = (htlcSuccess ++ claimHtlcSuccess).toSet\n  paymentPreimages.flatMap { paymentPreimage =>\n    // we only consider htlcs in our local commitment, because we only care about outgoing htlcs, which disappear first in the remote commitment\n    // if an outgoing htlc is in the remote commitment, then:\n    // - either it is in the local commitment (it was never fulfilled)\n    // - or we have already received the fulfill and forwarded it upstream\n    localCommit.spec.htlcs.collect {\n      case OutgoingHtlc(add) if add.paymentHash == sha256(paymentPreimage) => (add, paymentPreimage)\n    }\n  }\n}\n```\n\nThe misleading comment in the code suggests this approach is safe, hiding the bug from a casual review.\n\n# Stealing HTLCs\n\nAn attacker could exploit this bug to steal funds as follows:\n\n1. The attacker `M` opens a channel with the victim `B`, creating the following topology: `A -- B -- M`.\n2. The attacker routes a payment to themselves along the path `A->B->M`.\n3. `M` fails the payment by sending `update_fail_htlc` followed by `commitment_signed`.  `B` updates their local commitment and revokes their previous one by sending `revoke_and_ack` followed by `commitment_signed`.\n  - At this point, `M` has two valid commitments: one with the HTLC present and one with it removed.\n  - Also at this point, `B` only has one valid commitment with the HTLC already removed.\n4. `M` force-closes the channel by broadcasting their *older* commitment transaction where the HTLC still exists.\n5. `M` claims the HTLC on the blockchain using the payment preimage.\n6. `B` sees the on-chain transaction but fails to extract the preimage because the corresponding HTLC is missing from its *local* commitment.\n7. Because `B` never learned the preimage, it cannot claim the payment from `A`.\n\nWhen the time limit expires, `A` gets a refund, and the victim is left with the loss.\nThe attacker keeps both the original funds and the payment they claimed on-chain.\n\n# The Fix\n\nThe solution was to update `extractPreimages` to check for HTLCs across **all relevant commitment transactions**, including the remote and next-remote commitments, not just the local one.\n\n```scala\ndef extractPreimages(commitment: FullCommitment, tx: Transaction)(implicit log: LoggingAdapter): Set[(UpdateAddHtlc, ByteVector32)] = {\n  // ... (code omitted that extracts htlcSuccess and claimHtlcSuccess preimages from tx)\n  val paymentPreimages = (htlcSuccess ++ claimHtlcSuccess).toSet\n  paymentPreimages.flatMap { paymentPreimage =>\n    val paymentHash = sha256(paymentPreimage)\n    // We only care about outgoing HTLCs when we're trying to learn a preimage to relay upstream.\n    // Note that we may have already relayed the fulfill upstream if we already saw the preimage.\n    val fromLocal = commitment.localCommit.spec.htlcs.collect {\n      case OutgoingHtlc(add) if add.paymentHash == paymentHash => (add, paymentPreimage)\n    }\n    // From the remote point of view, those are incoming HTLCs.\n    val fromRemote = commitment.remoteCommit.spec.htlcs.collect {\n      case IncomingHtlc(add) if add.paymentHash == paymentHash => (add, paymentPreimage)\n    }\n    val fromNextRemote = commitment.nextRemoteCommit_opt.map(_.commit.spec.htlcs).getOrElse(Set.empty).collect {\n      case IncomingHtlc(add) if add.paymentHash == paymentHash => (add, paymentPreimage)\n    }\n    fromLocal ++ fromRemote ++ fromNextRemote\n  }\n}\n```\n\nThis change ensures that Eclair will correctly identify the HTLC and extract the necessary preimage, even if a malicious partner broadcasts an old channel state.\nThe [fix](https://github.com/ACINQ/eclair/commit/6a8df49a9bf006a0826b828020f551ecb6c7a33e#diff-97779917bce211cd035ebf8f9f265a7ecece4efcd1861c7bab05e0113dd86b06R1306-R1319) was discreetly included in a [larger pull request](https://github.com/ACINQ/eclair/pull/2966) for splicing and released in [Eclair 0.12.0](https://github.com/ACINQ/eclair/releases/tag/v0.12.0).\n\n# Discovery\n\nThe vulnerability was discovered accidentally during a discussion with Bastien Teinturier, who asked for a second look at the logic in the `extractPreimage` function.\nUpon review, the attack scenario was identified and reported.\n\n## Timeline\n\n- **2025-03-05:** Vulnerability reported to Bastien.\n- **2025-03-11:** Fix [merged](https://github.com/ACINQ/eclair/commit/6a8df49a9bf006a0826b828020f551ecb6c7a33e#diff-97779917bce211cd035ebf8f9f265a7ecece4efcd1861c7bab05e0113dd86b06R1306-R1319) and Eclair 0.12.0 released.\n- **2025-03-21:** Agreement on public disclosure in six months.\n- **2025-09-23:** Public disclosure.\n\n# Prevention\n\nIn response to the vulnerability report, Bastien sent the following:\n\n> This code seems to have been there from the very beginning of eclair, and has not been updated or challenged since then.\n> This is bad, I'm noticing that we lack a lot of unit tests for this kind of scenario, this should have been audited...\n> I'll spend time next week to check that we have tests for every known type of malicious force-close...\n> Thanks for reporting this, it's high time we audited that.\n\nAs promised, Bastien added a force-close [test suite](https://github.com/ACINQ/eclair/pull/3040) a couple weeks later.\nHad these tests existed from the start, this vulnerability would have been prevented.\n\n# Takeaways\n\n- More robust testing and auditing of Lightning implementations is badly needed.\n- Users should keep their node software updated.",
  "actions_summary": [
    {
      "id": 2,
      "count": 10
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 47,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "The following disclosure is copied verbatim from a <a href=\"https://morehouse.github.io/lightning/eclair-preimage-extraction-exploit/\" rel=\"noopener nofollow ugc\">blog post</a> on <a href=\"http://morehouse.github.io\" rel=\"noopener nofollow ugc\">morehouse.github.io</a>, reproduced here to facilitate discussion. \nA critical vulnerability in Eclair versions 0.11.0 and below allows attackers to steal node funds.\nUsers should immediately upgrade to <a href=\"https://github.com/ACINQ/eclair/releases/tag/v0.12.0\" rel=\"noopener nofollow ugc\">Eclair 0.12.0</a> or later to protect the&hellip;",
  "truncated": true,
  "post_url": "/t/disclosure-eclair-preimage-extraction-exploit/2010/1",
  "reactions": [
    {
      "id": "heart",
      "type": "emoji",
      "count": 5
    },
    {
      "id": "clap",
      "type": "emoji",
      "count": 4
    },
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 10,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}