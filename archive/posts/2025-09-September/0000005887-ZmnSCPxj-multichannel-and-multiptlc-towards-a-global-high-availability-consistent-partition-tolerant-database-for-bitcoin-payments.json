{
  "id": 5887,
  "name": "ZmnSCPxj jxPCSnmZ",
  "username": "ZmnSCPxj",
  "avatar_template": "/letter_avatar_proxy/v4/letter/z/ee7513/{size}.png",
  "created_at": "2025-09-17T00:26:38.646Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"ZmnSCPxj\" data-post=\"5\" data-topic=\"1983\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/letter_avatar_proxy/v4/letter/z/ee7513/48.png\" class=\"avatar\"> ZmnSCPxj:</div>\n<blockquote>\n<p>The ability to rollback the MultiPTLC exists only if the LSPs are the ones with knowledge of the receiver-can-claim scalars, and Ursula can only delegate that <em><strong>if it is making a single unit MultiPTLC instead of multiple parallel PTLCs</strong></em>.</p>\n</blockquote>\n</aside>\n<p>Again, let me emphasize this, that MultiPTLC holding only one unit of the payment is core to allowing the LSPs to be the only ones with knowledge of the receiver-can-claim scalars.</p>\n<p>If Ursula locks multiple units of the payment, as in the \u201cnormal\u201d source-level stuckless payments, then Ursula also needs to know some scalar that is part of the receiver-can-claim scalar.  This can be done with Magic Math, but now Ursula is required to be online to issue the receiver-can-claim scalar for exactly <em><strong>one</strong></em> of the outgoing payments.  This is unlike the MultiPTLC case where, after Ursula has gotten the MultiPTLC into the irrevocably committed state in the consistency protocol, Ursula can go offline and only the online LSPs need to keep being online and operating the \u201cstuckless but only because it was the original name\u201d payment protocol.</p>\n<p>We can do various magic math techniques to \u201callow\u201d Ursula to sod off and go offline, such as having different <code>deltaA</code> <code>deltaB</code> <code>deltaC</code> for each of Alice, Bob, and Carol.  But I should remind you that parts of the <code>delta</code> are outright revealed to remote forwarding nodes.  If a global surveillor exists, relying on <code>delta</code> to be secret to the LSPs means Ursula can end up paying more than just one unit of the payment it wanted to pay, because it is now possible for A B C to be part of the global surveillor and learning all of <code>deltaA</code> <code>deltaB</code> <code>deltaC</code> (if all the forwarding nodes that Ursula were unlucky enough to select are part of the global surveillor).  Thus, relying on separate <code>delta</code>s per LSP risks monetary loss if there is a global surveillor.  With a MultiPTLC instead, even if a global surveillor exists, all it learns is the proof-of-payment secret (and in the current HTLC world, every forwarding node learns the proof-of-payment anyway, so this is still an improvement) and Ursula has no risk of <em><strong>monetary loss</strong></em>, only risk of privacy loss, <em><strong>precisely because Ursula only locks one unit of payment before going offline, unlike with any other scheme where Ursula locks multiple units of the payment</strong></em>, where for full security Ursula needs to remain online to provide the receiver with a shard of the receiver-can-claim secret.</p>\n<p>There are a bunch of other magic stuff I also thought about, and then shot down, because it is simply much better for Ursula to ever only lock one unit of payment in a single MultiPTLC than for Ursula to have multiple plain PTLCs of which only exactly one is acceptable to be claimed.  I mean, a MultiPTLC is literally just a PTLC with multiple P branches and one TL branch, it is <em><strong>not</strong></em> that complicated.  I just do not know enough about the math involved if you can do something like just have multiple Taproot branches (which is why I proposed multiple alternate transactions that terminate at a plain PTLC, because that is what I am sure will work) but if that is possible than that simplifies things (I am <em><strong>not a mathist</strong></em>, I only portray one on the interwebz).  It lets Ursula delegate retries to the LSPs completely without requiring further interactions with Ursula, and Ursula can simply go online whenever she wants later.</p>\n<p>So my current proposed MultiPTLC scheme requires just 1.5 roundtrips:</p>\n<ul>\n<li>Ursula requests to one of the LSPs for a set of receiver-can-claim points plus tweaks.\n<ul>\n<li>Alice, Bob, and Carol can share some receiver-can-claim points and their tweaks to each other as they have high connectivity anyway, so whenever any random Ursula (or Ursula2 or Ursula3) asks for some points, they can easily replenish from their fellow LSPs.  The LSPs can sign the points and tweaks they issue so that random Ursulae can trust that the direct LSP they are talking to is not lying and that those points really are issued by the respective LSPs.</li>\n</ul>\n</li>\n<li>LSP responds with some number of receiver-can-claim points from itself and its fellow LSPs.</li>\n<li>After computing stuff and finding payment paths etc. etc. Ursula can then use the old \u201cfast forwarding\u201d scheme to make a single large message in a few dozen IP packets to provide enough information to let the MultiPTLC be irrevocably committed.</li>\n</ul>\n<p>After that, Ursula can go offline (in practice it should probably wait for a TCP <code>ACK</code> before disconnecting; it can just send a <code>FIN</code> (via <code>shutdown(fd, SHUT_WR)</code>) and then try to drain their end of the channel so that the TCP driver will eventually find some <code>ACK</code> embedded in the incoming TCP segments to ensure the last message got through in full).  Then, their wallet shows \u201c-1000 sats\u201d.  When Ursula comes back later, it just asks any of the LSPs for how the payment went.  If the LSPs decided to time out and stop retrying, the wallet can now show \u201c+1000 sats, refund from payment failure\u201d.  Otherwise if the payment succeeded on at least one path, the wallet replaces the last \u201c-1000 sats; confirmed\u201d.  If there are any stuck attempts in the \u201cstuckless in name only haha\u201d payment protocol, none of them affect the hop at Ursula, they only lock funds on the LSPs.</p>\n<p>And that is the important bit, the big difference between what Ursula holds in the wallet versus what the LSP holds in the routing node:</p>\n<ul>\n<li><em><strong>Without</strong></em> MultiPTLCs, there is the very real risk that the wallet says \u201cOkay the 5 USD went through, but sorry I have to hold another 5 USD for up to two weeks because the Lightning Network broke down\u201d on a 50 USD wallet, do you think Ursula will be happy?</li>\n<li><em><strong>With</strong></em> MultiPTLCs, the LSP has a very real risk that of its 200,000 USD investment in Lightning liquidity, maybe about 500 USD or so of it is always locked for several days in various PTLC-lock-chains due to remote nodes being down, this is just a cost of doing business on an unreliable network, which we are all already aware is true.</li>\n</ul>\n<p>MultiPTLCs are simpler and gives better UX <em><strong>and</strong></em> end-user security.  It is very rare to have something that has improved UX <em><strong>and</strong></em> end-user security, it is usually one or the other (what is sacrificed is the security of the LSPs who have to trust a quorum of their fellow LSPs, not the end-user).</p>\n<p>Gentle reminder that our current Lightning Network BOLT protocol requires 1.5 roundtrips <em><strong>per payment attempt</strong></em> and if there are payment failures, that\u2019s 1.5 roundtrips to cancel this attempt at the source and another 1.5 roundtrips for the next attempt etc. etc.  With this, it is 1.5 roundtrips per <em><strong>payment plan</strong></em> where a payment plan is a fixed set of multiple payment attempts.</p>\n<p>The nice thing is that there is nothing that requires the LSPs to know anything in the onion other than their layer, further layers can be kept hidden from the LSPs.  <em><strong>The LSPs can now make multiple attempts on behalf of Ursula without knowing the recipient, even without blinded routes</strong></em>.  Even if a payment attempt fails and falls back to the LSP, the LSP can assume it is simply a temporary failure and retry it a small amount of time later, in the hope that whatever prevented it from succeeding in the first place was just a temporary issue.</p>",
  "post_number": 6,
  "post_type": 1,
  "posts_count": 7,
  "updated_at": "2025-09-17T01:07:41.269Z",
  "reply_count": 1,
  "reply_to_post_number": 5,
  "quote_count": 1,
  "incoming_link_count": 0,
  "reads": 8,
  "readers_count": 7,
  "score": 6.6,
  "yours": false,
  "topic_id": 1983,
  "topic_slug": "multichannel-and-multiptlc-towards-a-global-high-availability-consistent-partition-tolerant-database-for-bitcoin-payments",
  "topic_title": "MultiChannel and MultiPTLC: Towards A Global High-Availability Consistent/Partition-Tolerant Database For Bitcoin Payments",
  "topic_html_title": "MultiChannel and MultiPTLC: Towards A Global High-Availability Consistent/Partition-Tolerant Database For Bitcoin Payments",
  "category_id": 7,
  "display_username": "ZmnSCPxj jxPCSnmZ",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"ZmnSCPxj, post:5, topic:1983\"]\nThe ability to rollback the MultiPTLC exists only if the LSPs are the ones with knowledge of the receiver-can-claim scalars, and Ursula can only delegate that ***if it is making a single unit MultiPTLC instead of multiple parallel PTLCs***.\n\n[/quote]\n\nAgain, let me emphasize this, that MultiPTLC holding only one unit of the payment is core to allowing the LSPs to be the only ones with knowledge of the receiver-can-claim scalars.\n\nIf Ursula locks multiple units of the payment, as in the \u201cnormal\u201d source-level stuckless payments, then Ursula also needs to know some scalar that is part of the receiver-can-claim scalar.  This can be done with Magic Math, but now Ursula is required to be online to issue the receiver-can-claim scalar for exactly ***one*** of the outgoing payments.  This is unlike the MultiPTLC case where, after Ursula has gotten the MultiPTLC into the irrevocably committed state in the consistency protocol, Ursula can go offline and only the online LSPs need to keep being online and operating the \u201cstuckless but only because it was the original name\u201d payment protocol.\n\nWe can do various magic math techniques to \u201callow\u201d Ursula to sod off and go offline, such as having different `deltaA` `deltaB` `deltaC` for each of Alice, Bob, and Carol.  But I should remind you that parts of the `delta` are outright revealed to remote forwarding nodes.  If a global surveillor exists, relying on `delta` to be secret to the LSPs means Ursula can end up paying more than just one unit of the payment it wanted to pay, because it is now possible for A B C to be part of the global surveillor and learning all of `deltaA` `deltaB` `deltaC` (if all the forwarding nodes that Ursula were unlucky enough to select are part of the global surveillor).  Thus, relying on separate `delta`s per LSP risks monetary loss if there is a global surveillor.  With a MultiPTLC instead, even if a global surveillor exists, all it learns is the proof-of-payment secret (and in the current HTLC world, every forwarding node learns the proof-of-payment anyway, so this is still an improvement) and Ursula has no risk of ***monetary loss***, only risk of privacy loss, ***precisely because Ursula only locks one unit of payment before going offline, unlike with any other scheme where Ursula locks multiple units of the payment***, where for full security Ursula needs to remain online to provide the receiver with a shard of the receiver-can-claim secret.\n\nThere are a bunch of other magic stuff I also thought about, and then shot down, because it is simply much better for Ursula to ever only lock one unit of payment in a single MultiPTLC than for Ursula to have multiple plain PTLCs of which only exactly one is acceptable to be claimed.  I mean, a MultiPTLC is literally just a PTLC with multiple P branches and one TL branch, it is ***not*** that complicated.  I just do not know enough about the math involved if you can do something like just have multiple Taproot branches (which is why I proposed multiple alternate transactions that terminate at a plain PTLC, because that is what I am sure will work) but if that is possible than that simplifies things (I am ***not a mathist***, I only portray one on the interwebz).  It lets Ursula delegate retries to the LSPs completely without requiring further interactions with Ursula, and Ursula can simply go online whenever she wants later.\n\nSo my current proposed MultiPTLC scheme requires just 1.5 roundtrips:\n\n* Ursula requests to one of the LSPs for a set of receiver-can-claim points plus tweaks.\n  * Alice, Bob, and Carol can share some receiver-can-claim points and their tweaks to each other as they have high connectivity anyway, so whenever any random Ursula (or Ursula2 or Ursula3) asks for some points, they can easily replenish from their fellow LSPs.  The LSPs can sign the points and tweaks they issue so that random Ursulae can trust that the direct LSP they are talking to is not lying and that those points really are issued by the respective LSPs.\n* LSP responds with some number of receiver-can-claim points from itself and its fellow LSPs.\n* After computing stuff and finding payment paths etc. etc. Ursula can then use the old \u201cfast forwarding\u201d scheme to make a single large message in a few dozen IP packets to provide enough information to let the MultiPTLC be irrevocably committed.\n\nAfter that, Ursula can go offline (in practice it should probably wait for a TCP `ACK` before disconnecting; it can just send a `FIN` (via `shutdown(fd, SHUT_WR)`) and then try to drain their end of the channel so that the TCP driver will eventually find some `ACK` embedded in the incoming TCP segments to ensure the last message got through in full).  Then, their wallet shows \u201c-1000 sats\u201d.  When Ursula comes back later, it just asks any of the LSPs for how the payment went.  If the LSPs decided to time out and stop retrying, the wallet can now show \u201c+1000 sats, refund from payment failure\u201d.  Otherwise if the payment succeeded on at least one path, the wallet replaces the last \u201c-1000 sats; confirmed\u201d.  If there are any stuck attempts in the \u201cstuckless in name only haha\u201d payment protocol, none of them affect the hop at Ursula, they only lock funds on the LSPs.\n\nAnd that is the important bit, the big difference between what Ursula holds in the wallet versus what the LSP holds in the routing node:\n\n* ***Without*** MultiPTLCs, there is the very real risk that the wallet says \u201cOkay the 5 USD went through, but sorry I have to hold another 5 USD for up to two weeks because the Lightning Network broke down\u201d on a 50 USD wallet, do you think Ursula will be happy?\n* ***With*** MultiPTLCs, the LSP has a very real risk that of its 200,000 USD investment in Lightning liquidity, maybe about 500 USD or so of it is always locked for several days in various PTLC-lock-chains due to remote nodes being down, this is just a cost of doing business on an unreliable network, which we are all already aware is true.\n\nMultiPTLCs are simpler and gives better UX ***and*** end-user security.  It is very rare to have something that has improved UX ***and*** end-user security, it is usually one or the other (what is sacrificed is the security of the LSPs who have to trust a quorum of their fellow LSPs, not the end-user).\n\nGentle reminder that our current Lightning Network BOLT protocol requires 1.5 roundtrips ***per payment attempt*** and if there are payment failures, that\u2019s 1.5 roundtrips to cancel this attempt at the source and another 1.5 roundtrips for the next attempt etc. etc.  With this, it is 1.5 roundtrips per ***payment plan*** where a payment plan is a fixed set of multiple payment attempts.\n\nThe nice thing is that there is nothing that requires the LSPs to know anything in the onion other than their layer, further layers can be kept hidden from the LSPs.  ***The LSPs can now make multiple attempts on behalf of Ursula without knowing the recipient, even without blinded routes***.  Even if a payment attempt fails and falls back to the LSP, the LSP can assume it is simply a temporary failure and retry it a small amount of time later, in the hope that whatever prevented it from succeeding in the first place was just a temporary issue.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 104,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "Again, let me emphasize this, that MultiPTLC holding only one unit of the payment is core to allowing the LSPs to be the only ones with knowledge of the receiver-can-claim scalars. \nIf Ursula locks multiple units of the payment, as in the \u201cnormal\u201d source-level stuckless payments, then Ursula also n&hellip;",
  "truncated": true,
  "post_url": "/t/multichannel-and-multiptlc-towards-a-global-high-availability-consistent-partition-tolerant-database-for-bitcoin-payments/1983/6",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}