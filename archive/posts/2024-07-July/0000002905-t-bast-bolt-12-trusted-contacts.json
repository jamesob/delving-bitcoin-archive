{
  "id": 2905,
  "name": "Bastien Teinturier",
  "username": "t-bast",
  "avatar_template": "/user_avatar/delvingbitcoin.org/t-bast/{size}/98_2.png",
  "created_at": "2024-07-30T15:12:09.428Z",
  "cooked": "<p>Bolt 12 makes it possible for lightning wallets to provide a UX that is very close to traditional payment applications. By attaching offers to metadata describing who those offers belong to, users can manage their \u201ccontacts list\u201d and easily pay them without any interaction (no need to manually share a Bolt 11 invoice for every payment). This is the kind of payment experience non-technical users expect.</p>\n<p>However, when sending money to their friends and family, users expect some form of mutual authentication: when Alice sends money to Bob, she wants Bob to know it came from her.</p>\n<p>This may seem at odds with the privacy benefits of Bolt 12, which explicitly hides the identity of both the payer and the recipient. The goal of this post is to create a standard way for payers to selectively reveal their identity when paying Bolt 12 offers.</p>\n<p>Such a feature makes a lot more sense if it works seamlessly across different wallets, so it should become a standard.</p>\n<p>There are two parts to this feature, which are somewhat orthogonal:</p>\n<ul>\n<li>contact key distribution</li>\n<li>contact mutual authentication</li>\n</ul>\n<h2><a name=\"contact-key-distribution-1\" class=\"anchor\" href=\"#contact-key-distribution-1\"></a>Contact Key Distribution</h2>\n<p>Every node that wants to support this feature must generate a <code>contact_key</code> that they will use to identify themselves to their trusted contacts. This key can for example be derived from the node\u2019s seed using a dedicated BIP32 derivation path.</p>\n<p>In order to advertise this key to trusted contacts, I see two options:</p>\n<ul>\n<li>(optionally) include it in offers</li>\n<li>(optionally) include it in BIP21 URIs</li>\n</ul>\n<p>Note that users may want to only reveal this key to their trusted contacts over a secure communication channel. Wallets should thus keep creating offers and BIP21 URIs that do NOT include this <code>contact_key</code> whenever users want to be paid privately (e.g. for offers posted on social media).</p>\n<h3><a name=\"option-1-tlv-field-in-offers-2\" class=\"anchor\" href=\"#option-1-tlv-field-in-offers-2\"></a>Option 1: TLV field in offers</h3>\n<p>We define a new odd TLV field that can be included in Bolt 12 offers:</p>\n<ul>\n<li>type: 23 (<code>offer_contact_key</code>)</li>\n<li>data:\n<ul>\n<li>[<code>point</code>:<code>contact_key</code>]</li>\n</ul>\n</li>\n</ul>\n<p>I like this option because it is very simple to integrate to existing lightning implementations. It also allows directly adding someone to our contacts list when paying one of their offers (if it contains this field).</p>\n<p>One tiny drawback is that users who want to create multiple offers with the same <code>contact_key</code> end up duplicating this field in every offer.</p>\n<p><a class=\"mention\" href=\"/u/rustyrussell\">@rustyrussell</a> mentioned using the existing <code>issuer</code> field, but I think that a dedicated field makes more sense here?</p>\n<h3><a name=\"option-2-bip21-query-parameter-3\" class=\"anchor\" href=\"#option-2-bip21-query-parameter-3\"></a>Option 2: BIP21 query parameter</h3>\n<p>We define a new optional query parameter that can be included in BIP21 URIs (or rather <a href=\"https://github.com/bitcoin/bips/pull/1555\">Matt\u2019s proposed replacement for BIP21</a>):</p>\n<pre data-code-wrap=\"txt\"><code class=\"lang-txt\">bitcoin:?lno=lno...&amp;lnck=lnck...\n</code></pre>\n<p>The key is encoded using bech32m with the <code>lnck</code> prefix, for example <code>lnck1qfuvmn3va9l0c54jtjs4q494n6nqjw3s7jn09gwh6j42v6q3tqtngkrs462</code>.</p>\n<p>This removes the potential duplication across multiple offers from the previous option, but forces wallets to use BIP21 URIs everywhere instead of plain offers.</p>\n<p>One drawback of this option is that it creates bigger QR codes.</p>\n<h3><a name=\"questions-4\" class=\"anchor\" href=\"#questions-4\"></a>Questions</h3>\n<p>Should we allow this <code>contact_key</code> to be rotated, or is it a static identity like your <code>node_id</code>? If we rotate it, our contacts won\u2019t be able to identify our payments until they\u2019ve received the new key, which is quite an annoying drawback.</p>\n<h2><a name=\"contact-mutual-authentication-5\" class=\"anchor\" href=\"#contact-mutual-authentication-5\"></a>Contact Mutual Authentication</h2>\n<p>We now assume that key distribution is solved: users have a list of their trusted contacts. Each trusted contact contains the <code>contact_key</code> and a list of Bolt 12 offers that can be used to pay this contact.</p>\n<p>When Alice wants to pay Bob (who is one of her trusted contacts), Alice can optionally decide to use her own <code>contact_key</code> to reveal her identity to Bob. Bob should only learn that the payment comes from Alice if Alice is also in Bob\u2019s contacts list.</p>\n<p>There are many ways we can achieve that. I\u2019m going to list three options below, starting from the simplest one.</p>\n<h3><a name=\"option-1-directly-use-invreq_payer_id-6\" class=\"anchor\" href=\"#option-1-directly-use-invreq_payer_id-6\"></a>Option 1: directly use <code>invreq_payer_id</code></h3>\n<p>Bolt 12 provides an <code>invreq_payer_id</code> field that is used to sign <code>invoice_request</code>s.\nWhen paying a trusted contact, we could directly set this to our <code>contact_key</code>.\nThe receiver can then match the <code>invreq_payer_id</code> with their own contacts list to identify the payment.</p>\n<p>While this is a very simple option, it has a few drawbacks:</p>\n<ul>\n<li>senders will sign <code>invoice_request</code>s to unrelated contacts with the same key</li>\n<li>senders will reveal their <code>contact_key</code> to recipients who may not have them in their contacts list</li>\n</ul>\n<p>The second point may not be an issue though: the sender wanted to identify themselves anyway.</p>\n<p>Using the <code>invreq_payer_id</code> to match contacts has an interesting benefit: the <code>invreq_payer_note</code> can be safely displayed. This field is provided by payers in their <code>invoice_request</code>, but they may contain spam or phishing. Once we know a payment comes from one of our contacts, it shouldn\u2019t be spam or phishing and can thus be displayed alongside the payment, which provides a nice UX.</p>\n<h3><a name=\"option-2-derive-per-contact-invreq_payer_id-7\" class=\"anchor\" href=\"#option-2-derive-per-contact-invreq_payer_id-7\"></a>Option 2: derive per-contact <code>invreq_payer_id</code></h3>\n<p>This option is similar to the previous one, but we derive a different <code>invreq_payer_id</code> for each contact:</p>\n<ul>\n<li>Let <span class=\"math\">`contact\\_key = contact\\_privkey * G`</span></li>\n<li><span class=\"math\">`ss = SHA256(contact\\_privkey_{payer} * contact\\_key_{recipient}) = SHA256(contact\\_key_{recipient} * contact\\_key_{payer})`</span> (ECDH between the two <code>contact_key</code>s)</li>\n<li><span class=\"math\">`b = SHA256(\"bolt12\\_contact\" || ss)`</span></li>\n<li><span class=\"math\">`invreq\\_payer\\_id = b * contact\\_key`</span></li>\n</ul>\n<p>This solves the drawbacks from the previous option without adding too much complexity. The <code>invreq_payer_id</code> can be derived once and stored when adding the contact to our contacts list. Similarly, we can derive and store the <code>invreq_payer_id</code> each contact will use when paying us, to efficiently match incoming payments.</p>\n<p>A potentially useful side-effect of this scheme is that if we throw away our <code>contact_privkey</code>, past payments we received will appear to be from random nodes. It becomes impossible to match them to the contact that sent us that payment. This can be used as a \u201cpanic button\u201d when we don\u2019t want our payment history to be revealed.</p>\n<h3><a name=\"option-3-use-blip-31-8\" class=\"anchor\" href=\"#option-3-use-blip-31-8\"></a>Option 3: use bLIP-31</h3>\n<p><a class=\"mention\" href=\"/u/mattcorallo\">@MattCorallo</a> defined a protocol for mutual message authentication in <a href=\"https://github.com/lightning/blips/pull/31\">bLIP 31</a>. He proposed using this protocol for the mutual authentication part of this feature. The protocol would then become:</p>\n<ul>\n<li>the \u201cinitiator\u201d is the payment recipient receiving an <code>invoice_request</code></li>\n<li>in the onion message they send back with their <code>invoice</code>, they would include the <code>init bytes</code></li>\n<li>the \u201cmessage-sender\u201d is the payer receiving an <code>invoice</code> containing some <code>init bytes</code></li>\n<li>in the payment onion they create, they would include the <code>encrypted_nonce</code></li>\n</ul>\n<p>I\u2019m not convinced this is the right approach for this feature, because:</p>\n<ul>\n<li>it\u2019s more complex and it doesn\u2019t seem to add anything useful compared to the previous options</li>\n<li>the main goal of this protocol is to send an encrypted message, which isn\u2019t what we\u2019re trying to do here</li>\n</ul>\n<p>I also see two drawbacks when using this for a contacts list feature:</p>\n<ul>\n<li>since onion messages are limited to 65kB, the \u201cinitiator\u201d cannot include more than ~1350 keys in their init bytes\n<ul>\n<li>this means that we cannot have more than 1350 contacts</li>\n<li>while this seems ok for \u201cnormal\u201d people, it is unnecessarily limits what people can build on top of bolt 12</li>\n<li>if for example twitter included a feature where you could be tipped by your followers, limiting this to 1350 people wouldn\u2019t work</li>\n</ul>\n</li>\n<li>since the payer needs to include a payload for the recipient, it won\u2019t work when the sender uses trampoline but the recipient doesn\u2019t</li>\n</ul>\n<p>Overall, while I think bLIP 31 is a useful protocol, I don\u2019t think it\u2019s the right one for this specific feature.</p>\n<h2><a name=\"conclusion-9\" class=\"anchor\" href=\"#conclusion-9\"></a>Conclusion</h2>\n<p>I\u2019d like to get feedback from other implementations and developers who work on wallet software.\nCan you comment on your preferred option for this feature, and anything you\u2019d like to change?\nOnce we have rough consensus, I\u2019ll update <a href=\"https://github.com/lightning/blips/pull/42\">bLIP 42</a> accordingly.</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2024-07-30T15:12:09.428Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 138,
  "reads": 22,
  "readers_count": 21,
  "score": 739.4,
  "yours": false,
  "topic_id": 1046,
  "topic_slug": "bolt-12-trusted-contacts",
  "topic_title": "Bolt 12 Trusted Contacts",
  "topic_html_title": "Bolt 12 Trusted Contacts",
  "category_id": 7,
  "display_username": "Bastien Teinturier",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Bolt 12 makes it possible for lightning wallets to provide a UX that is very close to traditional payment applications. By attaching offers to metadata describing who those offers belong to, users can manage their \"contacts list\" and easily pay them without any interaction (no need to manually share a Bolt 11 invoice for every payment). This is the kind of payment experience non-technical users expect.\n\nHowever, when sending money to their friends and family, users expect some form of mutual authentication: when Alice sends money to Bob, she wants Bob to know it came from her.\n\nThis may seem at odds with the privacy benefits of Bolt 12, which explicitly hides the identity of both the payer and the recipient. The goal of this post is to create a standard way for payers to selectively reveal their identity when paying Bolt 12 offers.\n\nSuch a feature makes a lot more sense if it works seamlessly across different wallets, so it should become a standard.\n\nThere are two parts to this feature, which are somewhat orthogonal:\n\n- contact key distribution\n- contact mutual authentication\n\n## Contact Key Distribution\n\nEvery node that wants to support this feature must generate a `contact_key` that they will use to identify themselves to their trusted contacts. This key can for example be derived from the node's seed using a dedicated BIP32 derivation path.\n\nIn order to advertise this key to trusted contacts, I see two options:\n\n- (optionally) include it in offers\n- (optionally) include it in BIP21 URIs\n\nNote that users may want to only reveal this key to their trusted contacts over a secure communication channel. Wallets should thus keep creating offers and BIP21 URIs that do NOT include this `contact_key` whenever users want to be paid privately (e.g. for offers posted on social media).\n\n### Option 1: TLV field in offers\n\nWe define a new odd TLV field that can be included in Bolt 12 offers:\n\n- type: 23 (`offer_contact_key`)\n- data:\n  - [`point`:`contact_key`]\n\nI like this option because it is very simple to integrate to existing lightning implementations. It also allows directly adding someone to our contacts list when paying one of their offers (if it contains this field).\n\nOne tiny drawback is that users who want to create multiple offers with the same `contact_key` end up duplicating this field in every offer.\n\n@rustyrussell mentioned using the existing `issuer` field, but I think that a dedicated field makes more sense here?\n\n### Option 2: BIP21 query parameter\n\nWe define a new optional query parameter that can be included in BIP21 URIs (or rather [Matt's proposed replacement for BIP21](https://github.com/bitcoin/bips/pull/1555)):\n\n```txt\nbitcoin:?lno=lno...&lnck=lnck...\n```\n\nThe key is encoded using bech32m with the `lnck` prefix, for example `lnck1qfuvmn3va9l0c54jtjs4q494n6nqjw3s7jn09gwh6j42v6q3tqtngkrs462`.\n\nThis removes the potential duplication across multiple offers from the previous option, but forces wallets to use BIP21 URIs everywhere instead of plain offers.\n\nOne drawback of this option is that it creates bigger QR codes.\n\n### Questions\n\nShould we allow this `contact_key` to be rotated, or is it a static identity like your `node_id`? If we rotate it, our contacts won't be able to identify our payments until they've received the new key, which is quite an annoying drawback.\n\n## Contact Mutual Authentication\n\nWe now assume that key distribution is solved: users have a list of their trusted contacts. Each trusted contact contains the `contact_key` and a list of Bolt 12 offers that can be used to pay this contact.\n\nWhen Alice wants to pay Bob (who is one of her trusted contacts), Alice can optionally decide to use her own `contact_key` to reveal her identity to Bob. Bob should only learn that the payment comes from Alice if Alice is also in Bob's contacts list.\n\nThere are many ways we can achieve that. I'm going to list three options below, starting from the simplest one.\n\n### Option 1: directly use `invreq_payer_id`\n\nBolt 12 provides an `invreq_payer_id` field that is used to sign `invoice_request`s.\nWhen paying a trusted contact, we could directly set this to our `contact_key`.\nThe receiver can then match the `invreq_payer_id` with their own contacts list to identify the payment.\n\nWhile this is a very simple option, it has a few drawbacks:\n\n- senders will sign `invoice_request`s to unrelated contacts with the same key\n- senders will reveal their `contact_key` to recipients who may not have them in their contacts list\n\nThe second point may not be an issue though: the sender wanted to identify themselves anyway.\n\nUsing the `invreq_payer_id` to match contacts has an interesting benefit: the `invreq_payer_note` can be safely displayed. This field is provided by payers in their `invoice_request`, but they may contain spam or phishing. Once we know a payment comes from one of our contacts, it shouldn't be spam or phishing and can thus be displayed alongside the payment, which provides a nice UX.\n\n### Option 2: derive per-contact `invreq_payer_id`\n\nThis option is similar to the previous one, but we derive a different `invreq_payer_id` for each contact:\n\n- Let $`contact\\_key = contact\\_privkey * G`$\n- $`ss = SHA256(contact\\_privkey_{payer} * contact\\_key_{recipient}) = SHA256(contact\\_key_{recipient} * contact\\_key_{payer})`$ (ECDH between the two `contact_key`s)\n- $`b = SHA256(\"bolt12\\_contact\" || ss)`$\n- $`invreq\\_payer\\_id = b * contact\\_key`$\n\nThis solves the drawbacks from the previous option without adding too much complexity. The `invreq_payer_id` can be derived once and stored when adding the contact to our contacts list. Similarly, we can derive and store the `invreq_payer_id` each contact will use when paying us, to efficiently match incoming payments.\n\nA potentially useful side-effect of this scheme is that if we throw away our `contact_privkey`, past payments we received will appear to be from random nodes. It becomes impossible to match them to the contact that sent us that payment. This can be used as a \"panic button\" when we don't want our payment history to be revealed.\n\n### Option 3: use bLIP-31\n\n@MattCorallo defined a protocol for mutual message authentication in [bLIP 31](https://github.com/lightning/blips/pull/31). He proposed using this protocol for the mutual authentication part of this feature. The protocol would then become:\n\n- the \"initiator\" is the payment recipient receiving an `invoice_request`\n- in the onion message they send back with their `invoice`, they would include the `init bytes`\n- the \"message-sender\" is the payer receiving an `invoice` containing some `init bytes`\n- in the payment onion they create, they would include the `encrypted_nonce`\n\nI'm not convinced this is the right approach for this feature, because:\n\n- it's more complex and it doesn't seem to add anything useful compared to the previous options\n- the main goal of this protocol is to send an encrypted message, which isn't what we're trying to do here\n\nI also see two drawbacks when using this for a contacts list feature:\n\n- since onion messages are limited to 65kB, the \"initiator\" cannot include more than ~1350 keys in their init bytes\n  - this means that we cannot have more than 1350 contacts\n  - while this seems ok for \"normal\" people, it is unnecessarily limits what people can build on top of bolt 12\n  - if for example twitter included a feature where you could be tipped by your followers, limiting this to 1350 people wouldn't work\n- since the payer needs to include a payload for the recipient, it won't work when the sender uses trampoline but the recipient doesn't\n\nOverall, while I think bLIP 31 is a useful protocol, I don't think it's the right one for this specific feature.\n\n## Conclusion\n\nI'd like to get feedback from other implementations and developers who work on wallet software.\nCan you comment on your preferred option for this feature, and anything you'd like to change?\nOnce we have rough consensus, I'll update [bLIP 42](https://github.com/lightning/blips/pull/42) accordingly.",
  "actions_summary": [
    {
      "id": 2,
      "count": 3
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 101,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 3
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 3,
  "current_user_used_main_reaction": false
}