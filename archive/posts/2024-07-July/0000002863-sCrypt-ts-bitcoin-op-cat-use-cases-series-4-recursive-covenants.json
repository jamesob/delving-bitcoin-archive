{
  "id": 2863,
  "name": "sCrypt",
  "username": "sCrypt-ts",
  "avatar_template": "/letter_avatar_proxy/v4/letter/s/94ad74/{size}.png",
  "created_at": "2024-07-05T11:07:31.253Z",
  "cooked": "<h1><a name=\"bitcoin-op_cat-use-cases-series-4-recursive-covenants-1\" class=\"anchor\" href=\"#bitcoin-op_cat-use-cases-series-4-recursive-covenants-1\"></a>Bitcoin OP_CAT Use Cases Series <span class=\"hashtag-raw\">#4:</span> Recursive Covenants</h1>\n<h2><a name=\"stateful-bitcoin-smart-contracts-2\" class=\"anchor\" href=\"#stateful-bitcoin-smart-contracts-2\"></a>Stateful Bitcoin Smart Contracts</h2>\n<h1><a name=\"recursive-covenants-3\" class=\"anchor\" href=\"#recursive-covenants-3\"></a>Recursive Covenants</h1>\n<p>As we explained in <a href=\"https://scryptplatform.medium.com/trustless-ordinal-sales-using-op-cat-enabled-covenants-on-bitcoin-0318052f02b2\" rel=\"noopener nofollow ugc\">series #1</a>, a Bitcoin covenant is a mechanism that allows the sender of a Bitcoin transaction to impose certain conditions on how the receiver can spend the coins.</p>\n<p>A recursive covenant is a type of covenant that applies not only to the immediate transaction but also to any subsequent transactions that spend the bitcoins. This means that the conditions imposed by the covenant could be enforced recursively in perpetuity.</p>\n<p>The main difference between a regular non-recursive covenant and a recursive covenant is the scope of the conditions. A regular covenant only applies to the immediate next transaction, while a recursive one extends to all future transactions that spend the bitcoins.</p>\n<p>Here\u2019s a simple example to illustrate the difference:</p>\n<ul>\n<li>Regular covenant: Alice sends Bob 1 BTC with the condition that Bob can only spend the BTC if he provides a valid signature from a specific public key. This condition only applies to the immediate transaction.</li>\n<li>Recursive covenant: Alice sends Bob 1 BTC with the condition that Bob can only spend the BTC if he provides a valid signature from a specific public key, and that any future transactions spending the BTC must also provide a valid signature from the same public key. This condition applies to all future transactions that spend the BTC.</li>\n</ul>\n<p>Recursive covenants can be more powerful and flexible than regular covenants. They represent a significant step forward in the programmability and flexibility of Bitcoin transactions, potentially opening up a wide array of new applications and use cases. For instance, they allow implementing more complex transaction logic required for interoperability with sidechains or other Layer 2 solutions.</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/1X/b3c2b59b0c3985ad4b4193296a60592c88310c2e.jpeg\" data-download-href=\"https://delvingbitcoin.org/uploads/default/b3c2b59b0c3985ad4b4193296a60592c88310c2e\" title=\"\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/1X/b3c2b59b0c3985ad4b4193296a60592c88310c2e_2_500x500.jpeg\" alt=\"\" data-base62-sha1=\"pEeD4n5pJ5LPLiz9jtgIqvHO0H4\" width=\"500\" height=\"500\" role=\"presentation\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/1X/b3c2b59b0c3985ad4b4193296a60592c88310c2e_2_500x500.jpeg, https://delvingbitcoin.org/uploads/default/original/1X/b3c2b59b0c3985ad4b4193296a60592c88310c2e.jpeg 1.5x, https://delvingbitcoin.org/uploads/default/original/1X/b3c2b59b0c3985ad4b4193296a60592c88310c2e.jpeg 2x\" data-dominant-color=\"8A8361\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\"></span><span class=\"informations\">700\u00d7700 174 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<h1><a name=\"bitcoin-smart-contracts-with-state-4\" class=\"anchor\" href=\"#bitcoin-smart-contracts-with-state-4\"></a>Bitcoin Smart Contracts with State</h1>\n<p>In Bitcoin\u2019s UTXO model, smart contracts are inherently one-off and stateless, as the UTXO containing the contract is consumed and destroyed when spent. Recursive covenants introduce a form of state that can be maintained and updated across multiple transactions. When a transaction spends a UTXO (Unspent Transaction Output) containing a stateful contract, the state of the contract is updated, and the new state is stored in the output of the spending transaction, all enforced by recursive covenants. Unlike traditional Bitcoin transactions, which are stateless and immutable once confirmed, stateful smart contracts enable the tracking and modification of state over time, akin to smart contracts on other blockchain platforms like Ethereum.</p>\n<p>Let us illustrate how it works with a simple counter contract. This basic contract maintains a single state: how many times it has been called since deployment.</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/1X/dc07cbb9bea37a59b53f92d81b4b2c064a317729.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/dc07cbb9bea37a59b53f92d81b4b2c064a317729\" title=\"\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/1X/dc07cbb9bea37a59b53f92d81b4b2c064a317729_2_690x173.png\" alt=\"\" data-base62-sha1=\"votKflVm6UMEwUk0Fzww4DNjJEJ\" width=\"690\" height=\"173\" role=\"presentation\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/1X/dc07cbb9bea37a59b53f92d81b4b2c064a317729_2_690x173.png, https://delvingbitcoin.org/uploads/default/original/1X/dc07cbb9bea37a59b53f92d81b4b2c064a317729.png 1.5x, https://delvingbitcoin.org/uploads/default/original/1X/dc07cbb9bea37a59b53f92d81b4b2c064a317729.png 2x\" data-dominant-color=\"B8C9B7\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\"></span><span class=\"informations\">700\u00d7175 29.1 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>Counter in a chain of transactions with state 0, 1, and 2</p>\n<p>The state is stored in an adjacent output next to the output containing the contract itself. More specifically, it is in an OP_RETURN output.</p>\n<pre><code class=\"lang-auto\">OP_RETURN OP_PUSHBYTES [counter value]\n</code></pre>\n<p>The Counter contract below resides in a Taproot output. There are two tricks worth highlighting:</p>\n<ol>\n<li>We choose to store state in a separate output, instead of the same taproot output. This allows us to avoid tweaking the taproot address in the contract, since the address remains unchanged. Tweaking involves heavy elliptic curve arithmetic, which necessitates either excessively long script or new opcode like <a href=\"https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html\" rel=\"noopener nofollow ugc\">OP_TAPLEAF_UPDATE_VERIFY</a>/OP_TLUV.</li>\n<li>We use covenant to get the txid of the previous transaction, which in turns allows us to parse the raw transaction and access its outputs.</li>\n</ol>\n<pre><code class=\"lang-auto\">export class Counter extends SmartContract {\n\n    @prop()\n    static readonly ZEROSAT: ByteString = toByteString('0000000000000000')\n\n    constructor() {\n        super(...arguments)\n    }\n\n    @method()\n    public increment(\n        shPreimage: SHPreimage,\n        prevTxVer: ByteString,\n        prevTxLocktime: ByteString,\n        prevTxInputContract: ByteString, // First input includes input count prefix...\n        prevTxInputFee: ByteString,\n        feePrevout: ByteString,\n        contractOutputSPK: ByteString, // contract output scriptPubKey\n        contractOutputAmount: ByteString, // contract output amount\n        contractOutputAmountNew: ByteString, // updated contract output amount\n        count: bigint\n    ) {\n        // Check sighash preimage.\n        const s = SigHashUtils.checkSHPreimage(shPreimage)\n        assert(this.checkSig(s, SigHashUtils.Gx))\n\n        // Construct prev tx.\n        const opreturnScript = OpCode.OP_RETURN + Counter.writeCount(int2ByteString(count))\n        const opreturnOutput =\n            Counter.ZEROSAT +\n            int2ByteString(len(opreturnScript)) +\n            opreturnScript\n        const prevTxId = hash256(\n            prevTxVer +\n            prevTxInputContract +\n            prevTxInputFee +\n            toByteString('02') +\n            contractOutputAmount +\n            contractOutputSPK +\n            opreturnOutput +\n            prevTxLocktime\n        )\n\n        // Validate prev tx.\n        const hashPrevouts = sha256(\n            prevTxId + toByteString('00000000') + feePrevout\n        )\n        assert(hashPrevouts == shPreimage.hashPrevouts, 'hashPrevouts mismatch')\n        assert(\n            shPreimage.inputNumber == toByteString('00000000'), 'contract must be called via first input'\n        )\n\n        // Increment counter.\n        const newCount = count + 1n\n        const opreturnScriptNew = OpCode.OP_RETURN + Counter.writeCount(int2ByteString(newCount))\n        const opreturnOutputNew =\n            Counter.ZEROSAT +\n            int2ByteString(len(opreturnScriptNew)) +\n            opreturnScriptNew\n\n        // Enforce outputs.\n        const hashOutputs = sha256(\n            // recurse: same scriptPubKey\n            contractOutputAmountNew + contractOutputSPK + opreturnOutputNew\n        )\n        assert(hashOutputs == shPreimage.hashOutputs, 'hashOutputs mismatch')\n    }\n}\n</code></pre>\n<p>The contract ensure the spending transactions satisfy the following properties:</p>\n<ul>\n<li>recursive covenant: the address of the first input is identical to the address of the first output</li>\n<li>state transition: the second output (i.e., the state output) of the current transaction must have a counter value exactly one larger than that in the previous transaction\u2019s second output</li>\n<li>having one input and one two outputs</li>\n</ul>\n<p>A single run results in the following transactions:</p>\n<ul>\n<li><strong>Deploy Transaction ID with initial state 0</strong>:</li>\n</ul>\n<p>[</p>\n<h2><a name=\"bitcoin-signet-transaction-142782e6dd8ffcf06554b8222637c237a65f47aab27c373da3ddd7b46cd8428c-5\" class=\"anchor\" href=\"#bitcoin-signet-transaction-142782e6dd8ffcf06554b8222637c237a65f47aab27c373da3ddd7b46cd8428c-5\"></a>Bitcoin Signet Transaction: 142782e6dd8ffcf06554b8222637c237a65f47aab27c373da3ddd7b46cd8428c</h2>\n<h3><a name=\"explore-the-full-bitcoin-ecosystem-with-the-mempool-open-source-project-see-the-real-time-status-of-your-6\" class=\"anchor\" href=\"#explore-the-full-bitcoin-ecosystem-with-the-mempool-open-source-project-see-the-real-time-status-of-your-6\"></a>Explore the full Bitcoin ecosystem with The Mempool Open Source Project\u00ae. See the real-time status of your\u2026</h3>\n<p>mempool.space\n](<a href=\"https://mempool.space/signet/tx/142782e6dd8ffcf06554b8222637c237a65f47aab27c373da3ddd7b46cd8428c?source=post_page-----6a3127a24af4--------------------------------\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">mempool - Bitcoin Explorer</a>)</p>\n<ul>\n<li><strong>Transaction ID with state 1 after incremented once</strong>:</li>\n</ul>\n<p>[</p>\n<h5><a name=\"bitcoin-signet-transaction-1d1112a7ba7d3dde969006ab3984564b67b5060d1d323d2d2bf963069b600f20-7\" class=\"anchor\" href=\"#bitcoin-signet-transaction-1d1112a7ba7d3dde969006ab3984564b67b5060d1d323d2d2bf963069b600f20-7\"></a>Bitcoin Signet Transaction: 1d1112a7ba7d3dde969006ab3984564b67b5060d1d323d2d2bf963069b600f20</h5>\n<h5><a name=\"explore-the-full-bitcoin-ecosystem-with-the-mempool-open-source-project-see-the-real-time-status-of-your-8\" class=\"anchor\" href=\"#explore-the-full-bitcoin-ecosystem-with-the-mempool-open-source-project-see-the-real-time-status-of-your-8\"></a>Explore the full Bitcoin ecosystem with The Mempool Open Source Project\u00ae. See the real-time status of your\u2026</h5>\n<p>mempool.space\n](<a href=\"https://mempool.space/signet/tx/1d1112a7ba7d3dde969006ab3984564b67b5060d1d323d2d2bf963069b600f20?source=post_page-----6a3127a24af4--------------------------------\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">mempool - Bitcoin Explorer</a>)</p>\n<ul>\n<li><strong>Transaction ID with state 2 after incremented twice</strong>:</li>\n</ul>\n<p>[</p>\n<h5><a name=\"bitcoin-signet-transaction-01a5ed59ec9497ec82d80dc2ba41025342d66a25eec6b4046ec5b8c4964295d1-9\" class=\"anchor\" href=\"#bitcoin-signet-transaction-01a5ed59ec9497ec82d80dc2ba41025342d66a25eec6b4046ec5b8c4964295d1-9\"></a>Bitcoin Signet Transaction: 01a5ed59ec9497ec82d80dc2ba41025342d66a25eec6b4046ec5b8c4964295d1</h5>\n<h5><a name=\"explore-the-full-bitcoin-ecosystem-with-the-mempool-open-source-project-see-the-real-time-status-of-your-10\" class=\"anchor\" href=\"#explore-the-full-bitcoin-ecosystem-with-the-mempool-open-source-project-see-the-real-time-status-of-your-10\"></a>Explore the full Bitcoin ecosystem with The Mempool Open Source Project\u00ae. See the real-time status of your\u2026</h5>\n<p>mempool.space\n](<a href=\"https://mempool.space/signet/tx/01a5ed59ec9497ec82d80dc2ba41025342d66a25eec6b4046ec5b8c4964295d1?source=post_page-----6a3127a24af4--------------------------------\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">mempool - Bitcoin Explorer</a>)</p>\n<p>Full code can be found at <a href=\"https://github.com/sCrypt-Inc/scrypt-btc-counter\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">GitHub - sCrypt-Inc/scrypt-btc-counter: A simple contract to increment a counter using recursive covenants</a>.</p>\n<p>More sophisticated state machines can be implemented similarly, where state transition is enforced entirely on chain. There can be alternative places and ways to store and encode states, different from the counter contract.</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2024-07-05T11:12:36.824Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 5,
  "reads": 24,
  "readers_count": 23,
  "score": 29.6,
  "yours": false,
  "topic_id": 1028,
  "topic_slug": "bitcoin-op-cat-use-cases-series-4-recursive-covenants",
  "topic_title": "Bitcoin OP_CAT Use Cases Series #4: Recursive Covenants",
  "topic_html_title": "Bitcoin OP_CAT Use Cases Series #4: Recursive Covenants",
  "category_id": 8,
  "display_username": "sCrypt",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "# Bitcoin OP_CAT Use Cases Series #4: Recursive Covenants\n## Stateful Bitcoin Smart Contracts\n\n# Recursive Covenants\n\nAs we explained in [series #1](https://scryptplatform.medium.com/trustless-ordinal-sales-using-op-cat-enabled-covenants-on-bitcoin-0318052f02b2), a Bitcoin covenant is a mechanism that allows the sender of a Bitcoin transaction to impose certain conditions on how the receiver can spend the coins.\n\nA recursive covenant is a type of covenant that applies not only to the immediate transaction but also to any subsequent transactions that spend the bitcoins. This means that the conditions imposed by the covenant could be enforced recursively in perpetuity.\n\nThe main difference between a regular non-recursive covenant and a recursive covenant is the scope of the conditions. A regular covenant only applies to the immediate next transaction, while a recursive one extends to all future transactions that spend the bitcoins.\n\nHere\u2019s a simple example to illustrate the difference:\n\n* Regular covenant: Alice sends Bob 1 BTC with the condition that Bob can only spend the BTC if he provides a valid signature from a specific public key. This condition only applies to the immediate transaction.\n* Recursive covenant: Alice sends Bob 1 BTC with the condition that Bob can only spend the BTC if he provides a valid signature from a specific public key, and that any future transactions spending the BTC must also provide a valid signature from the same public key. This condition applies to all future transactions that spend the BTC.\n\nRecursive covenants can be more powerful and flexible than regular covenants. They represent a significant step forward in the programmability and flexibility of Bitcoin transactions, potentially opening up a wide array of new applications and use cases. For instance, they allow implementing more complex transaction logic required for interoperability with sidechains or other Layer 2 solutions.\n\n![|700x700](upload://pEeD4n5pJ5LPLiz9jtgIqvHO0H4.jpeg)\n\n# Bitcoin Smart Contracts with State\n\nIn Bitcoin\u2019s UTXO model, smart contracts are inherently one-off and stateless, as the UTXO containing the contract is consumed and destroyed when spent. Recursive covenants introduce a form of state that can be maintained and updated across multiple transactions. When a transaction spends a UTXO (Unspent Transaction Output) containing a stateful contract, the state of the contract is updated, and the new state is stored in the output of the spending transaction, all enforced by recursive covenants. Unlike traditional Bitcoin transactions, which are stateless and immutable once confirmed, stateful smart contracts enable the tracking and modification of state over time, akin to smart contracts on other blockchain platforms like Ethereum.\n\nLet us illustrate how it works with a simple counter contract. This basic contract maintains a single state: how many times it has been called since deployment.\n\n![|700x176](upload://votKflVm6UMEwUk0Fzww4DNjJEJ.png)\n\nCounter in a chain of transactions with state 0, 1, and 2\n\nThe state is stored in an adjacent output next to the output containing the contract itself. More specifically, it is in an OP_RETURN output.\n```\nOP_RETURN OP_PUSHBYTES [counter value]\n```\n\nThe Counter contract below resides in a Taproot output. There are two tricks worth highlighting:\n\n1. We choose to store state in a separate output, instead of the same taproot output. This allows us to avoid tweaking the taproot address in the contract, since the address remains unchanged. Tweaking involves heavy elliptic curve arithmetic, which necessitates either excessively long script or new opcode like [OP_TAPLEAF_UPDATE_VERIFY](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html)/OP_TLUV.\n2. We use covenant to get the txid of the previous transaction, which in turns allows us to parse the raw transaction and access its outputs.\n\n```\nexport class Counter extends SmartContract {\n\n    @prop()\n    static readonly ZEROSAT: ByteString = toByteString('0000000000000000')\n\n    constructor() {\n        super(...arguments)\n    }\n\n    @method()\n    public increment(\n        shPreimage: SHPreimage,\n        prevTxVer: ByteString,\n        prevTxLocktime: ByteString,\n        prevTxInputContract: ByteString, // First input includes input count prefix...\n        prevTxInputFee: ByteString,\n        feePrevout: ByteString,\n        contractOutputSPK: ByteString, // contract output scriptPubKey\n        contractOutputAmount: ByteString, // contract output amount\n        contractOutputAmountNew: ByteString, // updated contract output amount\n        count: bigint\n    ) {\n        // Check sighash preimage.\n        const s = SigHashUtils.checkSHPreimage(shPreimage)\n        assert(this.checkSig(s, SigHashUtils.Gx))\n\n        // Construct prev tx.\n        const opreturnScript = OpCode.OP_RETURN + Counter.writeCount(int2ByteString(count))\n        const opreturnOutput =\n            Counter.ZEROSAT +\n            int2ByteString(len(opreturnScript)) +\n            opreturnScript\n        const prevTxId = hash256(\n            prevTxVer +\n            prevTxInputContract +\n            prevTxInputFee +\n            toByteString('02') +\n            contractOutputAmount +\n            contractOutputSPK +\n            opreturnOutput +\n            prevTxLocktime\n        )\n\n        // Validate prev tx.\n        const hashPrevouts = sha256(\n            prevTxId + toByteString('00000000') + feePrevout\n        )\n        assert(hashPrevouts == shPreimage.hashPrevouts, 'hashPrevouts mismatch')\n        assert(\n            shPreimage.inputNumber == toByteString('00000000'), 'contract must be called via first input'\n        )\n\n        // Increment counter.\n        const newCount = count + 1n\n        const opreturnScriptNew = OpCode.OP_RETURN + Counter.writeCount(int2ByteString(newCount))\n        const opreturnOutputNew =\n            Counter.ZEROSAT +\n            int2ByteString(len(opreturnScriptNew)) +\n            opreturnScriptNew\n\n        // Enforce outputs.\n        const hashOutputs = sha256(\n            // recurse: same scriptPubKey\n            contractOutputAmountNew + contractOutputSPK + opreturnOutputNew\n        )\n        assert(hashOutputs == shPreimage.hashOutputs, 'hashOutputs mismatch')\n    }\n}\n```\n\nThe contract ensure the spending transactions satisfy the following properties:\n\n* recursive covenant: the address of the first input is identical to the address of the first output\n* state transition: the second output (i.e., the state output) of the current transaction must have a counter value exactly one larger than that in the previous transaction\u2019s second output\n* having one input and one two outputs\n\nA single run results in the following transactions:\n\n* **Deploy Transaction ID with initial state 0**:\n\n[\n## Bitcoin Signet Transaction: 142782e6dd8ffcf06554b8222637c237a65f47aab27c373da3ddd7b46cd8428c\n### Explore the full Bitcoin ecosystem with The Mempool Open Source Project\u00ae. See the real-time status of your\u2026\nmempool.space\n](https://mempool.space/signet/tx/142782e6dd8ffcf06554b8222637c237a65f47aab27c373da3ddd7b46cd8428c?source=post_page-----6a3127a24af4--------------------------------)\n\n* **Transaction ID with state 1 after incremented once**:\n\n[\n##### Bitcoin Signet Transaction: 1d1112a7ba7d3dde969006ab3984564b67b5060d1d323d2d2bf963069b600f20\n##### Explore the full Bitcoin ecosystem with The Mempool Open Source Project\u00ae. See the real-time status of your\u2026\nmempool.space\n](https://mempool.space/signet/tx/1d1112a7ba7d3dde969006ab3984564b67b5060d1d323d2d2bf963069b600f20?source=post_page-----6a3127a24af4--------------------------------)\n\n* **Transaction ID with state 2 after incremented twice**:\n\n[\n##### Bitcoin Signet Transaction: 01a5ed59ec9497ec82d80dc2ba41025342d66a25eec6b4046ec5b8c4964295d1\n##### Explore the full Bitcoin ecosystem with The Mempool Open Source Project\u00ae. See the real-time status of your\u2026\nmempool.space\n](https://mempool.space/signet/tx/01a5ed59ec9497ec82d80dc2ba41025342d66a25eec6b4046ec5b8c4964295d1?source=post_page-----6a3127a24af4--------------------------------)\n\nFull code can be found at https://github.com/sCrypt-Inc/scrypt-btc-counter.\n\nMore sophisticated state machines can be implemented similarly, where state transition is enforced entirely on chain. There can be alternative places and ways to store and encode states, different from the counter contract.",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 477,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": "downloaded local copies of images",
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false
}