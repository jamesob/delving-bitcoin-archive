{
  "id": 2898,
  "name": "Pieter Wuille",
  "username": "sipa",
  "avatar_template": "/user_avatar/delvingbitcoin.org/sipa/{size}/102_2.png",
  "created_at": "2024-07-24T18:40:20.438Z",
  "cooked": "<h4><a name=\"introduction-1\" class=\"anchor\" href=\"#introduction-1\"></a>Introduction</h4>\n<p>In cluster mempool, we maintain a (hopefully close to optimal) linearization and chunking for all clusters at all times. The obvious <a href=\"https://delvingbitcoin.org/t/introduction-to-cluster-linearization/1032#h-24-block-building-and-eviction-7\">strategy</a> for building block templates with those is to include the chunks from high feerate to low feerate, from all clusters, until one no longer fits.</p>\n<p>To do so, we can precompute, along with the linearizations and chunkings themselves, a sorted set of all chunks, so that block template building can consider them easily in order of decreasing feerate.</p>\n<p>If the linearizations are optimal, and the chunks thus represent the consecutive highest-feerate remaining topological subsets of each cluster, then this strategy has the property that it constructs a block whose total fee is close to optimal too: the loss is bounded by <strong>the number of unfilled vsize times the feerate of the first chunk that does not fit</strong>. The unfilled vsize itself is limited by the vsize of chunks, and thus this suggests a vsize limit on clusters in addition to a limit on their count, just to make sure the unfilled block size cannot grow too large. Can we do better?</p>\n<p>Of course, once the next-best chunk no longer fits in a block, it\u2019s possible to instead just start skipping chunks that don\u2019t fit, and include ones that do fit (excluding ones that follow skipped chunks within the same cluster), similar to what the current ancestor-based mining algorithm does. Or it is possible to use a branch-and-bound search algorithm over these chunks to maximize fee by combining chunks.</p>\n<p>All of this however is restricted to <em>chunks</em>. If all chunks happen to consist of multiple large transactions, we will want to include groups of transactions that are smaller than a chunk.</p>\n<h4><a name=\"breaking-down-chunks-further-2\" class=\"anchor\" href=\"#breaking-down-chunks-further-2\"></a>Breaking down chunks further</h4>\n<p>If for some reason a chunk is not included, but we still want to consider prefixes of that chunk, it is possible to reconsider the remainder of the chunk by removing the last transaction and re-inserting the highest-feerate prefix of what remains into our sorted set of \u201cchunks\u201d to consider, similar to how the current (Bitcoin Core 15.x-27.x) block building algorithm re-inserts the remainder of ancestor sets into a heap. It does come with the runtime overhead of maintaining that heap, however, and is nontrivial to generalize to a branch-and-bound search variant that does more than a single eager selection loop.</p>\n<p>However, it is possible to precompute how chunks will break apart.</p>\n<p>As an example, consider the following cluster (all transactions have the same size):</p>\n<pre data-code-height=\"148\" data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">graph BT\nB[\"B: 4\"]; A[\"A: 7\"]; C[\"C: 1\"]; D[\"D: 6\"]; F[\"F: 3\"]; E[\"E: 5\"]; G[\"G: 6\"]; D--&gt;C; E--&gt;C; G--&gt;B; G--&gt;A; G--&gt;C; G--&gt;F;\n</code></pre>\n<p>with (optimal) linearization (A,B,C,D,E,F,G), chunked as [A,BCDEFG].</p>\n<p>If transaction G is removed, the BCDEFG chunk splits up into B, CDE, and F. Removing E from CDE leaves CD, and removing D leaves C.</p>\n<p>Thus, the set of chunks and subchunks to consider becomes A, B, C, CD, CDE, F, BCDEFG, or sorted by decreasing feerate:</p>\n<ul>\n<li>A: 7/1=7</li>\n<li>BCDEFG: 25/6=4.166</li>\n<li>B: 4/1=4</li>\n<li>CDE: 12/3=4</li>\n<li>CD: 7/2=3.5</li>\n<li>F: 3/1=3</li>\n<li>C: 1/1=1</li>\n</ul>\n<p>Note that there is exactly one such chunk/subchunk set per transaction: it is the chunk the transaction is in if the linearization were cut off after it. I will refer to these as the <em>absorption set</em> of each transaction. For the last transaction in a chunk, its absorption set equals the chunk itself. For other transactions, it will be a strictly lower-fee subset of its chunk.</p>\n<p>Given a precomputed ordered set with all these absorption sets (across all clusters), a block building algorithm can consider these sets in order from high-to-low feerate, skipping ones that are inapplicable due to non-continuation. In the example above, if A were included, but BCDEFG then skipped (e.g. because it does not fit), then B could still be included, followed by CDE, CD, or C. F would only be applicable if CDE was chosen.</p>\n<p>The advantage of this approach so far is just that no mutable data structure is needed to collect the broken-down chunks; instead, all possibly necessary breakdowns are computed ahead of time. The only required state at runtime is for each cluster, how long a prefix has been included already. The downside is that the sorted set will contain inapplicable sets which need to be skipped at block bulding time.</p>\n<p>For example, when A and BCDEFG have been included already, all further absorption sets (B, CDE, F, CD, C) are uninteresting and need to be skipped. If A, B, CDE, and F are included, CD and C need to be skipped. This may or may not be a worthwhile trade-off, but will depend on the actual clusters involved.</p>\n<h4><a name=\"repurposing-the-chunking-algorithm-3\" class=\"anchor\" href=\"#repurposing-the-chunking-algorithm-3\"></a>Repurposing the Chunking algorithm</h4>\n<p>Recall the <a href=\"https://delvingbitcoin.org/t/introduction-to-cluster-linearization/1032#h-22-feerate-diagrams-and-chunking-5\">chunking algorithm</a>:</p>\n<ul>\n<li><span class=\"math\">\\operatorname{Chunking}(C, L)</span>, for a cluster <span class=\"math\">C</span> with linearization <span class=\"math\">L</span>:\n<ul>\n<li>Set <span class=\"math\">R = []</span>, a list of sets of transactions.</li>\n<li>For <span class=\"math\">tx \\in L</span>:\n<ul>\n<li>Append the singleton <span class=\"math\">\\{tx\\}</span> to <span class=\"math\">R</span>.</li>\n<li>While <span class=\"math\">R</span> has two or more elements, and the feerate of the last one is higher than that of the penultimate one:\n<ul>\n<li>Replace the last two elements of <span class=\"math\">R</span> with their union.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Return <span class=\"math\">R</span>.</li>\n</ul>\n</li>\n</ul>\n<p>The state of the <span class=\"math\">R</span> list after every iteration of the for loop is exactly the chunking of the linearization when cut off after <span class=\"math\">tx</span>. In other words, the absorption sets are exactly the collection of sets that appear as the last element of <span class=\"math\">R</span> throughout the algorithm. In other words, the collection of all mempool absorption sets can be computed in <span class=\"math\">\\mathcal{O}(n)</span> time like chunking itself. Inserting them into a sorted set would take <span class=\"math\">\\mathcal{O}(n \\log m)</span> time, with <span class=\"math\">m</span> the total number of mempool transactions.</p>\n<h4><a name=\"sub-chunk-quality-4\" class=\"anchor\" href=\"#sub-chunk-quality-4\"></a>Sub-chunk quality</h4>\n<p>With this approach, the ordering of transactions <em>within</em> a chunk becomes relevant. The <a href=\"https://delvingbitcoin.org/t/introduction-to-cluster-linearization/1032#h-333-post-linearization-17\">post-linearization algorithm</a> informally does improve things in this regard, which makes it more relevant if absorption-set based block building is in use.</p>\n<p>That said, I am not sure whether a quality metric exists which is compatible with the existing feerate diagram metric (which only cares about super-chunk quality), distinguishes sub-chunk quality in a way that measurably contributes to block building quality, and retains the \u201coptimal linearization exists for every cluster\u201d property. Without such a metric it is hard to say what better sub-chunk quality really means, but the steps taken by post-linearization (swapping higher-feerate groups of transactions that follow lower-feerate groups) feels like an unambiguous improvement.</p>\n<h4><a name=\"branch-and-bound-search-5\" class=\"anchor\" href=\"#branch-and-bound-search-5\"></a>Branch-and-bound search</h4>\n<p>Instead of just picking all applicable absorption sets that fit and skipping other ones, it is also possible to backtrack when the block is (nearly) full to an earlier point, and change a chosen set into a non-chosen set. This yields a search algorithm that can try many combinations, and can be combined with branch-and-bound (whenever the feerate necessary to exceed the best seen fee so far with the remaining space available is less than the feerate of the next available absorption set, jump back to before the last non-chosen set).</p>\n<p>If this approach is done with just chunks, the result will (eventually, with no guarantees on runtime) find the maximal possible fee in a block consisting of a combination of prefixes of chunks. If it is performed with all absorption sets, the result will be the maximal possible fee in a block consisting of a combination of prefixes of linearizations (not necessarily restricted to chunk boundaries). This is because every prefix of a linearization can be written as a single sequence of applicable absorption sets.</p>\n<p>I believe it is when combined with such a search algorithm that the benefit of choosing precomputed absorption sets over the dynamic computation of applicable ones at runtime becomes really apparent. When backtracking, the state of the selection needs to be reset to the values it had at point jumped back to. In the case of precomputed absorption sets, that state is just the included prefix length for every cluster (e.g. as a dense hashmap), which is easy to reset. In the case of dynamically computed broken-up chunks, the obvious data structure to keep those broken-up chunks in is a <a href=\"https://en.wikipedia.org/wiki/Binary_heap\">binary heap</a>, but that does not permit cheap restoring of an earlier state.</p>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2024-07-24T18:40:20.438Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 5,
  "reads": 12,
  "readers_count": 11,
  "score": 27.2,
  "yours": false,
  "topic_id": 1044,
  "topic_slug": "cluster-mempool-block-building-with-sub-chunk-granularity",
  "topic_title": "Cluster mempool: block building with sub-chunk granularity",
  "topic_html_title": "Cluster mempool: block building with sub-chunk granularity",
  "category_id": 8,
  "display_username": "Pieter Wuille",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "#### Introduction\n\nIn cluster mempool, we maintain a (hopefully close to optimal) linearization and chunking for all clusters at all times. The obvious [strategy](https://delvingbitcoin.org/t/introduction-to-cluster-linearization/1032#h-24-block-building-and-eviction-7) for building block templates with those is to include the chunks from high feerate to low feerate, from all clusters, until one no longer fits.\n\nTo do so, we can precompute, along with the linearizations and chunkings themselves, a sorted set of all chunks, so that block template building can consider them easily in order of decreasing feerate.\n\nIf the linearizations are optimal, and the chunks thus represent the consecutive highest-feerate remaining topological subsets of each cluster, then this strategy has the property that it constructs a block whose total fee is close to optimal too: the loss is bounded by **the number of unfilled vsize times the feerate of the first chunk that does not fit**. The unfilled vsize itself is limited by the vsize of chunks, and thus this suggests a vsize limit on clusters in addition to a limit on their count, just to make sure the unfilled block size cannot grow too large. Can we do better?\n\nOf course, once the next-best chunk no longer fits in a block, it's possible to instead just start skipping chunks that don't fit, and include ones that do fit (excluding ones that follow skipped chunks within the same cluster), similar to what the current ancestor-based mining algorithm does. Or it is possible to use a branch-and-bound search algorithm over these chunks to maximize fee by combining chunks.\n\nAll of this however is restricted to *chunks*. If all chunks happen to consist of multiple large transactions, we will want to include groups of transactions that are smaller than a chunk.\n\n#### Breaking down chunks further\n\nIf for some reason a chunk is not included, but we still want to consider prefixes of that chunk, it is possible to reconsider the remainder of the chunk by removing the last transaction and re-inserting the highest-feerate prefix of what remains into our sorted set of \"chunks\" to consider, similar to how the current (Bitcoin Core 15.x-27.x) block building algorithm re-inserts the remainder of ancestor sets into a heap. It does come with the runtime overhead of maintaining that heap, however, and is nontrivial to generalize to a branch-and-bound search variant that does more than a single eager selection loop.\n\nHowever, it is possible to precompute how chunks will break apart.\n\nAs an example, consider the following cluster (all transactions have the same size):\n\n```mermaid height=148,auto\ngraph BT\nB[\"B: 4\"]; A[\"A: 7\"]; C[\"C: 1\"]; D[\"D: 6\"]; F[\"F: 3\"]; E[\"E: 5\"]; G[\"G: 6\"]; D-->C; E-->C; G-->B; G-->A; G-->C; G-->F;\n```\n\nwith (optimal) linearization (A,B,C,D,E,F,G), chunked as [A,BCDEFG].\n\nIf transaction G is removed, the BCDEFG chunk splits up into B, CDE, and F. Removing E from CDE leaves CD, and removing D leaves C.\n\nThus, the set of chunks and subchunks to consider becomes A, B, C, CD, CDE, F, BCDEFG, or sorted by decreasing feerate:\n* A: 7/1=7\n* BCDEFG: 25/6=4.166\n* B: 4/1=4\n* CDE: 12/3=4\n* CD: 7/2=3.5\n* F: 3/1=3\n* C: 1/1=1\n\nNote that there is exactly one such chunk/subchunk set per transaction: it is the chunk the transaction is in if the linearization were cut off after it. I will refer to these as the *absorption set* of each transaction. For the last transaction in a chunk, its absorption set equals the chunk itself. For other transactions, it will be a strictly lower-fee subset of its chunk.\n\nGiven a precomputed ordered set with all these absorption sets (across all clusters), a block building algorithm can consider these sets in order from high-to-low feerate, skipping ones that are inapplicable due to non-continuation. In the example above, if A were included, but BCDEFG then skipped (e.g. because it does not fit), then B could still be included, followed by CDE, CD, or C. F would only be applicable if CDE was chosen.\n\nThe advantage of this approach so far is just that no mutable data structure is needed to collect the broken-down chunks; instead, all possibly necessary breakdowns are computed ahead of time. The only required state at runtime is for each cluster, how long a prefix has been included already. The downside is that the sorted set will contain inapplicable sets which need to be skipped at block bulding time.\n\nFor example, when A and BCDEFG have been included already, all further absorption sets (B, CDE, F, CD, C) are uninteresting and need to be skipped. If A, B, CDE, and F are included, CD and C need to be skipped. This may or may not be a worthwhile trade-off, but will depend on the actual clusters involved.\n\n#### Repurposing the Chunking algorithm\n\nRecall the [chunking algorithm](https://delvingbitcoin.org/t/introduction-to-cluster-linearization/1032#h-22-feerate-diagrams-and-chunking-5):\n\n* $\\operatorname{Chunking}(C, L)$, for a cluster $C$ with linearization $L$:\n  * Set $R = []$, a list of sets of transactions.\n  * For $tx \\in L$:\n    * Append the singleton $\\{tx\\}$ to $R$.\n    * While $R$ has two or more elements, and the feerate of the last one is higher than that of the penultimate one:\n      * Replace the last two elements of $R$ with their union.\n  * Return $R$.\n\nThe state of the $R$ list after every iteration of the for loop is exactly the chunking of the linearization when cut off after $tx$. In other words, the absorption sets are exactly the collection of sets that appear as the last element of $R$ throughout the algorithm. In other words, the collection of all mempool absorption sets can be computed in $\\mathcal{O}(n)$ time like chunking itself. Inserting them into a sorted set would take $\\mathcal{O}(n \\log m)$ time, with $m$ the total number of mempool transactions.\n\n#### Sub-chunk quality\n\nWith this approach, the ordering of transactions *within* a chunk becomes relevant. The [post-linearization algorithm](https://delvingbitcoin.org/t/introduction-to-cluster-linearization/1032#h-333-post-linearization-17) informally does improve things in this regard, which makes it more relevant if absorption-set based block building is in use.\n\nThat said, I am not sure whether a quality metric exists which is compatible with the existing feerate diagram metric (which only cares about super-chunk quality), distinguishes sub-chunk quality in a way that measurably contributes to block building quality, and retains the \"optimal linearization exists for every cluster\" property. Without such a metric it is hard to say what better sub-chunk quality really means, but the steps taken by post-linearization (swapping higher-feerate groups of transactions that follow lower-feerate groups) feels like an unambiguous improvement.\n\n#### Branch-and-bound search\n\nInstead of just picking all applicable absorption sets that fit and skipping other ones, it is also possible to backtrack when the block is (nearly) full to an earlier point, and change a chosen set into a non-chosen set. This yields a search algorithm that can try many combinations, and can be combined with branch-and-bound (whenever the feerate necessary to exceed the best seen fee so far with the remaining space available is less than the feerate of the next available absorption set, jump back to before the last non-chosen set).\n\nIf this approach is done with just chunks, the result will (eventually, with no guarantees on runtime) find the maximal possible fee in a block consisting of a combination of prefixes of chunks. If it is performed with all absorption sets, the result will be the maximal possible fee in a block consisting of a combination of prefixes of linearizations (not necessarily restricted to chunk boundaries). This is because every prefix of a linearization can be written as a single sequence of applicable absorption sets.\n\nI believe it is when combined with such a search algorithm that the benefit of choosing precomputed absorption sets over the dynamic computation of applicable ones at runtime becomes really apparent. When backtracking, the state of the selection needs to be reset to the values it had at point jumped back to. In the case of precomputed absorption sets, that state is just the included prefix length for every cluster (e.g. as a dense hashmap), which is easy to reset. In the case of dynamically computed broken-up chunks, the obvious data structure to keep those broken-up chunks in is a [binary heap](https://en.wikipedia.org/wiki/Binary_heap), but that does not permit cheap restoring of an earlier state.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 96,
  "hidden": false,
  "trust_level": 3,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}