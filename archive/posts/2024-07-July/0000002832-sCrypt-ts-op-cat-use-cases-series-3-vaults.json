{
  "id": 2832,
  "name": "sCrypt",
  "username": "sCrypt-ts",
  "avatar_template": "/letter_avatar_proxy/v4/letter/s/94ad74/{size}.png",
  "created_at": "2024-07-01T00:17:54.078Z",
  "cooked": "<h1><a name=\"bitcoin-op_cat-use-cases-series-3-vaults-1\" class=\"anchor\" href=\"#bitcoin-op_cat-use-cases-series-3-vaults-1\"></a>Bitcoin OP_CAT Use Cases Series <span class=\"hashtag-raw\">#3:</span> Vaults</h1>\n<h2><a name=\"delayed-spending-2\" class=\"anchor\" href=\"#delayed-spending-2\"></a>Delayed spending</h2>\n<p>Following our <a href=\"https://delvingbitcoin.org/t/bitcoin-op-cat-use-cases-series-1-covenants/990\">series #1</a> and <a href=\"https://delvingbitcoin.org/t/op-cat-use-cases-series-2/988\">#2</a>, we demonstrate how to construct non-custodial vaults, to provide enhanced security for stored bitcoins. They are typically used to protect against theft by requiring a time delay to access the funds. We can think of vault smart contracts as special accounts whose keys can be neutralized if they fall into the hands of attackers. Vaults are Bitcoin\u2019s decentralized version of calling your bank to report a stolen credit card, rendering the attacker\u2019s transactions null and void. This disincentives key theft in the first place, as attackers know they cannot get away with theft.</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/1X/aee9b253bffb9e720800d2a2ea6d471270f20636.jpeg\" data-download-href=\"https://delvingbitcoin.org/uploads/default/aee9b253bffb9e720800d2a2ea6d471270f20636\" title=\"\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/1X/aee9b253bffb9e720800d2a2ea6d471270f20636_2_500x500.jpeg\" alt=\"\" data-base62-sha1=\"oXlLTsW6lxrFGbA2dlan1TDbGrc\" width=\"500\" height=\"500\" role=\"presentation\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/1X/aee9b253bffb9e720800d2a2ea6d471270f20636_2_500x500.jpeg, https://delvingbitcoin.org/uploads/default/original/1X/aee9b253bffb9e720800d2a2ea6d471270f20636.jpeg 1.5x, https://delvingbitcoin.org/uploads/default/original/1X/aee9b253bffb9e720800d2a2ea6d471270f20636.jpeg 2x\" data-dominant-color=\"638995\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\"></span><span class=\"informations\">700\u00d7700 103 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<h1><a name=\"how-vaults-work-3\" class=\"anchor\" href=\"#how-vaults-work-3\"></a>How Vaults Work</h1>\n<p>Funds locked in a vault contract can be accessed using either of two keys: a <em>vault</em> key, which is intended to be kept online and stored in a hot wallet, and a <em>recovery</em> key, which is kept securely offline in a cold wallet and used only for recovery. Typically, the <em>vault</em> key is used to create transactions that spend coins from the vault. Regardless of which key is used, any funds spent from the vault must pass through a time lock that holds the funds for a fixed period, such as 24 hours. This mechanism ensures that if a malicious actor obtains the <em>vault</em> key, they must broadcast a time-locked transaction on the blockchain before gaining access to the funds. This gives the vault owner a 24-hour window to detect the unauthorized movement of their funds and take action. During the time lock period, the contract allows the funds to be redirected to another address using the <em>recovery</em> key.</p>\n<p>To spend bitcoins from a vault, two sequential steps are required:</p>\n<ol>\n<li>Issue a withdrawal request to move coins out of the vault through a transaction known as an unvault.</li>\n<li>Wait for a predefined period (called the unvaulting period), such as 24 hours, after the first transaction is mined before moving the coins out in a subsequent transaction.</li>\n</ol>\n<p>The first transaction indicates an attempt to transfer the coins and gives the owner a chance to block the second transaction that would complete the transfer. Step 1 is similar to transferring money from a savings account to a checking account before spending it, while step 2 provides a 24-hour window to revert an unauthorized payment made from the checking account.</p>\n<h1><a name=\"implementation-4\" class=\"anchor\" href=\"#implementation-4\"></a>Implementation</h1>\n<p>The implementation of the vault mechanism using sCrypt involves three smart contracts: Trigger, Complete, and Cancel. Each is a leaf in the vault taproot as shown below.</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/1X/7c46b7d81ff2a54f0180c0d642a8e1256d765ddf.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/7c46b7d81ff2a54f0180c0d642a8e1256d765ddf\" title=\"\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/1X/7c46b7d81ff2a54f0180c0d642a8e1256d765ddf_2_690x196.png\" alt=\"\" data-base62-sha1=\"hJoIAOEliHMYwCMNPqz8EKjc4Ef\" width=\"690\" height=\"196\" role=\"presentation\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/1X/7c46b7d81ff2a54f0180c0d642a8e1256d765ddf_2_690x196.png, https://delvingbitcoin.org/uploads/default/original/1X/7c46b7d81ff2a54f0180c0d642a8e1256d765ddf.png 1.5x, https://delvingbitcoin.org/uploads/default/original/1X/7c46b7d81ff2a54f0180c0d642a8e1256d765ddf.png 2x\" data-dominant-color=\"EBEDF0\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\"></span><span class=\"informations\">700\u00d7199 39.4 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<pre><code class=\"lang-auto\">\nexport class VaultTriggerWithdrawal extends SmartContract {\n    @method()\n    public trigger(\n        shPreimage: SHPreimage,\n        sig: Sig,\n        vaultSPK: ByteString,\n        feeSPK: ByteString,\n        vaultAmt: ByteString,\n        feeAmt: ByteString,\n        targetSPK: ByteString\n    ) {\n        // Check sig.\n        assert(this.checkSig(sig, this.withdrawalPubKey))\n\n        // Check sighash preimage.\n        const s = SigHashUtils.checkSHPreimage(shPreimage)\n        assert(this.checkSig(s, SigHashUtils.Gx))\n\n        // Enforce spent scripts.\n        const hashSpentScripts = sha256(vaultSPK + feeSPK)\n        assert(hashSpentScripts == shPreimage.hashSpentScripts, 'hashSpentScripts mismatch')\n\n        // Enforce spent amounts.\n        const hashSpentAmounts = sha256(vaultAmt + feeAmt)\n        assert(hashSpentAmounts == shPreimage.hashSpentAmounts, 'hashSpentAmounts mismatch')\n\n        // Enforce outputs.\n        const dust = toByteString('2202000000000000')\n        const hashOutputs = sha256(\n            vaultAmt + vaultSPK +\n            dust + targetSPK\n        )\n        assert(hashOutputs == shPreimage.hashOutputs, 'hashOutputs mismatch')\n    }\n\n    // Default taproot key spend must be disabled!\n}\n</code></pre>\n<p>we validate the trigger transactions</p>\n<ul>\n<li>contain two inputs and two outputs.</li>\n<li>the amount in the first input matches the amount in the first output.</li>\n<li>the address of the first input is identical to the address of the first output.</li>\n</ul>\n<pre><code class=\"lang-auto\">export class VaultCompleteWithdrawal extends SmartContract {\n    @method()\n    public complete(\n        shPreimage: SHPreimage,\n        prevTxVer: ByteString,\n        prevTxLocktime: ByteString,\n        prevTxInputContract: ByteString, // First input chunk should also include length prefix...\n        prevTxInputFee: ByteString,\n        vaultSPK: ByteString,\n        vaultAmt: ByteString,\n        targetSPK: ByteString,\n        feePrevout: ByteString\n    ) {\n        this.csv(this.sequenceVal)\n\n        // Check sighash preimage.\n        const s = SigHashUtils.checkSHPreimage(shPreimage)\n        assert(this.checkSig(s, SigHashUtils.Gx))\n\n        // Construct prev tx.\n        const dust = toByteString('2202000000000000')\n        const prevTxId = hash256(\n            prevTxVer +\n            prevTxInputContract +\n            prevTxInputFee +\n            toByteString('02') + vaultAmt + vaultSPK + dust + targetSPK +\n            prevTxLocktime\n        )\n\n        // Enforce prevouts.\n        const hashPrevouts = sha256(\n            prevTxId + toByteString('00000000') +\n            feePrevout\n        )\n        assert(hashPrevouts == shPreimage.hashPrevouts, 'hashPrevouts mismatch')\n\n        // Enforce outputs\n        const hashOutputs = sha256(\n            vaultAmt + targetSPK\n        )\n        assert(hashOutputs == shPreimage.hashOutputs, 'hashOutputs mismatch')\n    }\n</code></pre>\n<p>The Complete transactions must satisfy the following properties:</p>\n<ul>\n<li>having two inputs and one output</li>\n<li>the previous transaction is a Trigger transaction and contains the destination address in the second output. We parse the content of the previous transaction in line 20\u201328</li>\n<li>the amount in the first output of the previous transaction matches the single output amount in the current transaction.</li>\n</ul>\n<pre><code class=\"lang-auto\">export class VaultCancelWithdrawal extends SmartContract {\n    @method()\n    public trigger(\n        shPreimage: SHPreimage,\n        sig: Sig,\n        vaultSPK: ByteString,\n        feeSPK: ByteString,\n        vaultAmt: ByteString,\n        feeAmt: ByteString\n    ) {\n        // Check sig.\n        assert(this.checkSig(sig, this.cancelPubKey))\n\n        // Check sighash preimage.\n        const s = SigHashUtils.checkSHPreimage(shPreimage)\n        assert(this.checkSig(s, SigHashUtils.Gx))\n\n        // Enforce spent scripts.\n        const hashSpentScripts = sha256(vaultSPK + feeSPK)\n        assert(hashSpentScripts == shPreimage.hashSpentScripts, 'hashSpentScripts mismatch')\n\n        // Enforce spent amounts.\n        const hashSpentAmounts = sha256(vaultAmt + feeAmt)\n        assert(hashSpentAmounts == shPreimage.hashSpentAmounts, 'hashSpentAmounts mismatch')\n\n        // Enforce outputs.\n        const hashOutputs = sha256(\n            vaultAmt + vaultSPK\n        )\n        assert(hashOutputs == shPreimage.hashOutputs, 'hashOutputs mismatch')\n    }\n\n    // Default taproot key spend must be disabled!\n}\n</code></pre>\n<p>Cancel transactions must ensure</p>\n<ul>\n<li>there are exactly two inputs and one output</li>\n<li>the amount of the first input matches the amount of the output.</li>\n</ul>\n<p>A single run results in the following transactions:</p>\n<ul>\n<li><strong>Trigger Transaction ID</strong>:</li>\n</ul>\n<p>[</p>\n<h2><a name=\"bitcoin-signet-transaction-8c87a62ae1f95efc653af384d034846693a11bf380184aaddb91540c5e74950b-5\" class=\"anchor\" href=\"#bitcoin-signet-transaction-8c87a62ae1f95efc653af384d034846693a11bf380184aaddb91540c5e74950b-5\"></a>Bitcoin Signet Transaction: 8c87a62ae1f95efc653af384d034846693a11bf380184aaddb91540c5e74950b</h2>\n<h3><a name=\"explore-the-full-bitcoin-ecosystem-with-the-mempool-open-source-project-see-the-real-time-status-of-your-6\" class=\"anchor\" href=\"#explore-the-full-bitcoin-ecosystem-with-the-mempool-open-source-project-see-the-real-time-status-of-your-6\"></a>Explore the full Bitcoin ecosystem with The Mempool Open Source Project\u00ae. See the real-time status of your\u2026</h3>\n<p>mempool.space\n](<a href=\"https://mempool.space/signet/tx/8c87a62ae1f95efc653af384d034846693a11bf380184aaddb91540c5e74950b\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">mempool - Bitcoin Explorer</a>)</p>\n<ul>\n<li><strong>Complete Transaction ID</strong>:</li>\n</ul>\n<p>(<a href=\"https://mempool.space/signet/tx/66b314e72c8ab07fb9b35db9e40aeff6e1b2817b89e653d6b50f7a9675d8fd9a\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">mempool - Bitcoin Explorer</a>)</p>\n<p>The full code of our vault implementation can be found <a href=\"https://github.com/sCrypt-Inc/scrypt-btc-vault\" rel=\"noopener nofollow ugc\">on GitHub</a>. It has been previously <a href=\"https://scryptplatform.medium.com/non-custodial-bitcoin-vaults-880c781effa7\" rel=\"noopener nofollow ugc\">implemented on Bitcoin SV</a>, which has a similar but different set of opcodes.</p>\n<h2><a name=\"script-versions-7\" class=\"anchor\" href=\"#script-versions-7\"></a>Script versions</h2>\n<p>There are alternative implementations in bare scripts, like <a href=\"https://github.com/taproot-wizards/purrfect_vault/blob/main/src/vault/script.rs\" rel=\"noopener nofollow ugc\">purrfect_vault</a> from Taproot Wizards. One major benefit of using sCrypt for implementing these vaults is its readability and maintainability. Traditional scripts are often difficult to read and modify.</p>\n<pre><code class=\"lang-auto\">OP_TOALTSTACK\n        OP_TOALTSTACK\n        OP_TOALTSTACK\n        OP_2DUP\n        OP_TOALTSTACK\n        OP_TOALTSTACK\n        OP_TOALTSTACK\n        OP_TOALTSTACK\n        OP_TOALTSTACK\n        // start with encoded leaf hash\n        OP_CAT\n        OP_CAT\n        OP_CAT\n        OP_CAT\n        push_slice (*DUST_AMOUNT)\n        OP_FROMALTSTACK\n        OP_CAT\n        OP_FROMALTSTACK\n        OP_FROMALTSTACK\n        OP_CAT\n        OP_SWAP\n        OP_CAT\n        OP_SHA256\n        OP_SWAP\n        OP_CAT\n        OP_CAT\n        OP_FROMALTSTACK\n        OP_FROMALTSTACK\n        OP_FROMALTSTACK\n        OP_FROMALTSTACK\n        OP_SWAP\n        OP_TOALTSTACK\n        OP_CAT\n        OP_SWAP\n        OP_TOALTSTACK\n        OP_SHA256\n        OP_SWAP\n        OP_CAT\n        OP_FROMALTSTACK\n        OP_FROMALTSTACK\n        OP_CAT\n        OP_SHA256\n        OP_SWAP\n        OP_CAT\n        OP_CAT\n        OP_CAT\n        OP_CAT\n        OP_CAT\n        OP_CAT\n</code></pre>",
  "post_number": 1,
  "post_type": 1,
  "updated_at": "2024-07-01T00:23:02.256Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 4,
  "reads": 13,
  "readers_count": 12,
  "score": 22.6,
  "yours": false,
  "topic_id": 1006,
  "topic_slug": "op-cat-use-cases-series-3-vaults",
  "topic_title": "OP_CAT Use cases series 3 : vaults",
  "topic_html_title": "OP_CAT Use cases series 3 : vaults",
  "category_id": 8,
  "display_username": "sCrypt",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "# Bitcoin OP_CAT Use Cases Series #3: Vaults\n## Delayed spending\n\nFollowing our [series #1](https://delvingbitcoin.org/t/bitcoin-op-cat-use-cases-series-1-covenants/990) and [#2](https://delvingbitcoin.org/t/op-cat-use-cases-series-2/988), we demonstrate how to construct non-custodial vaults, to provide enhanced security for stored bitcoins. They are typically used to protect against theft by requiring a time delay to access the funds. We can think of vault smart contracts as special accounts whose keys can be neutralized if they fall into the hands of attackers. Vaults are Bitcoin\u2019s decentralized version of calling your bank to report a stolen credit card, rendering the attacker\u2019s transactions null and void. This disincentives key theft in the first place, as attackers know they cannot get away with theft.\n\n![|700x700](upload://oXlLTsW6lxrFGbA2dlan1TDbGrc.jpeg)\n\n# How Vaults Work\n\nFunds locked in a vault contract can be accessed using either of two keys: a *vault* key, which is intended to be kept online and stored in a hot wallet, and a *recovery* key, which is kept securely offline in a cold wallet and used only for recovery. Typically, the *vault* key is used to create transactions that spend coins from the vault. Regardless of which key is used, any funds spent from the vault must pass through a time lock that holds the funds for a fixed period, such as 24 hours. This mechanism ensures that if a malicious actor obtains the *vault* key, they must broadcast a time-locked transaction on the blockchain before gaining access to the funds. This gives the vault owner a 24-hour window to detect the unauthorized movement of their funds and take action. During the time lock period, the contract allows the funds to be redirected to another address using the *recovery* key.\n\nTo spend bitcoins from a vault, two sequential steps are required:\n\n1. Issue a withdrawal request to move coins out of the vault through a transaction known as an unvault.\n2. Wait for a predefined period (called the unvaulting period), such as 24 hours, after the first transaction is mined before moving the coins out in a subsequent transaction.\n\nThe first transaction indicates an attempt to transfer the coins and gives the owner a chance to block the second transaction that would complete the transfer. Step 1 is similar to transferring money from a savings account to a checking account before spending it, while step 2 provides a 24-hour window to revert an unauthorized payment made from the checking account.\n\n# Implementation\n\nThe implementation of the vault mechanism using sCrypt involves three smart contracts: Trigger, Complete, and Cancel. Each is a leaf in the vault taproot as shown below.\n\n![|700x199](upload://hJoIAOEliHMYwCMNPqz8EKjc4Ef.png)\n\n```\n\nexport class VaultTriggerWithdrawal extends SmartContract {\n    @method()\n    public trigger(\n        shPreimage: SHPreimage,\n        sig: Sig,\n        vaultSPK: ByteString,\n        feeSPK: ByteString,\n        vaultAmt: ByteString,\n        feeAmt: ByteString,\n        targetSPK: ByteString\n    ) {\n        // Check sig.\n        assert(this.checkSig(sig, this.withdrawalPubKey))\n\n        // Check sighash preimage.\n        const s = SigHashUtils.checkSHPreimage(shPreimage)\n        assert(this.checkSig(s, SigHashUtils.Gx))\n\n        // Enforce spent scripts.\n        const hashSpentScripts = sha256(vaultSPK + feeSPK)\n        assert(hashSpentScripts == shPreimage.hashSpentScripts, 'hashSpentScripts mismatch')\n\n        // Enforce spent amounts.\n        const hashSpentAmounts = sha256(vaultAmt + feeAmt)\n        assert(hashSpentAmounts == shPreimage.hashSpentAmounts, 'hashSpentAmounts mismatch')\n\n        // Enforce outputs.\n        const dust = toByteString('2202000000000000')\n        const hashOutputs = sha256(\n            vaultAmt + vaultSPK +\n            dust + targetSPK\n        )\n        assert(hashOutputs == shPreimage.hashOutputs, 'hashOutputs mismatch')\n    }\n\n    // Default taproot key spend must be disabled!\n}\n```\n\n we validate the trigger transactions\n\n* contain two inputs and two outputs.\n* the amount in the first input matches the amount in the first output.\n* the address of the first input is identical to the address of the first output.\n\n```\nexport class VaultCompleteWithdrawal extends SmartContract {\n    @method()\n    public complete(\n        shPreimage: SHPreimage,\n        prevTxVer: ByteString,\n        prevTxLocktime: ByteString,\n        prevTxInputContract: ByteString, // First input chunk should also include length prefix...\n        prevTxInputFee: ByteString,\n        vaultSPK: ByteString,\n        vaultAmt: ByteString,\n        targetSPK: ByteString,\n        feePrevout: ByteString\n    ) {\n        this.csv(this.sequenceVal)\n\n        // Check sighash preimage.\n        const s = SigHashUtils.checkSHPreimage(shPreimage)\n        assert(this.checkSig(s, SigHashUtils.Gx))\n\n        // Construct prev tx.\n        const dust = toByteString('2202000000000000')\n        const prevTxId = hash256(\n            prevTxVer +\n            prevTxInputContract +\n            prevTxInputFee +\n            toByteString('02') + vaultAmt + vaultSPK + dust + targetSPK +\n            prevTxLocktime\n        )\n\n        // Enforce prevouts.\n        const hashPrevouts = sha256(\n            prevTxId + toByteString('00000000') +\n            feePrevout\n        )\n        assert(hashPrevouts == shPreimage.hashPrevouts, 'hashPrevouts mismatch')\n\n        // Enforce outputs\n        const hashOutputs = sha256(\n            vaultAmt + targetSPK\n        )\n        assert(hashOutputs == shPreimage.hashOutputs, 'hashOutputs mismatch')\n    }\n```\n\nThe Complete transactions must satisfy the following properties:\n\n* having two inputs and one output\n* the previous transaction is a Trigger transaction and contains the destination address in the second output. We parse the content of the previous transaction in line 20\u201328\n* the amount in the first output of the previous transaction matches the single output amount in the current transaction.\n\n```\nexport class VaultCancelWithdrawal extends SmartContract {\n    @method()\n    public trigger(\n        shPreimage: SHPreimage,\n        sig: Sig,\n        vaultSPK: ByteString,\n        feeSPK: ByteString,\n        vaultAmt: ByteString,\n        feeAmt: ByteString\n    ) {\n        // Check sig.\n        assert(this.checkSig(sig, this.cancelPubKey))\n\n        // Check sighash preimage.\n        const s = SigHashUtils.checkSHPreimage(shPreimage)\n        assert(this.checkSig(s, SigHashUtils.Gx))\n\n        // Enforce spent scripts.\n        const hashSpentScripts = sha256(vaultSPK + feeSPK)\n        assert(hashSpentScripts == shPreimage.hashSpentScripts, 'hashSpentScripts mismatch')\n\n        // Enforce spent amounts.\n        const hashSpentAmounts = sha256(vaultAmt + feeAmt)\n        assert(hashSpentAmounts == shPreimage.hashSpentAmounts, 'hashSpentAmounts mismatch')\n\n        // Enforce outputs.\n        const hashOutputs = sha256(\n            vaultAmt + vaultSPK\n        )\n        assert(hashOutputs == shPreimage.hashOutputs, 'hashOutputs mismatch')\n    }\n\n    // Default taproot key spend must be disabled!\n}\n```\n\nCancel transactions must ensure\n\n* there are exactly two inputs and one output\n* the amount of the first input matches the amount of the output.\n\nA single run results in the following transactions:\n\n* **Trigger Transaction ID**:\n\n[\n## Bitcoin Signet Transaction: 8c87a62ae1f95efc653af384d034846693a11bf380184aaddb91540c5e74950b\n### Explore the full Bitcoin ecosystem with The Mempool Open Source Project\u00ae. See the real-time status of your\u2026\nmempool.space\n](https://mempool.space/signet/tx/8c87a62ae1f95efc653af384d034846693a11bf380184aaddb91540c5e74950b)\n\n* **Complete Transaction ID**:\n\n(https://mempool.space/signet/tx/66b314e72c8ab07fb9b35db9e40aeff6e1b2817b89e653d6b50f7a9675d8fd9a)\n\nThe full code of our vault implementation can be found [on GitHub](https://github.com/sCrypt-Inc/scrypt-btc-vault). It has been previously [implemented on Bitcoin SV](https://scryptplatform.medium.com/non-custodial-bitcoin-vaults-880c781effa7), which has a similar but different set of opcodes.\n\n## Script versions\n\nThere are alternative implementations in bare scripts, like [purrfect_vault](https://github.com/taproot-wizards/purrfect_vault/blob/main/src/vault/script.rs) from Taproot Wizards. One major benefit of using sCrypt for implementing these vaults is its readability and maintainability. Traditional scripts are often difficult to read and modify.\n\n```\nOP_TOALTSTACK\n        OP_TOALTSTACK\n        OP_TOALTSTACK\n        OP_2DUP\n        OP_TOALTSTACK\n        OP_TOALTSTACK\n        OP_TOALTSTACK\n        OP_TOALTSTACK\n        OP_TOALTSTACK\n        // start with encoded leaf hash\n        OP_CAT\n        OP_CAT\n        OP_CAT\n        OP_CAT\n        push_slice (*DUST_AMOUNT)\n        OP_FROMALTSTACK\n        OP_CAT\n        OP_FROMALTSTACK\n        OP_FROMALTSTACK\n        OP_CAT\n        OP_SWAP\n        OP_CAT\n        OP_SHA256\n        OP_SWAP\n        OP_CAT\n        OP_CAT\n        OP_FROMALTSTACK\n        OP_FROMALTSTACK\n        OP_FROMALTSTACK\n        OP_FROMALTSTACK\n        OP_SWAP\n        OP_TOALTSTACK\n        OP_CAT\n        OP_SWAP\n        OP_TOALTSTACK\n        OP_SHA256\n        OP_SWAP\n        OP_CAT\n        OP_FROMALTSTACK\n        OP_FROMALTSTACK\n        OP_CAT\n        OP_SHA256\n        OP_SWAP\n        OP_CAT\n        OP_CAT\n        OP_CAT\n        OP_CAT\n        OP_CAT\n        OP_CAT\n```",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 477,
  "hidden": false,
  "trust_level": 0,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": "downloaded local copies of images",
  "can_view_edit_history": true,
  "wiki": false,
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}