{
  "id": 5447,
  "name": "Chris Stewart",
  "username": "Chris_Stewart_5",
  "avatar_template": "/user_avatar/delvingbitcoin.org/chris_stewart_5/{size}/296_2.png",
  "created_at": "2025-07-12T17:46:09.552Z",
  "cooked": "<h1><a name=\"p-5447-case-study-op_checktemplateverify-1\" class=\"anchor\" href=\"#p-5447-case-study-op_checktemplateverify-1\"></a>Case study: OP_CHECKTEMPLATEVERIFY</h1>\n<p>This case study explores how Script opcodes can be used to implement <strong>amount locks</strong>\u2014restrictions that ensure the value of inputs and outputs in a transaction meets certain conditions. The goal is to evaluate the required features and developer ergonomics for opcodes that push input and output amounts onto the stack. Rather than starting from scratch, we build on existing opcode proposals and retrofit them to support amount locks directly in Script.</p>\n<p>This requires two proposals I am working on:</p>\n<ol>\n<li><a href=\"https://github.com/Christewart/bips/blob/79257ba5d7a632fa828208f266fd4f5540ffba7f/bip-XXXX.mediawiki\" rel=\"noopener nofollow ugc\">64-bit arithmetic in Script</a></li>\n<li><a href=\"https://delvingbitcoin.org/t/op-inout-amount/549/3\"><code>OP_IN_AMOUNT</code> &amp; <code>OP_OUT_AMOUNT</code></a></li>\n</ol>\n<p><strong>Note:</strong> This study does not attempt to implement <em>destination locks</em>\u2014restrictions on where funds may be sent. That logic is preserved from the original proposal being examined.</p>\n<p><a href=\"https://github.com/Christewart/bitcoin/tree/2025-06-27-ctv-csfs-op-in-out-amount\" rel=\"noopener nofollow ugc\">Here</a> is a link to the repository that implements everything discussed below. A good place to start reading is the functional test: <a href=\"https://github.com/Christewart/bitcoin/blob/91815443c06b64858c532821d72c4e3a2b33aa52/test/functional/feature_ctv_amount.py\" rel=\"noopener nofollow ugc\"><code>feature_ctv_amount.py</code></a>.</p>\n<h1><a name=\"p-5447-op_checktemplateverify-2\" class=\"anchor\" href=\"#p-5447-op_checktemplateverify-2\"></a>OP_CHECKTEMPLATEVERIFY</h1>\n<p><a href=\"https://github.com/bitcoin/bips/blob/83ac8427e7f81cead035728b9c1d925aceddf0d0/bip-0119.mediawiki\" rel=\"noopener nofollow ugc\"><code>OP_CHECKTEMPLATEVERIFY</code></a> introduces a transaction template, a simple spending restriction that pattern matches a transaction against a hashed transaction specification. <code>OP_CTV</code> reduces many of the trust, interactivity, and storage requirements inherent with the use of pre-signing in applications.</p>\n<p>This case study is interested in the <a href=\"https://github.com/bitcoin/bips/blob/83ac8427e7f81cead035728b9c1d925aceddf0d0/bip-0119.mediawiki#user-content-OP_AMOUNTVERIFY\" rel=\"noopener nofollow ugc\"><code>AMOUNTVERIFY</code></a> section of the <code>OP_CTV</code> proposal. We will implement safe <a href=\"https://github.com/bitcoin/bips/blob/83ac8427e7f81cead035728b9c1d925aceddf0d0/bip-0119.mediawiki#user-content-Forwarding_Addresses\" rel=\"noopener nofollow ugc\">forwarding addresses</a> for OP_CTV that prevents users from</p>\n<ol>\n<li><a href=\"https://delvingbitcoin.org/t/understanding-and-mitigating-a-op-ctv-footgun-the-unsatisfiable-utxo/1809\">Accidentally creating unsatisfiable UTXOs</a></li>\n<li>Creating overfunded UTXOs that must pay large miner fees</li>\n</ol>\n<h2><a name=\"p-5447-safe-forwarding-addresses-with-op_in_amount-3\" class=\"anchor\" href=\"#p-5447-safe-forwarding-addresses-with-op_in_amount-3\"></a>Safe Forwarding Addresses with <code>OP_IN_AMOUNT</code></h2>\n<p>A \u201csafe\u201d forwarding address, in this context, refers to creating additional spending paths within an <code>OP_CTV</code> output\u2019s script that can be utilized when the amount received by the <code>OP_CTV</code> hash lock does <strong>not</strong> match the exact amount committed in the hash. By leveraging a proposed opcode like <code>OP_IN_AMOUNT</code> (which allows introspection of input amounts), we can build custom logic to handle such discrepancies.</p>\n<p>Let\u2019s illustrate with an example: Imagine our <code>OP_CTV</code> hash commits to spending an output that is expected to contain exactly 1 BTC. However, due to user error, only 0.9 BTC was actually sent to this <code>OP_CTV</code>-locked output. If we relied solely on the exact match specified by <code>OP_CTV</code> for a single input, this 0.9 BTC would become an <strong>unsatisfiable UTXO</strong>, permanently frozen.</p>\n<p>However, by incorporating an \u201camount lock guard\u201d using <code>OP_IN_AMOUNT</code>, we can define an alternative script path to recover these funds. Here\u2019s a conceptual representation of such a script:</p>\n<pre><code class=\"lang-auto\">OP_1,           # Push the index of the relevant input (e.g., the CTV input)\nOP_IN_AMOUNT,   # Push the actual amount of the input at that index onto the stack\n100000000,      # Push 1 BTC (in satoshis) onto the stack (the expected amount)\nOP_EQUAL,       # Check if the actual funding amount equals the expected amount\nOP_IF,          # If they are equal, execute the OP_CTV check\n  withdrawl_tx_hash, # The hash of the template transaction\n  OP_CHECKTEMPLATEVERIFY,\nOP_ELSE,        # Otherwise (if amounts don't match)\n  pub,          # Push a predefined public key\n  OP_CHECKSIG,  # Use a standard OP_CHECKSIG with this pubkey to recover funds\nOP_ENDIF\n\n</code></pre>\n<p>This script effectively encodes a \u201csafe forwarding address\u201d (or more accurately, a safe spending condition for the UTXO). If an incorrect amount of money is used to fund the <code>OP_CTV</code> output, the <code>OP_CHECKSIG</code> clause provides an accessible recovery mechanism. The funds, though misfunded, can still be spent by the holder of the <code>pub</code> key, preventing them from being irrevocably lost.</p>\n<p>Furthermore, <code>OP_IN_AMOUNT</code> allows for more sophisticated recovery logic. For instance, you could differentiate between overfunded vs. underfunded scenarios:</p>\n<ul>\n<li>\n<p><strong>Underfunded:</strong> Trigger a simple <code>OP_CHECKSIG</code> for recovery to a known address.</p>\n</li>\n<li>\n<p><strong>Overfunded (by a small amount):</strong> Perhaps apply a slightly higher miner fee to absorb the excess, or route it to a designated \u201cdust\u201d address.</p>\n</li>\n<li>\n<p><strong>Overfunded by a <em>large</em> amount (e.g., 100 BTC instead of 1 BTC):</strong> For such significant sums, you could enforce even more stringent security policies, like requiring a 2-of-3 multisig to recover the funds, rather than a single key, adding an extra layer of protection.</p>\n</li>\n</ul>\n<p>The Python test suite demonstrating this concept can be found <a href=\"https://github.com/Christewart/bitcoin/blob/91815443c06b64858c532821d72c4e3a2b33aa52/test/functional/feature_ctv_amount.py#L273\" rel=\"noopener nofollow ugc\">here</a>.</p>\n<hr>\n<h3><a name=\"p-5447-future-work-4\" class=\"anchor\" href=\"#p-5447-future-work-4\"></a>Future Work</h3>\n<p>Next, I will be addressing Salvatoshi\u2019s insightful point regarding <a href=\"https://delvingbitcoin.org/t/op-inout-amount/549/8\">amount replay attacks</a> in the context of <code>OP_IN_AMOUNT</code> and <code>OP_OUT_AMOUNT</code>. Stay tuned!</p>\n<hr>",
  "post_number": 9,
  "post_type": 1,
  "posts_count": 9,
  "updated_at": "2025-07-12T17:51:14.257Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 72,
  "reads": 26,
  "readers_count": 25,
  "score": 365.2,
  "yours": false,
  "topic_id": 549,
  "topic_slug": "op-inout-amount",
  "topic_title": "Op_inout_amount",
  "topic_html_title": "Op_inout_amount",
  "category_id": 7,
  "display_username": "Chris Stewart",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "# Case study: OP_CHECKTEMPLATEVERIFY\n\nThis case study explores how Script opcodes can be used to implement **amount locks**\u2014restrictions that ensure the value of inputs and outputs in a transaction meets certain conditions. The goal is to evaluate the required features and developer ergonomics for opcodes that push input and output amounts onto the stack. Rather than starting from scratch, we build on existing opcode proposals and retrofit them to support amount locks directly in Script.\n\nThis requires two proposals I am working on:\n\n1.  [64-bit arithmetic in Script](https://github.com/Christewart/bips/blob/79257ba5d7a632fa828208f266fd4f5540ffba7f/bip-XXXX.mediawiki)\n2.  [`OP_IN_AMOUNT` & `OP_OUT_AMOUNT`](https://delvingbitcoin.org/t/op-inout-amount/549/3)\n\n**Note:** This study does not attempt to implement _destination locks_\u2014restrictions on where funds may be sent. That logic is preserved from the original proposal being examined.\n\n[Here](https://github.com/Christewart/bitcoin/tree/2025-06-27-ctv-csfs-op-in-out-amount) is a link to the repository that implements everything discussed below. A good place to start reading is the functional test: [`feature_ctv_amount.py`](https://github.com/Christewart/bitcoin/blob/91815443c06b64858c532821d72c4e3a2b33aa52/test/functional/feature_ctv_amount.py).\n\n# OP_CHECKTEMPLATEVERIFY\n\n[`OP_CHECKTEMPLATEVERIFY`](https://github.com/bitcoin/bips/blob/83ac8427e7f81cead035728b9c1d925aceddf0d0/bip-0119.mediawiki) introduces a transaction template, a simple spending restriction that pattern matches a transaction against a hashed transaction specification. `OP_CTV` reduces many of the trust, interactivity, and storage requirements inherent with the use of pre-signing in applications.\n\nThis case study is interested in the [`AMOUNTVERIFY`](https://github.com/bitcoin/bips/blob/83ac8427e7f81cead035728b9c1d925aceddf0d0/bip-0119.mediawiki#user-content-OP_AMOUNTVERIFY) section of the `OP_CTV` proposal. We will implement safe [forwarding addresses](https://github.com/bitcoin/bips/blob/83ac8427e7f81cead035728b9c1d925aceddf0d0/bip-0119.mediawiki#user-content-Forwarding_Addresses) for OP_CTV that prevents users from\n1. [Accidentally creating unsatisfiable UTXOs](https://delvingbitcoin.org/t/understanding-and-mitigating-a-op-ctv-footgun-the-unsatisfiable-utxo/1809?u=chris_stewart_5)\n2. Creating overfunded UTXOs that must pay large miner fees\n\n## Safe Forwarding Addresses with `OP_IN_AMOUNT`\n\nA \"safe\" forwarding address, in this context, refers to creating additional spending paths within an `OP_CTV` output's script that can be utilized when the amount received by the `OP_CTV` hash lock does **not** match the exact amount committed in the hash. By leveraging a proposed opcode like `OP_IN_AMOUNT` (which allows introspection of input amounts), we can build custom logic to handle such discrepancies.\n\nLet's illustrate with an example: Imagine our `OP_CTV` hash commits to spending an output that is expected to contain exactly 1 BTC. However, due to user error, only 0.9 BTC was actually sent to this `OP_CTV`-locked output. If we relied solely on the exact match specified by `OP_CTV` for a single input, this 0.9 BTC would become an **unsatisfiable UTXO**, permanently frozen.\n\nHowever, by incorporating an \"amount lock guard\" using `OP_IN_AMOUNT`, we can define an alternative script path to recover these funds. Here's a conceptual representation of such a script:\n\n```\nOP_1,           # Push the index of the relevant input (e.g., the CTV input)\nOP_IN_AMOUNT,   # Push the actual amount of the input at that index onto the stack\n100000000,      # Push 1 BTC (in satoshis) onto the stack (the expected amount)\nOP_EQUAL,       # Check if the actual funding amount equals the expected amount\nOP_IF,          # If they are equal, execute the OP_CTV check\n  withdrawl_tx_hash, # The hash of the template transaction\n  OP_CHECKTEMPLATEVERIFY,\nOP_ELSE,        # Otherwise (if amounts don't match)\n  pub,          # Push a predefined public key\n  OP_CHECKSIG,  # Use a standard OP_CHECKSIG with this pubkey to recover funds\nOP_ENDIF\n\n```\n\nThis script effectively encodes a \"safe forwarding address\" (or more accurately, a safe spending condition for the UTXO). If an incorrect amount of money is used to fund the `OP_CTV` output, the `OP_CHECKSIG` clause provides an accessible recovery mechanism. The funds, though misfunded, can still be spent by the holder of the `pub` key, preventing them from being irrevocably lost.\n\nFurthermore, `OP_IN_AMOUNT` allows for more sophisticated recovery logic. For instance, you could differentiate between overfunded vs. underfunded scenarios:\n\n-   **Underfunded:** Trigger a simple `OP_CHECKSIG` for recovery to a known address.\n    \n-   **Overfunded (by a small amount):** Perhaps apply a slightly higher miner fee to absorb the excess, or route it to a designated \"dust\" address.\n    \n-   **Overfunded by a _large_ amount (e.g., 100 BTC instead of 1 BTC):** For such significant sums, you could enforce even more stringent security policies, like requiring a 2-of-3 multisig to recover the funds, rather than a single key, adding an extra layer of protection.\n    \n\nThe Python test suite demonstrating this concept can be found [here](https://github.com/Christewart/bitcoin/blob/91815443c06b64858c532821d72c4e3a2b33aa52/test/functional/feature_ctv_amount.py#L273).\n\n----------\n\n### Future Work\n\nNext, I will be addressing Salvatoshi's insightful point regarding [amount replay attacks](https://delvingbitcoin.org/t/op-inout-amount/549/8?u=chris_stewart_5) in the context of `OP_IN_AMOUNT` and `OP_OUT_AMOUNT`. Stay tuned!\n\n----------",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 193,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": "Github link was replaced with a permanent link",
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "<a name=\"p-5447-case-study-op_checktemplateverify-1\" class=\"anchor\" href=\"#p-5447-case-study-op_checktemplateverify-1\"></a>Case study: OP_CHECKTEMPLATEVERIFY\nThis case study explores how Script opcodes can be used to implement amount locks\u2014restrictions that ensure the value of inputs and outputs in a transaction meets certain conditions. The goal is to evaluate the required features and developer ergonomics for opcodes &hellip;",
  "truncated": true,
  "post_url": "/t/op-inout-amount/549/9",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}