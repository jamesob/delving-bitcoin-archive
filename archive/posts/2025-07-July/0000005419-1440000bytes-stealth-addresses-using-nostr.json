{
  "id": 5419,
  "name": "/dev/fd0",
  "username": "1440000bytes",
  "avatar_template": "/user_avatar/delvingbitcoin.org/1440000bytes/{size}/301_2.png",
  "created_at": "2025-07-09T16:54:40.810Z",
  "cooked": "<p>Nostr uses the same <a href=\"https://github.com/nostr-protocol/nips/blob/477e3dfd4d672a830d157f32c41795b7a143b9d7/01.md\" rel=\"noopener nofollow ugc\">cryptography</a> to generate keys as bitcoin. So, users can generate new keys from npub and receive bitcoin payments.</p>\n<p><strong>Motivation</strong></p>\n<ul>\n<li>BIP 47 v1 uses OP_RETURN for notifications</li>\n<li>Silent payments scanning affects UX</li>\n</ul>\n<p><strong>Protocol</strong></p>\n<p>Alice would generate a new key for Bob and share the notification as encrypted message using NIP-17. Bob\u2019s wallet will save the details to receive payments from Alice in future. Alice will get a new address for Bob by incrementing counter.</p>\n<p>A BIP or NIP could be written to describe the specifications and below is a proof of concept:</p>\n<p><strong>Proof of Concept</strong></p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/2X/3/32e17af5f8557aa90e0abca8852661d231a6d98f.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/32e17af5f8557aa90e0abca8852661d231a6d98f\" title=\"image\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/2X/3/32e17af5f8557aa90e0abca8852661d231a6d98f_2_690x260.png\" alt=\"image\" data-base62-sha1=\"7g6XHh5s41VKyx4lEGGtRtdYaKP\" width=\"690\" height=\"260\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/2X/3/32e17af5f8557aa90e0abca8852661d231a6d98f_2_690x260.png, https://delvingbitcoin.org/uploads/default/optimized/2X/3/32e17af5f8557aa90e0abca8852661d231a6d98f_2_1035x390.png 1.5x, https://delvingbitcoin.org/uploads/default/original/2X/3/32e17af5f8557aa90e0abca8852661d231a6d98f.png 2x\" data-dominant-color=\"393938\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">image</span><span class=\"informations\">1157\u00d7437 39.1 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/2X/b/bc40ce378b2eaf38f2805d6c1af67def195725ed.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/bc40ce378b2eaf38f2805d6c1af67def195725ed\" title=\"image\"><img src=\"https://delvingbitcoin.org/uploads/default/original/2X/b/bc40ce378b2eaf38f2805d6c1af67def195725ed.png\" alt=\"image\" data-base62-sha1=\"qRmBNxJucVxqcmn4l63T3F3tV2B\" width=\"690\" height=\"248\" data-dominant-color=\"393A39\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">image</span><span class=\"informations\">1115\u00d7402 35.2 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<pre data-code-wrap=\"python\"><code class=\"lang-python\">#!/usr/bin/env python3\n\nimport hashlib\nimport hmac\nimport secrets\nimport json\nimport os\nfrom typing import Tuple, Optional\n\nfrom nostr.key import PrivateKey, PublicKey\nimport coincurve\n\n\nclass NostrKeyGenerator:\n    \n    def __init__(self, private_key_hex: str):\n        if len(private_key_hex) != 64:\n            raise ValueError(\"Private key must be 64 hex characters\")\n        \n        try:\n            private_key_bytes = bytes.fromhex(private_key_hex)\n            self.private_key = PrivateKey(private_key_bytes)\n            self.public_key = self.private_key.public_key\n        except ValueError:\n            raise ValueError(\"Invalid hex string for private key\")\n    \n    def get_private_key_hex(self) -&gt; str:\n        return self.private_key.hex()\n    \n    def get_public_key_hex(self) -&gt; str:\n        return self.public_key.hex()\n    \n    def compute_shared_secret(self, other_public_key_hex: str) -&gt; bytes:\n        shared_secret = self.private_key.compute_shared_secret(other_public_key_hex)\n        if isinstance(shared_secret, bytes):\n            return shared_secret\n        else:\n            return bytes.fromhex(shared_secret)\n    \n    def generate_stealth_public_key(self, recipient_public_key_hex: str, counter: int = 0) -&gt; str:\n        shared_secret = self.compute_shared_secret(recipient_public_key_hex)\n        counter_bytes = counter.to_bytes(4, 'big')\n        \n        key_factor = hmac.new(shared_secret, counter_bytes + b\"stealth\", hashlib.sha256).digest()\n        \n        recipient_key_bytes = bytes.fromhex('02' + recipient_public_key_hex)\n        recipient_point = coincurve.PublicKey(recipient_key_bytes)\n        \n        factor_private_key = coincurve.PrivateKey(key_factor)\n        factor_point = factor_private_key.public_key\n        \n        combined_point = recipient_point.combine([factor_point])\n        \n        compressed_pubkey = combined_point.format(compressed=True)\n        return compressed_pubkey[1:].hex()\n    \n    def derive_stealth_private_key(self, sender_public_key_hex: str, counter: int = 0) -&gt; Tuple[str, str]:\n        shared_secret = self.compute_shared_secret(sender_public_key_hex)\n        counter_bytes = counter.to_bytes(4, 'big')\n        \n        key_factor = hmac.new(shared_secret, counter_bytes + b\"stealth\", hashlib.sha256).digest()\n        \n        factor_int = int.from_bytes(key_factor, 'big')\n        my_private_int = int(self.private_key.hex(), 16)\n        \n        secp256k1_order = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n        new_private_int = (my_private_int + factor_int) % secp256k1_order\n        \n        new_private_bytes = new_private_int.to_bytes(32, 'big')\n        new_private_key = PrivateKey(new_private_bytes)\n        \n        new_public_key = new_private_key.public_key\n        \n        coincurve_private = coincurve.PrivateKey(new_private_bytes)\n        coincurve_public = coincurve_private.public_key\n        compressed_pubkey = coincurve_public.format(compressed=True)\n        \n        return (new_private_bytes.hex(), compressed_pubkey[1:].hex())\n\n\ndef validate_hex_key(key_hex: str, key_type: str, expected_length: int) -&gt; bool:\n    if len(key_hex) != expected_length:\n        print(f\"Error: {key_type} must be {expected_length} hex characters\")\n        return False\n    \n    try:\n        bytes.fromhex(key_hex)\n        return True\n    except ValueError:\n        print(f\"Error: {key_type} must be valid hex\")\n        return False\n\n\ndef generate_stealth_public_key():\n    print(\"\\n\\033[34mYou are the SENDER. Generate a stealth public key for the recipient.\\033[0m\")\n    print()\n    \n    sender_private = input(\"Enter your private key (64 hex chars): \").strip()\n    if not validate_hex_key(sender_private, \"Private key\", 64):\n        return\n    \n    recipient_public = input(\"Enter recipient's public key (64 hex chars): \").strip()\n    if not validate_hex_key(recipient_public, \"Public key\", 64):\n        return\n    \n    try:\n        counter = int(input(\"Enter counter value (0-999, default 0): \").strip() or \"0\")\n        if counter &lt; 0 or counter &gt; 999:\n            print(\"Counter must be between 0 and 999\")\n            return\n    except ValueError:\n        print(\"Counter must be a number\")\n        return\n    \n    try:\n        keygen = NostrKeyGenerator(sender_private)\n        stealth_pubkey = keygen.generate_stealth_public_key(recipient_public, counter)\n        \n        print(f\"\\n\\033[32mGenerated Stealth Public Key: {stealth_pubkey}\\033[0m\")\n        print()\n        print(\"\\033[33mShare these details with the recipient:\\033[0m\")\n        print(f\"\\033[33m   - Your public key: {keygen.get_public_key_hex()}\\033[0m\")\n        print(f\"\\033[33m   - Counter used: {counter}\\033[0m\")\n        \n    except Exception as e:\n        print(f\"Error generating stealth public key: {e}\")\n\n\ndef derive_stealth_private_key():\n    print(\"\\n\\033[34mYou are the RECIPIENT. Derive the private key for a stealth public key.\\033[0m\")\n    print()\n    \n    recipient_private = input(\"Enter your private key (64 hex chars): \").strip()\n    if not validate_hex_key(recipient_private, \"Private key\", 64):\n        return\n    \n    sender_public = input(\"Enter sender's public key (64 hex chars): \").strip()\n    if not validate_hex_key(sender_public, \"Public key\", 64):\n        return\n    \n    try:\n        counter = int(input(\"Enter counter value used by sender: \").strip())\n        if counter &lt; 0 or counter &gt; 999:\n            print(\"Counter must be between 0 and 999\")\n            return\n    except ValueError:\n        print(\"Counter must be a number\")\n        return\n    \n    try:\n        keygen = NostrKeyGenerator(recipient_private)\n        stealth_private, stealth_public = keygen.derive_stealth_private_key(sender_public, counter)\n        \n        print(f\"\\n\\033[95mDerived Stealth Private Key: {stealth_private}\\033[0m\")\n        print(f\"\\033[32mDerived Stealth Public Key: {stealth_public}\\033[0m\")\n        print()\n        \n    except Exception as e:\n        print(f\"Error deriving private key: {e}\")\n\n\ndef generate_random_keypair():\n    \n    private_key_bytes = secrets.token_bytes(32)\n    private_key = PrivateKey(private_key_bytes)\n    \n    print(f\"\\nPrivate Key: {private_key.hex()}\")\n    print(f\"Public Key:  {private_key.public_key.hex()}\")\n    print()\n\n\ndef main():\n    while True:\n        print(\"\\n\" + \"=\"*70)\n        print(\"                    Nostr Stealth Key Generator\")\n        print(\"=\"*70)\n        print(\"1. Generate random keypair\")\n        print(\"2. Get stealth public key\")\n        print(\"3. Get stealth private key\")\n        print(\"4. Exit\")\n        print(\"=\"*70)\n        \n        choice = input(\"Enter your choice (1-4): \").strip()\n        \n        if choice == \"1\":\n            generate_random_keypair()\n        elif choice == \"2\":\n            generate_stealth_public_key()\n        elif choice == \"3\":\n            derive_stealth_private_key()\n        elif choice == \"4\":\n            break\n        else:\n            print(\"Invalid choice, please try again\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 1,
  "updated_at": "2025-07-09T17:13:25.556Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 56,
  "reads": 10,
  "readers_count": 9,
  "score": 262.0,
  "yours": false,
  "topic_id": 1816,
  "topic_slug": "stealth-addresses-using-nostr",
  "topic_title": "Stealth addresses using nostr",
  "topic_html_title": "Stealth addresses using nostr",
  "category_id": 8,
  "display_username": "/dev/fd0",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 3,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Nostr uses the same [cryptography](https://github.com/nostr-protocol/nips/blob/477e3dfd4d672a830d157f32c41795b7a143b9d7/01.md) to generate keys as bitcoin. So, users can generate new keys from npub and receive bitcoin payments.\n\n**Motivation**\n\n* BIP 47 v1 uses OP_RETURN for notifications\n* Silent payments scanning affects UX\n\n**Protocol**\n\nAlice would generate a new key for Bob and share the notification as encrypted message using NIP-17. Bob's wallet will save the details to receive payments from Alice in future. Alice will get a new address for Bob by incrementing counter.\n\nA BIP or NIP could be written to describe the specifications and below is a proof of concept:\n\n**Proof of Concept**\n\n![image|690x260](upload://7g6XHh5s41VKyx4lEGGtRtdYaKP.png)\n\n![image|690x248](upload://qRmBNxJucVxqcmn4l63T3F3tV2B.png)\n\n```python\n#!/usr/bin/env python3\n\nimport hashlib\nimport hmac\nimport secrets\nimport json\nimport os\nfrom typing import Tuple, Optional\n\nfrom nostr.key import PrivateKey, PublicKey\nimport coincurve\n\n\nclass NostrKeyGenerator:\n    \n    def __init__(self, private_key_hex: str):\n        if len(private_key_hex) != 64:\n            raise ValueError(\"Private key must be 64 hex characters\")\n        \n        try:\n            private_key_bytes = bytes.fromhex(private_key_hex)\n            self.private_key = PrivateKey(private_key_bytes)\n            self.public_key = self.private_key.public_key\n        except ValueError:\n            raise ValueError(\"Invalid hex string for private key\")\n    \n    def get_private_key_hex(self) -> str:\n        return self.private_key.hex()\n    \n    def get_public_key_hex(self) -> str:\n        return self.public_key.hex()\n    \n    def compute_shared_secret(self, other_public_key_hex: str) -> bytes:\n        shared_secret = self.private_key.compute_shared_secret(other_public_key_hex)\n        if isinstance(shared_secret, bytes):\n            return shared_secret\n        else:\n            return bytes.fromhex(shared_secret)\n    \n    def generate_stealth_public_key(self, recipient_public_key_hex: str, counter: int = 0) -> str:\n        shared_secret = self.compute_shared_secret(recipient_public_key_hex)\n        counter_bytes = counter.to_bytes(4, 'big')\n        \n        key_factor = hmac.new(shared_secret, counter_bytes + b\"stealth\", hashlib.sha256).digest()\n        \n        recipient_key_bytes = bytes.fromhex('02' + recipient_public_key_hex)\n        recipient_point = coincurve.PublicKey(recipient_key_bytes)\n        \n        factor_private_key = coincurve.PrivateKey(key_factor)\n        factor_point = factor_private_key.public_key\n        \n        combined_point = recipient_point.combine([factor_point])\n        \n        compressed_pubkey = combined_point.format(compressed=True)\n        return compressed_pubkey[1:].hex()\n    \n    def derive_stealth_private_key(self, sender_public_key_hex: str, counter: int = 0) -> Tuple[str, str]:\n        shared_secret = self.compute_shared_secret(sender_public_key_hex)\n        counter_bytes = counter.to_bytes(4, 'big')\n        \n        key_factor = hmac.new(shared_secret, counter_bytes + b\"stealth\", hashlib.sha256).digest()\n        \n        factor_int = int.from_bytes(key_factor, 'big')\n        my_private_int = int(self.private_key.hex(), 16)\n        \n        secp256k1_order = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n        new_private_int = (my_private_int + factor_int) % secp256k1_order\n        \n        new_private_bytes = new_private_int.to_bytes(32, 'big')\n        new_private_key = PrivateKey(new_private_bytes)\n        \n        new_public_key = new_private_key.public_key\n        \n        coincurve_private = coincurve.PrivateKey(new_private_bytes)\n        coincurve_public = coincurve_private.public_key\n        compressed_pubkey = coincurve_public.format(compressed=True)\n        \n        return (new_private_bytes.hex(), compressed_pubkey[1:].hex())\n\n\ndef validate_hex_key(key_hex: str, key_type: str, expected_length: int) -> bool:\n    if len(key_hex) != expected_length:\n        print(f\"Error: {key_type} must be {expected_length} hex characters\")\n        return False\n    \n    try:\n        bytes.fromhex(key_hex)\n        return True\n    except ValueError:\n        print(f\"Error: {key_type} must be valid hex\")\n        return False\n\n\ndef generate_stealth_public_key():\n    print(\"\\n\\033[34mYou are the SENDER. Generate a stealth public key for the recipient.\\033[0m\")\n    print()\n    \n    sender_private = input(\"Enter your private key (64 hex chars): \").strip()\n    if not validate_hex_key(sender_private, \"Private key\", 64):\n        return\n    \n    recipient_public = input(\"Enter recipient's public key (64 hex chars): \").strip()\n    if not validate_hex_key(recipient_public, \"Public key\", 64):\n        return\n    \n    try:\n        counter = int(input(\"Enter counter value (0-999, default 0): \").strip() or \"0\")\n        if counter < 0 or counter > 999:\n            print(\"Counter must be between 0 and 999\")\n            return\n    except ValueError:\n        print(\"Counter must be a number\")\n        return\n    \n    try:\n        keygen = NostrKeyGenerator(sender_private)\n        stealth_pubkey = keygen.generate_stealth_public_key(recipient_public, counter)\n        \n        print(f\"\\n\\033[32mGenerated Stealth Public Key: {stealth_pubkey}\\033[0m\")\n        print()\n        print(\"\\033[33mShare these details with the recipient:\\033[0m\")\n        print(f\"\\033[33m   - Your public key: {keygen.get_public_key_hex()}\\033[0m\")\n        print(f\"\\033[33m   - Counter used: {counter}\\033[0m\")\n        \n    except Exception as e:\n        print(f\"Error generating stealth public key: {e}\")\n\n\ndef derive_stealth_private_key():\n    print(\"\\n\\033[34mYou are the RECIPIENT. Derive the private key for a stealth public key.\\033[0m\")\n    print()\n    \n    recipient_private = input(\"Enter your private key (64 hex chars): \").strip()\n    if not validate_hex_key(recipient_private, \"Private key\", 64):\n        return\n    \n    sender_public = input(\"Enter sender's public key (64 hex chars): \").strip()\n    if not validate_hex_key(sender_public, \"Public key\", 64):\n        return\n    \n    try:\n        counter = int(input(\"Enter counter value used by sender: \").strip())\n        if counter < 0 or counter > 999:\n            print(\"Counter must be between 0 and 999\")\n            return\n    except ValueError:\n        print(\"Counter must be a number\")\n        return\n    \n    try:\n        keygen = NostrKeyGenerator(recipient_private)\n        stealth_private, stealth_public = keygen.derive_stealth_private_key(sender_public, counter)\n        \n        print(f\"\\n\\033[95mDerived Stealth Private Key: {stealth_private}\\033[0m\")\n        print(f\"\\033[32mDerived Stealth Public Key: {stealth_public}\\033[0m\")\n        print()\n        \n    except Exception as e:\n        print(f\"Error deriving private key: {e}\")\n\n\ndef generate_random_keypair():\n    \n    private_key_bytes = secrets.token_bytes(32)\n    private_key = PrivateKey(private_key_bytes)\n    \n    print(f\"\\nPrivate Key: {private_key.hex()}\")\n    print(f\"Public Key:  {private_key.public_key.hex()}\")\n    print()\n\n\ndef main():\n    while True:\n        print(\"\\n\" + \"=\"*70)\n        print(\"                    Nostr Stealth Key Generator\")\n        print(\"=\"*70)\n        print(\"1. Generate random keypair\")\n        print(\"2. Get stealth public key\")\n        print(\"3. Get stealth private key\")\n        print(\"4. Exit\")\n        print(\"=\"*70)\n        \n        choice = input(\"Enter your choice (1-4): \").strip()\n        \n        if choice == \"1\":\n            generate_random_keypair()\n        elif choice == \"2\":\n            generate_stealth_public_key()\n        elif choice == \"3\":\n            derive_stealth_private_key()\n        elif choice == \"4\":\n            break\n        else:\n            print(\"Invalid choice, please try again\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 247,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "Nostr uses the same <a href=\"https://github.com/nostr-protocol/nips/blob/477e3dfd4d672a830d157f32c41795b7a143b9d7/01.md\" rel=\"noopener nofollow ugc\">cryptography</a> to generate keys as bitcoin. So, users can generate new keys from npub and receive bitcoin payments. \nMotivation \n\nBIP 47 v1 uses OP_RETURN for notifications\nSilent payments scanning affects UX\n\nProtocol \nAlice would generate a new key for Bob and share the notificat&hellip;",
  "truncated": true,
  "post_url": "/t/stealth-addresses-using-nostr/1816/1",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}