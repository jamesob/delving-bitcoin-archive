{
  "id": 5391,
  "name": "Anthony Towns",
  "username": "ajtowns",
  "avatar_template": "/user_avatar/delvingbitcoin.org/ajtowns/{size}/417_2.png",
  "created_at": "2025-07-02T05:01:19.119Z",
  "cooked": "<aside class=\"quote no-group\" data-username=\"sjors\" data-post=\"80\" data-topic=\"1509\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/sjors/48/59_2.png\" class=\"avatar\"> sjors:</div>\n<blockquote>\n<p>I guess I\u2019m stuck in 2021 when we thought that just Taproot would do the trick.</p>\n</blockquote>\n</aside>\n<p>I think there\u2019s also a lack of tooling/standardisation for doing a PTLC reveal in combination with a musig 2-of-2 (which would be efficient on-chain), or even general tx signatures (ie <code>x CHECKSIGVERIFY y CHECKSIG</code>).</p>\n<p>The efficient way of doing PTLCs would be to have a partially-presigned musig2 signature for the redeem tx, where completing the signature reveals the PTLC secret to the other party. But this would require adaptor signature support for musig2, and that\u2019s not part of the spec and was removed from the secp256k1 implementation see <a href=\"https://github.com/bitcoin-core/secp256k1/pull/1479\">pr#1479</a>. Doing it less efficiently as a separate adaptor signature would work too, but even plain adaptor signatures for schnorr sigs also isn\u2019t available in secp256k1.</p>\n<p>These also aren\u2019t included even in the more experimental secp256k1-zkp project, see <a href=\"https://github.com/BlockstreamResearch/secp256k1-zkp/pull/299\">pr#299</a>, though secp256k1-zkp does have support for ECDSA-based adaptor signatures (<a href=\"https://github.com/BlockstreamResearch/secp256k1-zkp/pull/117\">pr#117</a>) and adaptor signatures in the old musig scheme that predates musig2 and <a href=\"https://github.com/bitcoin/bips/blob/36618d1c3c6b1559d0ce69fd958191b8789f350a/bip-0327.mediawiki\">BIP-327</a> (see <a href=\"https://github.com/BlockstreamResearch/secp256k1-zkp/blob/6152622613fdf1c5af6f31f74c427c4e9ee120ce/src/modules/musig/musig.md\">musig.md</a>).</p>\n<p>If the tooling were ready, I could see PTLC support being added as a \u201clet\u2019s get it in early so it\u2019s already widely supported when we actually want to enable it\u201d, but I don\u2019t think anyone considers it a high enough priority to put in the work to get the crypto stuff standardised and polished. Making the unhappy path more efficient is something that could be done later on a per-peer basis without too much hassle.</p>\n<p>Having CAT+CSFS available would avoid the tooling issue, at a cost in on-chain efficiency (though only in the unhappy path, of course), using 102 witness bytes for a PTLC reveal versus 56/67 witness bytes for a HTLC reveal. In particular, the script <code>&lt;R&gt; CAT &lt;G&gt; DUP CSFS</code> can be satisfied by having <code>&lt;s&gt;</code> on the stack where <code>s*G = R + H(R,G,G)*G</code>, so the preimage of <code>R</code> can be calculated as <code>r = s - H(R,G,G)</code>, with straightforward ECC maths, and no need for secret keys. I think with only CSFS available you continue having similar tooling problems, because you need to use adaptor signatures to prevent your counterparty from choosing a different R value for the signature.</p>\n<p>EDIT: <code>&lt;R&gt; TUCK SWAP CAT SWAP DUP CSFS</code>, which uses R for the pubkey and message as well as the nonce, probably works better \u2013 73 witness bytes for the reveal is pretty close to the HTLC version, and the calculation is just <code>r = s/(1 + H(R,R,R))</code> which is only slightly more annoying, in that it requires a modular division. (Maybe <code>OP_0</code> would be a better \u201cmessage\u201d in this case)</p>\n<p>(These issues are independent of the update complexity and peer protocol updates <a class=\"mention\" href=\"/u/instagibbs\">@instagibbs</a> describes above)</p>",
  "post_number": 82,
  "post_type": 1,
  "posts_count": 81,
  "updated_at": "2025-07-04T05:01:24.540Z",
  "reply_count": 1,
  "reply_to_post_number": 80,
  "quote_count": 1,
  "incoming_link_count": 32,
  "reads": 42,
  "readers_count": 41,
  "score": 198.4,
  "yours": false,
  "topic_id": 1509,
  "topic_slug": "ctv-csfs-can-we-reach-consensus-on-a-first-step-towards-covenants",
  "topic_title": "CTV+CSFS: Can we reach consensus on a first step towards covenants?",
  "topic_html_title": "CTV+CSFS: Can we reach consensus on a first step towards covenants?",
  "category_id": 7,
  "display_username": "Anthony Towns",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 3,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "[quote=\"sjors, post:80, topic:1509\"]\nI guess I\u2019m stuck in 2021 when we thought that just Taproot would do the trick.\n[/quote]\n\nI think there's also a lack of tooling/standardisation for doing a PTLC reveal in combination with a musig 2-of-2 (which would be efficient on-chain), or even general tx signatures (ie `x CHECKSIGVERIFY y CHECKSIG`).\n\nThe efficient way of doing PTLCs would be to have a partially-presigned musig2 signature for the redeem tx, where completing the signature reveals the PTLC secret to the other party. But this would require adaptor signature support for musig2, and that's not part of the spec and was removed from the secp256k1 implementation see [pr#1479](https://github.com/bitcoin-core/secp256k1/pull/1479). Doing it less efficiently as a separate adaptor signature would work too, but even plain adaptor signatures for schnorr sigs also isn't available in secp256k1.\n\nThese also aren't included even in the more experimental secp256k1-zkp project, see [pr#299](https://github.com/BlockstreamResearch/secp256k1-zkp/pull/299), though secp256k1-zkp does have support for ECDSA-based adaptor signatures ([pr#117](https://github.com/BlockstreamResearch/secp256k1-zkp/pull/117)) and adaptor signatures in the old musig scheme that predates musig2 and [BIP-327](https://github.com/bitcoin/bips/blob/36618d1c3c6b1559d0ce69fd958191b8789f350a/bip-0327.mediawiki) (see [musig.md](https://github.com/BlockstreamResearch/secp256k1-zkp/blob/6152622613fdf1c5af6f31f74c427c4e9ee120ce/src/modules/musig/musig.md)).\n\nIf the tooling were ready, I could see PTLC support being added as a \"let's get it in early so it's already widely supported when we actually want to enable it\", but I don't think anyone considers it a high enough priority to put in the work to get the crypto stuff standardised and polished. Making the unhappy path more efficient is something that could be done later on a per-peer basis without too much hassle.\n\nHaving CAT+CSFS available would avoid the tooling issue, at a cost in on-chain efficiency (though only in the unhappy path, of course), using 102 witness bytes for a PTLC reveal versus 56/67 witness bytes for a HTLC reveal. In particular, the script `<R> CAT <G> DUP CSFS` can be satisfied by having `<s>` on the stack where `s*G = R + H(R,G,G)*G`, so the preimage of `R` can be calculated as `r = s - H(R,G,G)`, with straightforward ECC maths, and no need for secret keys. I think with only CSFS available you continue having similar tooling problems, because you need to use adaptor signatures to prevent your counterparty from choosing a different R value for the signature.\n\nEDIT: `<R> TUCK SWAP CAT SWAP DUP CSFS`, which uses R for the pubkey and message as well as the nonce, probably works better -- 73 witness bytes for the reveal is pretty close to the HTLC version, and the calculation is just `r = s/(1 + H(R,R,R))` which is only slightly more annoying, in that it requires a modular division. (Maybe `OP_0` would be a better \"message\" in this case)\n\n(These issues are independent of the update complexity and peer protocol updates @instagibbs describes above)",
  "actions_summary": [
    {
      "id": 2,
      "count": 2
    }
  ],
  "moderator": true,
  "admin": true,
  "staff": true,
  "user_id": 3,
  "hidden": false,
  "trust_level": 4,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "I think there\u2019s also a lack of tooling/standardisation for doing a PTLC reveal in combination with a musig 2-of-2 (which would be efficient on-chain), or even general tx signatures (ie x CHECKSIGVERIFY y CHECKSIG). \nThe efficient way of doing PTLCs would be to have a partially-presigned musig2 sign&hellip;",
  "truncated": true,
  "post_url": "/t/ctv-csfs-can-we-reach-consensus-on-a-first-step-towards-covenants/1509/82",
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    },
    {
      "id": "open_mouth",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 2,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}