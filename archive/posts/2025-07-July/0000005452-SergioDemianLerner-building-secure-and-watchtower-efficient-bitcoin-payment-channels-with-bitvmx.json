{
  "id": 5452,
  "name": "",
  "username": "SergioDemianLerner",
  "avatar_template": "/letter_avatar_proxy/v4/letter/s/779978/{size}.png",
  "created_at": "2025-07-14T12:18:28.590Z",
  "cooked": "<p>Hi!\nI\u2019m copypasting here an article I wrote about how to create Watchtower-efficient payment channels with BitVMX.\nThe original article is here: <a href=\"https://bitvmx.org/knowledge/building-secure-and-watchtower-efficient-bitcoin-payment-channels-with-bitvmx\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">BitVMX | Building Secure and Watchtower-efficient Bitcoin Payment Channels with BitVMX</a>.</p>\n<h2><a name=\"p-5452-intro-1\" class=\"anchor\" href=\"#p-5452-intro-1\"></a>Intro</h2>\n<p>This article presents a sample payment channel that uses to support efficient revocations. It can be easily extended to function as a state channel and support Hash-Time Locked Contracts (HTLCs) for lightning-like routing. However, we aim to keep it simple so that it serves as a clear example of BitVMX\u2019s capabilities and how it can be integrated as a subcomponent of other Bitcoin protocols. In this example, BitVMX is used to handle state revocations and enable efficient watchtowers that store only O(1) data per payment channel.</p>\n<p>Each state of our toy payment channel has a sequence number <em>i</em>, which increments with every state update. When the parties agree to move to the next state (e.g., rebalance the shared account), they must co-sign three transactions. They can use a multisig or MuSig2 scheme to reduce the on-chain footprint. Then, they create two revocation messages\u2014one for each party\u2014signed with Schnorr signatures. A revocation message contains the new state sequence number <em>i</em> and represents the message: \u201cI revoke all states prior to <em>i</em>.\u201d In practice, the message is simply the number <em>i</em>, signed with a private key designated solely for this purpose.</p>\n<p>When Alice wants to unilaterally close the channel, she can only do so by signing the sequence number <em>i</em> using a one-time signature (OTS) scheme. This sequence number defines the state that Alice claims should determine the final balance distribution between her and Bob. If Alice uses an outdated state\u2014say she signs <em>j</em>, with <em>j &lt; i</em>\u2014a dispute mechanism is triggered to penalize her. Bob simply needs to present the OTS-signed value j and the Schnorr-signed message \u201cI revoke all states prior to <em>i</em>,\u201d which Alice previously issued and which Bob has stored. A Bitcoin script verifies the OTS signature, while a RISC-V program executed via BitVMX verifies the Schnorr signature and checks whether <em>j &lt; i</em>. If this condition holds, Bob wins the dispute and can claim all funds in the channel.</p>\n<hr>\n<h2><a name=\"p-5452-transaction-dag-2\" class=\"anchor\" href=\"#p-5452-transaction-dag-2\"></a>Transaction DAG</h2>\n<p>The figure below illustrates the transaction directed acyclic graph (DAG) created by the protocol. Only the <em>SetupTx</em> is published on-chain; other transactions are published only as needed.</p>\n<ul>\n<li><strong>Violet boxes</strong>: Transactions published by Alice</li>\n<li><strong>Pink boxes</strong>: Transactions published by Bob</li>\n<li><strong>Yellow boxes</strong>: A sequence of transactions issued alternatively by Alice, Bob, or their watchtowers</li>\n<li><strong>Orange boxes</strong>: Transactions re-created with every state update</li>\n<li><strong>Gray box</strong>: A transaction issued by a watchtower</li>\n<li><strong>Green box</strong>: The initial funding transaction, which either owner can issue</li>\n</ul>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/2X/2/28127e8640a68547524613703e885a1971effd3c.jpeg\" data-download-href=\"https://delvingbitcoin.org/uploads/default/28127e8640a68547524613703e885a1971effd3c\" title=\"\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/2X/2/28127e8640a68547524613703e885a1971effd3c_2_527x499.jpeg\" alt=\"\" data-base62-sha1=\"5IuINqxtg1Dauh381UTGjbPZH7S\" role=\"presentation\" width=\"527\" height=\"499\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/2X/2/28127e8640a68547524613703e885a1971effd3c_2_527x499.jpeg, https://delvingbitcoin.org/uploads/default/optimized/2X/2/28127e8640a68547524613703e885a1971effd3c_2_790x748.jpeg 1.5x, https://delvingbitcoin.org/uploads/default/optimized/2X/2/28127e8640a68547524613703e885a1971effd3c_2_1054x998.jpeg 2x\" data-dominant-color=\"EAE6DE\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\"></span><span class=\"informations\">1999\u00d71894 251 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>The transaction Direct Acyclic Graph (DAG) for a Simple Payment Channel</p>\n<p>When Alice publishes <em>StartTx(j)</em>, she commits to the sequence number <em>j</em>. Either Alice or Bob can then OTS-sign the value <em>j</em> in <em>AssertTx(j)</em>. Normally, Alice signs this transaction. However, we must consider whether Bob could disrupt the protocol by signing it himself. If Bob detects that <em>j</em> is not the latest state <em>i</em>, he should refrain from signing <em>AssertTx(j)</em>\u2014he lacks Alice\u2019s signed sequence number for <em>j</em> and thus cannot initiate a valid dispute. If <em>j = i</em>, Bob can safely sign and publish <em>AssertTx(i)</em>, which won\u2019t affect the protocol\u2019s integrity.</p>\n<h2><a name=\"p-5452-setup-3\" class=\"anchor\" href=\"#p-5452-setup-3\"></a>Setup</h2>\n<p>There are two main parties in this protocol: Alice and Bob, referred to as the <strong>owners</strong> of the channel. Optional auxiliary parties, <em>Wa</em> and <em>Wb</em>, act as watchtowers for Alice and Bob, respectively.</p>\n<h3><a name=\"p-5452-initialization-4\" class=\"anchor\" href=\"#p-5452-initialization-4\"></a>Initialization</h3>\n<ol>\n<li>Each owner chooses a hidden pre-image (<em>Pa</em> by Alice and <em>Pb</em> by Bob) and sends the other the corresponding hash (<em>Ha = H\u00b6</em> and <em>Hb = H(Pb)</em>).</li>\n<li>Each owner generates an OTS key pair (pair <em>A1</em> for Alice and <em>B1</em> for <em>Bob</em>) for signing sequence values <em>i</em>, using 32-bit unsigned integers to allow up to 4 billion updates. Public keys are exchanged.</li>\n<li>Both parties construct a DAG of co-signed transactions, including:</li>\n</ol>\n<ul>\n<li><em>SetupTx</em></li>\n<li>BitVMX Dispute Channels</li>\n<li><em>AliceWinsTx()</em>, <em>BobWinsTx()</em></li>\n<li><em>TimerForBobTx</em>, <em>TimerForAliceTx</em></li>\n<li><em>TimeoutForAliceTx</em>, <em>TimeoutForBobTx</em></li>\n</ul>\n<ol start=\"4\">\n<li>They create the initial transactions: <em>PayTx(0)</em>, <em>AssertTx(0)</em>, and <em>StartTx(0)</em>. These define an initial exit path where each owner can withdraw their initial deposit. No revocation messages exist at this point, so no challenges are possible.</li>\n<li>Each owner generates another OTS key pair (<em>A2</em> by Alice, <em>B2</em> by Bob) for signing inputs to dispute channels.</li>\n<li>If watchtowers are used, they provide their OTS public keys to the owners, who create additional dispute channels that only the watchtower can sign.</li>\n</ol>\n<hr>\n<h2><a name=\"p-5452-advancing-to-the-next-state-5\" class=\"anchor\" href=\"#p-5452-advancing-to-the-next-state-5\"></a>Advancing to the Next State</h2>\n<p>When a payment occurs (e.g., Alice pays Bob), both parties must advance to the next state and revoke the previous one. Without loss of generality, let\u2019s assume Alice is paying Bob. Bob has an incentive to complete the protocol.</p>\n<ol>\n<li><strong>Alice and Bob sign</strong> <em>PayTx(t)</em> and <em>AssertTx(i)</em>, exchanging signatures.</li>\n<li><strong>Bob signs</strong> <em>StartTx(t)</em> and sends it to Alice. Now Alice can continue with either state, but Bob can only use the old state. Since he received funds, Bob is motivated to proceed.</li>\n<li><strong>Alice gives Bob</strong> a revocation message <em>Ma(i)</em>, which is a Schnorr signature on <em>i</em>, representing: \u201cI, Alice, revoke all states prior to <em>i</em>.\u201d Now Alice can only use the new state.</li>\n<li><strong>Alice co-signs</strong> <em>StartTx(t)</em> and sends it to Bob. Alice can only use the new state; Bob could use either, but the new state benefits him more.</li>\n<li><strong>Bob forwards</strong> Alice\u2019s revocation to his watchtower and issues his own revocation message <em>Mb(i)</em> to Alice. At this point, neither party can safely use the old state.</li>\n</ol>\n<hr>\n<h2><a name=\"p-5452-liveness-guarantees-during-state-transitions-6\" class=\"anchor\" href=\"#p-5452-liveness-guarantees-during-state-transitions-6\"></a>Liveness Guarantees During State Transitions</h2>\n<p>To prevent a party from stalling the protocol mid-update, the channel includes a timeout mechanism. If Alice issues <em>StartTx(j)</em> but delays or refuses to issue the corresponding <em>AssertTx(j)</em> in a timely manner, Bob can respond by publishing <em>TimerForAliceTx</em>. This transaction initiates a countdown, giving Alice a limited window to publish <em>AssertTx(j)</em>. If Alice fails to do so before the timer expires, Bob may publish <em>TimeoutForAliceTx</em>, which awards him all funds in the channel as a penalty for Alice\u2019s non-cooperation.</p>\n<p>The timer is triggered using the preimage <em>Pa</em>, which Alice reveals when she publishes <em>StartTx(j)</em>. This ensures that only Alice can start this process, and only Bob can enforce the timeout based on her actions.</p>\n<hr>\n<h2><a name=\"p-5452-closing-the-channel-7\" class=\"anchor\" href=\"#p-5452-closing-the-channel-7\"></a>Closing the Channel</h2>\n<p>If both parties agree to close the channel, they co-sign a payment transaction that spends directly from the SetupTx, distributing the funds accordingly. If funds remain in intermediate connector outputs (used for pre-paying fees or managing dust outputs), they can also be collected and shared.</p>\n<p>If one party becomes uncooperative, the other performs a <strong>unilateral close</strong>:</p>\n<ul>\n<li>Publish the latest <em>StartTx</em> and <em>AssertTx</em></li>\n<li>Wait for a potential dispute</li>\n<li>Publish <em>PayTx</em>, which is timelocked to allow dispute resolution</li>\n</ul>\n<p>The <em>PayTx</em> timeout can be shortened when no dispute occurs, it doesn\u2019t need to match the dispute worse case time, but this complexity is omitted here to keep the transaction DAG simple.</p>\n<hr>\n<h2><a name=\"p-5452-watchtowers-8\" class=\"anchor\" href=\"#p-5452-watchtowers-8\"></a>Watchtowers</h2>\n<p>Watchtowers receive periodic revocation messages <em>M(i)</em> for a given payment channel, identified by a monitoring ID (<em>MoId</em>). The <em>MoId</em> is derived from the channel\u2019s funding transaction ID and the owner\u2019s public key. If the same watchtower monitors both parties, each will have a distinct <em>MoId</em>.</p>\n<p>When a watchtower receives a new revocation <em>M(i)</em>, it can safely discard all prior revocations for the same <em>MoId</em>. This is a significant improvement over Lightning Network watchtowers, which must store a revocation key for every state update. Thanks to BitVMX\u2019s ability to verify complex logic off-chain, revocations become more storage-efficient and secure.</p>\n<hr>\n<h2><a name=\"p-5452-htlcs-9\" class=\"anchor\" href=\"#p-5452-htlcs-9\"></a>HTLCs</h2>\n<p>(This section is available in the original article since it has more images and this forum restricts to 1 image per post)</p>\n<hr>\n<h2><a name=\"p-5452-summary-10\" class=\"anchor\" href=\"#p-5452-summary-10\"></a>Summary</h2>\n<p>This article introduced a sample Bitcoin payment channel that leverages BitVMX to enable efficient state revocations and support for compact watchtower implementations. By encoding state revocation logic through Schnorr-signed messages and verifying them using BitVMX, the protocol achieves robust dispute resolution with minimal on-chain data. The payment channel uses a directed acyclic graph (DAG) of transactions, with one-time signatures (OTS) enforcing state commitments. Watchtowers benefit from an O(1) storage requirement by tracking only the latest revocation message per channel, improving upon the standard Lightning Network approach. We also show how to add HTLCs, PTLCs and other new locking functions. While the design is simplified for clarity, it highlights the extensibility of BitVMX in constructing secure and efficient off-chain Bitcoin protocols.</p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 1,
  "updated_at": "2025-07-14T12:23:32.094Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 2,
  "reads": 13,
  "readers_count": 12,
  "score": 12.6,
  "yours": false,
  "topic_id": 1830,
  "topic_slug": "building-secure-and-watchtower-efficient-bitcoin-payment-channels-with-bitvmx",
  "topic_title": "Building Secure and Watchtower-efficient Bitcoin Payment Channels with BitVMX",
  "topic_html_title": "Building Secure and Watchtower-efficient Bitcoin Payment Channels with BitVMX",
  "category_id": 7,
  "display_username": "",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Hi! \nI'm copypasting here an article I wrote about how to create Watchtower-efficient payment channels with BitVMX.\nThe original article is here: https://bitvmx.org/knowledge/building-secure-and-watchtower-efficient-bitcoin-payment-channels-with-bitvmx.\n\n## Intro\n\nThis article presents a sample payment channel that uses to support efficient revocations. It can be easily extended to function as a state channel and support Hash-Time Locked Contracts (HTLCs) for lightning-like routing. However, we aim to keep it simple so that it serves as a clear example of BitVMX\u2019s capabilities and how it can be integrated as a subcomponent of other Bitcoin protocols. In this example, BitVMX is used to handle state revocations and enable efficient watchtowers that store only O(1) data per payment channel.\n\n\n\nEach state of our toy payment channel has a sequence number *i*, which increments with every state update. When the parties agree to move to the next state (e.g., rebalance the shared account), they must co-sign three transactions. They can use a multisig or MuSig2 scheme to reduce the on-chain footprint. Then, they create two revocation messages\u2014one for each party\u2014signed with Schnorr signatures. A revocation message contains the new state sequence number *i* and represents the message: \"I revoke all states prior to *i*.\" In practice, the message is simply the number *i*, signed with a private key designated solely for this purpose.\n\nWhen Alice wants to unilaterally close the channel, she can only do so by signing the sequence number *i* using a one-time signature (OTS) scheme. This sequence number defines the state that Alice claims should determine the final balance distribution between her and Bob. If Alice uses an outdated state\u2014say she signs *j*, with *j < i*\u2014a dispute mechanism is triggered to penalize her. Bob simply needs to present the OTS-signed value j and the Schnorr-signed message \u201cI revoke all states prior to *i*,\u201d which Alice previously issued and which Bob has stored. A Bitcoin script verifies the OTS signature, while a RISC-V program executed via BitVMX verifies the Schnorr signature and checks whether *j < i*. If this condition holds, Bob wins the dispute and can claim all funds in the channel.\n\n---\n\n## Transaction DAG\n\nThe figure below illustrates the transaction directed acyclic graph (DAG) created by the protocol. Only the *SetupTx* is published on-chain; other transactions are published only as needed.\n\n* **Violet boxes**: Transactions published by Alice\n* **Pink boxes**: Transactions published by Bob\n* **Yellow boxes**: A sequence of transactions issued alternatively by Alice, Bob, or their watchtowers\n* **Orange boxes**: Transactions re-created with every state update\n* **Gray box**: A transaction issued by a watchtower\n* **Green box**: The initial funding transaction, which either owner can issue\n\n![](upload://5IuINqxtg1Dauh381UTGjbPZH7S.jpeg)\n\nThe transaction Direct Acyclic Graph (DAG) for a Simple Payment Channel\n\nWhen Alice publishes *StartTx(j)*, she commits to the sequence number *j*. Either Alice or Bob can then OTS-sign the value *j* in *AssertTx(j)*. Normally, Alice signs this transaction. However, we must consider whether Bob could disrupt the protocol by signing it himself. If Bob detects that *j* is not the latest state *i*, he should refrain from signing *AssertTx(j)*\u2014he lacks Alice\u2019s signed sequence number for *j* and thus cannot initiate a valid dispute. If *j = i*, Bob can safely sign and publish *AssertTx(i)*, which won\u2019t affect the protocol\u2019s integrity.\n\n## Setup\n\nThere are two main parties in this protocol: Alice and Bob, referred to as the **owners** of the channel. Optional auxiliary parties, *Wa* and *Wb*, act as watchtowers for Alice and Bob, respectively.\n\n### Initialization\n\n1. Each owner chooses a hidden pre-image (*Pa* by Alice and *Pb* by Bob) and sends the other the corresponding hash (*Ha = H(Pa)* and *Hb = H(Pb)*).\n2. Each owner generates an OTS key pair (pair *A1* for Alice and *B1* for *Bob*) for signing sequence values *i*, using 32-bit unsigned integers to allow up to 4 billion updates. Public keys are exchanged.\n3. Both parties construct a DAG of co-signed transactions, including:\n\n  * *SetupTx*\n  * BitVMX Dispute Channels\n  * *AliceWinsTx()*, *BobWinsTx()*\n  * *TimerForBobTx*, *TimerForAliceTx*\n  * *TimeoutForAliceTx*, *TimeoutForBobTx*\n4. They create the initial transactions: *PayTx(0)*, *AssertTx(0)*, and *StartTx(0)*. These define an initial exit path where each owner can withdraw their initial deposit. No revocation messages exist at this point, so no challenges are possible.\n5. Each owner generates another OTS key pair (*A2* by Alice, *B2* by Bob) for signing inputs to dispute channels.\n6. If watchtowers are used, they provide their OTS public keys to the owners, who create additional dispute channels that only the watchtower can sign.\n\n---\n\n## Advancing to the Next State\n\nWhen a payment occurs (e.g., Alice pays Bob), both parties must advance to the next state and revoke the previous one. Without loss of generality, let\u2019s assume Alice is paying Bob. Bob has an incentive to complete the protocol.\n\n1. **Alice and Bob sign** *PayTx(t)* and *AssertTx(i)*, exchanging signatures.\n2. **Bob signs** *StartTx(t)* and sends it to Alice. Now Alice can continue with either state, but Bob can only use the old state. Since he received funds, Bob is motivated to proceed.\n3. **Alice gives Bob** a revocation message *Ma(i)*, which is a Schnorr signature on *i*, representing: \u201cI, Alice, revoke all states prior to *i*.\u201d Now Alice can only use the new state.\n4. **Alice co-signs** *StartTx(t)* and sends it to Bob. Alice can only use the new state; Bob could use either, but the new state benefits him more.\n5. **Bob forwards** Alice\u2019s revocation to his watchtower and issues his own revocation message *Mb(i)* to Alice. At this point, neither party can safely use the old state.\n\n---\n\n## Liveness Guarantees During State Transitions\n\nTo prevent a party from stalling the protocol mid-update, the channel includes a timeout mechanism. If Alice issues *StartTx(j)* but delays or refuses to issue the corresponding *AssertTx(j)* in a timely manner, Bob can respond by publishing *TimerForAliceTx*. This transaction initiates a countdown, giving Alice a limited window to publish *AssertTx(j)*. If Alice fails to do so before the timer expires, Bob may publish *TimeoutForAliceTx*, which awards him all funds in the channel as a penalty for Alice\u2019s non-cooperation.\n\nThe timer is triggered using the preimage *Pa*, which Alice reveals when she publishes *StartTx(j)*. This ensures that only Alice can start this process, and only Bob can enforce the timeout based on her actions.\n\n---\n\n## Closing the Channel\n\nIf both parties agree to close the channel, they co-sign a payment transaction that spends directly from the SetupTx, distributing the funds accordingly. If funds remain in intermediate connector outputs (used for pre-paying fees or managing dust outputs), they can also be collected and shared.\n\nIf one party becomes uncooperative, the other performs a **unilateral close**:\n\n* Publish the latest *StartTx* and *AssertTx*\n* Wait for a potential dispute\n* Publish *PayTx*, which is timelocked to allow dispute resolution\n\nThe *PayTx* timeout can be shortened when no dispute occurs, it doesn\u2019t need to match the dispute worse case time, but this complexity is omitted here to keep the transaction DAG simple.\n\n---\n\n## Watchtowers\n\nWatchtowers receive periodic revocation messages *M(i)* for a given payment channel, identified by a monitoring ID (*MoId*). The *MoId* is derived from the channel\u2019s funding transaction ID and the owner\u2019s public key. If the same watchtower monitors both parties, each will have a distinct *MoId*.\n\nWhen a watchtower receives a new revocation *M(i)*, it can safely discard all prior revocations for the same *MoId*. This is a significant improvement over Lightning Network watchtowers, which must store a revocation key for every state update. Thanks to BitVMX\u2019s ability to verify complex logic off-chain, revocations become more storage-efficient and secure.\n\n---\n\n## HTLCs\n\n(This section is available in the original article since it has more images and this forum restricts to 1 image per post)\n\n---\n\n## Summary\n\nThis article introduced a sample Bitcoin payment channel that leverages BitVMX to enable efficient state revocations and support for compact watchtower implementations. By encoding state revocation logic through Schnorr-signed messages and verifying them using BitVMX, the protocol achieves robust dispute resolution with minimal on-chain data. The payment channel uses a directed acyclic graph (DAG) of transactions, with one-time signatures (OTS) enforcing state commitments. Watchtowers benefit from an O(1) storage requirement by tracking only the latest revocation message per channel, improving upon the standard Lightning Network approach. We also show how to add HTLCs, PTLCs and other new locking functions. While the design is simplified for clarity, it highlights the extensibility of BitVMX in constructing secure and efficient off-chain Bitcoin protocols.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 855,
  "hidden": false,
  "trust_level": 0,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": "downloaded local copies of images",
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "Hi!\nI\u2019m copypasting here an article I wrote about how to create Watchtower-efficient payment channels with BitVMX.\nThe original article is here: <a href=\"https://bitvmx.org/knowledge/building-secure-and-watchtower-efficient-bitcoin-payment-channels-with-bitvmx\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">BitVMX | Building Secure and Watchtower-efficient Bitcoin Payment Channels with BitVMX</a>. \n<a name=\"p-5452-intro-1\" class=\"anchor\" href=\"#p-5452-intro-1\"></a>Intro\nThis article presents a sample payment channel that uses to &hellip;",
  "truncated": true,
  "post_url": "/t/building-secure-and-watchtower-efficient-bitcoin-payment-channels-with-bitvmx/1830/1",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false
}