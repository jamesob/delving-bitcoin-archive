{
  "id": 6884,
  "name": "Oleks",
  "username": "olkurbatov",
  "avatar_template": "/user_avatar/delvingbitcoin.org/olkurbatov/{size}/299_2.png",
  "created_at": "2026-02-16T20:53:40.683Z",
  "cooked": "<p>We can also extend BLISK with DLC-style adaptor points. Precisely, we can perform adaptor/condition-dependent compilation.</p>\n<h2><a name=\"p-6884-the-idea-1\" class=\"anchor\" href=\"#p-6884-the-idea-1\" aria-label=\"Heading link\"></a>The Idea</h2>\n<p>Consider the policy <span class=\"math\">A\\land(B \\lor C)</span> - Alice is required, plus one of Bob or Carol. Now suppose we want a fallback: if some external condition is met (a price change, timeout, etc.), Bob or Carol can spend without Alice.</p>\n<p>We can do this by wrapping Alice\u2019s input node in a disjunction with an adaptor point <span class=\"math\">T_a</span> derived from an oracle\u2019s pre-committed parameters:</p>\n<div class=\"math\">\nT_a = R_i + \\mathcal{H}(P_O, R_i, e)\\cdot P_O,\n</div>\n<p>where <span class=\"math\">P_O</span> is the oracle\u2019s long-term public key, <span class=\"math\">R_i</span> is a pre-committed nonce for attestation slot <span class=\"math\">i</span>, and <span class=\"math\">e</span> is the event descriptor (e.g., encoded price or timestamp).</p>\n<p>Before the oracle signs <span class=\"math\">e</span>, nobody knows <span class=\"math\">\\mathsf{dlog}(T_a)</span>. After attestation, the oracle publishes</p>\n<div class=\"math\">\ns_i = r_i + \\mathcal{H}(P_O, R_i, e)\\cdot sk_O,\n</div>\n<p>which is exactly the secret key for <span class=\"math\">T_a</span>.</p>\n<p>The modified policy becomes <span class=\"math\">(A\\lor T_a)\\land(B \\lor C)</span>. After we compile this policy, we receive a single root key (like in a classic BLISK).</p>\n<blockquote>\n<p>An important part here is a proof-carrying compilation: when the <span class=\"math\">(A\\lor T_a)</span>\nOR gate is compiled, Alice must prove <span class=\"math\">T_a</span> and <span class=\"math\">\\mathsf{ECDH}(A, T_a)</span> were correctly constructed from the agreed oracle parameters <span class=\"math\">(R_i, P_O, e)</span>. Without this proof, Alice could substitute a point with a known discrete log and keep her veto forever, while the fallback is silently dead. The mentioned <span class=\"math\">\\Pi.\\mathsf{Prove}</span> step handles this; it just gets a slightly richer relation.</p>\n</blockquote>\n<p>After the oracle signed an appropriate event, Bob or Carol extracts <span class=\"math\">sk_{T_a} \\gets s_i</span> from the oracle\u2019s public signature, derives the OR-gate shared secret via <span class=\"math\">\\mathcal{H}(sk_{T_a} \\cdot P_A)</span>, and signs. In other words, the policy collapses to <span class=\"math\">B \\lor C</span>. The verifier still checks one signature against the same root key; no difference is visible.</p>\n<p>Pros:</p>\n<ul>\n<li>If the oracle signs a defined event properly, the adaptor unlocks, and the access structure changes automatically with no participant interaction</li>\n<li>The oracle follows a standard DLC attestation protocol and doesn\u2019t even know that some policies depend on it (for the timelock case, imagine the server (it can be MPC or your own time server), which signs a new timestamp every 1000 ms)</li>\n<li>Different gates can reference different oracles and events* (we can apply DLC to the entire circuit, to some subtree, or even to a single user or key)</li>\n<li>The existence of oracle conditions, trigger events, and policy structure remains hidden</li>\n</ul>\n<blockquote>\n<p>*If we have a condition logic like:</p>\n<pre><code class=\"lang-auto\">if (e == 1) then A\nelse if (e == 2) then A + B\n...\nelse if (e == n) then A + B + ... + N\n</code></pre>\n<p>it can still be compressed to a single key after BLISK compilation</p>\n</blockquote>\n<p>Limitations and caveats:</p>\n<ul>\n<li>Liveness of the oracle and the need to monitor it</li>\n<li>Irreversibility: once attested, <span class=\"math\">T_a</span> is permanently unlocked</li>\n<li>Each adaptor point is bound to a specific <span class=\"math\">(R_i, e)</span> pair. Nonce reuse breaks security; the usage of a different nonce from the committed one breaks the adaptor</li>\n</ul>",
  "post_number": 15,
  "post_type": 1,
  "posts_count": 15,
  "updated_at": "2026-02-16T20:53:40.683Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 8,
  "readers_count": 7,
  "score": 1.4,
  "yours": false,
  "topic_id": 2217,
  "topic_slug": "blisk-boolean-circuit-logic-integrated-into-the-single-key",
  "topic_title": "BLISK: Boolean circuit Logic Integrated into the Single Key",
  "topic_html_title": "BLISK: Boolean circuit Logic Integrated into the Single Key",
  "category_id": 7,
  "display_username": "Oleks",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": "",
  "bookmarked": false,
  "raw": "We can also extend BLISK with DLC-style adaptor points. Precisely, we can perform adaptor/condition-dependent compilation.\n\n## The Idea\nConsider the policy $A\\land(B \\lor C)$ - Alice is required, plus one of Bob or Carol. Now suppose we want a fallback: if some external condition is met (a price change, timeout, etc.), Bob or Carol can spend without Alice.\n\nWe can do this by wrapping Alice's input node in a disjunction with an adaptor point $T_a$ derived from an oracle's pre-committed parameters:\n$$T_a = R_i + \\mathcal{H}(P_O, R_i, e)\\cdot P_O,$$\nwhere $P_O$ is the oracle's long-term public key, $R_i$ is a pre-committed nonce for attestation slot $i$, and $e$ is the event descriptor (e.g., encoded price or timestamp).\n\nBefore the oracle signs $e$, nobody knows $\\mathsf{dlog}(T_a)$. After attestation, the oracle publishes \n$$s_i = r_i + \\mathcal{H}(P_O, R_i, e)\\cdot sk_O,$$\nwhich is exactly the secret key for $T_a$.\n\nThe modified policy becomes $(A\\lor T_a)\\land(B \\lor C)$. After we compile this policy, we receive a single root key (like in a classic BLISK). \n\n> An important part here is a proof-carrying compilation: when the $(A\\lor T_a)$\nOR gate is compiled, Alice must prove $T_a$ and $\\mathsf{ECDH}(A, T_a)$ were correctly constructed from the agreed oracle parameters $(R_i, P_O, e)$. Without this proof, Alice could substitute a point with a known discrete log and keep her veto forever, while the fallback is silently dead. The mentioned $\\Pi.\\mathsf{Prove}$ step handles this; it just gets a slightly richer relation.\n\nAfter the oracle signed an appropriate event, Bob or Carol extracts $sk_{T_a} \\gets s_i$ from the oracle's public signature, derives the OR-gate shared secret via $\\mathcal{H}(sk_{T_a} \\cdot P_A)$, and signs. In other words, the policy collapses to $B \\lor C$. The verifier still checks one signature against the same root key; no difference is visible.\n\nPros:\n- If the oracle signs a defined event properly, the adaptor unlocks, and the access structure changes automatically with no participant interaction\n- The oracle follows a standard DLC attestation protocol and doesn't even know that some policies depend on it (for the timelock case, imagine the server (it can be MPC or your own time server), which signs a new timestamp every 1000 ms)\n- Different gates can reference different oracles and events* (we can apply DLC to the entire circuit, to some subtree, or even to a single user or key)\n- The existence of oracle conditions, trigger events, and policy structure remains hidden\n\n> *If we have a condition logic like:\n> ```\n> if (e == 1) then A\n> else if (e == 2) then A + B\n> ...\n> else if (e == n) then A + B + ... + N\n> ```\n> it can still be compressed to a single key after BLISK compilation\n\nLimitations and caveats:\n- Liveness of the oracle and the need to monitor it\n- Irreversibility: once attested, $T_a$ is permanently unlocked\n- Each adaptor point is bound to a specific $(R_i, e)$ pair. Nonce reuse breaks security; the usage of a different nonce from the committed one breaks the adaptor",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 246,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "We can also extend BLISK with DLC-style adaptor points. Precisely, we can perform adaptor/condition-dependent compilation. \n<a name=\"p-6884-the-idea-1\" class=\"anchor\" href=\"#p-6884-the-idea-1\" aria-label=\"Heading link\"></a>The Idea\nConsider the policy A\\land(B \\lor C) - Alice is required, plus one of Bob or Carol. Now suppose we want a fallback: if some external condition is met (a price change, &hellip;",
  "truncated": true,
  "post_url": "/t/blisk-boolean-circuit-logic-integrated-into-the-single-key/2217/15",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}