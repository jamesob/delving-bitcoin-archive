{
  "id": 6940,
  "name": "Ilya Evdokimov",
  "username": "evd0kim",
  "avatar_template": "/user_avatar/delvingbitcoin.org/evd0kim/{size}/1111_2.png",
  "created_at": "2026-02-24T14:54:52.568Z",
  "cooked": "<h3><a name=\"p-6940-summary-1\" class=\"anchor\" href=\"#p-6940-summary-1\" aria-label=\"Heading link\"></a>Summary</h3>\n<p>In the previous piece, <a href=\"https://delvingbitcoin.org/t/zk-statechains-without-states/2166\">\"ZK-Statechains Without States,</a>\" we outlined the idea of combining statechain peg-in/out mechanisms for ZK-rollups. This post further expands into a specific protocol implementation that leverages a zerocash transaction architecture for private transfers using Aztec Barretenberg circuits. The network may consist of validators, provers, regular nodes, and <a href=\"https://delvingbitcoin.org/t/building-a-vault-using-blinded-co-signers/2141/3\">blind signers</a>, which can operate independently of each other. The existing prototype implements a simplified blind vault setup and employs RISC Zero circuits for pre-signing transactions and withdrawals. Additionally, we deploy a federation for our bridge model versus other rollup-style bridges (i.e. BitVM2). With further modifications, we believe we can see the user have a signing key in the blind vault as well as see the user be able to transfer ownership of the vault making it similar to a Mercury Layer-style transfer.  In this model, the user becomes a co-signer in the vault with relative timelock verification either via RISC Zero circuits or during private note transfer. The ZK-rollup design may be extended with additional circuits to support specific smart-contracting functions. It may be for example, collateral management. The project is built on top of the Bitcoin Development Kit library and reuses code and components from the <a href=\"https://delvingbitcoin.org/t/building-a-vault-using-blinded-co-signers/2141\">blind vault project</a> by <a class=\"mention\" href=\"/u/halseth\">@Halseth</a>.</p>\n<p><a href=\"https://github.com/zerosats/ciphera-appchain\" rel=\"noopener nofollow ugc\">GitHub Ciphera Chain</a>.</p>\n<h3><a name=\"p-6940-network-entities-2\" class=\"anchor\" href=\"#p-6940-network-entities-2\" aria-label=\"Heading link\"></a>Network Entities</h3>\n<p>The minimal configuration of our network consists of two entities: one validator and one prover.</p>\n<p>Validators are the core participants in the consensus process. Their responsibilities include block approval, leader rotation, and consensus participation. In the original design (which is a rollup on top of Polygon PoS), each validator must accumulate approvals from a majority (&gt;2/3) of validators for a block to be finalized. We maintained this requirement for our  Bitcoin implementation. Validators, along with provers, represent signing entities in the BDK-based multisignature wallet. They facilitate finalization of PSBT transactions and post state root hashes on-chain using OP_RETURN outputs.</p>\n<p>Provers are responsible for generating aggregated validity proofs using the Aztec Barretenberg backend. They create cryptographic proofs that aggregate multiple UTXO transaction zero-knowledge proofs into a single proof. Due to our use of a federated bridge model, we do not post state differentials to a separate data availability solution, simply because our network may be open to new listening nodes that can collect proofs and maintain a common mempool.</p>\n<p>The prover can run in full proving mode or mock prover mode (for testing). A non-validator, full node entity handles block storage, propagation, and transaction processing. In some configurations, signers who authorize vault creation, pre-signed backup transactions, and burns may use a node configuration for listening to the network and verifying state update commitments in Bitcoin blocks.\nNetwork Liveness and Safety\nThe original ZK-rollup design treats the rollup as an isolated BFT system that happens to post proofs to its underlying L1 (Polygon PoS). It leverages Doomslug/Solid-style consensus, which works well when the network is well-connected. But, this creates brittle failure modes during partitions. In our new design, these consensus engines were removed, and a directed acyclic graph (DAG)-like structure is used for resolving potential competing proofs and avoiding network failures inside bitcoin\u2019s long, expected 10 minute block interval. The proposed tail-based design reframes the rollup as a Bitcoin-anchored system in which the rollup produces candidate state transitions while Bitcoin provides the global ordering and fork-choice rule.\nNodes maintain flexibility until Bitcoin \u201cconfirms\u201d which branch is canonical. There is no global mempool state; each node has its own mempool for both Bitcoin and the rollup network. Moreover, these state transactions may not only be unconfirmed, but potentially not even signed. This means they exist solely in the validator\u2019s local memory and not in any mempool.\nThis is why the node doesn\u2019t wait for signatures when processing rollup blocks. It forms the next state and immediately returns control to the higher-level code that invoked block processing. That same code can then invoke processing of the next block, and it will similarly form the next state and return control without waiting for signatures on the previous state. Signing blocks is a purely asynchronous operation.\nThis is philosophically similar to how optimistic rollups work on Ethereum (fraud proofs with challenge periods), but adapted for proof-of-work\u2019s probabilistic model. The result is a system that inherits Bitcoin\u2019s liveness properties while maintaining the safety guarantees of ZK proofs.\nIn the current implementation, the DAG serves the purpose of algorithmically resolving conflicting state updates. It guarantees minimal liveness but cannot ensure safety in the broad consensus sense because the network currently lacks a proper consensus implementation. It remains to be shown whether the ZK-rollup network could benefit from a DAG for soft-settlement guarantees and implementation of prover coordination algorithms for decentralized UTXO aggregation.</p>\n<h3><a name=\"p-6940-mints-and-burns-3\" class=\"anchor\" href=\"#p-6940-mints-and-burns-3\" aria-label=\"Heading link\"></a>Mints and Burns</h3>\n<p>Due to the expressiveness of rollup smart contracts on Ethereum, they can successfully manage various tasks and provide interfaces to verifier contracts (e.g., AggregateVerifier) to validate submitted proofs. Other tasks include tracking the current root hash of the rollup\u2019s Merkle tree, deposits/mints, and withdrawals/burns. The contract also stored a validator set, which helped with network coordination.</p>\n<p>In the Bitcoin-based design, the rollup module implicitly tracks the validator set via a dedicated multisignature wallet. Bitcoin transactions also help track the true root hash of the rollup\u2019s Merkle tree. Beyond that, the Bitcoin rollup smart contract does not allow any extra features in its current design. While deposited funds could be stored in a single UTXO of the rollup contract, we chose a different approach for privacy reasons and for technical feasibility.</p>\n<p>We also enabled future upgrades to designs that include depositors as co-signers in a covenant \u201csimulated\u201d by a blind vault and a selection of pre-signed transactions. The recently proposed <a href=\"https://delvingbitcoin.org/t/blisk-boolean-circuit-logic-integrated-into-the-single-key/2217/3\">BLISK</a> appears to be a promising approach for constructing sophisticated policies, including threshold schemes involving fewer validator keys than needed for securing consensus and a transitory key in the vault ownership transfer scheme. <a href=\"https://github.com/arbedout/sigbash_v2\" rel=\"noopener nofollow ugc\">Sigbash</a> deserves to be mentioned too and it appears to be very close to the Blind vault proposal we have used in the present work.</p>\n<p>The figure below illustrates the existing flow for blind signers. The \u201cStatecoin TX\u201d transaction has not been implemented to date for the sake of simplicity and due to the federated on/off ramp model. When depositing into a vault, the user also receives a backup transaction that allows them to spend from this vault after one block-year. This feature was introduced for experimentation and illustrates the flexibility of blind vaults and pre-signed transactions when it comes to potential contingency scenarios. If the user hasn\u2019t moved funds on the rollup, on-chain coins can be recovered. This scheme could work when the rollup employs a market-based approach for on/off-ramping (similar to Signet on Ethereum). When a deposit (on-ramping user) after an undetermined amount of time finds a corresponding burn request (off-ramping user) and funds can be directly withdrawn during an atomic swap.</p>\n<pre data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">stateDiagram-v2\ndirection LR\n[*] --&gt; UserUTXO: User has funds\n\nstate \"\ud83d\udc64 User UTXO\" as UserUTXO {\n[*] --&gt; Spendable\nSpendable: P2TR (single sig)\nSpendable: Amount 1.0 BTC\n}\n\nstate \"\ud83c\udfe6 Statecoin Vault\" as VaultUTXO {\n[*] --&gt; Locked\nLocked: P2TR (MuSig2 2-of-2)\nLocked: Amount 0.999 BTC\nLocked: Spending requires blind signatures\n}\n\nstate \"\u23f3 Pre-signed Backup\" as UnvaultUTXO {\n[*] --&gt; Timelocked\nTimelocked: P2TR (MuSig2 2-of-2)\nTimelocked: Amount 0.998 BTC nSequence 144 blocks\n}\n\nstate \"\u2705 User\" as Destination {\n[*] --&gt; Received\nReceived: User controlled\nReceived: Amount 0.997 BTC\n}\n\nstate \"\u267b\ufe0f Mint Recovery\" as Recovery {\n[*] --&gt; Safe\nSafe: Cold storage\nSafe: nSequence 52560 blocks\n}\n\nUserUTXO --&gt; VaultUTXO: Deposit TX\nVaultUTXO --&gt; Recovery: Vault Recovery TX (rollup network stops)\nVaultUTXO --&gt; Destination: Burn TX (valid SNARK)\n\nVaultUTXO --&gt; UnvaultUTXO: Statecoin TX (blind signed)\n</code></pre>\n<p>The transaction flow described above may be initiated using a special \u201cciphera-cli\u201d tool that allows simple Bitcoin key management and Ciphera chain note management, and implements a simple client for the Ciphera network. The tool contains some parts of the blind vault project by Halseth, namely the \u201cwallet\u201d and \u201cdepositor\u201d components. It interacts with the Ciphera node API, which provides coordination for blind signing.</p>\n<pre data-code-wrap=\"mermaid\"><code class=\"lang-mermaid\">flowchart TB\nsubgraph User[\"\ud83d\udc64 User Role\"]\ndirection TB\nDepositor[\"Wallet&lt;br&gt;(Create and Destroy, Key Management, Notes)\"]\nend\nsubgraph ClientLayer[\"Aggregation Layer\"]\nClient[\"Coordinator Server\"]\nend\nsubgraph SignerLayer[\"Co-Signing Service\"]\nSigner1[\"signer #1&lt;br&gt;(Blind Signer)&lt;br&gt;:8080\"]\nSigner2[\"signer #2&lt;br&gt;(Blind Signer)&lt;br&gt;:8081\"]\nSignerN[\"signer #N&lt;br&gt;...\"]\nend\nsubgraph VaultSystem[\"\ud83d\udd10 Ciphera Vault API\"]\nClientLayer\nSignerLayer\nend\nsubgraph ZKProofs[\"\ud83d\udd12 Zero-Knowledge Proofs\"]\nZKMusig[\"zk-musig&lt;br&gt;(MuSig2 Proofs)\"]\nZKTx[\"zk-tx&lt;br&gt;(Timelock Proofs)\"]\nend\nDepositor -- POST /vault&lt;br&gt;POST /unvault --&gt; Client\nClient -- Init sessions&lt;br&gt;Get pubkeys/nonces --&gt; Signer1 &amp; Signer2\nClient -- ... --&gt; SignerN\nClient -- Blinded messages&lt;br&gt;+ ZK proofs --&gt; Signer1 &amp; Signer2\nSigner1 -- Partial&lt;br&gt;signatures --&gt; Client\nSigner2 -- Partial&lt;br&gt;signatures --&gt; Client\nClient -- Generate proofs --&gt; ZKMusig\nClient -- Timelock proofs --&gt; ZKTx\n\nstyle ZKTx stroke-width:4px,stroke-dasharray: 5\n\n</code></pre>\n<p>The original ZK-rollup mechanisms for preventing double-spends during minting and burning were preserved for the Bitcoin version. The UTXO circuit contains conditional blocks that separate rules by note kind and allow verification of specific transactions related to the creation and destruction of private notes.</p>\n<pre><code class=\"lang-auto\">   if (kind == 1) {\n        //SEND\n        assert(input_value == output_value, \"Input and output totals do not match\");\n    } else if (kind == 2) {\n        // MINT\n        // Assert mint utxo is balanced:\n        //   - `output_value` is checked above\n        //   - `input_value` is checked as it must have previously been an output value\n        //   - `msg_value` is checked above (but also using that to overflow would be detrimental to the\n        //      attacker)\n        assert(output_value == input_value + msg_value, \"Mint output must match value message\");\n        // Assert mint hash\n        assert(mint_hash == msg_hash, \"Mint hash must match message\");\n        // Assert note kind\n        assert(output_notes[0].kind == msg_note_kind, \"Mint note kind must match message\")\n    } else if (kind == 3) {\n        // BURN\n        // Prevent frontrunning the txn and changing the evm address\n        assert(pmessage4 == burn_addr, \"messages[4] must match private input\");\n        // Assert burn hash\n        assert(burn_hash == msg_hash, \"Burn hash must match message\");\n        // Assert burn utxo is balanced:\n        //   - `output_value` is checked above\n        //   - `input_value` is checked as it must have previously been an output value\n        //   - `msg_value` is checked above\n        assert(input_value == output_value + msg_value, \"Burn output must match value message\");\n        // Assert burn kind\n        assert(input_notes[0].note.kind == msg_note_kind, \"Burn note kind must match message\")\n    } else {\n        assert(false, \"Invalid kind\");\n    }\n</code></pre>\n<p>For EVM transactions, note burns include commitments to the withdrawal address, while mints are simply received via regular token transfer. For Bitcoin, due to Barretenberg\u2019s use of the BN254 curve, Schnorr public keys cannot be directly committed to because of curve limitations. We have a prototype library for handling Bitcoin-specific cryptographic primitives but it is not tested yet and to be released soon. The key corresponding to the user\u2019s address may exceed the BN254 field modulus, overflowing public input messages in circuit arguments. It is possible to commit to pre-Taproot script pubkeys, but this option was rejected due to the associated privacy implications.</p>\n<pre><code class=\"lang-auto\">pub struct Note {\n    pub kind: Field,\n    pub value: Field,\n    pub address: Field,\n    pub psi: Field,\n}\n</code></pre>\n<p>For Taproot public keys, the solution was to split keys into two 16-byte parts and place them in two note fields, which are 254-bit elements. In this way, we reused the \u201cKind\u201d (\u201cContract address\u201d) and \u201cPsi\u201d fields.</p>\n<pre><code class=\"lang-auto\">   pub fn new_mint(output_notes: [Note; 2], mint_address: Option&lt;Element&gt;) -&gt; Self {\n        Self {\n            kind: UtxoKind::Mint,\n            input_notes: [InputNote::padding_note(), InputNote::padding_note()],\n            output_notes,\n            address: mint_address,\n        }\n    }\n</code></pre>\n<p>For burns, the situation demanded a different approach due to the circuit design. The \u201cPsi\u201d field outputs of burn transactions were used to place burn addresses. According to the circuit, burn output \u201cKind\u201d fields must be checked against the inputs, meaning that minting and burning are tied to the creation and destruction of the corresponding vault.</p>\n<pre><code class=\"lang-auto\">   pub fn new_burn(\n        input_notes: [InputNote; 2],\n        burn_address: Element,\n        vault_elem1: Element,\n        vault_elem2: Element,\n    ) -&gt; Self {\n        let output1 = Note {\n            kind: Element::ZERO,\n            contract: Element::ZERO,\n            address: Element::ZERO,\n            psi: vault_elem1,\n            value: Element::ZERO,\n        };\n        let output2 = Note {\n            kind: Element::ZERO,\n            contract: Element::ZERO,\n            address: Element::ZERO,\n            psi: vault_elem2,\n            value: Element::ZERO,\n        };\n        Self {\n            kind: UtxoKind::Burn,\n            input_notes,\n            output_notes: [output1, output2],\n            address: Some(burn_address),\n        }\n    }\n</code></pre>\n<p>Since it is possible to commit an entire public key into a mint note, note creation is more straightforward than burns on the backend side. This is closer to the original Polygon PoS implementation. Upon receipt of the Ciphera note proofs, the validator extracts the public key and converts it into a script pubkey for requesting the confirmed balance from the indexer. If the UTXO amount is equal to the mint note value, validators approve the transaction in the new block, and the new note becomes included in the state; otherwise, it is rejected. Using \u201cciphera-cli,\u201d the flow for mints is a three-step process: 1) the user creates a new blind vault and checks the vault backup transaction; 2) coins must be sent to this address, and the amount must match\u2014otherwise nothing will be minted on the Ciphera; 3) new mint note proofs must be created client-side and submitted to the Ciphera validator. Unless rollup operators are malicious, the user always receives funds back. If we assume a spending policy where the user\u2019s key blocks spending (as in statechains), rollup operators cannot spend from the blind vault.</p>\n<p>The simplest naive implementation of burns requires the node to know two Taproot addresses during verification of the burn note proof. The first is the blind vault address and the second is the recipient address; together, they require four 254-bit element variables to represent. A more advanced approach (from a privacy standpoint) could rely on a shorter vault creation session identifier represented via a single element variable. This must be stored by all signers and requires persistent state, which has not been implemented to date. For convenience, \u201cciphera-cli\u201d uses \u201cvault-state.json\u201d for loading the current session and submits a request for spending from the vault along with the prepared burn proof. The node checks whether the burn proof is valid, coordinates signing of the vault exit, broadcasts the transaction, and then submits the burn proof to the network.</p>\n<p>Mint and burn note kinds are implicitly connected via the UTXO circuit because they share the same first 16 bytes of the vault\u2019s public key. Changes made:</p>\n<pre><code class=\"lang-auto\">input_notes[i].note.kind == msg_note_kind\n</code></pre>\n<p>Such linkage is convenient for prototyping a Bitcoin ZK-rollup, albeit it makes private notes non-fungible. The NFT model appears disadvantageous from a privacy standpoint; however, it may be a more convenient way to think about potential applications within the ZK-rollup, such as exchanges or lending protocols. Users ultimately have a validation mechanism at their disposal for all data they receive peer-to-peer.\nConclusion\nThe current implementation of the Ciphera chain is closer to a sidechain model with federated custody with a novel vault implementation that ensures users have a pre-signed exit transaction in the event of liveness failures. The upgrade to a statechain-like model, where users have a signing key in the vault set up, requires more research iterations and deeper security analysis. The Ciphera chain serves as a working prototype for an eventual zero-knowledge rollup on top of Bitcoin that supports zerocash-style payments. Aztec\u2019s Barretenberg backend, which provides proof generation and verification, may be ported to RISC-V, meaning that RISC Zero could serve as a wrapper for generating Groth16 proofs for BitVM-type bridges. At present, we feel this approach appears to have no technical advantages over the blind vault model, which is simpler, more flexible, and cheaper than any known BitVM versions. As more Musig-based solutions like BLISK or Sigbash are getting introduced, we believe that building dedicated vaults with sophisticated policies and tracking UTXO subsets or implementing SPV clients off-chain could improve trust assumptions of sidesystems.</p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 1,
  "updated_at": "2026-02-24T14:54:52.568Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 3,
  "reads": 4,
  "readers_count": 3,
  "score": 5.6,
  "yours": false,
  "topic_id": 2285,
  "topic_slug": "ciphera-a-bitcoin-zk-appchain-implementation",
  "topic_title": "Ciphera - a Bitcoin ZK Appchain Implementation",
  "topic_html_title": "Ciphera - a Bitcoin ZK Appchain Implementation",
  "category_id": 7,
  "display_username": "Ilya Evdokimov",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "### Summary \nIn the previous piece, [\"ZK-Statechains Without States,](https://delvingbitcoin.org/t/zk-statechains-without-states/2166)\" we outlined the idea of combining statechain peg-in/out mechanisms for ZK-rollups. This post further expands into a specific protocol implementation that leverages a zerocash transaction architecture for private transfers using Aztec Barretenberg circuits. The network may consist of validators, provers, regular nodes, and [blind signers](https://delvingbitcoin.org/t/building-a-vault-using-blinded-co-signers/2141/3), which can operate independently of each other. The existing prototype implements a simplified blind vault setup and employs RISC Zero circuits for pre-signing transactions and withdrawals. Additionally, we deploy a federation for our bridge model versus other rollup-style bridges (i.e. BitVM2). With further modifications, we believe we can see the user have a signing key in the blind vault as well as see the user be able to transfer ownership of the vault making it similar to a Mercury Layer-style transfer.  In this model, the user becomes a co-signer in the vault with relative timelock verification either via RISC Zero circuits or during private note transfer. The ZK-rollup design may be extended with additional circuits to support specific smart-contracting functions. It may be for example, collateral management. The project is built on top of the Bitcoin Development Kit library and reuses code and components from the [blind vault project](https://delvingbitcoin.org/t/building-a-vault-using-blinded-co-signers/2141) by @Halseth. \n\n[GitHub Ciphera Chain](https://github.com/zerosats/ciphera-appchain).\n\n### Network Entities\n\nThe minimal configuration of our network consists of two entities: one validator and one prover.\n\nValidators are the core participants in the consensus process. Their responsibilities include block approval, leader rotation, and consensus participation. In the original design (which is a rollup on top of Polygon PoS), each validator must accumulate approvals from a majority (>2/3) of validators for a block to be finalized. We maintained this requirement for our  Bitcoin implementation. Validators, along with provers, represent signing entities in the BDK-based multisignature wallet. They facilitate finalization of PSBT transactions and post state root hashes on-chain using OP_RETURN outputs.\n\nProvers are responsible for generating aggregated validity proofs using the Aztec Barretenberg backend. They create cryptographic proofs that aggregate multiple UTXO transaction zero-knowledge proofs into a single proof. Due to our use of a federated bridge model, we do not post state differentials to a separate data availability solution, simply because our network may be open to new listening nodes that can collect proofs and maintain a common mempool.\n\nThe prover can run in full proving mode or mock prover mode (for testing). A non-validator, full node entity handles block storage, propagation, and transaction processing. In some configurations, signers who authorize vault creation, pre-signed backup transactions, and burns may use a node configuration for listening to the network and verifying state update commitments in Bitcoin blocks.\nNetwork Liveness and Safety\nThe original ZK-rollup design treats the rollup as an isolated BFT system that happens to post proofs to its underlying L1 (Polygon PoS). It leverages Doomslug/Solid-style consensus, which works well when the network is well-connected. But, this creates brittle failure modes during partitions. In our new design, these consensus engines were removed, and a directed acyclic graph (DAG)-like structure is used for resolving potential competing proofs and avoiding network failures inside bitcoin\u2019s long, expected 10 minute block interval. The proposed tail-based design reframes the rollup as a Bitcoin-anchored system in which the rollup produces candidate state transitions while Bitcoin provides the global ordering and fork-choice rule.\nNodes maintain flexibility until Bitcoin \"confirms\" which branch is canonical. There is no global mempool state; each node has its own mempool for both Bitcoin and the rollup network. Moreover, these state transactions may not only be unconfirmed, but potentially not even signed. This means they exist solely in the validator's local memory and not in any mempool.\nThis is why the node doesn't wait for signatures when processing rollup blocks. It forms the next state and immediately returns control to the higher-level code that invoked block processing. That same code can then invoke processing of the next block, and it will similarly form the next state and return control without waiting for signatures on the previous state. Signing blocks is a purely asynchronous operation.\nThis is philosophically similar to how optimistic rollups work on Ethereum (fraud proofs with challenge periods), but adapted for proof-of-work's probabilistic model. The result is a system that inherits Bitcoin's liveness properties while maintaining the safety guarantees of ZK proofs.\nIn the current implementation, the DAG serves the purpose of algorithmically resolving conflicting state updates. It guarantees minimal liveness but cannot ensure safety in the broad consensus sense because the network currently lacks a proper consensus implementation. It remains to be shown whether the ZK-rollup network could benefit from a DAG for soft-settlement guarantees and implementation of prover coordination algorithms for decentralized UTXO aggregation.\n\n### Mints and Burns\n\nDue to the expressiveness of rollup smart contracts on Ethereum, they can successfully manage various tasks and provide interfaces to verifier contracts (e.g., AggregateVerifier) to validate submitted proofs. Other tasks include tracking the current root hash of the rollup's Merkle tree, deposits/mints, and withdrawals/burns. The contract also stored a validator set, which helped with network coordination.\n\nIn the Bitcoin-based design, the rollup module implicitly tracks the validator set via a dedicated multisignature wallet. Bitcoin transactions also help track the true root hash of the rollup's Merkle tree. Beyond that, the Bitcoin rollup smart contract does not allow any extra features in its current design. While deposited funds could be stored in a single UTXO of the rollup contract, we chose a different approach for privacy reasons and for technical feasibility.\n\nWe also enabled future upgrades to designs that include depositors as co-signers in a covenant \"simulated\" by a blind vault and a selection of pre-signed transactions. The recently proposed [BLISK](https://delvingbitcoin.org/t/blisk-boolean-circuit-logic-integrated-into-the-single-key/2217/3) appears to be a promising approach for constructing sophisticated policies, including threshold schemes involving fewer validator keys than needed for securing consensus and a transitory key in the vault ownership transfer scheme. [Sigbash](https://github.com/arbedout/sigbash_v2) deserves to be mentioned too and it appears to be very close to the Blind vault proposal we have used in the present work. \n\nThe figure below illustrates the existing flow for blind signers. The \"Statecoin TX\" transaction has not been implemented to date for the sake of simplicity and due to the federated on/off ramp model. When depositing into a vault, the user also receives a backup transaction that allows them to spend from this vault after one block-year. This feature was introduced for experimentation and illustrates the flexibility of blind vaults and pre-signed transactions when it comes to potential contingency scenarios. If the user hasn't moved funds on the rollup, on-chain coins can be recovered. This scheme could work when the rollup employs a market-based approach for on/off-ramping (similar to Signet on Ethereum). When a deposit (on-ramping user) after an undetermined amount of time finds a corresponding burn request (off-ramping user) and funds can be directly withdrawn during an atomic swap.\n\n\n```mermaid\nstateDiagram-v2\ndirection LR\n[*] --> UserUTXO: User has funds\n\nstate \"\ud83d\udc64 User UTXO\" as UserUTXO {\n[*] --> Spendable\nSpendable: P2TR (single sig)\nSpendable: Amount 1.0 BTC\n}\n\nstate \"\ud83c\udfe6 Statecoin Vault\" as VaultUTXO {\n[*] --> Locked\nLocked: P2TR (MuSig2 2-of-2)\nLocked: Amount 0.999 BTC\nLocked: Spending requires blind signatures\n}\n\nstate \"\u23f3 Pre-signed Backup\" as UnvaultUTXO {\n[*] --> Timelocked\nTimelocked: P2TR (MuSig2 2-of-2)\nTimelocked: Amount 0.998 BTC nSequence 144 blocks\n}\n\nstate \"\u2705 User\" as Destination {\n[*] --> Received\nReceived: User controlled\nReceived: Amount 0.997 BTC\n}\n\nstate \"\u267b\ufe0f Mint Recovery\" as Recovery {\n[*] --> Safe\nSafe: Cold storage\nSafe: nSequence 52560 blocks\n}\n\nUserUTXO --> VaultUTXO: Deposit TX\nVaultUTXO --> Recovery: Vault Recovery TX (rollup network stops)\nVaultUTXO --> Destination: Burn TX (valid SNARK)\n\nVaultUTXO --> UnvaultUTXO: Statecoin TX (blind signed)\n```\n\nThe transaction flow described above may be initiated using a special \"ciphera-cli\" tool that allows simple Bitcoin key management and Ciphera chain note management, and implements a simple client for the Ciphera network. The tool contains some parts of the blind vault project by Halseth, namely the \"wallet\" and \"depositor\" components. It interacts with the Ciphera node API, which provides coordination for blind signing.\n\n\n```mermaid\nflowchart TB\nsubgraph User[\"\ud83d\udc64 User Role\"]\ndirection TB\nDepositor[\"Wallet<br>(Create and Destroy, Key Management, Notes)\"]\nend\nsubgraph ClientLayer[\"Aggregation Layer\"]\nClient[\"Coordinator Server\"]\nend\nsubgraph SignerLayer[\"Co-Signing Service\"]\nSigner1[\"signer #1<br>(Blind Signer)<br>:8080\"]\nSigner2[\"signer #2<br>(Blind Signer)<br>:8081\"]\nSignerN[\"signer #N<br>...\"]\nend\nsubgraph VaultSystem[\"\ud83d\udd10 Ciphera Vault API\"]\nClientLayer\nSignerLayer\nend\nsubgraph ZKProofs[\"\ud83d\udd12 Zero-Knowledge Proofs\"]\nZKMusig[\"zk-musig<br>(MuSig2 Proofs)\"]\nZKTx[\"zk-tx<br>(Timelock Proofs)\"]\nend\nDepositor -- POST /vault<br>POST /unvault --> Client\nClient -- Init sessions<br>Get pubkeys/nonces --> Signer1 & Signer2\nClient -- ... --> SignerN\nClient -- Blinded messages<br>+ ZK proofs --> Signer1 & Signer2\nSigner1 -- Partial<br>signatures --> Client\nSigner2 -- Partial<br>signatures --> Client\nClient -- Generate proofs --> ZKMusig\nClient -- Timelock proofs --> ZKTx\n\nstyle ZKTx stroke-width:4px,stroke-dasharray: 5\n\n```\n\n\nThe original ZK-rollup mechanisms for preventing double-spends during minting and burning were preserved for the Bitcoin version. The UTXO circuit contains conditional blocks that separate rules by note kind and allow verification of specific transactions related to the creation and destruction of private notes.\n\n```\n   if (kind == 1) {\n        //SEND\n        assert(input_value == output_value, \"Input and output totals do not match\");\n    } else if (kind == 2) {\n        // MINT\n        // Assert mint utxo is balanced:\n        //   - `output_value` is checked above\n        //   - `input_value` is checked as it must have previously been an output value\n        //   - `msg_value` is checked above (but also using that to overflow would be detrimental to the\n        //      attacker)\n        assert(output_value == input_value + msg_value, \"Mint output must match value message\");\n        // Assert mint hash\n        assert(mint_hash == msg_hash, \"Mint hash must match message\");\n        // Assert note kind\n        assert(output_notes[0].kind == msg_note_kind, \"Mint note kind must match message\")\n    } else if (kind == 3) {\n        // BURN\n        // Prevent frontrunning the txn and changing the evm address\n        assert(pmessage4 == burn_addr, \"messages[4] must match private input\");\n        // Assert burn hash\n        assert(burn_hash == msg_hash, \"Burn hash must match message\");\n        // Assert burn utxo is balanced:\n        //   - `output_value` is checked above\n        //   - `input_value` is checked as it must have previously been an output value\n        //   - `msg_value` is checked above\n        assert(input_value == output_value + msg_value, \"Burn output must match value message\");\n        // Assert burn kind\n        assert(input_notes[0].note.kind == msg_note_kind, \"Burn note kind must match message\")\n    } else {\n        assert(false, \"Invalid kind\");\n    }\n```\n\nFor EVM transactions, note burns include commitments to the withdrawal address, while mints are simply received via regular token transfer. For Bitcoin, due to Barretenberg's use of the BN254 curve, Schnorr public keys cannot be directly committed to because of curve limitations. We have a prototype library for handling Bitcoin-specific cryptographic primitives but it is not tested yet and to be released soon. The key corresponding to the user's address may exceed the BN254 field modulus, overflowing public input messages in circuit arguments. It is possible to commit to pre-Taproot script pubkeys, but this option was rejected due to the associated privacy implications.\n\n```\npub struct Note {\n    pub kind: Field,\n    pub value: Field,\n    pub address: Field,\n    pub psi: Field,\n}\n```\n\nFor Taproot public keys, the solution was to split keys into two 16-byte parts and place them in two note fields, which are 254-bit elements. In this way, we reused the \"Kind\" (\u201cContract address\u201d) and \"Psi\" fields.\n\n```\n   pub fn new_mint(output_notes: [Note; 2], mint_address: Option<Element>) -> Self {\n        Self {\n            kind: UtxoKind::Mint,\n            input_notes: [InputNote::padding_note(), InputNote::padding_note()],\n            output_notes,\n            address: mint_address,\n        }\n    }\n```\n\nFor burns, the situation demanded a different approach due to the circuit design. The \"Psi\" field outputs of burn transactions were used to place burn addresses. According to the circuit, burn output \"Kind\" fields must be checked against the inputs, meaning that minting and burning are tied to the creation and destruction of the corresponding vault.\n\n```\n   pub fn new_burn(\n        input_notes: [InputNote; 2],\n        burn_address: Element,\n        vault_elem1: Element,\n        vault_elem2: Element,\n    ) -> Self {\n        let output1 = Note {\n            kind: Element::ZERO,\n            contract: Element::ZERO,\n            address: Element::ZERO,\n            psi: vault_elem1,\n            value: Element::ZERO,\n        };\n        let output2 = Note {\n            kind: Element::ZERO,\n            contract: Element::ZERO,\n            address: Element::ZERO,\n            psi: vault_elem2,\n            value: Element::ZERO,\n        };\n        Self {\n            kind: UtxoKind::Burn,\n            input_notes,\n            output_notes: [output1, output2],\n            address: Some(burn_address),\n        }\n    }\n```\n\nSince it is possible to commit an entire public key into a mint note, note creation is more straightforward than burns on the backend side. This is closer to the original Polygon PoS implementation. Upon receipt of the Ciphera note proofs, the validator extracts the public key and converts it into a script pubkey for requesting the confirmed balance from the indexer. If the UTXO amount is equal to the mint note value, validators approve the transaction in the new block, and the new note becomes included in the state; otherwise, it is rejected. Using \"ciphera-cli,\" the flow for mints is a three-step process: 1) the user creates a new blind vault and checks the vault backup transaction; 2) coins must be sent to this address, and the amount must match\u2014otherwise nothing will be minted on the Ciphera; 3) new mint note proofs must be created client-side and submitted to the Ciphera validator. Unless rollup operators are malicious, the user always receives funds back. If we assume a spending policy where the user's key blocks spending (as in statechains), rollup operators cannot spend from the blind vault.\n\nThe simplest naive implementation of burns requires the node to know two Taproot addresses during verification of the burn note proof. The first is the blind vault address and the second is the recipient address; together, they require four 254-bit element variables to represent. A more advanced approach (from a privacy standpoint) could rely on a shorter vault creation session identifier represented via a single element variable. This must be stored by all signers and requires persistent state, which has not been implemented to date. For convenience, \"ciphera-cli\" uses \"vault-state.json\" for loading the current session and submits a request for spending from the vault along with the prepared burn proof. The node checks whether the burn proof is valid, coordinates signing of the vault exit, broadcasts the transaction, and then submits the burn proof to the network.\n\nMint and burn note kinds are implicitly connected via the UTXO circuit because they share the same first 16 bytes of the vault's public key. Changes made:\n\n```\ninput_notes[i].note.kind == msg_note_kind\n```\n\nSuch linkage is convenient for prototyping a Bitcoin ZK-rollup, albeit it makes private notes non-fungible. The NFT model appears disadvantageous from a privacy standpoint; however, it may be a more convenient way to think about potential applications within the ZK-rollup, such as exchanges or lending protocols. Users ultimately have a validation mechanism at their disposal for all data they receive peer-to-peer.\nConclusion\nThe current implementation of the Ciphera chain is closer to a sidechain model with federated custody with a novel vault implementation that ensures users have a pre-signed exit transaction in the event of liveness failures. The upgrade to a statechain-like model, where users have a signing key in the vault set up, requires more research iterations and deeper security analysis. The Ciphera chain serves as a working prototype for an eventual zero-knowledge rollup on top of Bitcoin that supports zerocash-style payments. Aztec's Barretenberg backend, which provides proof generation and verification, may be ported to RISC-V, meaning that RISC Zero could serve as a wrapper for generating Groth16 proofs for BitVM-type bridges. At present, we feel this approach appears to have no technical advantages over the blind vault model, which is simpler, more flexible, and cheaper than any known BitVM versions. As more Musig-based solutions like BLISK or Sigbash are getting introduced, we believe that building dedicated vaults with sophisticated policies and tracking UTXO subsets or implementing SPV clients off-chain could improve trust assumptions of sidesystems.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 710,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "<a name=\"p-6940-summary-1\" class=\"anchor\" href=\"#p-6940-summary-1\" aria-label=\"Heading link\"></a>Summary\nIn the previous piece, <a href=\"https://delvingbitcoin.org/t/zk-statechains-without-states/2166\">&quot;ZK-Statechains Without States,</a>&quot; we outlined the idea of combining statechain peg-in/out mechanisms for ZK-rollups. This post further expands into a specific protocol implementation that leverages a zerocash transaction architecture for private transfers using Aztec Ba&hellip;",
  "truncated": true,
  "post_url": "/t/ciphera-a-bitcoin-zk-appchain-implementation/2285/1",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}