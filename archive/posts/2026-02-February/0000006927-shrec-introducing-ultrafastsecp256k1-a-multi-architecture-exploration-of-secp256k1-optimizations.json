{
  "id": 6927,
  "name": "vano",
  "username": "shrec",
  "avatar_template": "/user_avatar/delvingbitcoin.org/shrec/{size}/1856_2.png",
  "created_at": "2026-02-22T11:57:49.789Z",
  "cooked": "<p><strong>Introduction</strong>\nHello everyone. I\u2019ve been developing a high-throughput  implementation called <strong>UltrafastSecp256k1</strong>. The project, which was open-sourced on February 11th, 2026, started as an exploration of how modern hardware features (SHA-NI, AVX2, ARM64 Assembly) can be leveraged to push the limits of ECC performance across diverse platforms\u2014from high-end x86 servers to resource-constrained IoT devices like ESP32-S3 and RISC-V boards.</p>\n<p>The goal is to create a highly portable, constant-time, and branchless library that is accessible through multiple language bindings (12+ languages including Rust, Go, Swift, and Dart). I am reaching out to this community for a technical audit, feedback on the cryptographic primitives, and suggestions on our constant-time implementation.</p>\n<h3><a name=\"p-6927-architecture-core-optimizations-1\" class=\"anchor\" href=\"#p-6927-architecture-core-optimizations-1\" aria-label=\"Heading link\"></a><strong>Architecture &amp; Core Optimizations</strong></h3>\n<p>The library is built on a \u201cZero-Allocation\u201d hot-path contract, ensuring no heap overhead during critical operations. Key technical pillars include:</p>\n<ul>\n<li><strong>Field Representation</strong>: We transitioned to a  field representation for Point internals, enabling <code>__int128</code> lazy reduction across constant-time (CT) operations.</li>\n<li><strong>Constant-Time Field Inversion</strong>: Implemented using the <strong>SafeGCD (divsteps)</strong> algorithm, specifically optimized for different architectures (e.g.,  divsteps for robustness).</li>\n<li><strong>Scalar Multiplication</strong>: Leverages <strong>GLV Endomorphism</strong> via -decomposition combined with interleaved double-and-add, significantly reducing the cycle count for .</li>\n<li><strong>Hardware Acceleration</strong>: We use <strong>SHA-NI (Intel/AMD SHA Extensions)</strong> for high-speed hashing dispatching and <strong>AVX2 CT table lookups</strong> for secure, constant-time scans.</li>\n<li><strong>I-Cache Efficiency</strong>: We utilize <code>noinline</code> on large functions like <code>jac52_add_mixed_inplace</code> to prevent instruction cache pollution, resulting in a ~59% reduction in I-cache misses.</li>\n</ul>\n<h3><a name=\"p-6927-platform-specific-implementation-benchmarks-2\" class=\"anchor\" href=\"#p-6927-platform-specific-implementation-benchmarks-2\" aria-label=\"Heading link\"></a><strong>Platform-Specific Implementation &amp; Benchmarks</strong></h3>\n<p>We have focused on making the library performant where it\u2019s needed most:</p>\n<ul>\n<li><strong>x86_64</strong>: Utilizing <strong>Comb precomputation tables</strong> (teeth=6, blocks=43) to optimize  operations, achieving significant speedups over standard implementations.</li>\n<li><strong>ARM64 (Android/Linux)</strong>: Hand-tuned  multiply/square bypasses directly calling assembly, optimized for Cortex-A76 and newer cores.</li>\n<li><strong>Embedded &amp; Emerging</strong>: Current support for <strong>ESP32-S3</strong> and upcoming optimizations for <strong>RISC-V (Milk-V Mars)</strong>.</li>\n</ul>\n<p><strong>Current State (v3.10.x):</strong>\nThe library currently passes over 12,000 consistency tests across x86 and ARM64 platforms. The ecosystem includes full bindings for <strong>NPM (Node.js/React Native)</strong> and <strong>NuGet (.NET)</strong>, making it ready for high-level integration.</p>\n<h3><a name=\"p-6927-request-for-review-technical-discussion-3\" class=\"anchor\" href=\"#p-6927-request-for-review-technical-discussion-3\" aria-label=\"Heading link\"></a><strong>Request for Review &amp; Technical Discussion</strong></h3>\n<p>I am specifically looking for feedback on:</p>\n<ol>\n<li><strong>Constant-Time Integrity</strong>: Review of our  assembly bypasses for potential side-channel leaks.</li>\n<li><strong>Algorithm Selection</strong>: Evaluation of our <strong>H-Product Serial Inversion</strong> and <strong>SafeGCD</strong> implementation details.</li>\n<li><strong>Branchless Logic</strong>: Suggestions for further removing branches in the point-normalization and signing flows to improve security.</li>\n</ol>\n<p>The project is fully open-source, and I believe that peer review from the Delving Bitcoin community is vital to ensure this tool remains both fast and secure for the wider ecosystem.</p>\n<p><strong>GitHub Repository:</strong> <a href=\"https://github.com/shrec/UltrafastSecp256k1\" rel=\"noopener nofollow ugc\">https://github.com/shrec/UltrafastSecp256k1</a></p>\n<p><strong>Technical Changelog:</strong><a href=\"https://github.com/shrec/UltrafastSecp256k1/blob/main/CHANGELOG.md\" rel=\"noopener nofollow ugc\">https://github.com/shrec/UltrafastSecp256k1/blob/c649f6dfd80b1611b17f606206b156e3c2e6a058/CHANGELOG.md</a></p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 1,
  "updated_at": "2026-02-22T12:05:15.311Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 2,
  "reads": 8,
  "readers_count": 7,
  "score": 26.4,
  "yours": false,
  "topic_id": 2280,
  "topic_slug": "introducing-ultrafastsecp256k1-a-multi-architecture-exploration-of-secp256k1-optimizations",
  "topic_title": "Introducing UltrafastSecp256k1: A Multi-Architecture Exploration of Secp256k1 Optimizations",
  "topic_html_title": "Introducing UltrafastSecp256k1: A Multi-Architecture Exploration of Secp256k1 Optimizations",
  "category_id": 8,
  "display_username": "vano",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": "",
  "bookmarked": false,
  "raw": "**Introduction**\nHello everyone. I\u2019ve been developing a high-throughput  implementation called **UltrafastSecp256k1**. The project, which was open-sourced on February 11th, 2026, started as an exploration of how modern hardware features (SHA-NI, AVX2, ARM64 Assembly) can be leveraged to push the limits of ECC performance across diverse platforms\u2014from high-end x86 servers to resource-constrained IoT devices like ESP32-S3 and RISC-V boards.\n\nThe goal is to create a highly portable, constant-time, and branchless library that is accessible through multiple language bindings (12+ languages including Rust, Go, Swift, and Dart). I am reaching out to this community for a technical audit, feedback on the cryptographic primitives, and suggestions on our constant-time implementation.\n\n### **Architecture & Core Optimizations**\n\nThe library is built on a \u201cZero-Allocation\u201d hot-path contract, ensuring no heap overhead during critical operations. Key technical pillars include:\n\n* **Field Representation**: We transitioned to a  field representation for Point internals, enabling `__int128` lazy reduction across constant-time (CT) operations.\n* **Constant-Time Field Inversion**: Implemented using the **SafeGCD (divsteps)** algorithm, specifically optimized for different architectures (e.g.,  divsteps for robustness).\n* **Scalar Multiplication**: Leverages **GLV Endomorphism** via -decomposition combined with interleaved double-and-add, significantly reducing the cycle count for .\n* **Hardware Acceleration**: We use **SHA-NI (Intel/AMD SHA Extensions)** for high-speed hashing dispatching and **AVX2 CT table lookups** for secure, constant-time scans.\n* **I-Cache Efficiency**: We utilize `noinline` on large functions like `jac52_add_mixed_inplace` to prevent instruction cache pollution, resulting in a \\~59% reduction in I-cache misses.\n\n### **Platform-Specific Implementation & Benchmarks**\n\nWe have focused on making the library performant where it\u2019s needed most:\n\n* **x86_64**: Utilizing **Comb precomputation tables** (teeth=6, blocks=43) to optimize  operations, achieving significant speedups over standard implementations.\n* **ARM64 (Android/Linux)**: Hand-tuned  multiply/square bypasses directly calling assembly, optimized for Cortex-A76 and newer cores.\n* **Embedded & Emerging**: Current support for **ESP32-S3** and upcoming optimizations for **RISC-V (Milk-V Mars)**.\n\n**Current State (v3.10.x):**\nThe library currently passes over 12,000 consistency tests across x86 and ARM64 platforms. The ecosystem includes full bindings for **NPM (Node.js/React Native)** and **NuGet (.NET)**, making it ready for high-level integration.\n\n### **Request for Review & Technical Discussion**\n\nI am specifically looking for feedback on:\n\n1. **Constant-Time Integrity**: Review of our  assembly bypasses for potential side-channel leaks.\n2. **Algorithm Selection**: Evaluation of our **H-Product Serial Inversion** and **SafeGCD** implementation details.\n3. **Branchless Logic**: Suggestions for further removing branches in the point-normalization and signing flows to improve security.\n\nThe project is fully open-source, and I believe that peer review from the Delving Bitcoin community is vital to ensure this tool remains both fast and secure for the wider ecosystem.\n\n**GitHub Repository:** [https://github.com/shrec/UltrafastSecp256k1](https://github.com/shrec/UltrafastSecp256k1)\n\n**Technical Changelog:**[https://github.com/shrec/UltrafastSecp256k1/blob/c649f6dfd80b1611b17f606206b156e3c2e6a058/CHANGELOG.md](https://github.com/shrec/UltrafastSecp256k1/blob/main/CHANGELOG.md)",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 1103,
  "hidden": false,
  "trust_level": 0,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": "Github link was replaced with a permanent link",
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "Introduction\nHello everyone. I\u2019ve been developing a high-throughput  implementation called UltrafastSecp256k1. The project, which was open-sourced on February 11th, 2026, started as an exploration of how modern hardware features (SHA-NI, AVX2, ARM64 Assembly) can be leveraged to push the limits of E&hellip;",
  "truncated": true,
  "post_url": "/t/introducing-ultrafastsecp256k1-a-multi-architecture-exploration-of-secp256k1-optimizations/2280/1",
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}