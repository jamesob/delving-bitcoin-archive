{
  "id": 6791,
  "name": "",
  "username": "ademan",
  "avatar_template": "/user_avatar/delvingbitcoin.org/ademan/{size}/337_2.png",
  "created_at": "2026-02-10T19:09:41.561Z",
  "cooked": "<h1><a name=\"p-6791-tl-dr-1\" class=\"anchor\" href=\"#p-6791-tl-dr-1\" aria-label=\"Heading link\"></a>TL; DR</h1>\n<p>By combining <code>OP_CHECKSIGFROMSTACK</code> with a vector commitment, you can build public blockchain oracles that provide powerful introspection abilities to bitcoin scripts.\nWhile oracle based verification is well understood, this scheme has unusually strong incentives for honest behavior relative to typical oracle constructions.\nUsing multiple oracles, and potentially slashing bonded collateral, can further strengthen these incentives.\nIn this scheme, trust may be reduced enough to support very advanced protocols, including MEVil-generating ones.\nSince one motivation for preferring <code>OP_PAIRCOMMIT</code> over <code>OP_CAT</code> is to avoid enabling MEVil-generating protocols, this scheme slightly weakens the motivation for <code>OP_PAIRCOMMIT</code>.</p>\n<h1><a name=\"p-6791-op_paircommithttpsgithubcomlnhancebipsblob5221a4e75e983e7040f5a3d039fb62d775371500bip-0442md-2\" class=\"anchor\" href=\"#p-6791-op_paircommithttpsgithubcomlnhancebipsblob5221a4e75e983e7040f5a3d039fb62d775371500bip-0442md-2\" aria-label=\"Heading link\"></a><a href=\"https://github.com/lnhance/bips/blob/5221a4e75e983e7040f5a3d039fb62d775371500/bip-0442.md\" rel=\"noopener nofollow ugc\"><code>OP_PAIRCOMMIT</code></a></h1>\n<p>BIP-442 defines <code>OP_PAIRCOMMIT</code> which pops two items from the stack and pushes a hash which commits to both.\nOne of the motivations for <code>OP_PAIRCOMMIT</code> is to support vector commitments in Bitcoin script without enabling as much functionality as <code>OP_CAT</code> does.</p>\n<h1><a name=\"p-6791-op_checksigfromstackhttpsgithubcomlnhancebipsblob5221a4e75e983e7040f5a3d039fb62d775371500bip-0348md-3\" class=\"anchor\" href=\"#p-6791-op_checksigfromstackhttpsgithubcomlnhancebipsblob5221a4e75e983e7040f5a3d039fb62d775371500bip-0348md-3\" aria-label=\"Heading link\"></a><a href=\"https://github.com/lnhance/bips/blob/5221a4e75e983e7040f5a3d039fb62d775371500/bip-0348.md\" rel=\"noopener nofollow ugc\"><code>OP_CHECKSIGFROMSTACK</code></a></h1>\n<p>BIP-348 defines <code>OP_CHECKSIGFROMSTACK</code> which pops three items from the stack: a signature, a message, and a public key, and pushes whether the signature is correct given the message and public key.\n<code>OP_CHECKSIGFROMSTACK</code> makes it significantly easier to consume oracle commitments in Bitcoin script.</p>\n<h1><a name=\"p-6791-the-concept-4\" class=\"anchor\" href=\"#p-6791-the-concept-4\" aria-label=\"Heading link\"></a>The Concept</h1>\n<p>This is likely obvious, but worth stating explicitly.</p>\n<p>An oracle can sign a commitment to the contents of a Bitcoin block such that a native Bitcoin script can verify arbitrary facts about that block, its ancestors, transaction fields, prevouts, values, etc.</p>\n<p>This scheme works with both <code>OP_CAT</code> and <code>OP_PAIRCOMMIT</code> but is mostly uninteresting if <code>OP_CAT</code> is activated.</p>\n<p>Given a vector commitment <code>vc(x0, x1, x2, ...)</code> that commits to the items <code>x0..xN</code>, we can define a block commitment <code>bc(b)</code>.\nThe specific fields below are illustrative, almost anything derivable from block data could be committed to instead.</p>\n<h2><a name=\"p-6791-commitment-structure-5\" class=\"anchor\" href=\"#p-6791-commitment-structure-5\" aria-label=\"Heading link\"></a>Commitment Structure</h2>\n<h3><a name=\"p-6791-input-commitment-6\" class=\"anchor\" href=\"#p-6791-input-commitment-6\" aria-label=\"Heading link\"></a>Input Commitment</h3>\n<pre><code class=\"lang-auto\">ic(i) = vc(i.txid, i.vout, i.sequence, i.ssig)\n</code></pre>\n<h3><a name=\"p-6791-output-commitment-7\" class=\"anchor\" href=\"#p-6791-output-commitment-7\" aria-label=\"Heading link\"></a>Output Commitment</h3>\n<pre><code class=\"lang-auto\">oc(o) = vc(o.amount, o.spk)\n</code></pre>\n<h3><a name=\"p-6791-transaction-commitment-8\" class=\"anchor\" href=\"#p-6791-transaction-commitment-8\" aria-label=\"Heading link\"></a>Transaction Commitment</h3>\n<pre><code class=\"lang-auto\">tc(tx) = vc(\n\ttx.version,\n\ttx.nin,\n\tvc(ic(tx.in[0]), ic(tx.in[1]), ic(tx.in[2]), ...),\n\ttx.nout,\n\tvc(oc(tx.out[0]), oc(tx.out[1]), oc(tx.out[2]), ...),\n)\n</code></pre>\n<h3><a name=\"p-6791-block-commitment-9\" class=\"anchor\" href=\"#p-6791-block-commitment-9\" aria-label=\"Heading link\"></a>Block Commitment</h3>\n<pre><code class=\"lang-auto\">bc(b) = vc(\n\tb.version,\n\tbc(b.previous),\n\tb.time,\n\tb.bits,\n\tb.nonce,\n\tvc(\n\t\ttc(b.tx[0]),\n\t\ttc(b.tx[1]),\n\t\ttc(b.tx[2]),\n\t\t...\n\t)\n)\n</code></pre>\n<h1><a name=\"p-6791-significance-10\" class=\"anchor\" href=\"#p-6791-significance-10\" aria-label=\"Heading link\"></a>Significance</h1>\n<p>It\u2019s widely understood that complex, arbitrary computations can be verified on-chain if you\u2019re willing to trust a third party oracle.\nWhat is potentially interesting here is that oracle commitments to data derived from blocks have stronger incentives to behave honestly than typical oracle schemes.</p>\n<p>In this scheme, the oracle only publishes a single signature per block over a deterministic commitment to blockchain data.\nAny party can independently recompute the commitment from the blockchain and verify what the oracle signed.</p>\n<p>This gives the scheme three properties that encourage honest oracle behavior.</p>\n<ol>\n<li><strong>Universal verifiability</strong>\nAnyone already validating the blockchain can verify the oracle commitments themselves.</li>\n<li><strong>Cheating cannot be selectively hidden</strong>\nBecause there is only one commitment per block* (see Caveats), the oracle cannot cheat selectively.\nAll verifiers verify all (public) data commitments out of self-interest.</li>\n<li><strong>Provability</strong>\nFraud proofs are trivial to construct and share.</li>\n</ol>\n<p>These properties mean the oracle has a significantly reduced chance of cheating without detection, increasing the expected cost of dishonest behavior.\nWhen multiple such oracles are combined, the chance of successful, economically rational cheating is also reduced, further diminishing incentives to attempt it.\nAs a result, this scheme may be sufficient to enable a wide array of advanced protocols, including MEVil-generating protocols (for instance AMMs) that I and others wish to avoid.\nSince a key motivation for <code>OP_PAIRCOMMIT</code> is to avoid enabling exactly these kinds of smart contracts, this observation slightly weakens the case for <code>OP_PAIRCOMMIT</code>.</p>\n<p>Furthermore, I suspect (but don\u2019t know) that oracles could have BitVM secured bonds which could be slashed if they publish signatures over invalid commitments.\nIn this case, oracles would publish their signature and a proof that they calculated the block commitment <code>bc(x)</code> correctly.\nThis is perhaps the most interesting, and potentially offers a substantial improvement in incentives compared to other oracle constructions.\nHowever, I\u2019m not positive this can work, as I\u2019m not well versed in the exciting developments in the BitVM arena.</p>\n<p>But taken together, using multiple oracles producing trivially verifiable commitments, with slashable bonds, this scheme may make powerful introspection possible with only <code>OP_PAIRCOMMIT</code> and <code>OP_CHECKSIGFROMSTACK</code>.</p>\n<h1><a name=\"p-6791-further-thoughts-11\" class=\"anchor\" href=\"#p-6791-further-thoughts-11\" aria-label=\"Heading link\"></a>Further Thoughts</h1>\n<p>The general principle is that using a vector commitment an oracle can sign a commitment to an arbitrarily large set of data, and if this set of data can be easily verified, then users have a higher than normal assurance that the oracle cannot get away with cheating.\nIf BitVM bonds can be fashioned for these oracles, and if they could be made for other chains (I don\u2019t see why not), it might enable an interesting class of bridges.\nIf it\u2019s possible, it still requires careful consideration.\nBond values and funds secured can, without detection, become unbalanced to the point that good oracle behavior is no longer economically incentivized.</p>\n<h1><a name=\"p-6791-caveats-12\" class=\"anchor\" href=\"#p-6791-caveats-12\" aria-label=\"Heading link\"></a>Caveats</h1>\n<p>A reliable public publishing system is required to assume only one commitment per block per oracle.\nIn practice, something like publishing commitments on nostr should be sufficient.\nNevertheless, it is still possible for an oracle to attempt private cheating by collusion.\nAn oracle may collude with a smart contract actor to provide an invalid commitment only to that actor (so that they can defraud another smart contract actor).\nVerifiers can still identify this kind of cheating with a bit more work, as long as the commitment ends up on chain.\nOff-chain protocols using these oracles lose this protection entirely, and would need to verify the commitments themselves.</p>\n<h1><a name=\"p-6791-llm-disclosure-13\" class=\"anchor\" href=\"#p-6791-llm-disclosure-13\" aria-label=\"Heading link\"></a>LLM Disclosure</h1>\n<p>I\u2019m not sure anyone cares on delving but just in case\u2026\nThe original draft of this was 100% written by me, but I\u2019m a pretty crummy writer (just look at my other posts).\nChatGPT helped me clean up the prose significantly, all edits were applied manually by me.\nI tried to never take its suggestions verbatim, but there were times the suggestion was unambiguously better than anything I could come up with.\nNone of the concepts come from or are derived from ChatGPT output.\nEven the overall structure is mostly from my first draft.</p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 2,
  "updated_at": "2026-02-10T19:14:44.290Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 1,
  "reads": 6,
  "readers_count": 5,
  "score": 6.2,
  "yours": false,
  "topic_id": 2243,
  "topic_slug": "arbitrary-introspection-using-paircommit-csfs-and-oracles",
  "topic_title": "Arbitrary Introspection Using PAIRCOMMIT, CSFS, and Oracles",
  "topic_html_title": "Arbitrary Introspection Using PAIRCOMMIT, CSFS, and Oracles",
  "category_id": 7,
  "display_username": "",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "# TL; DR\n\nBy combining `OP_CHECKSIGFROMSTACK` with a vector commitment, you can build public blockchain oracles that provide powerful introspection abilities to bitcoin scripts.\nWhile oracle based verification is well understood, this scheme has unusually strong incentives for honest behavior relative to typical oracle constructions.\nUsing multiple oracles, and potentially slashing bonded collateral, can further strengthen these incentives.\nIn this scheme, trust may be reduced enough to support very advanced protocols, including MEVil-generating ones.\nSince one motivation for preferring `OP_PAIRCOMMIT` over `OP_CAT` is to avoid enabling MEVil-generating protocols, this scheme slightly weakens the motivation for `OP_PAIRCOMMIT`.\n\n# [`OP_PAIRCOMMIT`](https://github.com/lnhance/bips/blob/5221a4e75e983e7040f5a3d039fb62d775371500/bip-0442.md)\n\nBIP-442 defines `OP_PAIRCOMMIT` which pops two items from the stack and pushes a hash which commits to both.\nOne of the motivations for `OP_PAIRCOMMIT` is to support vector commitments in Bitcoin script without enabling as much functionality as `OP_CAT` does.\n\n# [`OP_CHECKSIGFROMSTACK`](https://github.com/lnhance/bips/blob/5221a4e75e983e7040f5a3d039fb62d775371500/bip-0348.md)\n\nBIP-348 defines `OP_CHECKSIGFROMSTACK` which pops three items from the stack: a signature, a message, and a public key, and pushes whether the signature is correct given the message and public key.\n`OP_CHECKSIGFROMSTACK` makes it significantly easier to consume oracle commitments in Bitcoin script.\n\n# The Concept\n\nThis is likely obvious, but worth stating explicitly.\n\nAn oracle can sign a commitment to the contents of a Bitcoin block such that a native Bitcoin script can verify arbitrary facts about that block, its ancestors, transaction fields, prevouts, values, etc.\n\nThis scheme works with both `OP_CAT` and `OP_PAIRCOMMIT` but is mostly uninteresting if `OP_CAT` is activated.\n\nGiven a vector commitment `vc(x0, x1, x2, ...)` that commits to the items `x0..xN`, we can define a block commitment `bc(b)`.\nThe specific fields below are illustrative, almost anything derivable from block data could be committed to instead.\n\n## Commitment Structure\n\n### Input Commitment\n\n```\nic(i) = vc(i.txid, i.vout, i.sequence, i.ssig)\n```\n\n### Output Commitment\n\n```\noc(o) = vc(o.amount, o.spk)\n```\n\n### Transaction Commitment\n\n```\ntc(tx) = vc(\n\ttx.version,\n\ttx.nin,\n\tvc(ic(tx.in[0]), ic(tx.in[1]), ic(tx.in[2]), ...),\n\ttx.nout,\n\tvc(oc(tx.out[0]), oc(tx.out[1]), oc(tx.out[2]), ...),\n)\n```\n\n### Block Commitment\n\n```\nbc(b) = vc(\n\tb.version,\n\tbc(b.previous),\n\tb.time,\n\tb.bits,\n\tb.nonce,\n\tvc(\n\t\ttc(b.tx[0]),\n\t\ttc(b.tx[1]),\n\t\ttc(b.tx[2]),\n\t\t...\n\t)\n)\n```\n\n# Significance\n\nIt\u2019s widely understood that complex, arbitrary computations can be verified on-chain if you\u2019re willing to trust a third party oracle.\nWhat is potentially interesting here is that oracle commitments to data derived from blocks have stronger incentives to behave honestly than typical oracle schemes.\n\nIn this scheme, the oracle only publishes a single signature per block over a deterministic commitment to blockchain data.\nAny party can independently recompute the commitment from the blockchain and verify what the oracle signed.\n\nThis gives the scheme three properties that encourage honest oracle behavior.\n\n1. **Universal verifiability**\n   Anyone already validating the blockchain can verify the oracle commitments themselves.\n2. **Cheating cannot be selectively hidden**\n   Because there is only one commitment per block\\* (see Caveats), the oracle cannot cheat selectively.\n   All verifiers verify all (public) data commitments out of self-interest.\n3. **Provability**\n   Fraud proofs are trivial to construct and share.\n\nThese properties mean the oracle has a significantly reduced chance of cheating without detection, increasing the expected cost of dishonest behavior.\nWhen multiple such oracles are combined, the chance of successful, economically rational cheating is also reduced, further diminishing incentives to attempt it.\nAs a result, this scheme may be sufficient to enable a wide array of advanced protocols, including MEVil-generating protocols (for instance AMMs) that I and others wish to avoid.\nSince a key motivation for `OP_PAIRCOMMIT` is to avoid enabling exactly these kinds of smart contracts, this observation slightly weakens the case for `OP_PAIRCOMMIT`.\n\nFurthermore, I suspect (but don\u2019t know) that oracles could have BitVM secured bonds which could be slashed if they publish signatures over invalid commitments.\nIn this case, oracles would publish their signature and a proof that they calculated the block commitment `bc(x)` correctly.\nThis is perhaps the most interesting, and potentially offers a substantial improvement in incentives compared to other oracle constructions.\nHowever, I\u2019m not positive this can work, as I\u2019m not well versed in the exciting developments in the BitVM arena.\n\nBut taken together, using multiple oracles producing trivially verifiable commitments, with slashable bonds, this scheme may make powerful introspection possible with only `OP_PAIRCOMMIT` and `OP_CHECKSIGFROMSTACK`.\n\n# Further Thoughts\n\nThe general principle is that using a vector commitment an oracle can sign a commitment to an arbitrarily large set of data, and if this set of data can be easily verified, then users have a higher than normal assurance that the oracle cannot get away with cheating.\nIf BitVM bonds can be fashioned for these oracles, and if they could be made for other chains (I don\u2019t see why not), it might enable an interesting class of bridges.\nIf it\u2019s possible, it still requires careful consideration.\nBond values and funds secured can, without detection, become unbalanced to the point that good oracle behavior is no longer economically incentivized.\n\n# Caveats\n\nA reliable public publishing system is required to assume only one commitment per block per oracle.\nIn practice, something like publishing commitments on nostr should be sufficient.\nNevertheless, it is still possible for an oracle to attempt private cheating by collusion.\nAn oracle may collude with a smart contract actor to provide an invalid commitment only to that actor (so that they can defraud another smart contract actor).\nVerifiers can still identify this kind of cheating with a bit more work, as long as the commitment ends up on chain.\nOff-chain protocols using these oracles lose this protection entirely, and would need to verify the commitments themselves.\n\n# LLM Disclosure\n\nI'm not sure anyone cares on delving but just in case...\nThe original draft of this was 100% written by me, but I'm a pretty crummy writer (just look at my other posts).\nChatGPT helped me clean up the prose significantly, all edits were applied manually by me.\nI tried to never take its suggestions verbatim, but there were times the suggestion was unambiguously better than anything I could come up with.\nNone of the concepts come from or are derived from ChatGPT output.\nEven the overall structure is mostly from my first draft.",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 276,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": "Github link was replaced with a permanent link",
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "<a name=\"p-6791-tl-dr-1\" class=\"anchor\" href=\"#p-6791-tl-dr-1\" aria-label=\"Heading link\"></a>TL; DR\nBy combining OP_CHECKSIGFROMSTACK with a vector commitment, you can build public blockchain oracles that provide powerful introspection abilities to bitcoin scripts.\nWhile oracle based verification is well understood, this scheme has unusually strong incentives for honest behavior relative to&hellip;",
  "truncated": true,
  "post_url": "/t/arbitrary-introspection-using-paircommit-csfs-and-oracles/2243/1",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}