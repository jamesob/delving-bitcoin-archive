{
  "id": 6979,
  "name": "Toby Sharp",
  "username": "tobysharp",
  "avatar_template": "/letter_avatar_proxy/v4/letter/t/dbc845/{size}.png",
  "created_at": "2026-02-27T06:53:09.689Z",
  "cooked": "<h1><a name=\"p-6979-hornet-node-1\" class=\"anchor\" href=\"#p-6979-hornet-node-1\" aria-label=\"Heading link\"></a>Hornet Node</h1>\n<p>Bitcoin\u2019s consensus rules have never existed as a standalone specification \u2013 they are defined implicitly by the reference client. Hornet Node is an attempt to change that: a minimal, ground-up Bitcoin client built around a declarative spec. As a side effect of the novel architecture, it currently validates mainnet 10x faster than Core v30 (<code>-assumevalid</code> on 32-core workstation).</p>\n<p>I published a paper last September [1] introducing Hornet and posted it to the bitcoin-dev mailing list. In case you missed it, I\u2019m recapping here with code snippets and the latest developments.</p>\n<h2><a name=\"p-6979-part-i-hornet-node-2\" class=\"anchor\" href=\"#p-6979-part-i-hornet-node-2\" aria-label=\"Heading link\"></a>Part I: Hornet Node</h2>\n<p>Hornet Node is a <strong>specification-first</strong> minimal alternative Bitcoin client built from scratch for clarity, correctness, and performance.</p>\n<h3><a name=\"p-6979-what-problem-is-hornet-aiming-to-solve-3\" class=\"anchor\" href=\"#p-6979-what-problem-is-hornet-aiming-to-solve-3\" aria-label=\"Heading link\"></a><strong>What problem is Hornet aiming to solve?</strong></h3>\n<p>Bitcoin is defined by its consensus rules, yet those rules have never existed as a clear, independent specification. Hornet begins from the premise that the protocol deserves a precise, executable foundation separate from any particular codebase, so that Bitcoin\u2019s software can evolve and diversify safely even as its rules ossify.</p>\n<h3><a name=\"p-6979-the-goals-of-hornet-node-are-4\" class=\"anchor\" href=\"#p-6979-the-goals-of-hornet-node-are-4\" aria-label=\"Heading link\"></a><strong>The goals of Hornet Node are:</strong></h3>\n<ul>\n<li>Show that Bitcoin consensus can be expressed as a clear, concise, executable specification without side effects.</li>\n<li>Provide a correct, auditable, and compact implementation with a path toward formal verification.</li>\n<li>Offer a working alternative client for experimentation, education, and client diversification.</li>\n<li>Demonstrate how clean architecture can also enable significant performance improvements.</li>\n</ul>\n<h3><a name=\"p-6979-current-status-5\" class=\"anchor\" href=\"#p-6979-current-status-5\" aria-label=\"Heading link\"></a><strong>Current status</strong></h3>\n<p>Currently Hornet Node can validate mainnet in 15 minutes using <code>-assumevalid</code> on a 32-core workstation.</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/2X/9/9b7d4dfd0aa375511b85579b845c00c29fdcfb06.jpeg\" data-download-href=\"https://delvingbitcoin.org/uploads/default/9b7d4dfd0aa375511b85579b845c00c29fdcfb06\" title=\"sync\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/2X/9/9b7d4dfd0aa375511b85579b845c00c29fdcfb06_2_690x458.jpeg\" alt=\"sync\" data-base62-sha1=\"mbwtfTFCNqxH1ADeO2KgRrAgyIS\" width=\"690\" height=\"458\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/2X/9/9b7d4dfd0aa375511b85579b845c00c29fdcfb06_2_690x458.jpeg, https://delvingbitcoin.org/uploads/default/optimized/2X/9/9b7d4dfd0aa375511b85579b845c00c29fdcfb06_2_1035x687.jpeg 1.5x, https://delvingbitcoin.org/uploads/default/optimized/2X/9/9b7d4dfd0aa375511b85579b845c00c29fdcfb06_2_1380x916.jpeg 2x\" data-dominant-color=\"464544\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">sync</span><span class=\"informations\">2472\u00d71644 758 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<blockquote>\n<p><em>Hornet Node performing IBD and displaying status info in a browser window.</em></p>\n</blockquote>\n<h2><a name=\"p-6979-part-ii-hornets-declarative-c-consensus-spec-6\" class=\"anchor\" href=\"#p-6979-part-ii-hornets-declarative-c-consensus-spec-6\" aria-label=\"Heading link\"></a>Part II: Hornet\u2019s Declarative C++ Consensus Spec</h2>\n<p>Validation rulesets are expressed as a hierarchy of composable, declarative, pure, free functions over immutable inputs, returning a single error code. The declarative focus means that we emphasize what must be true rather than how to compute it. The pure functions mean that there are no side effects or other mutated state.</p>\n<p>At the highest level, the consensus library API exposes the <code>ValidateBlock</code> function to determine whether an incoming block is valid to be appended to a specific parent block in the timechain.</p>\n<pre data-code-wrap=\"cpp\"><code class=\"lang-cpp\">// Each block MUST obey all consensus rules.\n[[nodiscard]] inline Result ValidateBlock(const protocol::Block&amp; block,       // The block to validate.\n                                        const protocol::BlockHeader&amp; parent,  // The preceding block's header.\n                                        const HeaderAncestryView&amp; view,       // A view onto the chain of previous headers.\n                                        const int64_t current_time,           // The current time in milliseconds since 1970-01-01T00:00:00Z.\n                                        const UnspentOutputsView&amp; unspent) {  // A view onto the set of all unspent transaction outputs.\n  // clang-format off\n  static const auto ruleset = std::make_tuple(\n    Rule{ValidateHeader,          MakeHeaderContext},         // Each block MUST begin with a valid header.\n    Rule{ValidateNonSpending,     MakeEnvironmentContext},    // Each block MUST obey structural and contextual consensus rules.\n    Rule{ValidateSpending,        MakeBlockSpendingContext}   // Each transaction input MUST be spendable in the current block.\n  );\n  // clang-format on                                            \n  const BlockValidationContext context{block, parent, view, current_time, unspent};\n  return ValidateRules(ruleset, view.Length(), context);\n}\n</code></pre>\n<p>The lower-level validation functions like <code>ValidateHeader</code> are implemented themselves as a set of specification rules, each accompanied by a clear English statement of the rule being enforced.</p>\n<pre data-code-wrap=\"cpp\"><code class=\"lang-cpp\">// Performs header validation, aligned with Core's CheckBlockHeader and ContextualCheckBlockHeader.\n[[nodiscard]] inline Result ValidateHeader(const HeaderValidationContext&amp; context) {\n  // clang-format off\n  static const auto ruleset = std::make_tuple(\n    Rule{ValidatePreviousHash},         // A header MUST reference the hash of its valid parent.\n    Rule{ValidateProofOfWork},          // A header MUST satisfy the chain's target proof-of-work.\n    Rule{ValidateDifficultyAdjustment}, // A header's proof-of-work target MUST satisfy the difficulty adjustment formula.\n    Rule{ValidateMedianTimePast},       // A header timestamp MUST be strictly greater than the median of its 11 ancestors' timestamps.\n    Rule{ValidateTimestampCurrent},     // A header timestamp MUST be less than or equal to network-adjusted time plus 2 hours.\n    Rule{ValidateVersion}               // A header version number MUST meet deployment requirements depending on activated BIPs.\n  );\n  // clang-format on\n  return ValidateRules(ruleset, 0, context);\n}\n</code></pre>\n<p>At the lowest level, validation rules each return either success, or a specific error code.</p>\n<pre data-code-wrap=\"cpp\"><code class=\"lang-cpp\">// A header MUST reference the hash of its valid parent.\n[[nodiscard]] inline Result ValidatePreviousHash(\n    const HeaderValidationContext&amp; context) {\n  if (context.parent.ComputeHash() != context.header.GetPreviousBlockHash())\n    return Error::Header_ParentNotFound;\n  return {};\n}\n\n// A header's 256-bit hash value MUST NOT exceed the header's proof-of-work target.\n[[nodiscard]] inline Result ValidateProofOfWork(\n    const HeaderValidationContext&amp; context) {\n  const auto hash = context.header.ComputeHash();\n  const auto target = context.header.GetCompactTarget().Expand();\n  if (!(hash &lt;= target)) return Error::Header_InvalidProofOfWork;\n  return {};\n}\n</code></pre>\n<p>The entire executable consensus spec occupies ~800 lines of code.</p>\n<h2><a name=\"p-6979-part-iii-the-hornet-validation-pipeline-and-utxo-database-7\" class=\"anchor\" href=\"#p-6979-part-iii-the-hornet-validation-pipeline-and-utxo-database-7\" aria-label=\"Heading link\"></a>Part III: The Hornet Validation Pipeline and UTXO Database</h2>\n<p>In a previous post [3] I wrote about the Hornet UTXO(1) lock-free database that I wrote to enable a highly parallel validation engine that can process many blocks concurrently during IBD. (Also discussed on Optech Podcast <span class=\"hashtag-raw\">#391</span> [4].)</p>\n<p>This is how I was able to get the IBD validation time down to 15 minutes on my local workstation, compared to 167 minutes with Core v30. The stateless nature of consensus validation is also an important aspect here. Some more detailed but rough notes on my custom database can be found here pending a full write-up [5].</p>\n<p>Although consensus logic requires the concept of querying a set of unspent transaction outputs, the database mechanics are not exposed to the consensus layer, so that concerns remain separated. Instead, the consensus layer defines a pure interface that allows either to query for existence of unspent outputs (e.g. <code>-assumevalid</code>), or to actually retrieve the stored state for those outputs.</p>\n<pre data-code-wrap=\"cpp\"><code class=\"lang-cpp\">// This class represents an abstract view onto the whole set of unspent outputs.\nclass UnspentOutputsView {\n public:\n  virtual ~UnspentOutputsView() = default;\n\n  // Returns success if all the block's transaction inputs correspond to pre-existing unspent transaction outputs.\n  // Otherwise, returns Error::Transaction_NotUnspent.\n  virtual Result QueryPrevoutsUnspent(const protocol::Block&amp; block) const = 0;\n\n  // Calls fn for each transaction input, passing in the stored state from the corresponding previous output.\n  // Or, if any transaction input does not correspond to an unspent output, returns Error::Transaction_NotUnspent.\n  template &lt;typename Fn&gt; Result ForEachSpend(const protocol::Block&amp; block, Fn&amp;&amp; fn) const;\n};\n</code></pre>\n<p>The rule to validate the spendability of a block\u2019s transactions calls this interface to validate scripts for each input:</p>\n<pre data-code-wrap=\"cpp\"><code class=\"lang-cpp\">// Each transaction input MUST be spendable in the current block.\n[[nodiscard]] inline Result ValidateSpending(const BlockSpendingContext&amp; context) {\n  return context.unspent.ForEachSpend(context.block,\n    [&amp;](const SpendRecord&amp; spend) { \n      return ValidateInputSpend(spend, context.height);\n    });\n}\n</code></pre>\n<p>where the <code>SpendRecord</code> includes the pubkey script and other details from the funding transaction.</p>\n<pre data-code-wrap=\"cpp\"><code class=\"lang-cpp\">struct SpendRecord {\n  int funding_height;\n  uint32_t funding_flags;\n  int64_t amount;\n  std::span&lt;const uint8_t&gt; pubkey_script;\n  protocol::TransactionConstView tx;\n  int spend_input_index;\n\n  bool IsCoinbase() const { return funding_flags &amp; 1; }\n};\n</code></pre>\n<p>This keeps the consensus layer nicely compact and separate from all of the implementation choices of the UTXO database.</p>\n<h2><a name=\"p-6979-part-iv-the-hornet-dsl-8\" class=\"anchor\" href=\"#p-6979-part-iv-the-hornet-dsl-8\" aria-label=\"Heading link\"></a>Part IV: The Hornet DSL</h2>\n<p>Beyond the C++ declarative specification, the goal of Hornet is to go further and express the consensus rules in a pure functional language. Such a restricted language can be designed to facilitate formal verification of a client to the spec. An interpreter or compiler for such a spec could in theory be formally proven to implement the specification exactly. This would be the holy grail of consensus that allows for client diversity without risk of consensus split due to coding bugs.</p>\n<p>This part of Hornet is future work. However, my early drafts for the specification DSL are experimenting with a precise, mathematical style. The language has the following properties:</p>\n<ul>\n<li>Pure functional style. Every rule is a function from inputs to a result with no hidden dependencies or side effects. Rules compose the way mathematical propositions do. All variables are immutable.</li>\n<li>Mathematical notation. Quantifiers (\u2200, \u2203), set membership (\u2208), concatenation (\u29fa), and summation (\u03a3) express functional operators succinctly. The non-ASCII characters are a deliberate choice for a spec that will be read and audited far more than it is edited.</li>\n<li>Native serialization. Protocol types like <code>Block</code>, <code>Transaction</code>, and <code>Header</code> are defined as plain structs with built-in serialization semantics, so the spec defines the wire format and the validation logic in the same language.</li>\n<li>Built-in cryptographic primitives. Functions like SHA256 and secp256k1 verification are treated as built-in axioms, defined in other specification documents.</li>\n</ul>\n<pre><code class=\"lang-auto\">// Returns the Merkle root of a sequence of hashes, defined recursively.\nLet MerkleRoot : (xs \u2208 Hash\u27e8\u27e9, unique \u2208 bool := true) -&gt; (root \u2208 Hash, unique \u2208 bool)\n    // Make a tuple from each consecutive pair in the sequence, ignoring any odd tail.\n    Let pairs :=\n        \u27e8 (xs[2i], xs[2i + 1]) : i \u2208 \u27e60, |xs| / 2\u27ef \u27e9\n    // Evaluate whether uniqueness is preserved among all such pairs.\n    Let unique_at_level := \u2200 (a, b) \u2208 pairs, a \u2260 b\n    // Duplicate an odd tail for completeness.\n    Let extended :=\n    \u23a7   pairs                         if |xs| even,\n    \u23a9   pairs \u29fa (xs.last, xs.last)    otherwise\n\n|-&gt; \u23a7   (xs.first, unique)  if |xs| = 1,  // Returns the root hash and the accumulated uniqueness.\n    \u23a8   MerkleRoot(\u27e8SHA256\u00b2(a \u29fa b) : (a, b) \u2208 extended\u27e9, unique \u2227 unique_at_level)\n    \u23a9                       otherwise     // Recurses into the next level of the tree.\n</code></pre>\n<p>In the <code>MerkleRoot</code> function above, we define the Bitcoin-specific logic for grouping pairs of leaves and repeating the last leaf in an odd cardinality. Notice how the functional style specifies the required logic and constructions, rather than what machine instructions should be used to compute the result.</p>\n<p>The resulting code (9 lines plus comments) is remarkably concise without losing any precision. The style will be most legible to readers with familiarity in mathematics.</p>\n<p>Below, the <code>Rule</code> keyword denotes a function with one or more <code>Require</code> statements: these evaluate a Boolean expression, and if false, a named error bubbles up the stack to fail validation.</p>\n<pre><code class=\"lang-auto\">// The total number of signature operations in a block MUST NOT exceed the consensus maximum.\nRule SigOpLimit(block \u2208 Block)\n    Let SigOpCost : (op \u2208 OpCode) -&gt; int32 |-&gt; \n      \u23a7  1  if op \u2208 {Op_CheckSig,      Op_CheckSigVerify     },\n      \u23a8 20  if op \u2208 {Op_CheckMultiSig, Op_CheckMultiSigVerify},\n      \u23a9  0  otherwise\n    Require \u03a3 SigOpCost(inst.opcode)\n            \u2200 inst \u2208 script.instructions\n            \u2200 script \u2208 tx.inputs.scriptSig \u29fa tx.outputs.scriptPubKey\n            \u2200 tx \u2208 block.transactions\n        \u2264 20,000\n</code></pre>\n<p>In <code>SigOpLimit</code> here, we use projections, concatenation, and a local function to express the legacy sigop cost extremely compactly.</p>\n<p>Below, these functions and some others not shown here are combined for the structural block validation:</p>\n<pre><code class=\"lang-auto\">Rule ValidateBlockStructure(block \u2208 Block)\n    // A block MUST contain at least one transaction.\n    Require NonEmptyBlock:      block.transactions \u2260 \u2205\n\n    // A block\u2019s Merkle root field MUST equal the Merkle root of its transaction list.\n    Require ValidateMerkleRoot(block)\n    \n    // A block\u2019s serialized size (before SegWit) MUST NOT exceed 1,000,000 bytes.\n    Require OriginalSizeLimit:  |SerializeNoWitness(block)| &lt;= 1,000,000\n    \n    // A block MUST contain exactly one coinbase transaction, and it MUST be the first transaction.\n    Require UniqueCoinbase:     \u2203! tx \u2208 block.transactions : IsCoinbase(tx)\n    Require CoinbaseFirst:      IsCoinbase(block.transactions.first)\n\n    // Every transaction in a block MUST be valid according to transaction-level consensus rules.\n    Require \u2200 tx \u2208 block.transactions, ValidateTransaction(tx)\n\n    // The total number of signature operations in a block MUST NOT exceed the consensus maximum.\n    Require SigOpLimit(block)\n</code></pre>\n<p>The Hornet DSL specification will also be declarative and executable. But unlike the C++ specification, it will be a pure, formal specification with a path to formal reasoning and verification. It will also be legible to engineers, mathematicians, and all programmers, rather than only to C++ developers.</p>\n<h2><a name=\"p-6979-summary-9\" class=\"anchor\" href=\"#p-6979-summary-9\" aria-label=\"Heading link\"></a>Summary</h2>\n<p>Hornet Node is a new, compact, alternative Bitcoin client built around a pure, declarative specification of consensus rules in modern C++. This stage of development is almost complete, with IBD running 10x the speed of Core v30. A future phase will be to migrate the specification to a pure, functional domain-specific language custom-designed to formally express the consensus rules in the clearest and most precise form.</p>\n<p>If you have questions or feedback, feel free to drop me a reply.</p>\n<p>I also wrote an overview with more details and some FAQ [2].</p>\n<p>Hornet is a self-funded project. If you\u2019d like to support my work on a formal specification for Bitcoin consensus, you can donate to <code>33Y6TCLKvgjgk69CEAmDPijgXeTaXp8hYd</code>, or get in touch.</p>\n<p>Thanks in advance for any interest, encouragement, and support.</p>\n<p>Best wishes,<br>\nT#</p>\n<p>[1] Hornet Node and the Hornet DSL: A minimal, executable specification for Bitcoin consensus by Toby Sharp, September 2025. <a href=\"https://arxiv.org/abs/2509.15754\" rel=\"noopener nofollow ugc\">arXiv PDF</a></p>\n<p>[2] hornetnode dot org / overview.html</p>\n<p>[3] <a href=\"https://delvingbitcoin.org/t/hornet-utxo-1-a-custom-constant-time-highly-parallel-utxo-database/2201\" class=\"inline-onebox\">Hornet UTXO(1): A custom, constant-time, highly parallel UTXO database</a></p>\n<p>[4] <a href=\"https://bitcoinops.org/en/podcast/2026/02/10/\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">Bitcoin Optech Newsletter #391 Recap Podcast | Bitcoin Optech</a></p>\n<p>[5] hornetnode dot org / utxo.html</p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 1,
  "updated_at": "2026-02-27T06:53:09.689Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 5,
  "readers_count": 4,
  "score": 1.0,
  "yours": false,
  "topic_id": 2300,
  "topic_slug": "hornet-node-v0-1-update",
  "topic_title": "Hornet Node v0.1 Update",
  "topic_html_title": "Hornet Node v0.1 Update",
  "category_id": 8,
  "display_username": "Toby Sharp",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "# Hornet Node\n\nBitcoin's consensus rules have never existed as a standalone specification -- they are defined implicitly by the reference client. Hornet Node is an attempt to change that: a minimal, ground-up Bitcoin client built around a declarative spec. As a side effect of the novel architecture, it currently validates mainnet 10x faster than Core v30 (`-assumevalid` on 32-core workstation).\n\nI published a paper last September [1] introducing Hornet and posted it to the bitcoin-dev mailing list. In case you missed it, I'm recapping here with code snippets and the latest developments.\n\n## Part I: Hornet Node\n\nHornet Node is a **specification-first** minimal alternative Bitcoin client built from scratch for clarity, correctness, and performance. \n\n### **What problem is Hornet aiming to solve?**\n\nBitcoin is defined by its consensus rules, yet those rules have never existed as a clear, independent specification. Hornet begins from the premise that the protocol deserves a precise, executable foundation separate from any particular codebase, so that Bitcoin's software can evolve and diversify safely even as its rules ossify.\n\n### **The goals of Hornet Node are:**\n* Show that Bitcoin consensus can be expressed as a clear, concise, executable specification without side effects.\n* Provide a correct, auditable, and compact implementation with a path toward formal verification.\n* Offer a working alternative client for experimentation, education, and client diversification.\n* Demonstrate how clean architecture can also enable significant performance improvements.\n\n### **Current status**\n\nCurrently Hornet Node can validate mainnet in 15 minutes using `-assumevalid` on a 32-core workstation.\n\n![sync|690x458, 100%](upload://mbwtfTFCNqxH1ADeO2KgRrAgyIS.jpeg)\n> *Hornet Node performing IBD and displaying status info in a browser window.*\n\n## Part II: Hornet's Declarative C++ Consensus Spec\n\nValidation rulesets are expressed as a hierarchy of composable, declarative, pure, free functions over immutable inputs, returning a single error code. The declarative focus means that we emphasize what must be true rather than how to compute it. The pure functions mean that there are no side effects or other mutated state.\n\nAt the highest level, the consensus library API exposes the `ValidateBlock` function to determine whether an incoming block is valid to be appended to a specific parent block in the timechain.\n\n```cpp\n// Each block MUST obey all consensus rules.\n[[nodiscard]] inline Result ValidateBlock(const protocol::Block& block,       // The block to validate.\n                                        const protocol::BlockHeader& parent,  // The preceding block's header.\n                                        const HeaderAncestryView& view,       // A view onto the chain of previous headers.\n                                        const int64_t current_time,           // The current time in milliseconds since 1970-01-01T00:00:00Z.\n                                        const UnspentOutputsView& unspent) {  // A view onto the set of all unspent transaction outputs.\n  // clang-format off\n  static const auto ruleset = std::make_tuple(\n    Rule{ValidateHeader,          MakeHeaderContext},         // Each block MUST begin with a valid header.\n    Rule{ValidateNonSpending,     MakeEnvironmentContext},    // Each block MUST obey structural and contextual consensus rules.\n    Rule{ValidateSpending,        MakeBlockSpendingContext}   // Each transaction input MUST be spendable in the current block.\n  );\n  // clang-format on                                            \n  const BlockValidationContext context{block, parent, view, current_time, unspent};\n  return ValidateRules(ruleset, view.Length(), context);\n}\n```\n\nThe lower-level validation functions like `ValidateHeader` are implemented themselves as a set of specification rules, each accompanied by a clear English statement of the rule being enforced.\n\n```cpp\n// Performs header validation, aligned with Core's CheckBlockHeader and ContextualCheckBlockHeader.\n[[nodiscard]] inline Result ValidateHeader(const HeaderValidationContext& context) {\n  // clang-format off\n  static const auto ruleset = std::make_tuple(\n    Rule{ValidatePreviousHash},         // A header MUST reference the hash of its valid parent.\n    Rule{ValidateProofOfWork},          // A header MUST satisfy the chain's target proof-of-work.\n    Rule{ValidateDifficultyAdjustment}, // A header's proof-of-work target MUST satisfy the difficulty adjustment formula.\n    Rule{ValidateMedianTimePast},       // A header timestamp MUST be strictly greater than the median of its 11 ancestors' timestamps.\n    Rule{ValidateTimestampCurrent},     // A header timestamp MUST be less than or equal to network-adjusted time plus 2 hours.\n    Rule{ValidateVersion}               // A header version number MUST meet deployment requirements depending on activated BIPs.\n  );\n  // clang-format on\n  return ValidateRules(ruleset, 0, context);\n}\n```\n\nAt the lowest level, validation rules each return either success, or a specific error code.\n\n```cpp\n// A header MUST reference the hash of its valid parent.\n[[nodiscard]] inline Result ValidatePreviousHash(\n    const HeaderValidationContext& context) {\n  if (context.parent.ComputeHash() != context.header.GetPreviousBlockHash())\n    return Error::Header_ParentNotFound;\n  return {};\n}\n\n// A header's 256-bit hash value MUST NOT exceed the header's proof-of-work target.\n[[nodiscard]] inline Result ValidateProofOfWork(\n    const HeaderValidationContext& context) {\n  const auto hash = context.header.ComputeHash();\n  const auto target = context.header.GetCompactTarget().Expand();\n  if (!(hash <= target)) return Error::Header_InvalidProofOfWork;\n  return {};\n}\n```\n\nThe entire executable consensus spec occupies ~800 lines of code.\n\n## Part III: The Hornet Validation Pipeline and UTXO Database\n\nIn a previous post [3] I wrote about the Hornet UTXO(1) lock-free database that I wrote to enable a highly parallel validation engine that can process many blocks concurrently during IBD. (Also discussed on Optech Podcast #391 [4].)\n\nThis is how I was able to get the IBD validation time down to 15 minutes on my local workstation, compared to 167 minutes with Core v30. The stateless nature of consensus validation is also an important aspect here. Some more detailed but rough notes on my custom database can be found here pending a full write-up [5].\n\nAlthough consensus logic requires the concept of querying a set of unspent transaction outputs, the database mechanics are not exposed to the consensus layer, so that concerns remain separated. Instead, the consensus layer defines a pure interface that allows either to query for existence of unspent outputs (e.g. `-assumevalid`), or to actually retrieve the stored state for those outputs.\n\n```cpp\n// This class represents an abstract view onto the whole set of unspent outputs.\nclass UnspentOutputsView {\n public:\n  virtual ~UnspentOutputsView() = default;\n\n  // Returns success if all the block's transaction inputs correspond to pre-existing unspent transaction outputs.\n  // Otherwise, returns Error::Transaction_NotUnspent.\n  virtual Result QueryPrevoutsUnspent(const protocol::Block& block) const = 0;\n\n  // Calls fn for each transaction input, passing in the stored state from the corresponding previous output.\n  // Or, if any transaction input does not correspond to an unspent output, returns Error::Transaction_NotUnspent.\n  template <typename Fn> Result ForEachSpend(const protocol::Block& block, Fn&& fn) const;\n};\n```\n\nThe rule to validate the spendability of a block's transactions calls this interface to validate scripts for each input:\n\n```cpp\n// Each transaction input MUST be spendable in the current block.\n[[nodiscard]] inline Result ValidateSpending(const BlockSpendingContext& context) {\n  return context.unspent.ForEachSpend(context.block,\n    [&](const SpendRecord& spend) { \n      return ValidateInputSpend(spend, context.height);\n    });\n}\n```\n\nwhere the `SpendRecord` includes the pubkey script and other details from the funding transaction.\n\n```cpp\nstruct SpendRecord {\n  int funding_height;\n  uint32_t funding_flags;\n  int64_t amount;\n  std::span<const uint8_t> pubkey_script;\n  protocol::TransactionConstView tx;\n  int spend_input_index;\n\n  bool IsCoinbase() const { return funding_flags & 1; }\n};\n```\n\nThis keeps the consensus layer nicely compact and separate from all of the implementation choices of the UTXO database.\n\n## Part IV: The Hornet DSL\n\nBeyond the C++ declarative specification, the goal of Hornet is to go further and express the consensus rules in a pure functional language. Such a restricted language can be designed to facilitate formal verification of a client to the spec. An interpreter or compiler for such a spec could in theory be formally proven to implement the specification exactly. This would be the holy grail of consensus that allows for client diversity without risk of consensus split due to coding bugs.\n\nThis part of Hornet is future work. However, my early drafts for the specification DSL are experimenting with a precise, mathematical style. The language has the following properties:\n\n- Pure functional style. Every rule is a function from inputs to a result with no hidden dependencies or side effects. Rules compose the way mathematical propositions do. All variables are immutable.\n- Mathematical notation. Quantifiers (\u2200, \u2203), set membership (\u2208), concatenation (\u29fa), and summation (\u03a3) express functional operators succinctly. The non-ASCII characters are a deliberate choice for a spec that will be read and audited far more than it is edited.\n- Native serialization. Protocol types like `Block`, `Transaction`, and `Header` are defined as plain structs with built-in serialization semantics, so the spec defines the wire format and the validation logic in the same language.\n- Built-in cryptographic primitives. Functions like SHA256 and secp256k1 verification are treated as built-in axioms, defined in other specification documents.\n\n```f#\n// Returns the Merkle root of a sequence of hashes, defined recursively.\nLet MerkleRoot : (xs \u2208 Hash\u27e8\u27e9, unique \u2208 bool := true) -> (root \u2208 Hash, unique \u2208 bool)\n    // Make a tuple from each consecutive pair in the sequence, ignoring any odd tail.\n    Let pairs :=\n        \u27e8 (xs[2i], xs[2i + 1]) : i \u2208 \u27e60, |xs| / 2\u27ef \u27e9\n    // Evaluate whether uniqueness is preserved among all such pairs.\n    Let unique_at_level := \u2200 (a, b) \u2208 pairs, a \u2260 b\n    // Duplicate an odd tail for completeness.\n    Let extended :=\n    \u23a7   pairs                         if |xs| even,\n    \u23a9   pairs \u29fa (xs.last, xs.last)    otherwise\n\n|-> \u23a7   (xs.first, unique)  if |xs| = 1,  // Returns the root hash and the accumulated uniqueness.\n    \u23a8   MerkleRoot(\u27e8SHA256\u00b2(a \u29fa b) : (a, b) \u2208 extended\u27e9, unique \u2227 unique_at_level)\n    \u23a9                       otherwise     // Recurses into the next level of the tree.\n```\n\nIn the `MerkleRoot` function above, we define the Bitcoin-specific logic for grouping pairs of leaves and repeating the last leaf in an odd cardinality. Notice how the functional style specifies the required logic and constructions, rather than what machine instructions should be used to compute the result.\n\nThe resulting code (9 lines plus comments) is remarkably concise without losing any precision. The style will be most legible to readers with familiarity in mathematics.\n\nBelow, the `Rule` keyword denotes a function with one or more `Require` statements: these evaluate a Boolean expression, and if false, a named error bubbles up the stack to fail validation.\n\n```f#\n// The total number of signature operations in a block MUST NOT exceed the consensus maximum.\nRule SigOpLimit(block \u2208 Block)\n    Let SigOpCost : (op \u2208 OpCode) -> int32 |-> \n      \u23a7  1  if op \u2208 {Op_CheckSig,      Op_CheckSigVerify     },\n      \u23a8 20  if op \u2208 {Op_CheckMultiSig, Op_CheckMultiSigVerify},\n      \u23a9  0  otherwise\n    Require \u03a3 SigOpCost(inst.opcode)\n            \u2200 inst \u2208 script.instructions\n            \u2200 script \u2208 tx.inputs.scriptSig \u29fa tx.outputs.scriptPubKey\n            \u2200 tx \u2208 block.transactions\n        \u2264 20,000\n```\n\nIn `SigOpLimit` here, we use projections, concatenation, and a local function to express the legacy sigop cost extremely compactly.\n\nBelow, these functions and some others not shown here are combined for the structural block validation:\n\n```f#\nRule ValidateBlockStructure(block \u2208 Block)\n    // A block MUST contain at least one transaction.\n    Require NonEmptyBlock:      block.transactions \u2260 \u2205\n\n    // A block\u2019s Merkle root field MUST equal the Merkle root of its transaction list.\n    Require ValidateMerkleRoot(block)\n    \n    // A block\u2019s serialized size (before SegWit) MUST NOT exceed 1,000,000 bytes.\n    Require OriginalSizeLimit:  |SerializeNoWitness(block)| <= 1,000,000\n    \n    // A block MUST contain exactly one coinbase transaction, and it MUST be the first transaction.\n    Require UniqueCoinbase:     \u2203! tx \u2208 block.transactions : IsCoinbase(tx)\n    Require CoinbaseFirst:      IsCoinbase(block.transactions.first)\n\n    // Every transaction in a block MUST be valid according to transaction-level consensus rules.\n    Require \u2200 tx \u2208 block.transactions, ValidateTransaction(tx)\n\n    // The total number of signature operations in a block MUST NOT exceed the consensus maximum.\n    Require SigOpLimit(block)\n```\n\nThe Hornet DSL specification will also be declarative and executable. But unlike the C++ specification, it will be a pure, formal specification with a path to formal reasoning and verification. It will also be legible to engineers, mathematicians, and all programmers, rather than only to C++ developers.\n\n\n## Summary\n\nHornet Node is a new, compact, alternative Bitcoin client built around a pure, declarative specification of consensus rules in modern C++. This stage of development is almost complete, with IBD running 10x the speed of Core v30. A future phase will be to migrate the specification to a pure, functional domain-specific language custom-designed to formally express the consensus rules in the clearest and most precise form.\n\nIf you have questions or feedback, feel free to drop me a reply.\n\nI also wrote an overview with more details and some FAQ [2].\n\nHornet is a self-funded project. If you'd like to support my work on a formal specification for Bitcoin consensus, you can donate to `33Y6TCLKvgjgk69CEAmDPijgXeTaXp8hYd`, or get in touch.\n\nThanks in advance for any interest, encouragement, and support.\n\nBest wishes,\\\nT#\n\n[1] Hornet Node and the Hornet DSL: A minimal, executable specification for Bitcoin consensus by Toby Sharp, September 2025. [arXiv PDF](https://arxiv.org/abs/2509.15754)\n\n[2] hornetnode dot org / overview.html\n\n[3] https://delvingbitcoin.org/t/hornet-utxo-1-a-custom-constant-time-highly-parallel-utxo-database/2201\n\n[4] https://bitcoinops.org/en/podcast/2026/02/10/\n\n[5] hornetnode dot org / utxo.html",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 1037,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "<a name=\"p-6979-hornet-node-1\" class=\"anchor\" href=\"#p-6979-hornet-node-1\" aria-label=\"Heading link\"></a>Hornet Node\nBitcoin\u2019s consensus rules have never existed as a standalone specification \u2013 they are defined implicitly by the reference client. Hornet Node is an attempt to change that: a minimal, ground-up Bitcoin client built around a declarative spec. As a side effect of the novel architecture, it &hellip;",
  "truncated": true,
  "post_url": "/t/hornet-node-v0-1-update/2300/1",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}