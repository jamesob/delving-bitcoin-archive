{
  "id": 6762,
  "name": "Galois Field",
  "username": "GaloisField2718",
  "avatar_template": "/user_avatar/delvingbitcoin.org/galoisfield2718/{size}/824_2.png",
  "created_at": "2026-02-06T22:57:26.067Z",
  "cooked": "<h1><a name=\"p-6762-a-max-plus-perspective-on-package-relay-and-block-assembly-1\" class=\"anchor\" href=\"#p-6762-a-max-plus-perspective-on-package-relay-and-block-assembly-1\" aria-label=\"Heading link\"></a>A max-plus perspective on package relay and block assembly</h1>\n<h2><a name=\"p-6762-motivation-2\" class=\"anchor\" href=\"#p-6762-motivation-2\" aria-label=\"Heading link\"></a>Motivation</h2>\n<p>Package relay, CPFP, ancestor limits, and block assembly are often discussed separately. In practice, they interact tightly, and their combined behavior can be hard to reason about.</p>\n<p>Common observations include:</p>\n<ul>\n<li>sharp inclusion thresholds for packages,</li>\n<li>blocks that appear to leave some weight unused,</li>\n<li>small fee changes that suddenly make a transaction viable.</li>\n</ul>\n<p>This post proposes a simple conceptual framework to reason about these effects. It does <strong>not</strong> suggest any protocol or policy change.</p>\n<p><em>Related work includes mempool-based fee estimation techniques, which derive practical estimates from block templates. The perspective in this post abstracts beyond specific heuristics to clarify underlying economic incentives and marginal trade-offs.</em></p>\n<hr>\n<h2><a name=\"p-6762-what-miners-are-effectively-optimizing-3\" class=\"anchor\" href=\"#p-6762-what-miners-are-effectively-optimizing-3\" aria-label=\"Heading link\"></a>What miners are effectively optimizing</h2>\n<p>From a miner\u2019s perspective, block assembly consists of selecting transactions:</p>\n<ul>\n<li>subject to a block weight limit and dependency constraints,</li>\n<li>in order to maximize total fees.</li>\n</ul>\n<p>Abstractly, this is an optimization problem over a DAG with additive rewards (fees) and additive costs (weight). In practice, miners rely on greedy heuristics to approximate this optimization, but the underlying objective remains the same.</p>\n<hr>\n<h2><a name=\"p-6762-packages-as-incremental-decisions-4\" class=\"anchor\" href=\"#p-6762-packages-as-incremental-decisions-4\" aria-label=\"Heading link\"></a>Packages as incremental decisions</h2>\n<p>Block construction is incremental. Miners repeatedly decide whether adding a transaction\u2014or a transaction together with its unconfirmed ancestors\u2014is worthwhile.</p>\n<p>This makes it natural to reason in terms of <em>packages</em>, evaluated by their <strong>marginal contribution</strong>:</p>\n<ul>\n<li>additional fees gained,</li>\n<li>additional weight consumed.</li>\n</ul>\n<p>Dependencies can make marginal contributions non-linear at the transaction level, which is why packages\u2014not individual transactions\u2014are the natural unit of comparison.</p>\n<hr>\n<h2><a name=\"p-6762-the-implicit-trade-off-and-the-shadow-price-of-weight-5\" class=\"anchor\" href=\"#p-6762-the-implicit-trade-off-and-the-shadow-price-of-weight-5\" aria-label=\"Heading link\"></a>The implicit trade-off and the shadow price of weight</h2>\n<p>Each incremental addition trades off fees against weight. The block weight limit induces an implicit <em>shadow price</em> for weight: the <strong>minimum fee (in sats) a miner requires to consume one additional unit of block weight at that moment</strong>.</p>\n<p>This price:</p>\n<ul>\n<li>is not configured explicitly,</li>\n<li>is not fixed,</li>\n<li>emerges from competition between transactions in the mempool.</li>\n</ul>\n<p>Concretely, the shadow price corresponds to the effective <em>feerate cutoff</em> at block assembly time. It is <strong>revealed</strong>, not computed:</p>\n<ul>\n<li>by the lowest-feerate transaction or package that still gets included,</li>\n<li>and the highest-feerate transaction or package that is excluded.</li>\n</ul>\n<hr>\n<h2><a name=\"p-6762-why-leftover-space-does-not-imply-non-optimal-behavior-6\" class=\"anchor\" href=\"#p-6762-why-leftover-space-does-not-imply-non-optimal-behavior-6\" aria-label=\"Heading link\"></a>Why leftover space does not imply non-optimal behavior</h2>\n<p>An optimal block is not necessarily a full block. If no remaining transaction or package offers a positive marginal benefit at the current shadow price of weight, then including nothing further is optimal\u2014even if some weight remains unused.</p>\n<p>In practice today, most blocks are near the weight limit, and leftover space is often explained by mempool conditions or template construction details. The point here is not about frequency, but about interpretation.</p>\n<p>This marginal cost can implicitly reflect factors such as validation or propagation overhead, without needing to model them explicitly. The relevant question is therefore not:</p>\n<blockquote>\n<p>\u201cIs there space left in the block?\u201d</p>\n</blockquote>\n<p>but:</p>\n<blockquote>\n<p>\u201cIs there any remaining transaction whose marginal fee exceeds the current shadow price?\u201d</p>\n</blockquote>\n<p>Observing leftover block space alone is not sufficient to infer non-optimal miner behavior.</p>\n<hr>\n<h2><a name=\"p-6762-threshold-effects-and-abrupt-behavior-7\" class=\"anchor\" href=\"#p-6762-threshold-effects-and-abrupt-behavior-7\" aria-label=\"Heading link\"></a>Threshold effects and abrupt behavior</h2>\n<p>This optimization problem is linear but constrained, which makes its solutions <strong>piecewise linear</strong>.</p>\n<p>As a result:</p>\n<ul>\n<li>small fee changes can cross thresholds,</li>\n<li>entire packages may suddenly become viable or non-viable.</li>\n</ul>\n<p>These effects are structural consequences of the optimization problem, not necessarily strategic choices.</p>\n<hr>\n<h2><a name=\"p-6762-relation-to-max-plus-algebra-and-tropical-geometry-8\" class=\"anchor\" href=\"#p-6762-relation-to-max-plus-algebra-and-tropical-geometry-8\" aria-label=\"Heading link\"></a>Relation to max-plus algebra and tropical geometry</h2>\n<p>The underlying computation relies on:</p>\n<ul>\n<li>maximization (choosing the best option),</li>\n<li>addition (accumulating fees and weight).</li>\n</ul>\n<p>This corresponds to well-known frameworks such as max-plus algebra and dynamic programming on DAGs. In mathematics, this perspective is often referred to as <em>tropical (max-plus) geometry</em>. No advanced mathematics is required here; the term is used only as a descriptive lens.</p>\n<hr>\n<h2><a name=\"p-6762-conclusion-9\" class=\"anchor\" href=\"#p-6762-conclusion-9\" aria-label=\"Heading link\"></a>Conclusion</h2>\n<p>Block assembly and package relay already follow a coherent optimization logic. Making this logic explicit helps clarify observed behavior and avoid misinterpretation, without requiring any changes to Bitcoin itself.</p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 3,
  "updated_at": "2026-02-06T22:57:26.067Z",
  "reply_count": 1,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 4,
  "reads": 16,
  "readers_count": 15,
  "score": 43.2,
  "yours": false,
  "topic_id": 2235,
  "topic_slug": "a-max-plus-perspective-on-package-relay-and-block-assembly",
  "topic_title": "A max-plus perspective on package relay and block assembly",
  "topic_html_title": "A max-plus perspective on package relay and block assembly",
  "category_id": 6,
  "display_username": "Galois Field",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "# A max-plus perspective on package relay and block assembly\n\n## Motivation\n\nPackage relay, CPFP, ancestor limits, and block assembly are often discussed separately. In practice, they interact tightly, and their combined behavior can be hard to reason about.\n\nCommon observations include:\n\n* sharp inclusion thresholds for packages,\n* blocks that appear to leave some weight unused,\n* small fee changes that suddenly make a transaction viable.\n\nThis post proposes a simple conceptual framework to reason about these effects. It does **not** suggest any protocol or policy change.\n\n*Related work includes mempool-based fee estimation techniques, which derive practical estimates from block templates. The perspective in this post abstracts beyond specific heuristics to clarify underlying economic incentives and marginal trade-offs.*\n\n---\n\n## What miners are effectively optimizing\n\nFrom a miner\u2019s perspective, block assembly consists of selecting transactions:\n\n* subject to a block weight limit and dependency constraints,\n* in order to maximize total fees.\n\nAbstractly, this is an optimization problem over a DAG with additive rewards (fees) and additive costs (weight). In practice, miners rely on greedy heuristics to approximate this optimization, but the underlying objective remains the same.\n\n---\n\n## Packages as incremental decisions\n\nBlock construction is incremental. Miners repeatedly decide whether adding a transaction\u2014or a transaction together with its unconfirmed ancestors\u2014is worthwhile.\n\nThis makes it natural to reason in terms of *packages*, evaluated by their **marginal contribution**:\n\n* additional fees gained,\n* additional weight consumed.\n\nDependencies can make marginal contributions non-linear at the transaction level, which is why packages\u2014not individual transactions\u2014are the natural unit of comparison.\n\n---\n\n## The implicit trade-off and the shadow price of weight\n\nEach incremental addition trades off fees against weight. The block weight limit induces an implicit *shadow price* for weight: the **minimum fee (in sats) a miner requires to consume one additional unit of block weight at that moment**.\n\nThis price:\n\n* is not configured explicitly,\n* is not fixed,\n* emerges from competition between transactions in the mempool.\n\nConcretely, the shadow price corresponds to the effective *feerate cutoff* at block assembly time. It is **revealed**, not computed:\n\n* by the lowest-feerate transaction or package that still gets included,\n* and the highest-feerate transaction or package that is excluded.\n\n---\n\n## Why leftover space does not imply non-optimal behavior\n\nAn optimal block is not necessarily a full block. If no remaining transaction or package offers a positive marginal benefit at the current shadow price of weight, then including nothing further is optimal\u2014even if some weight remains unused.\n\nIn practice today, most blocks are near the weight limit, and leftover space is often explained by mempool conditions or template construction details. The point here is not about frequency, but about interpretation.\n\nThis marginal cost can implicitly reflect factors such as validation or propagation overhead, without needing to model them explicitly. The relevant question is therefore not:\n\n> \u201cIs there space left in the block?\u201d\n\nbut:\n\n> \u201cIs there any remaining transaction whose marginal fee exceeds the current shadow price?\u201d\n\nObserving leftover block space alone is not sufficient to infer non-optimal miner behavior.\n\n---\n\n## Threshold effects and abrupt behavior\n\nThis optimization problem is linear but constrained, which makes its solutions **piecewise linear**.\n\nAs a result:\n\n* small fee changes can cross thresholds,\n* entire packages may suddenly become viable or non-viable.\n\nThese effects are structural consequences of the optimization problem, not necessarily strategic choices.\n\n---\n\n## Relation to max-plus algebra and tropical geometry\n\nThe underlying computation relies on:\n\n* maximization (choosing the best option),\n* addition (accumulating fees and weight).\n\nThis corresponds to well-known frameworks such as max-plus algebra and dynamic programming on DAGs. In mathematics, this perspective is often referred to as *tropical (max-plus) geometry*. No advanced mathematics is required here; the term is used only as a descriptive lens.\n\n---\n\n## Conclusion\n\nBlock assembly and package relay already follow a coherent optimization logic. Making this logic explicit helps clarify observed behavior and avoid misinterpretation, without requiring any changes to Bitcoin itself.",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 549,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "<a name=\"p-6762-a-max-plus-perspective-on-package-relay-and-block-assembly-1\" class=\"anchor\" href=\"#p-6762-a-max-plus-perspective-on-package-relay-and-block-assembly-1\" aria-label=\"Heading link\"></a>A max-plus perspective on package relay and block assembly\n<a name=\"p-6762-motivation-2\" class=\"anchor\" href=\"#p-6762-motivation-2\" aria-label=\"Heading link\"></a>Motivation\nPackage relay, CPFP, ancestor limits, and block assembly are often discussed separately. In practice, they interact tightly, and their combined behavior can be hard to reason about. \nCommon observations include: \n\nsharp inclusion &hellip;",
  "truncated": true,
  "post_url": "/t/a-max-plus-perspective-on-package-relay-and-block-assembly/2235/1",
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}