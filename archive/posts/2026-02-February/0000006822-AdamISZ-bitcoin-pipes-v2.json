{
  "id": 6822,
  "name": "Adam Gibson",
  "username": "AdamISZ",
  "avatar_template": "/user_avatar/delvingbitcoin.org/adamisz/{size}/418_2.png",
  "created_at": "2026-02-13T15:30:32.585Z",
  "cooked": "<p>Fascinating, thank you for publishing this.</p>\n<p>I find myself very interested in one particular line of reasoning in this post:</p>\n<aside class=\"quote no-group quote-modified\" data-username=\"nemothenoone\" data-post=\"1\" data-topic=\"2249\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/nemothenoone/48/768_2.png\" class=\"avatar\"> nemothenoone:</div>\n<blockquote>\n<p>This fully characterizes the available design space. Any spending rule that works <strong>without changing Bitcoin\u2019s consensus rules</strong> must ultimately boil down to a single question:</p>\n<blockquote>\n<p>Can a valid signature under this public key be produced or not?</p>\n</blockquote>\n<p>There is no other hook available to enforce authorization.</p>\n<p>The key insight behind PIPEs is to treat this constraint not as a limitation, but as the design surface.</p>\n</blockquote>\n</aside>\n<p>On a first read through, I found this convincing: let\u2019s consider how one can gate spending via any privileged knowledge status: we only have (a) signatures and (b) hashlocks, available in Script. Even the ECC equivalent of hashlocks is not available: pubkeys can only be matched against signatures, not private keys, in Script.</p>\n<p>So the obvious problem with hashlocks is part of the sort of \u201cBitcoin 101\u201d that we all looked at on the wiki back in the day - \u201clocking\u201d a utxo to the preimage of a sha2 hash is non-functional because once you publish the unlocking script anyone can read it and replace your destination address. Which seems to reinforce your point: a <em>signature</em> is the only way to authorize <em>a particular payment</em>.</p>\n<p>But two counterpoints spring up:</p>\n<ul>\n<li>The \u201ccanonical\u201d solution to the hashlock enforcement problem is, of course, seen in HTLC and similar: you <em>can</em> attach specific identities, <em>additional</em> to the hashlock: still a signature, but an additional \u201cgate\u201d that needn\u2019t be related to the witness encryption. Also interesting in this context may be that, through a combination of taproot structures and plain old Script, you can make some kind of large OR condition (one of these pubkeys and the hashlock)</li>\n<li>Most interesting is that you are using witness encryption <em>not</em> to enforce authorization of specific transfers but to enable full control of the utxo. You call this \u201cbinary covenant\u201d but I feel like the bitcoin research community has taken up the word \u201ccovenant\u201d as specifically restricting the manner of spending - and that\u2019s even setting aside <a class=\"mention\" href=\"/u/ajtowns\">@ajtowns</a> imo very valid point that \u201ccovenant\u201d is a terrible name for this. But meh, forget about names. Your system decrypting to the private key, not to a specific authorization, means that the distinction between the value of a hashlock, and the value of a signature, doesn\u2019t apply, right? Is WE for hashlock preimages a possible alternative in the design space? (I have zero clue whether it would be easier, harder, or just not functional; I\u2019m just reacting to the statement that the design space is <em>only</em> signatures).</li>\n</ul>",
  "post_number": 2,
  "post_type": 1,
  "posts_count": 2,
  "updated_at": "2026-02-13T15:30:32.585Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 1,
  "incoming_link_count": 0,
  "reads": 2,
  "readers_count": 1,
  "score": 0.4,
  "yours": false,
  "topic_id": 2249,
  "topic_slug": "bitcoin-pipes-v2",
  "topic_title": "Bitcoin PIPEs v2",
  "topic_html_title": "Bitcoin PIPEs v2",
  "category_id": 7,
  "display_username": "Adam Gibson",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "Fascinating, thank you for publishing this.\n\nI find myself very interested in one particular line of reasoning in this post:\n\n[quote=\"nemothenoone, post:1, topic:2249\"]\nThis fully characterizes the available design space. Any spending rule that works **without changing Bitcoin\u2019s consensus rules** must ultimately boil down to a single question:\n\n> Can a valid signature under this public key be produced or not?\n\nThere is no other hook available to enforce authorization.\n\nThe key insight behind PIPEs is to treat this constraint not as a limitation, but as the design surface.\n\n[/quote]\n\nOn a first read through, I found this convincing: let\u2019s consider how one can gate spending via any privileged knowledge status: we only have (a) signatures and (b) hashlocks, available in Script. Even the ECC equivalent of hashlocks is not available: pubkeys can only be matched against signatures, not private keys, in Script.\n\nSo the obvious problem with hashlocks is part of the sort of \u201cBitcoin 101\u201d that we all looked at on the wiki back in the day - \u201clocking\u201d a utxo to the preimage of a sha2 hash is non-functional because once you publish the unlocking script anyone can read it and replace your destination address. Which seems to reinforce your point: a *signature* is the only way to authorize *a particular payment*.\n\nBut two counterpoints spring up:\n\n* The \u201ccanonical\u201d solution to the hashlock enforcement problem is, of course, seen in HTLC and similar: you *can* attach specific identities, *additional* to the hashlock: still a signature, but an additional \u201cgate\u201d that needn\u2019t be related to the witness encryption. Also interesting in this context may be that, through a combination of taproot structures and plain old Script, you can make some kind of large OR condition (one of these pubkeys and the hashlock)\n* Most interesting is that you are using witness encryption *not* to enforce authorization of specific transfers but to enable full control of the utxo. You call this \u201cbinary covenant\u201d but I feel like the bitcoin research community has taken up the word \u201ccovenant\u201d as specifically restricting the manner of spending - and that\u2019s even setting aside @ajtowns imo very valid point that \u201ccovenant\u201d is a terrible name for this. But meh, forget about names. Your system decrypting to the private key, not to a specific authorization, means that the distinction between the value of a hashlock, and the value of a signature, doesn\u2019t apply, right? Is WE for hashlock preimages a possible alternative in the design space? (I have zero clue whether it would be easier, harder, or just not functional; I\u2019m just reacting to the statement that the design space is *only* signatures).",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 343,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "Fascinating, thank you for publishing this. \nI find myself very interested in one particular line of reasoning in this post: \n\nOn a first read through, I found this convincing: let\u2019s consider how one can gate spending via any privileged knowledge status: we only have (a) signatures and (b) hashlocks&hellip;",
  "truncated": true,
  "post_url": "/t/bitcoin-pipes-v2/2249/2",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}