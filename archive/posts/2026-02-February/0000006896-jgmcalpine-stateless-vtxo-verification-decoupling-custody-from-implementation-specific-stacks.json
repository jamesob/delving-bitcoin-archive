{
  "id": 6896,
  "name": "Jon",
  "username": "jgmcalpine",
  "avatar_template": "/user_avatar/delvingbitcoin.org/jgmcalpine/{size}/1840_2.png",
  "created_at": "2026-02-18T19:55:08.377Z",
  "cooked": "<h2><a name=\"p-6896-i-introduction-bifurcated-custody-and-the-half-key-problem-1\" class=\"anchor\" href=\"#p-6896-i-introduction-bifurcated-custody-and-the-half-key-problem-1\" aria-label=\"Heading link\"></a><strong>I. Introduction: Bifurcated Custody and the \u201cHalf-Key\u201d Problem</strong></h2>\n<p>As the VTXO ecosystem evolves, lead implementations are diverging to optimize for different throughput and latency profiles. While this flexibility is beneficial, it creates a \u201cVerification Gap.\u201d In the VTXO model, custody is bifurcated into what we call the <strong>Half-Key Problem</strong>: spending authority requires both a private key and the specific off-chain transaction context (the \u201cMap\u201d). Unlike the L1 UTXO model, where this context is a public good preserved on-chain, VTXO context is ephemeral and off-chain.</p>\n<p>Without independent verification of this \u201cMap,\u201d user custody becomes coupled to implementation-specific software stacks. If a user cannot verify or reconstruct their exit path outside of their Ark Service Provider\u2019s (ASP) proprietary environment, they are in a state of <strong>Implementation-Coupled Custody</strong>.</p>\n<p>This post proposes a <strong>Stateless VTXO Verification</strong> model and a neutral \u201cAudit Ingredient\u201d schema. Our goal is to provide a path for independent auditability\u2014specifically for high-security, <code>no_std</code> environments like hardware wallets\u2014ensuring that users can verify their off-chain state regardless of the underlying implementation\u2019s design choices.</p>\n<h2><a name=\"p-6896-ii-forensic-observations-the-dialects-of-vtxos-2\" class=\"anchor\" href=\"#p-6896-ii-forensic-observations-the-dialects-of-vtxos-2\" aria-label=\"Heading link\"></a><strong>II. Forensic Observations: The Dialects of VTXOs</strong></h2>\n<p>In developing <strong>libvpack-rs</strong>, a stateless <code>no_std</code> verifier, we observed significant \u201cdialect\u201d differences in how implementations construct the VTXO identity and transaction templates.</p>\n<h4><a name=\"p-6896-h-1-indexing-standards-3\" class=\"anchor\" href=\"#p-6896-h-1-indexing-standards-3\" aria-label=\"Heading link\"></a>1. Indexing Standards</h4>\n<p>*   <strong>Ark Labs</strong> treats the VTXO as being synonymous with the <strong>Virtual Transaction</strong> itself. Their 32-byte ID commits to the entire transaction (assuming the user occupies the primary output).</p>\n<p>*   <strong>Second Tech</strong> treats the VTXO as a <strong>distinct output</strong> within a potentially multi-output transaction. Their 36-byte ID (OutPoint) allows for a more flexible topology where a single virtual transaction might create multiple VTXOs (e.g., in a batched payment).</p>\n<h4><a name=\"p-6896-h-2-the-nsequence-signal-4\" class=\"anchor\" href=\"#p-6896-h-2-the-nsequence-signal-4\" aria-label=\"Heading link\"></a><strong>2. The nSequence Signal</strong></h4>\n<p>We observed divergent uses of the <code>nSequence</code> field in pre-signed exit trees:</p>\n<p>*   <strong>Ark Labs:</strong> Utilizing <code>0xFFFFFFFE</code> to signal RBF compatibility within the constraints of TRUC (BIP-431) policies.</p>\n<p>*   <strong>Second Tech</strong>: Exploring <code>0x00000000</code> to leverage BIP-68 relative timelocks.</p>\n<p>These choices change the <code>SIGHASH</code> of every transaction in the tree. An independent verifier must \u201cknow the dialect\u201d to prove that a signature is valid.</p>\n<h2><a name=\"p-6896-iii-proposal-the-minimal-viable-vtxo-mvv-schema-v01-rfc-5\" class=\"anchor\" href=\"#p-6896-iii-proposal-the-minimal-viable-vtxo-mvv-schema-v01-rfc-5\" aria-label=\"Heading link\"></a><strong>III. Proposal: The Minimal Viable VTXO (MVV) Schema v0.1 (RFC)</strong></h2>\n<p>To enable independent verification without slowing down innovation, we propose a standardized <strong>\u201cAudit Ingredient\u201d</strong> format. This schema is intended as a draft for comment by the community.</p>\n<pre data-code-wrap=\"rust\"><code class=\"lang-rust\">/// The Minimal Viable VTXO (MVV) Ingredient Schema (v0.1 RFC)\n\npub struct VtxoIngredient {\n  /// Implementation version to identify template logic (nSequence/Identity     dialects)\n  pub dialect_version: u32,\n  pub amount: u64,\n  pub script_pubkey: Vec&lt;u8&gt;,\n  pub vout: u32,\n  /// The relative timelock required for the exit\n  pub exit_delta: u32,\n  pub sequence: u32,\n  /// Merkle path to the L1 Anchor\n  pub path: Vec&lt;VPackPathStep&gt;,\n  /// The L1 Anchor (TxID and Vout) where the tree is rooted\n  pub anchor_outpoint: OutPoint,\n}\n\npub struct VPackPathStep {\n  /// Every output in this transaction *except* the one leading to the user.\n  /// Includes other users\u2019 VTXOs and protocol anchors/connectors.\n  pub other_outputs: Vec&lt;VPackOutput&gt;,\n  /// The ASP\u2019s signature authorizing this specific step in the tree\n  pub signature: [u8; 64],\n  pub parent_index: u32,\n}\n\npub struct VPackOutput {\n  pub value: u64,\n  pub script_pubkey: Vec,\n}\n</code></pre>\n<p>Structurally, V-PACK treats all non-user outputs (whether they are \u2018siblings\u2019 belonging to other users or \u2018connectors\u2019 used for fee management) as a single category of <strong>Other Outputs</strong>. By carrying the literal value and <code>script_pubkey</code> for these components, the verifier can reconstruct the TxID and verify the signature without needing to understand the implementation-specific semantics of each output type.</p>\n<p>By exporting this schema, ASPs allow users to move their \u201cMap\u201d into a neutral environment. A tool like <code>vpack</code> can then \u201cre-bake\u201d the templates and verify the user\u2019s spending authority.</p>\n<h2><a name=\"p-6896-iv-libvpack-rs-structural-vs-consensus-validity-6\" class=\"anchor\" href=\"#p-6896-iv-libvpack-rs-structural-vs-consensus-validity-6\" aria-label=\"Heading link\"></a><strong>IV. libvpack-rs: Structural vs. Consensus Validity</strong></h2>\n<p>The primary goal of <code>libvpack-rs</code> is to provide a \u201cStateless Verifier.\u201d It is important to distinguish between the two pillars of validity it aims to address:</p>\n<p>1.  <strong>Structural Validity (Current Focus):</strong> Proving the off-chain \u201cMap\u201d is mathematically sound. <code>vpack</code> verifies that the Merkle path leads to a valid L1 anchor and that the transaction preimages match the signatures.</p>\n<p>2.  <strong>Consensus Validity (Roadmap):</strong> Proving the money exists on-chain. While <code>vpack</code> is stateless, our roadmap includes an interface to ingest Compact Block Filters (BIP-158) or external block explorer data to verify that the <code>anchor_outpoint</code> remains unspent.</p>\n<p>The decision to keep the library <code>no_std</code> is deliberate. For VTXO-based scaling solutions to reach their full potential, we should provide a path for verification within high-security, restricted environments like hardware wallets. This would allow devices like a hardware wallet to run a lean Rust library to verify the \u201cMap\u201d before a user signs a Forfeit transaction.</p>\n<h2><a name=\"p-6896-v-the-policy-trap-beyond-consensus-7\" class=\"anchor\" href=\"#p-6896-v-the-policy-trap-beyond-consensus-7\" aria-label=\"Heading link\"></a><strong>V. The Policy Trap: Beyond Consensus</strong></h2>\n<p>A major challenge for independent verifiers is <strong>Mempool Policy</strong>. An exit path may be valid under consensus rules but unbroadcastable under current relay policies.</p>\n<p>For example, an Ark tree 20 levels deep is valid on-chain, but BIP-431 (TRUC) limits mempool packages to a depth of 2. If a user is not aware of this \u201cPolicy Trap,\u201d they may believe they have a valid exit when they actually have a \u201cpinned\u201d or un-relayable transaction. We are exploring how <code>vpack</code> can include a <strong>Policy Auditor</strong> to warn users if their VTXO \u201cMap\u201d is structurally sound but policy-invalid.</p>\n<h2><a name=\"p-6896-vi-open-questions-future-research-8\" class=\"anchor\" href=\"#p-6896-vi-open-questions-future-research-8\" aria-label=\"Heading link\"></a><strong>VI. Open Questions &amp; Future Research</strong></h2>\n<p>1.  <strong>Path Exclusivity:</strong> Current verification proves a path *exists*. Proving that no *malicious* paths exist (e.g., ASP backdoors) requires full tree disclosure. How do we standardize full-tree audits for mobile clients?</p>\n<p>2.  <strong>Generic vs. Semantic Connectors:</strong> We propose treating Connectors as generic VPackOutputs (blobbing value + script) to simplify verification. Is there a use case where the verifier <em>must</em> understand the semantic logic of a Connector (e.g., inspecting the witness stack) that this generic approach misses?</p>\n<p>3.  <strong>Nostr Backup Standard:</strong> Should we formalize a NIP for the encrypted storage of <code>VtxoIngredient</code> blobs?</p>\n<h2><a name=\"p-6896-vii-conclusion-9\" class=\"anchor\" href=\"#p-6896-vii-conclusion-9\" aria-label=\"Heading link\"></a><strong>VII. Conclusion</strong></h2>\n<p>The diversity in current Ark implementations is a sign of a healthy protocol. Our goal with <code>vpack</code> is to ensure that this diversity does not lead to implementation-coupled custody. By adopting a stateless verification model and a standardized \u201cAudit Ingredient\u201d export, we allow implementations to move fast while giving users the tools to <strong>verify, not trust.</strong></p>\n<p>*You can view the current implementation of the stateless verifier at [github.com/jgmcalpine/libvpack-rs]( <a href=\"https://github.com/jgmcalpine/libvpack-rs\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">GitHub - jgmcalpine/libvpack-rs: Universal verifier and 'life raft' for the VTXO (Virtual UTXO) primitive. Enabling independent auditability and sovereign recovery across Ark-like scaling implementations.</a> ).*</p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 1,
  "updated_at": "2026-02-18T20:03:07.480Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 1,
  "reads": 13,
  "readers_count": 12,
  "score": 7.6,
  "yours": false,
  "topic_id": 2267,
  "topic_slug": "stateless-vtxo-verification-decoupling-custody-from-implementation-specific-stacks",
  "topic_title": "Stateless VTXO Verification: Decoupling Custody from Implementation-Specific Stacks",
  "topic_html_title": "Stateless VTXO Verification: Decoupling Custody from Implementation-Specific Stacks",
  "category_id": 7,
  "display_username": "Jon",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": "",
  "bookmarked": false,
  "raw": "## **I. Introduction: Bifurcated Custody and the \u201cHalf-Key\u201d Problem**\n\nAs the VTXO ecosystem evolves, lead implementations are diverging to optimize for different throughput and latency profiles. While this flexibility is beneficial, it creates a \u201cVerification Gap.\u201d In the VTXO model, custody is bifurcated into what we call the **Half-Key Problem**: spending authority requires both a private key and the specific off-chain transaction context (the \u201cMap\u201d). Unlike the L1 UTXO model, where this context is a public good preserved on-chain, VTXO context is ephemeral and off-chain.\n\nWithout independent verification of this \u201cMap,\u201d user custody becomes coupled to implementation-specific software stacks. If a user cannot verify or reconstruct their exit path outside of their Ark Service Provider\u2019s (ASP) proprietary environment, they are in a state of **Implementation-Coupled Custody**.\n\nThis post proposes a **Stateless VTXO Verification** model and a neutral \u201cAudit Ingredient\u201d schema. Our goal is to provide a path for independent auditability\u2014specifically for high-security, `no_std` environments like hardware wallets\u2014ensuring that users can verify their off-chain state regardless of the underlying implementation\u2019s design choices.\n\n## **II. Forensic Observations: The Dialects of VTXOs**\n\nIn developing **libvpack-rs**, a stateless `no_std` verifier, we observed significant \u201cdialect\u201d differences in how implementations construct the VTXO identity and transaction templates.\n\n#### 1. Indexing Standards\n\n\\*   **Ark Labs** treats the VTXO as being synonymous with the **Virtual Transaction** itself. Their 32-byte ID commits to the entire transaction (assuming the user occupies the primary output).\n\n\\*   **Second Tech** treats the VTXO as a **distinct output** within a potentially multi-output transaction. Their 36-byte ID (OutPoint) allows for a more flexible topology where a single virtual transaction might create multiple VTXOs (e.g., in a batched payment).\n\n#### **2. The nSequence Signal**\n\nWe observed divergent uses of the `nSequence` field in pre-signed exit trees:\n\n\\*   **Ark Labs:** Utilizing `0xFFFFFFFE` to signal RBF compatibility within the constraints of TRUC (BIP-431) policies.\n\n\\*   **Second Tech**: Exploring `0x00000000` to leverage BIP-68 relative timelocks.\n\nThese choices change the `SIGHASH` of every transaction in the tree. An independent verifier must \u201cknow the dialect\u201d to prove that a signature is valid.\n\n## **III. Proposal: The Minimal Viable VTXO (MVV) Schema v0.1 (RFC)**\n\nTo enable independent verification without slowing down innovation, we propose a standardized **\u201cAudit Ingredient\u201d** format. This schema is intended as a draft for comment by the community.\n\n```rust\n/// The Minimal Viable VTXO (MVV) Ingredient Schema (v0.1 RFC)\n\npub struct VtxoIngredient {\n  /// Implementation version to identify template logic (nSequence/Identity     dialects)\n  pub dialect_version: u32,\n  pub amount: u64,\n  pub script_pubkey: Vec<u8>,\n  pub vout: u32,\n  /// The relative timelock required for the exit\n  pub exit_delta: u32,\n  pub sequence: u32,\n  /// Merkle path to the L1 Anchor\n  pub path: Vec<VPackPathStep>,\n  /// The L1 Anchor (TxID and Vout) where the tree is rooted\n  pub anchor_outpoint: OutPoint,\n}\n\npub struct VPackPathStep {\n  /// Every output in this transaction *except* the one leading to the user.\n  /// Includes other users\u2019 VTXOs and protocol anchors/connectors.\n  pub other_outputs: Vec<VPackOutput>,\n  /// The ASP\u2019s signature authorizing this specific step in the tree\n  pub signature: [u8; 64],\n  pub parent_index: u32,\n}\n\npub struct VPackOutput {\n  pub value: u64,\n  pub script_pubkey: Vec,\n}\n```\n\nStructurally, V-PACK treats all non-user outputs (whether they are \u2018siblings\u2019 belonging to other users or \u2018connectors\u2019 used for fee management) as a single category of **Other Outputs**. By carrying the literal value and `script_pubkey` for these components, the verifier can reconstruct the TxID and verify the signature without needing to understand the implementation-specific semantics of each output type.\n\nBy exporting this schema, ASPs allow users to move their \u201cMap\u201d into a neutral environment. A tool like `vpack` can then \u201cre-bake\u201d the templates and verify the user\u2019s spending authority.\n\n## **IV. libvpack-rs: Structural vs. Consensus Validity**\n\nThe primary goal of `libvpack-rs` is to provide a \u201cStateless Verifier.\u201d It is important to distinguish between the two pillars of validity it aims to address:\n\n1\\.  **Structural Validity (Current Focus):** Proving the off-chain \u201cMap\u201d is mathematically sound. `vpack` verifies that the Merkle path leads to a valid L1 anchor and that the transaction preimages match the signatures.\n\n2\\.  **Consensus Validity (Roadmap):** Proving the money exists on-chain. While `vpack` is stateless, our roadmap includes an interface to ingest Compact Block Filters (BIP-158) or external block explorer data to verify that the `anchor_outpoint` remains unspent.\n\nThe decision to keep the library `no_std` is deliberate. For VTXO-based scaling solutions to reach their full potential, we should provide a path for verification within high-security, restricted environments like hardware wallets. This would allow devices like a hardware wallet to run a lean Rust library to verify the \u201cMap\u201d before a user signs a Forfeit transaction.\n\n## **V. The Policy Trap: Beyond Consensus**\n\nA major challenge for independent verifiers is **Mempool Policy**. An exit path may be valid under consensus rules but unbroadcastable under current relay policies.\n\nFor example, an Ark tree 20 levels deep is valid on-chain, but BIP-431 (TRUC) limits mempool packages to a depth of 2. If a user is not aware of this \u201cPolicy Trap,\u201d they may believe they have a valid exit when they actually have a \u201cpinned\u201d or un-relayable transaction. We are exploring how `vpack` can include a **Policy Auditor** to warn users if their VTXO \u201cMap\u201d is structurally sound but policy-invalid.\n\n## **VI. Open Questions & Future Research**\n\n1\\.  **Path Exclusivity:** Current verification proves a path \\*exists\\*. Proving that no \\*malicious\\* paths exist (e.g., ASP backdoors) requires full tree disclosure. How do we standardize full-tree audits for mobile clients?\n\n2\\.  **Generic vs. Semantic Connectors:** We propose treating Connectors as generic VPackOutputs (blobbing value + script) to simplify verification. Is there a use case where the verifier *must* understand the semantic logic of a Connector (e.g., inspecting the witness stack) that this generic approach misses?\n\n3\\.  **Nostr Backup Standard:** Should we formalize a NIP for the encrypted storage of `VtxoIngredient` blobs?\n\n## **VII. Conclusion**\n\nThe diversity in current Ark implementations is a sign of a healthy protocol. Our goal with `vpack` is to ensure that this diversity does not lead to implementation-coupled custody. By adopting a stateless verification model and a standardized \u201cAudit Ingredient\u201d export, we allow implementations to move fast while giving users the tools to **verify, not trust.**\n\n\\*You can view the current implementation of the stateless verifier at \\[github.com/jgmcalpine/libvpack-rs\\]( https://github.com/jgmcalpine/libvpack-rs ).\\*",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 1023,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "<a name=\"p-6896-i-introduction-bifurcated-custody-and-the-half-key-problem-1\" class=\"anchor\" href=\"#p-6896-i-introduction-bifurcated-custody-and-the-half-key-problem-1\" aria-label=\"Heading link\"></a>I. Introduction: Bifurcated Custody and the \u201cHalf-Key\u201d Problem\nAs the VTXO ecosystem evolves, lead implementations are diverging to optimize for different throughput and latency profiles. While this flexibility is beneficial, it creates a \u201cVerification Gap.\u201d In the VTXO model, custody is bifurcated &hellip;",
  "truncated": true,
  "post_url": "/t/stateless-vtxo-verification-decoupling-custody-from-implementation-specific-stacks/2267/1",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}