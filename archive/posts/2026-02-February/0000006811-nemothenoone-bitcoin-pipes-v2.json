{
  "id": 6811,
  "name": "Misha Komarov",
  "username": "nemothenoone",
  "avatar_template": "/user_avatar/delvingbitcoin.org/nemothenoone/{size}/768_2.png",
  "created_at": "2026-02-12T16:51:45.622Z",
  "cooked": "<h1><a name=\"p-6811-bitcoin-pipes-v2-covenants-and-zkps-on-the-bitcoin-l1-via-witness-encryption-1\" class=\"anchor\" href=\"#p-6811-bitcoin-pipes-v2-covenants-and-zkps-on-the-bitcoin-l1-via-witness-encryption-1\" aria-label=\"Heading link\"></a>Bitcoin PIPEs v2: Covenants and ZKPs on the Bitcoin L1 via Witness Encryption.</h1>\n<blockquote>\n<p>PIPE v2 [2] explores a cryptographic alternative to Bitcoin covenants that operates entirely within existing consensus rules. Instead of extending Script or relying on optimistic dispute mechanisms, PIPE v2 enforces spending conditions by <em>witness-gating access to a Bitcoin signing key</em>. A valid Schnorr signature can be produced if and only if a specified NP statement is true. This yields a non-interactive mechanism deployable without a soft fork, in which Bitcoin funds become spendable if and only if a specified condition is satisfied, sufficient for vaults, exits, fraud proofs, and zk-proof gated releases, under well-defined cryptographic assumptions.</p>\n</blockquote>\n<p>Bitcoin\u2019s transaction validation model is intentionally minimal. At the consensus layer, Bitcoin verifies only that a transaction correctly spends unspent outputs and that each input is authorized by a valid digital signature. This simplicity is a defining strength: it keeps consensus rules stable, auditability high, and the security model well understood. At the same time, it places hard limits on the kinds of spending policies that can be enforced directly on-chain.</p>\n<p>Several approaches try to address this limitation. Script extensions such as <code>OP_CTV</code>, <code>OP_CAT</code>, and <code>OP_CSFS</code> increase expressiveness but require a soft fork which is a change to Bitcoin\u2019s consensus rules. Optimistic protocols such as BitVM avoid consensus changes, but introduce interactivity, challenge periods, and liveness assumptions. These tradeoffs are acceptable for some applications, but not all.</p>\n<p>PIPE versions [1,2] explore a different point in the design space: enforcing spending conditions <strong>without new opcodes and without optimistic challenge mechanisms,</strong> by shifting enforcement entirely <em>out of Bitcoin Script and into cryptography</em>. Rather than asking Bitcoin to verify whether a transaction satisfies a condition, PIPE v2 makes it <em>cryptographically impossible</em> to produce a valid signature unless that condition holds.</p>\n<p>This post presents PIPE v2 through the abstraction of <strong>witness signatures</strong>: conditional signature schemes in which producing a valid signature is equivalent to proving membership in a hard NP relation. We explain how PIPE v2 realizes witness signatures using witness encryption, characterize the resulting authorization semantics, and clarify its scope.</p>\n<h2><a name=\"p-6811-core-idea-enforcing-spending-rules-cryptographically-2\" class=\"anchor\" href=\"#p-6811-core-idea-enforcing-spending-rules-cryptographically-2\" aria-label=\"Heading link\"></a>Core Idea: Enforcing Spending Rules Cryptographically</h2>\n<p>Let\u2019s think what Bitcoin already provides.</p>\n<ul>\n<li>At the consensus layer, Bitcoin exposes a single authorization primitive: <strong>signature validity</strong>. A transaction input is accepted if it carries a valid Schnorr signature under the public key specified by the spent output. This is the only condition Bitcoin enforces for spending authorization.</li>\n<li>What Bitcoin deliberately does not encode is <em>why</em> a signature was produced. Bitcoin Script does not capture intent, context, or the computation that led to a signature.</li>\n</ul>\n<p>This fully characterizes the available design space. Any spending rule that works <strong>without changing Bitcoin\u2019s consensus rules</strong> must ultimately boil down to a single question:</p>\n<blockquote>\n<p>Can a valid signature under this public key be produced or not?</p>\n</blockquote>\n<p>There is no other hook available to enforce authorization.</p>\n<p>The key insight behind PIPEs is to treat this constraint not as a limitation, but as the design surface.</p>\n<blockquote>\n<p>If signature validity is the only thing Bitcoin enforces, then the strongest spending rule we can implement without a soft fork is one that controls <strong>whether a signature can be produced at all</strong>.</p>\n</blockquote>\n<p>PIPE v2 do exactly this by moving enforcement <em>before</em> signing. Instead of asking Bitcoin Script to check a condition, PIPEs attach the condition to <strong>access to the signing key itself</strong>.</p>\n<p>In a PIPE, the signing key corresponding to a Bitcoin address is not directly available. Instead, it is cryptographically locked behind a condition\u2014such as the existence of a valid zero-knowledge proof, an exit proof, or a fraud proof. If the condition is satisfied, the key can be recovered and used to produce an ordinary Schnorr signature. If the condition is not satisfied, producing a valid signature is computationally infeasible.</p>\n<p>From Bitcoin\u2019s perspective, nothing changes. The transaction contains a standard signature under a standard public key and verifies as usual. From a protocol designer\u2019s perspective, this extracts the maximum possible programmability from Bitcoin\u2019s existing authorization model: arbitrary off-chain logic can gate spendability, without new opcodes, without interactivity, and without changing consensus.</p>\n<h3><a name=\"p-6811-formalization-pipe-as-a-witness-signature-3\" class=\"anchor\" href=\"#p-6811-formalization-pipe-as-a-witness-signature-3\" aria-label=\"Heading link\"></a>Formalization: PIPE as a Witness Signature</h3>\n<p>To instantiate this idea, we introduce <strong>witness signatures</strong> and the corresponding <strong>PIPE construction (PIPE v2).</strong></p>\n<p>At a high level, a witness signature is just a normal Bitcoin signature but with a twist:</p>\n<blockquote>\n<p>A valid signature can be produced if and only if a specific external condition is satisfied.</p>\n</blockquote>\n<p>A PIPE consists of two main phases: <strong>setup</strong> and <strong>signing</strong>.</p>\n<p>During setup, a standard Bitcoin key pair is generated, but the private key is never revealed. Instead, it is cryptographically locked behind a condition such as the validity of some off-chain computation. This locking is done using <strong>witness encryption</strong>, which allows the private key to be recovered only by someone who can produce valid evidence (a <em>witness</em>) that the condition holds.</p>\n<p>During signing, a party that has such a witness tries to recover the private key. If the witness is valid, key recovery succeeds, and the party can produce an ordinary Schnorr signature. If the witness is invalid, recovering the key and thus producing a valid signature is computationally infeasible.</p>\n<h3><a name=\"p-6811-pipe-v2-construction-at-a-glance-4\" class=\"anchor\" href=\"#p-6811-pipe-v2-construction-at-a-glance-4\" aria-label=\"Heading link\"></a>PIPE v2 Construction (at a glance)</h3>\n<ul>\n<li>\n<p><strong>Setup</strong> <em>(performed in a distributed manner)</em></p>\n<ul>\n<li>Generate a standard Bitcoin key pair <span class=\"math\">(sk, pk)</span>.</li>\n<li>Fix a spending condition, expressed as a statement (e.g., a circuit <span class=\"math\">C</span> with public input <span class=\"math\">x</span>).</li>\n<li>Encrypt the signing key <span class=\"math\">sk</span> under this statement using <strong>witness encryption</strong>.</li>\n<li>Publish the public key <span class=\"math\">pk</span> and ciphertext.</li>\n</ul>\n<p>(No party learns <span class=\"math\">sk</span>  during setup, assuming at least one setup party behaves honestly i.e., no full collusion.)</p>\n</li>\n<li>\n<p><strong>Sign</strong></p>\n<ul>\n<li>Input: a message to be signed and a witness <span class=\"math\">w</span>.</li>\n<li>If <span class=\"math\">w</span> is a valid witness for the statement, decrypt the ciphertext and obtain <span class=\"math\">sk</span>\n<ul>\n<li>Generate a Schnorr signature with <span class=\"math\">sk</span>.</li>\n</ul>\n</li>\n<li>If <span class=\"math\">w</span> is invalid, recovering <span class=\"math\">sk</span> and producing a valid signature is computationally infeasible.</li>\n</ul>\n</li>\n<li>\n<p><strong>Verification (Bitcoin)</strong></p>\n<ul>\n<li>Bitcoin verifies the resulting Schnorr signature under <span class=\"math\">pk</span> as usual.</li>\n<li>No statement, witness, or auxiliary data appears on-chain.</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><strong>Research Status:</strong> At [[alloc] init], we are leading ongoing research on the cryptographic core of PIPE v2, with a particular focus on witness encryption. In addition to the abstract PIPE construction, we investigate how witness encryption can be instantiated in a way that is both analyzable and scalable. To this end, we introduce a withness encryption scheme based of Adaptive Arithmetic Determinant Programs (AADP) [3].\nAlongside this, we systematically analyze prior and contemporary witness-encryption constructions.</p>\n</blockquote>\n<h2><a name=\"p-6811-covenant-semantics-what-pipes-enforce-and-what-they-dont-5\" class=\"anchor\" href=\"#p-6811-covenant-semantics-what-pipes-enforce-and-what-they-dont-5\" aria-label=\"Heading link\"></a>Covenant Semantics: What PIPEs Enforce (and What They Don\u2019t)</h2>\n<p>PIPEs v2 do not attempt to reproduce the full range of covenant semantics proposed for Bitcoin Script. Instead, they realize a specific and intentionally limited class of spending rules.</p>\n<h3><a name=\"p-6811-binary-np-covenants-6\" class=\"anchor\" href=\"#p-6811-binary-np-covenants-6\" aria-label=\"Heading link\"></a>Binary NP Covenants</h3>\n<p>PIPE v2 enforces what we call <strong>binary covenants</strong>. At a high level, a PIPE enforces exactly one decision about a UTXO:</p>\n<blockquote>\n<p>Is spending authorized or not?</p>\n</blockquote>\n<p>Concretely, a PIPE controls whether the signing key for a UTXO is released. No additional structure is imposed on the spending transaction itself. PIPEs do not constrain the transaction format, outputs, or fee structure once authorization is granted. After the key is released, the signer holds an ordinary Bitcoin private key and can construct any valid transaction.</p>\n<p>This model naturally captures a wide range of useful conditions whose outcome is binary. Examples include:</p>\n<ul>\n<li>\n<p><strong>\u201cA valid zk-proof/ SNARK proof is provided.\u201d</strong></p>\n<p>For example, a proof that a condition holds (e.g., eligibility, membership, or correctness of a hidden computation).</p>\n</li>\n<li>\n<p><strong>\u201cA fraud proof exists.\u201d</strong></p>\n<p>Used to unlock funds only if incorrect behavior can be shown.</p>\n</li>\n<li>\n<p><strong>\u201cAn exit condition is satisfied.\u201d</strong></p>\n<p>Such as proving inclusion in a commitment, knowledge of a secret, or eligibility to withdraw from an off-chain system.</p>\n</li>\n<li>\n<p><strong>\u201cA state transition is valid.\u201d</strong></p>\n<p>For instance, verifying that a rollup, bridge, or metaprotocol update follows the agreed rules.</p>\n</li>\n</ul>\n<p>In all cases, the covenant enforced by PIPEs answers a single question: <em>is the condition satisfied or not?</em> If yes, the funds become spendable; if no, they remain locked.</p>\n<blockquote>\n<p>This tradeoff is intentional. <strong>PIPE v1</strong> [1] already achieves non-interactivity and consensus compatibility, and serves as a proof of principle for cryptographic enforcement of spending conditions on Bitcoin. However, it relies on highly expressive cryptographic machinery (e.g., Functional Encryption, Indistinguishable Obfuscation) that is difficult to instantiate efficiently with current techniques. <strong>PIPE v2</strong> [2]deliberately narrows the scope to one-time, binary authorization conditions. This simplification reduces cryptographic complexity while preserving the core guarantee: spending is possible if and only if a specified condition is satisfied.</p>\n</blockquote>\n<h2><a name=\"p-6811-why-binary-authorization-is-often-enough-7\" class=\"anchor\" href=\"#p-6811-why-binary-authorization-is-often-enough-7\" aria-label=\"Heading link\"></a><strong>Why Binary Authorization Is Often Enough</strong></h2>\n<p>In practice, many useful Bitcoin applications require exactly this level of control.</p>\n<h3><a name=\"p-6811-vaults-8\" class=\"anchor\" href=\"#p-6811-vaults-8\" aria-label=\"Heading link\"></a>Vaults</h3>\n<p>Vaults are a canonical example. In a vault, the core requirement is not to micromanage how funds are spent, but to ensure that <strong>withdrawal is possible only if a specific condition is met</strong>. For example:</p>\n<ul>\n<li>a beneficiary proves eligibility,</li>\n<li>a recovery condition is satisfied,</li>\n<li>an external certificate or proof is provided.</li>\n</ul>\n<p>Once the condition is met, the vault\u2019s purpose is fulfilled. Imposing further constraints on the withdrawal transaction itself is often unnecessary. PIPEs naturally match this pattern: the vault unlocks if and only if the condition holds.</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://delvingbitcoin.org/uploads/default/original/2X/4/4a1e82767db7ba893f11f4080783110e0b51910c.png\" data-download-href=\"https://delvingbitcoin.org/uploads/default/4a1e82767db7ba893f11f4080783110e0b51910c\" title=\"pipesv2\"><img src=\"https://delvingbitcoin.org/uploads/default/optimized/2X/4/4a1e82767db7ba893f11f4080783110e0b51910c_2_690x367.png\" alt=\"pipesv2\" data-base62-sha1=\"azGHmolvnXrgUWXe0MfwB2EUlRy\" width=\"690\" height=\"367\" srcset=\"https://delvingbitcoin.org/uploads/default/optimized/2X/4/4a1e82767db7ba893f11f4080783110e0b51910c_2_690x367.png, https://delvingbitcoin.org/uploads/default/optimized/2X/4/4a1e82767db7ba893f11f4080783110e0b51910c_2_1035x550.png 1.5x, https://delvingbitcoin.org/uploads/default/optimized/2X/4/4a1e82767db7ba893f11f4080783110e0b51910c_2_1380x734.png 2x\" data-dominant-color=\"252421\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">pipesv2</span><span class=\"informations\">2738\u00d71460 304 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<h3><a name=\"p-6811-exit-and-escape-conditions-9\" class=\"anchor\" href=\"#p-6811-exit-and-escape-conditions-9\" aria-label=\"Heading link\"></a>Exit and Escape Conditions</h3>\n<p>Many Bitcoin constructions include <em>escape hatches</em> or <em>exit paths</em>. These are not long-lived policies, but one-time conditions that allow funds to be recovered safely.</p>\n<p>Examples include:</p>\n<ul>\n<li>exits from off-chain protocols,</li>\n<li>recovery paths from stalled systems,</li>\n<li>fraud or misbehavior proofs.</li>\n</ul>\n<p>In these cases, the relevant question is binary: <em>does a valid exit proof exist or not?</em> Once it exists, the funds should be released. PIPEs enforce exactly this logic, without requiring interactive disputes or challenge periods.</p>\n<h3><a name=\"p-6811-proof-gated-releases-10\" class=\"anchor\" href=\"#p-6811-proof-gated-releases-10\" aria-label=\"Heading link\"></a>Proof-Gated Releases</h3>\n<p>ZK proof or SNARK proof systems typically attest to a single fact:</p>\n<ul>\n<li>a state transition is valid,</li>\n<li>a computation was executed correctly,</li>\n<li>a committed value satisfies a predicate.</li>\n</ul>\n<p>Such proofs already produce a boolean outcome: valid or invalid. PIPEs align directly with this model. They turn proof validity into spending authorization, without requiring Bitcoin Script to verify the proof itself.</p>\n<h3><a name=\"p-6811-optimistic-protocol-finalization-11\" class=\"anchor\" href=\"#p-6811-optimistic-protocol-finalization-11\" aria-label=\"Heading link\"></a>Optimistic Protocol Finalization</h3>\n<p>Even in optimistic designs, many outcomes ultimately reduce to a binary decision. After the dispute window closes, either a fraud proof was presented or it was not. Once that decision is made, no further enforcement is needed.</p>\n<p>PIPEs allow such finalization conditions to be enforced non-interactively: the existence of a valid proof directly unlocks funds, without on-chain disputes or timing assumptions.</p>\n<h2><a name=\"p-6811-opcodes-examples-12\" class=\"anchor\" href=\"#p-6811-opcodes-examples-12\" aria-label=\"Heading link\"></a>Opcodes Examples</h2>\n<ul>\n<li>\n<p><code>OP_VAULT.</code>According to the BIP (<a href=\"https://github.com/bitcoin/bips/pull/1421\" rel=\"noopener nofollow ugc\">https://github.com/bitcoin/bips/pull/1421</a>), <code>OP_VAULT</code> is valid only inside a Taproot leaf, and it enforces the following:</p>\n<ul>\n<li>Trigger path. There must be an output (trigger output) whose index and amount are taken from the stack. That output must be locked with the same Taproot tree, except that the currently executing leaf is replaced by a new script taken from the stack. The opcode recomputes the modified Taproot commitment and checks that the actual transaction output matches it (both scriptPubKey and amount).</li>\n<li>Optional recovery path. There may be a recovery output whose index and amount are also taken from the stack. That output must be locked with the original Taproot (unchanged tree) and have the specified amount (typically smaller).</li>\n<li>From a low-level point of view, this means that <code>OP_VAULT</code>:\n<ul>\n<li>takes trigger/recovery output indices and amounts from the stack,</li>\n<li>directly reads the corresponding outputs of the spending transaction,</li>\n<li>recomputes the expected Taproot commitments,</li>\n<li>and fails script evaluation if they do not match.</li>\n</ul>\n</li>\n</ul>\n<p>This way <code>OP_VAULT</code> enforces a predicate over the spending transaction structure and it is not possible to emulate <code>OP_VAULT</code> directly with a single PIPE-based transaction. But! What we can do, though, is to emulate the <code>OP_VAULT</code>-alike core behavior by re-designing the vault to consist of many keys holding being released per-used</p>\n</li>\n<li>\n<p><code>OP_CSFS</code> ( <a href=\"https://github.com/bitcoin/bips/blob/eae7d9fc57a5f3a2b0c4853c127cb4d27377dbf3/bip-0348.md\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">bips/bip-0348.md at eae7d9fc57a5f3a2b0c4853c127cb4d27377dbf3 \u00b7 bitcoin/bips \u00b7 GitHub</a> ). Since CSFS is a signature verification over stack inputs i.e. a pure arithmetic function. This way this BIP is a perfect candidate for deprecation because of being possible to be completely replaces by PIPEs-induced functionality.</p>\n</li>\n</ul>\n<h2><a name=\"p-6811-bitvm-enhancements-13\" class=\"anchor\" href=\"#p-6811-bitvm-enhancements-13\" aria-label=\"Heading link\"></a>BitVM Enhancements</h2>\n<p>In this section we show how the PIPE primitive may be used to enhance the optimistic-verification flow of the BitVM protocol. We show that the cryptographic and on-chain components of classic BitVM such as garbled circuits (GC), label commitments, and zk-proofs of consistency map naturally to a single PIPE instance.</p>\n<p>A BitVM computation is defined by a Boolean circuit for a predicate</p>\n<div class=\"math\">\nf : \\{0,1\\}^n \\rightarrow \\{0,1\\}.\n</div>\n<p>Both BitVM and BitVM-PIPE involve the same set of actors, and the emulation works because their responsibilities align structurally.</p>\n<ul>\n<li><strong>Operator</strong>. The operator claims knowledge of a witness <span class=\"math\">w</span> such that <span class=\"math\">f(w) = 1</span>. The operator\nprovides all necessary information to make it possible to generate a compact fraud proof in case if <span class=\"math\">f(w) = 0.</span></li>\n<li><strong>Signers Committee (SC)</strong>. Verifies the operator\u2019s setup, publishes the information provided by\nthe operator, and signs the on-chain transactions <span class=\"math\">AssertTx</span> and <span class=\"math\">DisproveTx</span>.\n<ul>\n<li>The <span class=\"math\">AssertTx</span> enforces the operator to start the protocol\u2019s dispute period by publishing some additional information necessary for fraud proof construction.</li>\n<li>The <span class=\"math\">DisproveTx</span> allows anyone to publish a fraud proof in case if the operator cheats and <span class=\"math\">f(w) = 0</span>.</li>\n</ul>\n</li>\n<li><strong>Challengers</strong>. Anyone able to detect operator\u2019s misbehavior during the dispute window and publish the <span class=\"math\">DisproveTx</span> transaction containing a valid fraud proof.</li>\n</ul>\n<p>In the BitVM case a fraud proof is equivalent to knowledge of the garbled circuit false-output label. To emulate this using PIPE, we reinterpret BitVM\u2019s disprove condition as the PIPE underlying hard relation: <span class=\"math\">R= f(w) = 0 \u2227 h= Hash(w)</span>.</p>\n<p>Here how the GC-based BitVM flow and its PIPE emulation compares:</p>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th><strong>BitVM using GC</strong></th>\n<th><strong>BitVM using PIPE</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Operator constructs a garbled circuit for <em>f</em> and sends to the SC: (1) garbled tables, (2) commitments to input labels and the false-output label, (3) a zk-proof of their consistency.</td>\n<td>Operator knows a witness <span class=\"math\">w</span> with <span class=\"math\">f(w) = 1</span>. He computes <span class=\"math\">h = Hash(w)</span> and runs <span class=\"math\">PIPE.Setup(1\u03bb, h) = ((h, ct, \u03c0), pk)</span> for a hard relation <span class=\"math\">R</span>. Operator sends the setup output to the SC.</td>\n</tr>\n<tr>\n<td>SC verifies the zk-proof ensuring that the garbling table and label commitments are consistent. SC then publishes the garbling table and the transac- tion templates <span class=\"math\">AssertTx</span> and <span class=\"math\">DisproveTx</span> off-chain, and signs both transactions.</td>\n<td>SC checks whether <span class=\"math\">PIPE.OutVerify((h, ct, \u03c0), pk, h) = 1</span>. If so, SC publishes <span class=\"math\">AssertTx</span>, <span class=\"math\">DisproveTx</span>, and <span class=\"math\">((h, ct, \u03c0), pk)</span> off-chain.</td>\n</tr>\n<tr>\n<td>Operator publishes <span class=\"math\">AssertTx</span> including openings of the committed input and false-output labels.</td>\n<td>Operator publishes <span class=\"math\">AssertTx</span> including a witness <em>w</em>consistent with <em>h</em>.</td>\n</tr>\n<tr>\n<td>If <em>f</em>(<em>w</em>) = 0, a challenger can compute the false- output label from the public GC data and publish <span class=\"math\">DisproveTx</span>.</td>\n<td>If <em>f</em>(<em>w</em>) = 0, a challenger can compute a valid PIPE signature <span class=\"math\">\u03c3 = PIPE.WSign((h, ct, \u03c0), w, m)</span>. The signing algorithm succeeds because (<em>h</em>, <em>w</em>) \u2208 <em>R</em>. The challenger publishes <span class=\"math\">DisproveTx</span> containing \u03c3, and the script verifies the Schnorr signature under <em>pk</em>.</td>\n</tr>\n<tr>\n<td>If no valid <span class=\"math\">DisproveTx</span> is posted during the dispute window, the optimistic path finalizes and the computation result is accepted.</td>\n<td>If no valid <span class=\"math\">DisproveTx</span> is posted during the dispute window, the optimistic path finalizes and the computation result is accepted.</td>\n</tr>\n</tbody>\n</table>\n</div><p>The emulation preserves the trust structure of GC-based BitVM protocols. We model the Signers Committee (SC) as a single logical party composed of <em>n</em> signers, and a permissionless set of challengers. Informally, the SC controls which spending conditions are put on-chain, while challengers enforce these conditions against a potentially dishonest operator.</p>\n<p>The SC is implemented as an <em>n</em>-of-<em>n</em> multisig on Bitcoin: all n signers must cooperate to authorize <span class=\"math\">AssertTx</span> and <span class=\"math\">DisproveTx</span>. This has two consequences:</p>\n<ul>\n<li><em>Liveness</em> depends on all n signers being online and willing to sign; a single unresponsive or malicious signer can halt progress.</li>\n<li><em>Soundness</em> depends on the SC as a whole behaving honestly when the setup is produced. If at least one signer is honest and follows the protocol, an invalid setup (e.g., wrong GC, wrong PIPE instance, or wrong script template) will not be signed and therefore will never appear on-chain. or wrong script template) will not be signed and therefore will never appear on-chain.</li>\n</ul>\n<p>Correctness with respect to the claimed computation holds as long as at least one challenger is honest. Challengers are permissionless and untrusted; their only role is to detect operator dishonesty during the dispute window. In BitVM, this means reconstructing the false-output label from the public GC; in BitVM-PIPE, it means opening the PIPE instance when <span class=\"math\">f(w) = 0</span>. If the operator cheats and the on-chain script is correct, a single honest challenger suffices to trigger the <span class=\"math\">DisproveTx</span> path.</p>\n<p>Liveness in the optimistic case requires that all <em>n</em> SC members remain online and sign the required transactions; no liveness assumption is placed on challengers. Finality is reached once <span class=\"math\">AssertTx</span> confirms and no valid dispute is posted before the timeout.</p>\n<p>Under these assumptions, BitVM-PIPE inherits the same safety\u2013liveness profile as GC-based BitVM: the SC is a fully trusted <em>n</em>-of-<em>n</em> committee that fixes the on-chain spending conditions, while a single honest challenger suffices to enforce these conditions against a dishonest operator.</p>\n<p>One structural difference between GC-based BitVM and BitVM-PIPE concerns the timing at which the operator\u2019s witness is fixed. In BitVM, the garbling, label-commitments, and the zk-consistency proof can be generated without knowing the actual input <em>w</em>; the setup phase is witness-agnostic. In BitVM-PIPE, by contrast, the PIPE instance includes the value <span class=\"math\">h = Hash(w)</span>, so the operator must know <em>w</em> at setup time. This distinction does not affect the optimistic-verification or dispute logic.</p>\n<p>Beyond the structural correspondence, the on-chain footprint of BitVM-PIPE is smaller than that of GC-based BitVM.</p>\n<p>The opening transaction <span class=\"math\">AssertTx</span> becomes smaller. In GC-based BitVM, the script must verify per-bit commitments to the input labels, which induces two hash computations for every bit of the operator\u2019s input <span class=\"math\">w</span> together with the associated control opcodes. In BitVM-PIPE, the assertion transaction checks only the single hash value <span class=\"math\">h = Hash(w)</span>. If w is an object that fits into a single Bitcoin stack item (for example, a Groth16 proof), then the <span class=\"math\">AssertTx</span> script becomes a very small constant-size program.</p>\n<p>The dispute transaction <span class=\"math\">DisproveTx</span> is also compact: it consists of a single signature check.</p>\n<p>Finally, the cost of both the setup phase and its verification depends only on the underlying PIPE primitive, and therefore solely on the chosen WE construction. As a result, the entire BitVM-PIPE construction inherits its asymptotic and concrete efficiency directly from the underlying PIPE instance.</p>\n<h2><a name=\"p-6811-performance-14\" class=\"anchor\" href=\"#p-6811-performance-14\" aria-label=\"Heading link\"></a>Performance</h2>\n<p>A python script (approximately) modeling the Garuda-alike verifier expressed in AADP gives the following results (with <span class=\"math\">v</span> denoting variable count and <span class=\"math\">g</span> denoting gate count):</p>\n<p>Substituting the ciphertext size formula <span class=\"math\">v(2g+ 1)^2 |\\mathbb{F}|</span>, we get 338 TB size of the ciphertext.\nDue to the cubic scaling of the ciphertext size, even marginal improvements in the circuit size translate into significant improvements in the ciphertext size.\nSize of the ciphertext might possibly be decreased further - for example, by picking a better hash with a certification-friendly S-box or choosing a curve with smaller 2-adicity of <span class=\"math\">F^d</span>. Overall, we conclude that this approach to witness encryption, while very costly, is realistically implementable.</p>\n<p>Computationally, the dominant cost arises from determinant computation. If properly parallelized (e.g., following the approach in <a href=\"https://arxiv.org/abs/1308.1536\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">[1308.1536] A Parallel Algorithm for Calculation of Large Determinants with High Accuracy for GPUs and MPI clusters</a> ), the determinant can be computed within approximately one Bitcoin L1 block interval (~10 minutes) using up to 50 CPU machines, each equipped with 256 CPU cores and approximately 7 TB of storage. Memory requirements are comparatively modest and do not constitute a primary bottleneck.</p>\n<p>At current cloud services pricing, renting such infrastructure amounts to approximately $100-200 per covenant execution, plus a negligible on-chain cost for signature verification. This makes the approach economically viable for near\u2013real-time covenant emulation. Moreover, these execution costs can likely be further reduced through batching techniques under development.</p>\n<h2><a name=\"p-6811-conclusion-15\" class=\"anchor\" href=\"#p-6811-conclusion-15\" aria-label=\"Heading link\"></a>Conclusion</h2>\n<p>Bitcoin PIPEs v2 present a cryptographic means of enforcing certain types of covenants on Bitcoin L1 without changing consensus rules and without additional trust mechanisms.</p>\n<p>Cryptographic covenant enforcement occurs by releasing a signing key only when a witness to an NP statement is provided. This way a valid Schnorr signature can be produced only if the prescribed condition holds.</p>\n<p>PIPEs v2 focused on witness encryption based on AADPs as a concrete and arithmetic-native construction. AADPs enable NP predicates particularly SNARK-verifiable statements to be expressed as explicit algebraic objects, allowing spending conditions to be enforced through determinant evaluation without any on-chain changes.</p>\n<p>While AADP-based witness encryption is not presented as a final or optimized instantiation, it provides a fully specified and analyzable framework that makes the trade-offs of cryptographically enforced spending conditions explicit. By grounding PIPEs in a single, arithmetic-native witness encryption approach, PIPEs v2 clarifies how expressive off-chain logic can be enforced in practice using existing cryptographic tools.</p>\n<p>Overall, PIPE v2 demonstrates that expressive, verifiable spending conditions can be achieved on Bitcoin purely through cryptography. Advancing this direction, by enhancing the WE scheme with alternative proof systems, iterating with performance optimizations, and applying PIPEs to vaults, bridges, and rollup architectures, offers a promising path toward richer functionality on Bitcoin.</p>\n<h2><a name=\"p-6811-references-16\" class=\"anchor\" href=\"#p-6811-references-16\" aria-label=\"Heading link\"></a>References</h2>\n<p>[1] <em>Mikhail Komarov, Bitcoin PIPEs,</em> <a href=\"https://www.allocinit.xyz/uploads/placeholder-bitcoin.pdf\" rel=\"noopener nofollow ugc\">https://www.allocinit.xyz/uploads/placeholder-bitcoin.pdf</a></p>\n<p>[2] <em>Michel Abdalla, Brent Carmer, Muhammed El Gebali, Handan Kilinc-Alper, Mikhail Komarov, Yaroslav Rebenko, Lev Soukhanov, Erkan Tairi, Elena Tatuzova and Patrick Towa. Bitcoin PIPEs v2.</em> <a href=\"https://eprint.iacr.org/2026/186\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">Bitcoin PIPEs v2</a></p>\n<p>[3] <em>Lev Soukhanov, Yaroslav Rebenko, Muhammad El Gebali, and Mikhail Komarov. Implementable</em>\n<em>witness encryption from arithmetic affine determinant programs.</em> <a href=\"https://eprint.iacr.org/2026/175\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">Implementable Witness Encryption from Arithmetic Affine Determinant Programs</a></p>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 1,
  "updated_at": "2026-02-12T16:56:49.908Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 13,
  "reads": 7,
  "readers_count": 6,
  "score": 66.4,
  "yours": false,
  "topic_id": 2249,
  "topic_slug": "bitcoin-pipes-v2",
  "topic_title": "Bitcoin PIPEs v2",
  "topic_html_title": "Bitcoin PIPEs v2",
  "category_id": 7,
  "display_username": "Misha Komarov",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 2,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "bookmarked": false,
  "raw": "# Bitcoin PIPEs v2: Covenants and ZKPs on the Bitcoin L1 via Witness Encryption.\n\n> PIPE v2 \\[2\\] explores a cryptographic alternative to Bitcoin covenants that operates entirely within existing consensus rules. Instead of extending Script or relying on optimistic dispute mechanisms, PIPE v2 enforces spending conditions by *witness-gating access to a Bitcoin signing key*. A valid Schnorr signature can be produced if and only if a specified NP statement is true. This yields a non-interactive mechanism deployable without a soft fork, in which Bitcoin funds become spendable if and only if a specified condition is satisfied, sufficient for vaults, exits, fraud proofs, and zk-proof gated releases, under well-defined cryptographic assumptions.\n\nBitcoin\u2019s transaction validation model is intentionally minimal. At the consensus layer, Bitcoin verifies only that a transaction correctly spends unspent outputs and that each input is authorized by a valid digital signature. This simplicity is a defining strength: it keeps consensus rules stable, auditability high, and the security model well understood. At the same time, it places hard limits on the kinds of spending policies that can be enforced directly on-chain.\n\nSeveral approaches try to address this limitation. Script extensions such as `OP_CTV`, `OP_CAT`, and `OP_CSFS` increase expressiveness but require a soft fork which is a change to Bitcoin\u2019s consensus rules. Optimistic protocols such as BitVM avoid consensus changes, but introduce interactivity, challenge periods, and liveness assumptions. These tradeoffs are acceptable for some applications, but not all.\n\nPIPE versions \\[1,2\\] explore a different point in the design space: enforcing spending conditions **without new opcodes and without optimistic challenge mechanisms,** by shifting enforcement entirely *out of Bitcoin Script and into cryptography*. Rather than asking Bitcoin to verify whether a transaction satisfies a condition, PIPE v2 makes it *cryptographically impossible* to produce a valid signature unless that condition holds.\n\nThis post presents PIPE v2 through the abstraction of **witness signatures**: conditional signature schemes in which producing a valid signature is equivalent to proving membership in a hard NP relation. We explain how PIPE v2 realizes witness signatures using witness encryption, characterize the resulting authorization semantics, and clarify its scope.\n\n## Core Idea: Enforcing Spending Rules Cryptographically\n\nLet\u2019s think what Bitcoin already provides.\n\n* At the consensus layer, Bitcoin exposes a single authorization primitive: **signature validity**. A transaction input is accepted if it carries a valid Schnorr signature under the public key specified by the spent output. This is the only condition Bitcoin enforces for spending authorization.\n* What Bitcoin deliberately does not encode is *why* a signature was produced. Bitcoin Script does not capture intent, context, or the computation that led to a signature.\n\nThis fully characterizes the available design space. Any spending rule that works **without changing Bitcoin\u2019s consensus rules** must ultimately boil down to a single question:\n\n> Can a valid signature under this public key be produced or not?\n\nThere is no other hook available to enforce authorization.\n\nThe key insight behind PIPEs is to treat this constraint not as a limitation, but as the design surface.\n\n> If signature validity is the only thing Bitcoin enforces, then the strongest spending rule we can implement without a soft fork is one that controls **whether a signature can be produced at all**.\n\nPIPE v2 do exactly this by moving enforcement *before* signing. Instead of asking Bitcoin Script to check a condition, PIPEs attach the condition to **access to the signing key itself**.\n\nIn a PIPE, the signing key corresponding to a Bitcoin address is not directly available. Instead, it is cryptographically locked behind a condition\u2014such as the existence of a valid zero-knowledge proof, an exit proof, or a fraud proof. If the condition is satisfied, the key can be recovered and used to produce an ordinary Schnorr signature. If the condition is not satisfied, producing a valid signature is computationally infeasible.\n\nFrom Bitcoin\u2019s perspective, nothing changes. The transaction contains a standard signature under a standard public key and verifies as usual. From a protocol designer\u2019s perspective, this extracts the maximum possible programmability from Bitcoin\u2019s existing authorization model: arbitrary off-chain logic can gate spendability, without new opcodes, without interactivity, and without changing consensus.\n\n### Formalization: PIPE as a Witness Signature\n\nTo instantiate this idea, we introduce **witness signatures** and the corresponding **PIPE construction (PIPE v2).**\n\nAt a high level, a witness signature is just a normal Bitcoin signature but with a twist:\n\n> A valid signature can be produced if and only if a specific external condition is satisfied.\n\nA PIPE consists of two main phases: **setup** and **signing**.\n\nDuring setup, a standard Bitcoin key pair is generated, but the private key is never revealed. Instead, it is cryptographically locked behind a condition such as the validity of some off-chain computation. This locking is done using **witness encryption**, which allows the private key to be recovered only by someone who can produce valid evidence (a *witness*) that the condition holds.\n\nDuring signing, a party that has such a witness tries to recover the private key. If the witness is valid, key recovery succeeds, and the party can produce an ordinary Schnorr signature. If the witness is invalid, recovering the key and thus producing a valid signature is computationally infeasible.\n\n### PIPE v2 Construction (at a glance)\n\n* **Setup** *(performed in a distributed manner)*\n\n  * Generate a standard Bitcoin key pair $(sk, pk)$.\n  * Fix a spending condition, expressed as a statement (e.g., a circuit $C$ with public input $x$).\n  * Encrypt the signing key $sk$ under this statement using **witness encryption**.\n  * Publish the public key $pk$ and ciphertext.\n\n  (No party learns $sk$  during setup, assuming at least one setup party behaves honestly i.e., no full collusion.)\n\n* **Sign**\n\n  * Input: a message to be signed and a witness $w$.\n  * If $w$ is a valid witness for the statement, decrypt the ciphertext and obtain $sk$\n    * Generate a Schnorr signature with $sk$.\n  * If $w$ is invalid, recovering $sk$ and producing a valid signature is computationally infeasible.\n\n* **Verification (Bitcoin)**\n\n  * Bitcoin verifies the resulting Schnorr signature under $pk$ as usual.\n  * No statement, witness, or auxiliary data appears on-chain.\n\n> **Research Status:** At \\[\\[alloc\\] init\\], we are leading ongoing research on the cryptographic core of PIPE v2, with a particular focus on witness encryption. In addition to the abstract PIPE construction, we investigate how witness encryption can be instantiated in a way that is both analyzable and scalable. To this end, we introduce a withness encryption scheme based of Adaptive Arithmetic Determinant Programs (AADP) \\[3\\].\n> Alongside this, we systematically analyze prior and contemporary witness-encryption constructions.\n\n## Covenant Semantics: What PIPEs Enforce (and What They Don\u2019t)\n\nPIPEs v2 do not attempt to reproduce the full range of covenant semantics proposed for Bitcoin Script. Instead, they realize a specific and intentionally limited class of spending rules.\n\n### Binary NP Covenants\n\nPIPE v2 enforces what we call **binary covenants**. At a high level, a PIPE enforces exactly one decision about a UTXO:\n\n> Is spending authorized or not?\n\nConcretely, a PIPE controls whether the signing key for a UTXO is released. No additional structure is imposed on the spending transaction itself. PIPEs do not constrain the transaction format, outputs, or fee structure once authorization is granted. After the key is released, the signer holds an ordinary Bitcoin private key and can construct any valid transaction.\n\nThis model naturally captures a wide range of useful conditions whose outcome is binary. Examples include:\n\n* **\u201cA valid zk-proof/ SNARK proof is provided.\u201d**\n\n  For example, a proof that a condition holds (e.g., eligibility, membership, or correctness of a hidden computation).\n\n* **\u201cA fraud proof exists.\u201d**\n\n  Used to unlock funds only if incorrect behavior can be shown.\n\n* **\u201cAn exit condition is satisfied.\u201d**\n\n  Such as proving inclusion in a commitment, knowledge of a secret, or eligibility to withdraw from an off-chain system.\n\n* **\u201cA state transition is valid.\u201d**\n\n  For instance, verifying that a rollup, bridge, or metaprotocol update follows the agreed rules.\n\nIn all cases, the covenant enforced by PIPEs answers a single question: *is the condition satisfied or not?* If yes, the funds become spendable; if no, they remain locked.\n\n> This tradeoff is intentional. **PIPE v1** \\[1\\] already achieves non-interactivity and consensus compatibility, and serves as a proof of principle for cryptographic enforcement of spending conditions on Bitcoin. However, it relies on highly expressive cryptographic machinery (e.g., Functional Encryption, Indistinguishable Obfuscation) that is difficult to instantiate efficiently with current techniques. **PIPE v2** \\[2\\]deliberately narrows the scope to one-time, binary authorization conditions. This simplification reduces cryptographic complexity while preserving the core guarantee: spending is possible if and only if a specified condition is satisfied.\n\n## **Why Binary Authorization Is Often Enough**\n\nIn practice, many useful Bitcoin applications require exactly this level of control.\n\n### Vaults\n\nVaults are a canonical example. In a vault, the core requirement is not to micromanage how funds are spent, but to ensure that **withdrawal is possible only if a specific condition is met**. For example:\n\n* a beneficiary proves eligibility,\n* a recovery condition is satisfied,\n* an external certificate or proof is provided.\n\nOnce the condition is met, the vault\u2019s purpose is fulfilled. Imposing further constraints on the withdrawal transaction itself is often unnecessary. PIPEs naturally match this pattern: the vault unlocks if and only if the condition holds.\n\n![pipesv2|690x367](upload://azGHmolvnXrgUWXe0MfwB2EUlRy.png)\n\n### Exit and Escape Conditions\n\nMany Bitcoin constructions include *escape hatches* or *exit paths*. These are not long-lived policies, but one-time conditions that allow funds to be recovered safely.\n\nExamples include:\n\n* exits from off-chain protocols,\n* recovery paths from stalled systems,\n* fraud or misbehavior proofs.\n\nIn these cases, the relevant question is binary: *does a valid exit proof exist or not?* Once it exists, the funds should be released. PIPEs enforce exactly this logic, without requiring interactive disputes or challenge periods.\n\n### Proof-Gated Releases\n\nZK proof or SNARK proof systems typically attest to a single fact:\n\n* a state transition is valid,\n* a computation was executed correctly,\n* a committed value satisfies a predicate.\n\nSuch proofs already produce a boolean outcome: valid or invalid. PIPEs align directly with this model. They turn proof validity into spending authorization, without requiring Bitcoin Script to verify the proof itself.\n\n### Optimistic Protocol Finalization\n\nEven in optimistic designs, many outcomes ultimately reduce to a binary decision. After the dispute window closes, either a fraud proof was presented or it was not. Once that decision is made, no further enforcement is needed.\n\nPIPEs allow such finalization conditions to be enforced non-interactively: the existence of a valid proof directly unlocks funds, without on-chain disputes or timing assumptions.\n\n## Opcodes Examples\n\n* `OP_VAULT.`According to the BIP (https://github.com/bitcoin/bips/pull/1421), `OP_VAULT` is valid only inside a Taproot leaf, and it enforces the following:\n\n  * Trigger path. There must be an output (trigger output) whose index and amount are taken from the stack. That output must be locked with the same Taproot tree, except that the currently executing leaf is replaced by a new script taken from the stack. The opcode recomputes the modified Taproot commitment and checks that the actual transaction output matches it (both scriptPubKey and amount).\n  * Optional recovery path. There may be a recovery output whose index and amount are also taken from the stack. That output must be locked with the original Taproot (unchanged tree) and have the specified amount (typically smaller).\n  * From a low-level point of view, this means that `OP_VAULT`:\n    * takes trigger/recovery output indices and amounts from the stack,\n    * directly reads the corresponding outputs of the spending transaction,\n    * recomputes the expected Taproot commitments,\n    * and fails script evaluation if they do not match.\n\n  This way `OP_VAULT` enforces a predicate over the spending transaction structure and it is not possible to emulate `OP_VAULT` directly with a single PIPE-based transaction. But! What we can do, though, is to emulate the `OP_VAULT`-alike core behavior by re-designing the vault to consist of many keys holding being released per-used\n\n* `OP_CSFS` ( https://github.com/bitcoin/bips/blob/eae7d9fc57a5f3a2b0c4853c127cb4d27377dbf3/bip-0348.md ). Since CSFS is a signature verification over stack inputs i.e. a pure arithmetic function. This way this BIP is a perfect candidate for deprecation because of being possible to be completely replaces by PIPEs-induced functionality.\n\n## BitVM Enhancements\n\nIn this section we show how the PIPE primitive may be used to enhance the optimistic-verification flow of the BitVM protocol. We show that the cryptographic and on-chain components of classic BitVM such as garbled circuits (GC), label commitments, and zk-proofs of consistency map naturally to a single PIPE instance.\n\nA BitVM computation is defined by a Boolean circuit for a predicate\n\n$$\nf : \\{0,1\\}^n \\rightarrow \\{0,1\\}.\n$$\n\nBoth BitVM and BitVM-PIPE involve the same set of actors, and the emulation works because their responsibilities align structurally.\n\n* **Operator**. The operator claims knowledge of a witness $w$ such that $f(w) = 1$. The operator\n  provides all necessary information to make it possible to generate a compact fraud proof in case if $f(w) = 0.$\n* **Signers Committee (SC)**. Verifies the operator\u2019s setup, publishes the information provided by\n  the operator, and signs the on-chain transactions $AssertTx$ and $DisproveTx$.\n  * The $AssertTx$ enforces the operator to start the protocol\u2019s dispute period by publishing some additional information necessary for fraud proof construction.\n  * The $DisproveTx$ allows anyone to publish a fraud proof in case if the operator cheats and $f(w) = 0$.\n* **Challengers**. Anyone able to detect operator\u2019s misbehavior during the dispute window and publish the $DisproveTx$ transaction containing a valid fraud proof.\n\nIn the BitVM case a fraud proof is equivalent to knowledge of the garbled circuit false-output label. To emulate this using PIPE, we reinterpret BitVM\u2019s disprove condition as the PIPE underlying hard relation: $R= f(w) = 0 \u2227 h= Hash(w)$.\n\nHere how the GC-based BitVM flow and its PIPE emulation compares:\n\n|**BitVM using GC**|**BitVM using PIPE**|\n| --- | --- |\n| Operator constructs a garbled circuit for *f* and sends to the SC: (1) garbled tables, (2) commitments to input labels and the false-output label, (3) a zk-proof of their consistency. | Operator knows a witness $w$ with $f(w) = 1$. He computes $h = Hash(w)$ and runs $PIPE.Setup(1\u03bb, h) = ((h, ct, \u03c0), pk)$ for a hard relation $R$. Operator sends the setup output to the SC. \n| SC verifies the zk-proof ensuring that the garbling table and label commitments are consistent. SC then publishes the garbling table and the transac- tion templates $AssertTx$ and $DisproveTx$ off-chain, and signs both transactions. | SC checks whether $PIPE.OutVerify((h, ct, \u03c0), pk, h) = 1$. If so, SC publishes $AssertTx$, $DisproveTx$, and $((h, ct, \u03c0), pk)$ off-chain. | \n| Operator publishes $AssertTx$ including openings of the committed input and false-output labels. | Operator publishes $AssertTx$ including a witness *w*consistent with *h*. |\n| If *f*(*w*) = 0, a challenger can compute the false- output label from the public GC data and publish $DisproveTx$. | If *f*(*w*) = 0, a challenger can compute a valid PIPE signature $\u03c3 = PIPE.WSign((h, ct, \u03c0), w, m)$. The signing algorithm succeeds because (*h*, *w*) \u2208 *R*. The challenger publishes $DisproveTx$ containing \u03c3, and the script verifies the Schnorr signature under *pk*. |\n| If no valid $DisproveTx$ is posted during the dispute window, the optimistic path finalizes and the computation result is accepted. | If no valid $DisproveTx$ is posted during the dispute window, the optimistic path finalizes and the computation result is accepted. |\n\nThe emulation preserves the trust structure of GC-based BitVM protocols. We model the Signers Committee (SC) as a single logical party composed of *n* signers, and a permissionless set of challengers. Informally, the SC controls which spending conditions are put on-chain, while challengers enforce these conditions against a potentially dishonest operator.\n\nThe SC is implemented as an *n*-of-*n* multisig on Bitcoin: all n signers must cooperate to authorize $AssertTx$ and $DisproveTx$. This has two consequences:\n\n* *Liveness* depends on all n signers being online and willing to sign; a single unresponsive or malicious signer can halt progress.\n* *Soundness* depends on the SC as a whole behaving honestly when the setup is produced. If at least one signer is honest and follows the protocol, an invalid setup (e.g., wrong GC, wrong PIPE instance, or wrong script template) will not be signed and therefore will never appear on-chain. or wrong script template) will not be signed and therefore will never appear on-chain.\n\nCorrectness with respect to the claimed computation holds as long as at least one challenger is honest. Challengers are permissionless and untrusted; their only role is to detect operator dishonesty during the dispute window. In BitVM, this means reconstructing the false-output label from the public GC; in BitVM-PIPE, it means opening the PIPE instance when $f(w) = 0$. If the operator cheats and the on-chain script is correct, a single honest challenger suffices to trigger the $DisproveTx$ path.\n\nLiveness in the optimistic case requires that all *n* SC members remain online and sign the required transactions; no liveness assumption is placed on challengers. Finality is reached once $AssertTx$ confirms and no valid dispute is posted before the timeout.\n\nUnder these assumptions, BitVM-PIPE inherits the same safety\u2013liveness profile as GC-based BitVM: the SC is a fully trusted *n*-of-*n* committee that fixes the on-chain spending conditions, while a single honest challenger suffices to enforce these conditions against a dishonest operator.\n\nOne structural difference between GC-based BitVM and BitVM-PIPE concerns the timing at which the operator\u2019s witness is fixed. In BitVM, the garbling, label-commitments, and the zk-consistency proof can be generated without knowing the actual input *w*; the setup phase is witness-agnostic. In BitVM-PIPE, by contrast, the PIPE instance includes the value $h = Hash(w)$, so the operator must know *w* at setup time. This distinction does not affect the optimistic-verification or dispute logic.\n\nBeyond the structural correspondence, the on-chain footprint of BitVM-PIPE is smaller than that of GC-based BitVM.\n\nThe opening transaction $AssertTx$ becomes smaller. In GC-based BitVM, the script must verify per-bit commitments to the input labels, which induces two hash computations for every bit of the operator\u2019s input $w$ together with the associated control opcodes. In BitVM-PIPE, the assertion transaction checks only the single hash value $h = Hash(w)$. If w is an object that fits into a single Bitcoin stack item (for example, a Groth16 proof), then the $AssertTx$ script becomes a very small constant-size program.\n\nThe dispute transaction $DisproveTx$ is also compact: it consists of a single signature check.\n\nFinally, the cost of both the setup phase and its verification depends only on the underlying PIPE primitive, and therefore solely on the chosen WE construction. As a result, the entire BitVM-PIPE construction inherits its asymptotic and concrete efficiency directly from the underlying PIPE instance.\n\n## Performance\n\nA python script (approximately) modeling the Garuda-alike verifier expressed in AADP gives the following results (with $v$ denoting variable count and $g$ denoting gate count):\n\nSubstituting the ciphertext size formula $v(2g+ 1)^2 |\\mathbb{F}|$, we get 338 TB size of the ciphertext.\nDue to the cubic scaling of the ciphertext size, even marginal improvements in the circuit size translate into significant improvements in the ciphertext size.\nSize of the ciphertext might possibly be decreased further - for example, by picking a better hash with a certification-friendly S-box or choosing a curve with smaller 2-adicity of $F^d$. Overall, we conclude that this approach to witness encryption, while very costly, is realistically implementable.\n\nComputationally, the dominant cost arises from determinant computation. If properly parallelized (e.g., following the approach in https://arxiv.org/abs/1308.1536 ), the determinant can be computed within approximately one Bitcoin L1 block interval (\\~10 minutes) using up to 50 CPU machines, each equipped with 256 CPU cores and approximately 7 TB of storage. Memory requirements are comparatively modest and do not constitute a primary bottleneck.\n\nAt current cloud services pricing, renting such infrastructure amounts to approximately $100-200 per covenant execution, plus a negligible on-chain cost for signature verification. This makes the approach economically viable for near\u2013real-time covenant emulation. Moreover, these execution costs can likely be further reduced through batching techniques under development.\n\n## Conclusion\n\nBitcoin PIPEs v2 present a cryptographic means of enforcing certain types of covenants on Bitcoin L1 without changing consensus rules and without additional trust mechanisms.\n\nCryptographic covenant enforcement occurs by releasing a signing key only when a witness to an NP statement is provided. This way a valid Schnorr signature can be produced only if the prescribed condition holds.\n\nPIPEs v2 focused on witness encryption based on AADPs as a concrete and arithmetic-native construction. AADPs enable NP predicates particularly SNARK-verifiable statements to be expressed as explicit algebraic objects, allowing spending conditions to be enforced through determinant evaluation without any on-chain changes.\n\nWhile AADP-based witness encryption is not presented as a final or optimized instantiation, it provides a fully specified and analyzable framework that makes the trade-offs of cryptographically enforced spending conditions explicit. By grounding PIPEs in a single, arithmetic-native witness encryption approach, PIPEs v2 clarifies how expressive off-chain logic can be enforced in practice using existing cryptographic tools.\n\nOverall, PIPE v2 demonstrates that expressive, verifiable spending conditions can be achieved on Bitcoin purely through cryptography. Advancing this direction, by enhancing the WE scheme with alternative proof systems, iterating with performance optimizations, and applying PIPEs to vaults, bridges, and rollup architectures, offers a promising path toward richer functionality on Bitcoin.\n\n## References\n\n\\[1\\] *Mikhail Komarov, Bitcoin PIPEs,* https://www.allocinit.xyz/uploads/placeholder-bitcoin.pdf\n\n\\[2\\] *Michel Abdalla, Brent Carmer, Muhammed El Gebali, Handan Kilinc-Alper, Mikhail Komarov, Yaroslav Rebenko, Lev Soukhanov, Erkan Tairi, Elena Tatuzova and Patrick Towa. Bitcoin PIPEs v2.* https://eprint.iacr.org/2026/186\n\n\\[3\\] *Lev Soukhanov, Yaroslav Rebenko, Muhammad El Gebali, and Mikhail Komarov. Implementable*\n*witness encryption from arithmetic affine determinant programs.* https://eprint.iacr.org/2026/175",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 514,
  "hidden": false,
  "trust_level": 0,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": "Github link was replaced with a permanent link",
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "<a name=\"p-6811-bitcoin-pipes-v2-covenants-and-zkps-on-the-bitcoin-l1-via-witness-encryption-1\" class=\"anchor\" href=\"#p-6811-bitcoin-pipes-v2-covenants-and-zkps-on-the-bitcoin-l1-via-witness-encryption-1\" aria-label=\"Heading link\"></a>Bitcoin PIPEs v2: Covenants and ZKPs on the Bitcoin L1 via Witness Encryption.\n\nPIPE v2 [2] explores a cryptographic alternative to Bitcoin covenants that operates entirely within existing consensus rules. Instead of extending Script or relying on optimistic dispute mechanisms, PIPE v2 enforces spen&hellip;",
  "truncated": true,
  "post_url": "/t/bitcoin-pipes-v2/2249/1",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}