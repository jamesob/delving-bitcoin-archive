{
  "id": 6715,
  "name": "Oleks",
  "username": "olkurbatov",
  "avatar_template": "/user_avatar/delvingbitcoin.org/olkurbatov/{size}/299_2.png",
  "created_at": "2026-02-01T20:57:29.165Z",
  "cooked": "<p>Thanks for the feedback!</p>\n<p>Your intuition is right, we can realize CNF-by-clauses using replicated secrets: pick a per-clause secret, privately distribute it to all members of that OR-subtree, and then ensure everyone agrees on the resulting clause public key (via signatures, for example). If all parties agree on the clause keys, we still get the \u201cqualified set can sign / non-qualified set can\u2019t\u201d.</p>\n<p>But, I think the BLISK approach has some additional advantages:</p>\n<ol>\n<li><strong>It avoids storing new secret material</strong>. With RSS/private broadcast, every member stores extra clause secrets (one per clause they belong to), and you need secure authenticated channels (or a private broadcast primitive) plus a verifiable key rotation for those secrets (which might be difficult). BLISK\u2019s OR-gate approach aims to keep the only long-term secrets as the parties\u2019 existing keys and to make clause material <em>derivable</em> via key agreement rather than <em>distributed</em>.</li>\n</ol>\n<aside class=\"quote no-group\" data-username=\"nkohen\" data-post=\"4\" data-topic=\"2217\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://delvingbitcoin.org/user_avatar/delvingbitcoin.org/nkohen/48/1792_2.png\" class=\"avatar\"> nkohen:</div>\n<blockquote>\n<p>If I\u2019m understanding correctly, during the ECDH-based setup you do have to store the aggregate secret for a disjunction subtree since you cannot non-interactively recompute it</p>\n</blockquote>\n</aside>\n<p>Quoting this: no, you don\u2019t have to store the aggregated (to be more precise, <strong>shared</strong>) secret, the secret for the clause is derived based on your secret and public values in the path. So, there is a state (and it\u2019s fair to call it stateful construction), but the state is shared among all participants, it can\u2019t be corrupted (only lost), and it\u2019s literally the set of public keys (representing nodes).</p>\n<ol start=\"2\">\n<li><strong>Prevent OR-gate cheating without requiring everyone in the clause to co-sign the resolution.</strong> If a \u201cresolver\u201d can publish an arbitrary public key for an OR node, they can pick a key known only to them, breaking liveness/semantics for other authorized members (even if the unforgeability of MuSig remains intact). With RSS, your \u201ceveryone signs the clause pubkey\u201d approach fixes this, but it changes the coordination/liveness model: now clause resolution requires collecting endorsements from the entire clause (or some approval rule), which can be painful for large/overlapping clauses or partially offline participants. BLISK instead aims for \u201cany eligible member can resolve\u201d, and everyone else can verify correctness non-interactively.</li>\n<li><strong>Rotation is where the ZK verifiability really matters.</strong>\nIn an RSS design, rotation generally means re-sharing/re-distributing clause secrets (interactive + authenticated private channels) or running a fresh DKG-like step per affected clause. In BLISK, we pay proof costs so that updating/resolving internal-node keys remains publicly checkable without re-running a distribution protocol. When one party is updating their key: 1) public keys of all other participants remain the same; 2) but they need to verify proofs and update a common state with the new version.</li>\n</ol>\n<p>So I agree ECDH isn\u2019t \u201ccryptographically necessary\u201d in principle; it\u2019s a concrete way to get the local-derivability property (\u201cany authorized member can derive the OR secret\u201d) without introducing fresh replicated secrets. And the ZKPs are there to enforce the well-formedness/consistency of OR resolutions without requiring all clause members to participate in the policy setup (and while allowing individual keys to be updated by their owners non-interactively).</p>",
  "post_number": 5,
  "post_type": 1,
  "posts_count": 5,
  "updated_at": "2026-02-01T20:57:29.165Z",
  "reply_count": 0,
  "reply_to_post_number": 4,
  "quote_count": 1,
  "incoming_link_count": 3,
  "reads": 9,
  "readers_count": 8,
  "score": 16.8,
  "yours": false,
  "topic_id": 2217,
  "topic_slug": "blisk-boolean-circuit-logic-integrated-into-the-single-key",
  "topic_title": "BLISK: Boolean circuit Logic Integrated into the Single Key",
  "topic_html_title": "BLISK: Boolean circuit Logic Integrated into the Single Key",
  "category_id": 7,
  "display_username": "Oleks",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": "",
  "bookmarked": false,
  "raw": "Thanks for the feedback!\n\nYour intuition is right, we can realize CNF-by-clauses using replicated secrets: pick a per-clause secret, privately distribute it to all members of that OR-subtree, and then ensure everyone agrees on the resulting clause public key (via signatures, for example). If all parties agree on the clause keys, we still get the \u201cqualified set can sign / non-qualified set can\u2019t\u201d.\n\nBut, I think the BLISK approach has some additional advantages:\n\n1. **It avoids storing new secret material**. With RSS/private broadcast, every member stores extra clause secrets (one per clause they belong to), and you need secure authenticated channels (or a private broadcast primitive) plus a verifiable key rotation for those secrets (which might be difficult). BLISK\u2019s OR-gate approach aims to keep the only long-term secrets as the parties\u2019 existing keys and to make clause material *derivable* via key agreement rather than *distributed*.\n[quote=\"nkohen, post:4, topic:2217\"]\nIf I\u2019m understanding correctly, during the ECDH-based setup you do have to store the aggregate secret for a disjunction subtree since you cannot non-interactively recompute it\n[/quote]\nQuoting this: no, you don't have to store the aggregated (to be more precise, **shared**) secret, the secret for the clause is derived based on your secret and public values in the path. So, there is a state (and it's fair to call it stateful construction), but the state is shared among all participants, it can't be corrupted (only lost), and it's literally the set of public keys (representing nodes). \n\n2. **Prevent OR-gate cheating without requiring everyone in the clause to co-sign the resolution.** If a \u201cresolver\u201d can publish an arbitrary public key for an OR node, they can pick a key known only to them, breaking liveness/semantics for other authorized members (even if the unforgeability of MuSig remains intact). With RSS, your \u201ceveryone signs the clause pubkey\u201d approach fixes this, but it changes the coordination/liveness model: now clause resolution requires collecting endorsements from the entire clause (or some approval rule), which can be painful for large/overlapping clauses or partially offline participants. BLISK instead aims for \"any eligible member can resolve\", and everyone else can verify correctness non-interactively. \n3. **Rotation is where the ZK verifiability really matters.**\nIn an RSS design, rotation generally means re-sharing/re-distributing clause secrets (interactive + authenticated private channels) or running a fresh DKG-like step per affected clause. In BLISK, we pay proof costs so that updating/resolving internal-node keys remains publicly checkable without re-running a distribution protocol. When one party is updating their key: 1) public keys of all other participants remain the same; 2) but they need to verify proofs and update a common state with the new version.\n\nSo I agree ECDH isn\u2019t \u201ccryptographically necessary\u201d in principle; it\u2019s a concrete way to get the local-derivability property (\u201cany authorized member can derive the OR secret\u201d) without introducing fresh replicated secrets. And the ZKPs are there to enforce the well-formedness/consistency of OR resolutions without requiring all clause members to participate in the policy setup (and while allowing individual keys to be updated by their owners non-interactively).",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 246,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "Thanks for the feedback! \nYour intuition is right, we can realize CNF-by-clauses using replicated secrets: pick a per-clause secret, privately distribute it to all members of that OR-subtree, and then ensure everyone agrees on the resulting clause public key (via signatures, for example). If all par&hellip;",
  "truncated": true,
  "post_url": "/t/blisk-boolean-circuit-logic-integrated-into-the-single-key/2217/5",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}