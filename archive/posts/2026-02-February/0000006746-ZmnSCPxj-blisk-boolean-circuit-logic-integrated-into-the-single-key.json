{
  "id": 6746,
  "name": "ZmnSCPxj jxPCSnmZ",
  "username": "ZmnSCPxj",
  "avatar_template": "/letter_avatar_proxy/v4/letter/z/ee7513/{size}.png",
  "created_at": "2026-02-05T00:24:51.042Z",
  "cooked": "<p>The goal here is to have a generic k-of-n Lightning Network node.  Channels require a <code>A &amp; B</code> between the channel parties, and for this \u201ck-of-n LN node\u201d future, either of <code>A</code> or <code>B</code> or both may actually be a k-of-n.</p>\n<p>Now, I believe ANY k-of-n policy can be iterated as a DNF, e.g. for a 2-of-4 of <code>A B C D</code>, that would be <code>((A &amp; B) | (A &amp; C) | (A &amp; D) | (B &amp; C) | (B &amp; D) | (C &amp; D))</code>.  And the DNF form can be converted to an equivalent CNF form (they are just normal forms and I believe any nested AND-OR expression can be converted to either form).</p>\n<p>Thus, we can consider ANY general policy of nested AND and OR gates, then flatten them to AND-of-OR and feed it to Blisk.</p>\n<p>Now the issues here for a k-of-n LN node are two-fold:</p>\n<ul>\n<li>Creating a new channel state basically requires a partial signature from the other side, but without the full signature being generated on our side \u2014 the point is that the full signature can only be safely generated on unilateral closure.  The CNF at the Blisk level may require the creation of the FULL signature, which is unsafe \u2014 storing the full signature is unsafe as old state can now be posted by anyone who gets access to your stored full signatures.  I would need to look more deeply into this to see if this is actually safe; my intuition is that there will be at least one term in the CNF that is controlled only by signatories of one side, which would serve as the decision-makers for when to do a unilateral close later (and create the full signature).</li>\n<li>After creating a new channel state, we need to invalidate old state.  There is simply no way to do this that still respects the shachain requirement of BOLT, so we should \u201cjust\u201d drop the shachain requirement.  Without the shachain requirement, the public key for the revocation key can be generated using flatten-to-CNF-then-Blisk and then at revocation time, the same calculations are done on private keys this time, then the resulting private key is the revocation private key that you hand over to the other party to revoke your old state.</li>\n</ul>\n<p>Both the above can be sidestepped by switching to Decker-Wattenhofer, BTW: each state change both creates the new state and invalidate old state in a single atomic step of creating the FULL signature under Decker-Wattenhofer.  And Decker-Wattenhofer, unlike Decker-Russell-Osuntokun, does not require a consensus change.</p>\n<p>Also this scheme of \u201cflatten to CNF form and then Blisk\u201d may be considered a generalization of this technique: <a href=\"https://delvingbitcoin.org/t/flattening-nested-2-of-2-of-a-1-of-1-and-a-k-of-n\">https://delvingbitcoin.org/t/flattening-nested-2-of-2-of-a-1-of-1-and-a-k-of-n</a></p>",
  "post_number": 12,
  "post_type": 1,
  "posts_count": 14,
  "updated_at": "2026-02-05T00:28:17.315Z",
  "reply_count": 1,
  "reply_to_post_number": 10,
  "quote_count": 0,
  "incoming_link_count": 1,
  "reads": 16,
  "readers_count": 15,
  "score": 13.0,
  "yours": false,
  "topic_id": 2217,
  "topic_slug": "blisk-boolean-circuit-logic-integrated-into-the-single-key",
  "topic_title": "BLISK: Boolean circuit Logic Integrated into the Single Key",
  "topic_html_title": "BLISK: Boolean circuit Logic Integrated into the Single Key",
  "category_id": 7,
  "display_username": "ZmnSCPxj jxPCSnmZ",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": null,
  "reply_to_user": {
    "id": 246,
    "username": "olkurbatov",
    "name": "Oleks",
    "avatar_template": "/user_avatar/delvingbitcoin.org/olkurbatov/{size}/299_2.png"
  },
  "bookmarked": false,
  "raw": "The goal here is to have a generic k-of-n Lightning Network node.  Channels require a `A & B` between the channel parties, and for this \"k-of-n LN node\" future, either of `A` or `B` or both may actually be a k-of-n.\n\nNow, I believe ANY k-of-n policy can be iterated as a DNF, e.g. for a 2-of-4 of `A B C D`, that would be `((A & B) | (A & C) | (A & D) | (B & C) | (B & D) | (C & D))`.  And the DNF form can be converted to an equivalent CNF form (they are just normal forms and I believe any nested AND-OR expression can be converted to either form).\n\nThus, we can consider ANY general policy of nested AND and OR gates, then flatten them to AND-of-OR and feed it to Blisk.\n\nNow the issues here for a k-of-n LN node are two-fold:\n\n* Creating a new channel state basically requires a partial signature from the other side, but without the full signature being generated on our side --- the point is that the full signature can only be safely generated on unilateral closure.  The CNF at the Blisk level may require the creation of the FULL signature, which is unsafe --- storing the full signature is unsafe as old state can now be posted by anyone who gets access to your stored full signatures.  I would need to look more deeply into this to see if this is actually safe; my intuition is that there will be at least one term in the CNF that is controlled only by signatories of one side, which would serve as the decision-makers for when to do a unilateral close later (and create the full signature).\n* After creating a new channel state, we need to invalidate old state.  There is simply no way to do this that still respects the shachain requirement of BOLT, so we should \"just\" drop the shachain requirement.  Without the shachain requirement, the public key for the revocation key can be generated using flatten-to-CNF-then-Blisk and then at revocation time, the same calculations are done on private keys this time, then the resulting private key is the revocation private key that you hand over to the other party to revoke your old state.\n\nBoth the above can be sidestepped by switching to Decker-Wattenhofer, BTW: each state change both creates the new state and invalidate old state in a single atomic step of creating the FULL signature under Decker-Wattenhofer.  And Decker-Wattenhofer, unlike Decker-Russell-Osuntokun, does not require a consensus change.\n\nAlso this scheme of \"flatten to CNF form and then Blisk\" may be considered a generalization of this technique: https://delvingbitcoin.org/t/flattening-nested-2-of-2-of-a-1-of-1-and-a-k-of-n",
  "actions_summary": [],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 104,
  "hidden": false,
  "trust_level": 2,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "The goal here is to have a generic k-of-n Lightning Network node.  Channels require a A &amp; B between the channel parties, and for this \u201ck-of-n LN node\u201d future, either of A or B or both may actually be a k-of-n. \nNow, I believe ANY k-of-n policy can be iterated as a DNF, e.g. for a 2-of-4 of A B C D, &hellip;",
  "truncated": true,
  "post_url": "/t/blisk-boolean-circuit-logic-integrated-into-the-single-key/2217/12",
  "reactions": [],
  "current_user_reaction": null,
  "reaction_users_count": 0,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null
}