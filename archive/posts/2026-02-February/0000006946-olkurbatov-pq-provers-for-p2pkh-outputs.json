{
  "id": 6946,
  "name": "Oleks",
  "username": "olkurbatov",
  "avatar_template": "/user_avatar/delvingbitcoin.org/olkurbatov/{size}/299_2.png",
  "created_at": "2026-02-25T11:20:42.282Z",
  "cooked": "<h2><a name=\"p-6946-intro-1\" class=\"anchor\" href=\"#p-6946-intro-1\" aria-label=\"Heading link\"></a>Intro</h2>\n<p>As part of the past research project, we\u2019ve been benchmarking PQ proof systems for proving ownership of a Bitcoin P2PKH address, without revealing the public key. Despite the fact that the benchmarks were made ~6 months ago (so some projects could make additional optimization and improvements for their frameworks, affecting the proof generation complexity), we wanted to share our results here since they shed light on the practical feasibility (and current limitations) of using current ZK frameworks for a post-quantum transition (I was told that this topic was raised on the mailing list some time ago).</p>\n<h2><a name=\"p-6946-motivation-2\" class=\"anchor\" href=\"#p-6946-motivation-2\" aria-label=\"Heading link\"></a>Motivation</h2>\n<p>Quantum computers threaten systems where knowledge of the public key suffices to recover the private key. For P2PKH outputs, the public key is hidden behind <code>ripemd-160(sha-256(pk))</code> until spending time, but once revealed in a transaction, it becomes vulnerable.</p>\n<p>One proposed approach to a PQ transition is to allow users to prove they own a Bitcoin address and cryptographically link it to a post-quantum address, all without exposing their public key on-chain. This requires a zero-knowledge proof that:</p>\n<ul>\n<li>The prover knows a public key <code>pk</code> such that <code>ripemd-160(sha256(pk))</code> matches a declared hash (from which the P2PKH address is trivially derivable).</li>\n<li>The prover knows a valid ECDSA signature <code>sigma</code> over a pre-determined message hash <code>hm</code> under <code>pk</code>.</li>\n</ul>\n<p>The proof system itself must be post-quantum secure.</p>\n<h2><a name=\"p-6946-what-were-proving-3\" class=\"anchor\" href=\"#p-6946-what-were-proving-3\" aria-label=\"Heading link\"></a>What we\u2019re proving</h2>\n<p>The circuit (program) is the same across all systems. The witness is <code>(pk, sigma)</code> and the statement is <code>(pk_hash, hm)</code>. Inside the proof:</p>\n<ol>\n<li>ECDSA signature verification over secp256k1</li>\n<li>SHA-256 hash of the public key (we could implement SHA-256 + RIPEMD-160 in circuits but we simplify the proving and leave <code>ripemd-160(.)</code> calculation public)</li>\n</ol>\n<p>The public signal is <code>(sha256(pk), hm)</code>: the verifier never sees <code>pk</code> itself. From <code>sha256(pk)</code> the P2PKH address is recoverable publicly via hash160 + Base58Check. All implementations use the same static test vectors (64-byte uncompressed public key, 64-byte signature, 32-byte message hash).</p>\n<blockquote>\n<p>Such a circuit design allows us to separate the signing (wallet) device from the proving device:</p>\n<ol>\n<li>We don\u2019t need to extract the secret key from the signing device, but only to ask signing the constant pre-defined message, so this approach is supposed to be secure</li>\n<li>We don\u2019t need to implement the proving on the signing device (sometimes it\u2019s not even possible because of their low-power design)</li>\n</ol>\n</blockquote>\n<p>Source code: <a href=\"https://github.com/BlockstreamResearch/pq-p2pkh\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">GitHub - BlockstreamResearch/pq-p2pkh: Benchmarks of post-quantum provers for P2PKH outputs</a></p>\n<h2><a name=\"p-6946-benchmark-results-4\" class=\"anchor\" href=\"#p-6946-benchmark-results-4\" aria-label=\"Heading link\"></a>Benchmark results</h2>\n<p>All native benchmarks were run on Apple M2 Max.</p>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th>Proving System</th>\n<th>Proving Time</th>\n<th>Verification Time</th>\n<th>Memory usage</th>\n<th>Proof Size</th>\n<th>Notes</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>STWO-Cairo</td>\n<td>8 s</td>\n<td>50 ms</td>\n<td>6 GB</td>\n<td>5.6 MB</td>\n<td>Cairo program, STWO prover</td>\n</tr>\n<tr>\n<td>Ligero (Apple M2 Max)</td>\n<td>4 s</td>\n<td>2 s</td>\n<td>1.8 GB</td>\n<td>4.2 MB</td>\n<td>Runs on Mac</td>\n</tr>\n<tr>\n<td>Ligero (WebGPU)</td>\n<td>22 s</td>\n<td>4 s</td>\n<td>1.9 GB</td>\n<td>4.2 MB</td>\n<td>Runs in Chromium browser</td>\n</tr>\n<tr>\n<td>RISC Zero</td>\n<td>2 m</td>\n<td>100 ms</td>\n<td>1.2 GB</td>\n<td>2 MB</td>\n<td>RISC-V zkVM</td>\n</tr>\n<tr>\n<td>SP1</td>\n<td>1 m</td>\n<td>2 s</td>\n<td>16 GB</td>\n<td>10 MB</td>\n<td>Succinct\u2019s zkVM</td>\n</tr>\n<tr>\n<td>Valida (Lita)</td>\n<td>4.5 m</td>\n<td>2 s</td>\n<td>12 GB</td>\n<td>6 MB</td>\n<td>Plonky3 backend</td>\n</tr>\n</tbody>\n</table>\n</div><p>A few notes and observations:</p>\n<ul>\n<li>\n<p>STWO-Cairo is the fastest native prover at ~8 seconds, but its current WASM build requires ~6 GB RAM, which makes it impractical for some environments today.</p>\n</li>\n<li>\n<p>Ligero is the only system that actually runs in a browser (via WebGPU), with a 22-second proving time. This is nice if client-sideness is important.</p>\n</li>\n<li>\n<p>RISC Zero was additionally successfully tested on mobile (iPhone 14 Pro): proof generation took ~6 minutes with ~1.2 GB peak RAM, which is surprisingly feasible for a phone.</p>\n</li>\n<li>\n<p>Verification times are generally fast (50 ms for the fastest), but the question of where verification happens matters enormously. The full on-chain verification (without wrappers) is not currently possible.</p>\n</li>\n</ul>\n<h2><a name=\"p-6946-summary-5\" class=\"anchor\" href=\"#p-6946-summary-5\" aria-label=\"Heading link\"></a>Summary</h2>\n<p>These benchmarks suggest that <strong>client-side STARK proving of P2PKH ownership is approaching feasibility</strong>, but:</p>\n<ul>\n<li>\n<p>Proof sizes. Our early (pre-optimization) benchmarks show the proof size ranged from 5.6 MB (STWO-Cairo) to 10 MB (SP1) for P2PKH-related proofs. These are fine for off-chain registries but far too large for anything on-chain.</p>\n</li>\n<li>\n<p>These proofs are useful for external registries (linking Bitcoin addresses to PQ addresses) or for future covenant designs, but not for direct on-chain PQ migration without protocol changes.</p>\n</li>\n<li>\n<p>Even 8 seconds on an M2 Max is a lot of computation, especially for low-powered signing devices (HWW).</p>\n</li>\n</ul>\n<h2><a name=\"p-6946-appendix-pq-signature-verification-benchmarks-6\" class=\"anchor\" href=\"#p-6946-appendix-pq-signature-verification-benchmarks-6\" aria-label=\"Heading link\"></a>Appendix. PQ signature verification benchmarks</h2>\n<p>We got carried away and also benchmarked STARK proofs for post-quantum signature verification, i.e., proving, within a STARK, that an SLH-DSA signature is valid. This might be relevant to privacy-preserving PQ applications (e.g., anonymous credentials, accumulators, etc.).</p>\n<div class=\"md-table\">\n<table>\n<thead>\n<tr>\n<th>System</th>\n<th>Algorithm</th>\n<th>Proof Gen.</th>\n<th>Proof Verif.</th>\n<th>Proof Size</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SP1</td>\n<td>Falcon-512</td>\n<td>40 s</td>\n<td>&lt;1 s</td>\n<td>12.5 MB</td>\n</tr>\n<tr>\n<td>RISC Zero</td>\n<td>Falcon-512</td>\n<td>2 min</td>\n<td>&lt;1 s</td>\n<td>1.4 MB</td>\n</tr>\n<tr>\n<td>SP1</td>\n<td>ML-DSA-87 (Dilithium)</td>\n<td>4.5 min</td>\n<td>3 s</td>\n<td>96.3 MB</td>\n</tr>\n<tr>\n<td>RISC Zero</td>\n<td>ML-DSA-87 (Dilithium)</td>\n<td>21 min</td>\n<td>&lt;1 s</td>\n<td>9.4 MB</td>\n</tr>\n<tr>\n<td>SP1</td>\n<td>SPHINCS\u00b1SHAKE256-256f</td>\n<td>97 min</td>\n<td>75 s</td>\n<td>~2.4 GB</td>\n</tr>\n<tr>\n<td>RISC Zero</td>\n<td>SPHINCS\u00b1SHAKE256-256f</td>\n<td>9 hours</td>\n<td>5 s</td>\n<td>226 MB</td>\n</tr>\n</tbody>\n</table>\n</div>",
  "post_number": 1,
  "post_type": 1,
  "posts_count": 1,
  "updated_at": "2026-02-25T11:20:42.282Z",
  "reply_count": 0,
  "reply_to_post_number": null,
  "quote_count": 0,
  "incoming_link_count": 0,
  "reads": 8,
  "readers_count": 7,
  "score": 16.4,
  "yours": false,
  "topic_id": 2287,
  "topic_slug": "pq-provers-for-p2pkh-outputs",
  "topic_title": "PQ provers for P2PKH outputs",
  "topic_html_title": "PQ provers for P2PKH outputs",
  "category_id": 7,
  "display_username": "Oleks",
  "primary_group_name": null,
  "flair_name": null,
  "flair_url": null,
  "flair_bg_color": null,
  "flair_color": null,
  "flair_group_id": null,
  "badges_granted": [],
  "version": 1,
  "can_edit": false,
  "can_delete": false,
  "can_recover": false,
  "can_see_hidden_post": false,
  "can_wiki": false,
  "user_title": "",
  "bookmarked": false,
  "raw": "## Intro\nAs part of the past research project, we've been benchmarking PQ proof systems for proving ownership of a Bitcoin P2PKH address, without revealing the public key. Despite the fact that the benchmarks were made ~6 months ago (so some projects could make additional optimization and improvements for their frameworks, affecting the proof generation complexity), we wanted to share our results here since they shed light on the practical feasibility (and current limitations) of using current ZK frameworks for a post-quantum transition (I was told that this topic was raised on the mailing list some time ago).\n\n## Motivation\nQuantum computers threaten systems where knowledge of the public key suffices to recover the private key. For P2PKH outputs, the public key is hidden behind `ripemd-160(sha-256(pk))` until spending time, but once revealed in a transaction, it becomes vulnerable.\n\nOne proposed approach to a PQ transition is to allow users to prove they own a Bitcoin address and cryptographically link it to a post-quantum address, all without exposing their public key on-chain. This requires a zero-knowledge proof that:\n* The prover knows a public key `pk` such that `ripemd-160(sha256(pk))` matches a declared hash (from which the P2PKH address is trivially derivable).\n* The prover knows a valid ECDSA signature `sigma` over a pre-determined message hash `hm` under `pk`.\n\nThe proof system itself must be post-quantum secure.\n\n## What we're proving\nThe circuit (program) is the same across all systems. The witness is `(pk, sigma)` and the statement is `(pk_hash, hm)`. Inside the proof:\n1. ECDSA signature verification over secp256k1\n2. SHA-256 hash of the public key (we could implement SHA-256 + RIPEMD-160 in circuits but we simplify the proving and leave `ripemd-160(.)` calculation public)\n\nThe public signal is `(sha256(pk), hm)`: the verifier never sees `pk` itself. From `sha256(pk)` the P2PKH address is recoverable publicly via hash160 + Base58Check. All implementations use the same static test vectors (64-byte uncompressed public key, 64-byte signature, 32-byte message hash).\n\n> Such a circuit design allows us to separate the signing (wallet) device from the proving device:\n> 1. We don't need to extract the secret key from the signing device, but only to ask signing the constant pre-defined message, so this approach is supposed to be secure\n> 2. We don't need to implement the proving on the signing device (sometimes it's not even possible because of their low-power design)\n\nSource code: https://github.com/BlockstreamResearch/pq-p2pkh\n\n## Benchmark results\n\nAll native benchmarks were run on Apple M2 Max.\n\n| Proving System | Proving Time | Verification Time | Memory usage| Proof Size | Notes |\n|---|---|---|---|---|---|\n| STWO-Cairo | 8 s | 50 ms | 6 GB | 5.6 MB | Cairo program, STWO prover |\n| Ligero (Apple M2 Max) | 4 s | 2 s | 1.8 GB | 4.2 MB | Runs on Mac|\n| Ligero (WebGPU) | 22 s | 4 s | 1.9 GB | 4.2 MB | Runs in Chromium browser |\n| RISC Zero | 2 m | 100 ms | 1.2 GB | 2 MB | RISC-V zkVM |\n| SP1 | 1 m | 2 s | 16 GB | 10 MB | Succinct's zkVM |\n| Valida (Lita) | 4.5 m | 2 s | 12 GB | 6 MB | Plonky3 backend |\n\nA few notes and observations:\n\n* STWO-Cairo is the fastest native prover at ~8 seconds, but its current WASM build requires ~6 GB RAM, which makes it impractical for some environments today.\n\n* Ligero is the only system that actually runs in a browser (via WebGPU), with a 22-second proving time. This is nice if client-sideness is important.\n\n* RISC Zero was additionally successfully tested on mobile (iPhone 14 Pro): proof generation took ~6 minutes with ~1.2 GB peak RAM, which is surprisingly feasible for a phone.\n\n* Verification times are generally fast (50 ms for the fastest), but the question of where verification happens matters enormously. The full on-chain verification (without wrappers) is not currently possible.\n\n## Summary\n\nThese benchmarks suggest that **client-side STARK proving of P2PKH ownership is approaching feasibility**, but:\n\n- Proof sizes. Our early (pre-optimization) benchmarks show the proof size ranged from 5.6 MB (STWO-Cairo) to 10 MB (SP1) for P2PKH-related proofs. These are fine for off-chain registries but far too large for anything on-chain.\n\n- These proofs are useful for external registries (linking Bitcoin addresses to PQ addresses) or for future covenant designs, but not for direct on-chain PQ migration without protocol changes.\n\n- Even 8 seconds on an M2 Max is a lot of computation, especially for low-powered signing devices (HWW).\n\n## Appendix. PQ signature verification benchmarks\nWe got carried away and also benchmarked STARK proofs for post-quantum signature verification, i.e., proving, within a STARK, that an SLH-DSA signature is valid. This might be relevant to privacy-preserving PQ applications (e.g., anonymous credentials, accumulators, etc.).\n\n| System | Algorithm | Proof Gen. | Proof Verif. | Proof Size |\n|---|---|---|---|---|\n| SP1 | Falcon-512 | 40 s | <1 s | 12.5 MB |\n| RISC Zero | Falcon-512 | 2 min | <1 s | 1.4 MB |\n| SP1 | ML-DSA-87 (Dilithium) | 4.5 min | 3 s | 96.3 MB |\n| RISC Zero | ML-DSA-87 (Dilithium) | 21 min | <1 s | 9.4 MB |\n| SP1 | SPHINCS+-SHAKE256-256f | 97 min | 75 s | ~2.4 GB |\n| RISC Zero | SPHINCS+-SHAKE256-256f | 9 hours | 5 s | 226 MB |",
  "actions_summary": [
    {
      "id": 2,
      "count": 1
    }
  ],
  "moderator": false,
  "admin": false,
  "staff": false,
  "user_id": 246,
  "hidden": false,
  "trust_level": 1,
  "deleted_at": null,
  "user_deleted": false,
  "edit_reason": null,
  "can_view_edit_history": true,
  "wiki": false,
  "excerpt": "<a name=\"p-6946-intro-1\" class=\"anchor\" href=\"#p-6946-intro-1\" aria-label=\"Heading link\"></a>Intro\nAs part of the past research project, we\u2019ve been benchmarking PQ proof systems for proving ownership of a Bitcoin P2PKH address, without revealing the public key. Despite the fact that the benchmarks were made ~6 months ago (so some projects could make additional optimization and improvements &hellip;",
  "truncated": true,
  "post_url": "/t/pq-provers-for-p2pkh-outputs/2287/1",
  "reactions": [
    {
      "id": "+1",
      "type": "emoji",
      "count": 1
    }
  ],
  "current_user_reaction": null,
  "reaction_users_count": 1,
  "current_user_used_main_reaction": false,
  "can_accept_answer": false,
  "can_unaccept_answer": false,
  "accepted_answer": false,
  "topic_accepted_answer": null,
  "can_vote": false
}