# CVE-2024-38365 public disclosure (btcd `FindAndDelete` bug)

AntoineP | 2024-10-10 09:02:17 UTC | #1

This work is a collaboration between Niklas GÃ¶gge ([Brink](https://brink.dev/)) and Antoine Poinsot ([Wizardsardine](https://wizardsardine.com/)). 

Btcd prior to version [0.24.2](https://github.com/btcsuite/btcd/releases/tag/v0.24.2) does not correctly implement the consensus rules for legacy signature verification. The incompatible behavior can be triggered by a standard transaction, making it possible for anyone to fork off vulnerable btcd nodes at virtually no cost.

# Details

When verifying a signature for a transaction input, the script interpreter of a Bitcoin node re-constructs the signed message and checks the signature against it. The original algorithm for re-constructing the message is detailed in [this wiki page](https://en.bitcoin.it/wiki/OP_CHECKSIG#How_it_works). Notably, the signed message contains a commitment to the Script being executed. For legacy transaction inputs any occurrence of the signature being verified is first removed from the executed Script committed in the message. This is often referred to as the `FindAndDelete` behavior, named after the function implementing this in Satoshi Nakamoto's original Bitcoin codebase.

`removeOpcodeByData` is Btcd's equivalent of Bitcoin Core's `FindAndDelete`. Prior to version 0.24.2, `removeOpcodeByData` would remove any data push from the executed Script that *contains* the signature. Whereas Bitcoin Core's (and Satoshi's) `FindAndDelete` only removes exact matches. Using public key recovery it is possible to create a Script which contains a signature check and an extraneous data push which contains the signature itself and additional padding data. This Script can be committed to in a P2SH output which can be spent by a standard transaction which would be considered valid by Bitcoin Core and invalid by vulnerable Btcd nodes.

This bug was introduced in commit [`76339baf6c9407b073828245e3458f4df35190ae`](https://github.com/btcsuite/btcd/commit/76339baf6c9407b073828245e3458f4df35190ae) in 2014, in reaction to a new Bitcoin Core unit test demonstrating the original implementation was consensus-incompatible.

# Credits

Thanks to the Btcd maintainers for awarding us a bug bounty.

# Timeline

- 2024-03-20 Niklas and Antoine discuss the quirks of Bitcoin Core's `FindAndDelete` (in relation to Antoine's research into the [worst case block validation time](https://delvingbitcoin.org/t/great-consensus-cleanup-revival/710?u=antoinep)) and decide to take a look at if Btcd got all the quirks right in their reimplementation
- 2024-03-22 Niklas and Antoine email a detailed report of the issue to Olaoluwa Osuntokun
- 2024-03-26 Olaoluwa acknowledges the issue and creates a discussion group with another Btcd maintainer
- 2024-05-07 Antoine reserves [CVE-2024-36051](https://www.cve.org/CVERecord?id=CVE-2024-36051) through Mitre
- 2024-06-21 Laolu reserves [CVE-2024-38365](https://github.com/btcsuite/btcd/security/advisories/GHSA-27vh-h6mc-q6g8) through Github
- 2024-04-26 A covert fix is included in PR [#2178](https://github.com/btcsuite/btcd/pull/2178)
- 2024-05-22 PR [#2178](https://github.com/btcsuite/btcd/pull/2178) is merged
- 2024-06-25 Version 0.24.2 is released with the fix
- 2024-09-20 Public disclosure

-------------------------

harding | 2024-10-10 23:22:25 UTC | #2

[quote="AntoineP, post:1, topic:1184"]
Using public key recovery it is possible to create a Script which contains a signature check and an extraneous data push which contains the signature itself and additional padding data.
[/quote]

What is the public key recovery for?

-------------------------

AntoineP | 2024-10-11 06:47:49 UTC | #3

To have a valid signature in the scriptpubkey.

To exploit this you want to have a data push in the scriptpubkey which contains the signature among other dummy data and then execute the signature check. When checking the signature Bitcoin Core's `FindAndDelete` won't drop the data push from the signature hash, but btcd will before version 0.24.2.

To cause a chain split you not only want the sighash calculation to differ, you want it to lead to a different signature check result. The only way to have a valid signature in the scriptpubkey is to generate the signature first and then to recover a public key from it plus the sighash. By performing a public key recovery using Bitcoin Core's sighash you'll get a public key such as the signature check passes on Bitcoin Core but fails on btcd. And vice-versa.

I have a documented Bitcoin Core unit test as a patch which generates such a transaction, that we sent to Laolu as part of the original report. I'm hesitant to share it publicly though since it would simplify the job of a script kiddy who wants to be annoying. I'll share the patch with you privately and share it on this thread later.

-------------------------

ariard | 2024-10-11 19:13:31 UTC | #4

> and additional padding data.

https://github.com/bitcoin/bitcoin/blob/48cf3da636089873ba7280e0d5b22eb81811d194/src/script/interpreter.cpp#L329

In my understanding of the bug, there is feeding of the two consensus-nodes, with the following
`scriptCode`, where the ECDSA sig and the "noise dummy data must match the length declared in
pushed bytes.

```

  1-byte        1-byte       ECDSA sig-bytes   "noise" dummy data-bytes

OP_PUSHDATA1 <bytes pushed> <signature> <padding data>

```

One should note that ECDSA sig length is malleable.

The non-upgraded, pre-0.24.2 btcd peers should remove the whole data push containing
the consensus valid signatures, before it's verified by the script interpreter. While
bitcoind peers can accept the valid signatures. I'm unsure that you really need public
key recovery to achieve that chain fork as a trick. I believe one has OP_PICK, OP_ROLL and other stack inspection opcodes available, that can be committed in the `scriptCode`.

-------------------------

